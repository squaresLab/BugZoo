typedef unsigned int size_t;
typedef unsigned char __u_char;
typedef unsigned short __u_short;
typedef unsigned int __u_int;
typedef unsigned long __u_long;
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long long __int64_t;
typedef unsigned long long __uint64_t;
typedef long long __quad_t;
typedef unsigned long long __u_quad_t;
typedef __u_quad_t __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef __u_quad_t __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned int __nlink_t;
typedef long __off_t;
typedef __quad_t __off64_t;
typedef int __pid_t;
struct __anonstruct___fsid_t_1 {
   int __val[2] ;
};
typedef struct __anonstruct___fsid_t_1 __fsid_t;
typedef long __clock_t;
typedef unsigned long __rlim_t;
typedef __u_quad_t __rlim64_t;
typedef unsigned int __id_t;
typedef long __time_t;
typedef unsigned int __useconds_t;
typedef long __suseconds_t;
typedef int __daddr_t;
typedef long __swblk_t;
typedef int __key_t;
typedef int __clockid_t;
typedef void *__timer_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef __quad_t __blkcnt64_t;
typedef unsigned long __fsblkcnt_t;
typedef __u_quad_t __fsblkcnt64_t;
typedef unsigned long __fsfilcnt_t;
typedef __u_quad_t __fsfilcnt64_t;
typedef int __ssize_t;
typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;
typedef int __intptr_t;
typedef unsigned int __socklen_t;
struct _IO_FILE;
struct _IO_FILE;
typedef struct _IO_FILE FILE;
typedef struct _IO_FILE __FILE;
union __anonunion___value_3 {
   unsigned int __wch ;
   char __wchb[4] ;
};
struct __anonstruct___mbstate_t_2 {
   int __count ;
   union __anonunion___value_3 __value ;
};
typedef struct __anonstruct___mbstate_t_2 __mbstate_t;
struct __anonstruct__G_fpos_t_4 {
   __off_t __pos ;
   __mbstate_t __state ;
};
typedef struct __anonstruct__G_fpos_t_4 _G_fpos_t;
struct __anonstruct__G_fpos64_t_5 {
   __off64_t __pos ;
   __mbstate_t __state ;
};
typedef struct __anonstruct__G_fpos64_t_5 _G_fpos64_t;
typedef short _G_int16_t;
typedef int _G_int32_t;
typedef unsigned short _G_uint16_t;
typedef unsigned int _G_uint32_t;
typedef __builtin_va_list __gnuc_va_list;
struct _IO_jump_t;
struct _IO_jump_t;
struct _IO_FILE;
typedef void _IO_lock_t;
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
enum __codecvt_result {
    __codecvt_ok = 0,
    __codecvt_partial = 1,
    __codecvt_error = 2,
    __codecvt_noconv = 3
} ;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15U * sizeof(int ) - 4U * sizeof(void *)) - sizeof(size_t )] ;
};
typedef struct _IO_FILE _IO_FILE;
struct _IO_FILE_plus;
struct _IO_FILE_plus;
typedef __ssize_t __io_read_fn(void *__cookie , char *__buf , size_t __nbytes );
typedef __ssize_t __io_write_fn(void *__cookie , char const   *__buf , size_t __n );
typedef int __io_seek_fn(void *__cookie , __off64_t *__pos , int __w );
typedef int __io_close_fn(void *__cookie );
typedef __gnuc_va_list va_list;
typedef __off_t off_t;
typedef __ssize_t ssize_t;
typedef _G_fpos_t fpos_t;
typedef int __sig_atomic_t;
struct __anonstruct___sigset_t_6 {
   unsigned long __val[1024U / (8U * sizeof(unsigned long ))] ;
};
typedef struct __anonstruct___sigset_t_6 __sigset_t;
typedef __sig_atomic_t sig_atomic_t;
typedef __sigset_t sigset_t;
typedef __pid_t pid_t;
typedef __uid_t uid_t;
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
typedef union sigval sigval_t;
struct __anonstruct__kill_8 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
struct __anonstruct__timer_9 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
struct __anonstruct__rt_10 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
struct __anonstruct__sigchld_11 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
struct __anonstruct__sigfault_12 {
   void *si_addr ;
};
struct __anonstruct__sigpoll_13 {
   long si_band ;
   int si_fd ;
};
union __anonunion__sifields_7 {
   int _pad[128U / sizeof(int ) - 3U] ;
   struct __anonstruct__kill_8 _kill ;
   struct __anonstruct__timer_9 _timer ;
   struct __anonstruct__rt_10 _rt ;
   struct __anonstruct__sigchld_11 _sigchld ;
   struct __anonstruct__sigfault_12 _sigfault ;
   struct __anonstruct__sigpoll_13 _sigpoll ;
};
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_7 _sifields ;
};
typedef struct siginfo siginfo_t;
enum __anonenum_14 {
    SI_ASYNCNL = -60,
    SI_TKILL = -6,
    SI_SIGIO = -5,
    SI_ASYNCIO = -4,
    SI_MESGQ = -3,
    SI_TIMER = -2,
    SI_QUEUE = -1,
    SI_USER = 0,
    SI_KERNEL = 128
} ;
enum __anonenum_15 {
    ILL_ILLOPC = 1,
    ILL_ILLOPN = 2,
    ILL_ILLADR = 3,
    ILL_ILLTRP = 4,
    ILL_PRVOPC = 5,
    ILL_PRVREG = 6,
    ILL_COPROC = 7,
    ILL_BADSTK = 8
} ;
enum __anonenum_16 {
    FPE_INTDIV = 1,
    FPE_INTOVF = 2,
    FPE_FLTDIV = 3,
    FPE_FLTOVF = 4,
    FPE_FLTUND = 5,
    FPE_FLTRES = 6,
    FPE_FLTINV = 7,
    FPE_FLTSUB = 8
} ;
enum __anonenum_17 {
    SEGV_MAPERR = 1,
    SEGV_ACCERR = 2
} ;
enum __anonenum_18 {
    BUS_ADRALN = 1,
    BUS_ADRERR = 2,
    BUS_OBJERR = 3
} ;
enum __anonenum_19 {
    TRAP_BRKPT = 1,
    TRAP_TRACE = 2
} ;
enum __anonenum_20 {
    CLD_EXITED = 1,
    CLD_KILLED = 2,
    CLD_DUMPED = 3,
    CLD_TRAPPED = 4,
    CLD_STOPPED = 5,
    CLD_CONTINUED = 6
} ;
enum __anonenum_21 {
    POLL_IN = 1,
    POLL_OUT = 2,
    POLL_MSG = 3,
    POLL_ERR = 4,
    POLL_PRI = 5,
    POLL_HUP = 6
} ;
struct __anonstruct__sigev_thread_23 {
   void (*_function)(sigval_t  ) ;
   void *_attribute ;
};
union __anonunion__sigev_un_22 {
   int _pad[64U / sizeof(int ) - 3U] ;
   __pid_t _tid ;
   struct __anonstruct__sigev_thread_23 _sigev_thread ;
};
struct sigevent {
   sigval_t sigev_value ;
   int sigev_signo ;
   int sigev_notify ;
   union __anonunion__sigev_un_22 _sigev_un ;
};
typedef struct sigevent sigevent_t;
enum __anonenum_24 {
    SIGEV_SIGNAL = 0,
    SIGEV_NONE = 1,
    SIGEV_THREAD = 2,
    SIGEV_THREAD_ID = 4
} ;
typedef void (*__sighandler_t)(int  );
typedef void (*sig_t)(int  );
union __anonunion___sigaction_handler_25 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
struct sigaction {
   union __anonunion___sigaction_handler_25 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
struct sigvec {
   void (*sv_handler)(int  ) ;
   int sv_mask ;
   int sv_flags ;
};
typedef signed char __s8;
typedef unsigned char __u8;
typedef short __s16;
typedef unsigned short __u16;
typedef int __s32;
typedef unsigned int __u32;
typedef long long __s64;
typedef unsigned long long __u64;
typedef unsigned short umode_t;
struct __anonstruct___kernel_fd_set_26 {
   unsigned long fds_bits[1024U / (8U * sizeof(unsigned long ))] ;
};
typedef struct __anonstruct___kernel_fd_set_26 __kernel_fd_set;
typedef void (*__kernel_sighandler_t)(int  );
typedef int __kernel_key_t;
typedef int __kernel_mqd_t;
typedef unsigned long __kernel_ino_t;
typedef unsigned short __kernel_mode_t;
typedef unsigned short __kernel_nlink_t;
typedef long __kernel_off_t;
typedef int __kernel_pid_t;
typedef unsigned short __kernel_ipc_pid_t;
typedef unsigned short __kernel_uid_t;
typedef unsigned short __kernel_gid_t;
typedef unsigned int __kernel_size_t;
typedef int __kernel_ssize_t;
typedef int __kernel_ptrdiff_t;
typedef long __kernel_time_t;
typedef long __kernel_suseconds_t;
typedef long __kernel_clock_t;
typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef int __kernel_daddr_t;
typedef char *__kernel_caddr_t;
typedef unsigned short __kernel_uid16_t;
typedef unsigned short __kernel_gid16_t;
typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;
typedef unsigned short __kernel_old_uid_t;
typedef unsigned short __kernel_old_gid_t;
typedef unsigned short __kernel_old_dev_t;
typedef long long __kernel_loff_t;
struct __anonstruct___kernel_fsid_t_27 {
   int val[2] ;
};
typedef struct __anonstruct___kernel_fsid_t_27 __kernel_fsid_t;
typedef __u16 __le16;
typedef __u16 __be16;
typedef __u32 __le32;
typedef __u32 __be32;
typedef __u64 __le64;
typedef __u64 __be64;
typedef __u16 __sum16;
typedef __u32 __wsum;
struct _fpx_sw_bytes {
   __u32 magic1 ;
   __u32 extended_size ;
   __u64 xstate_bv ;
   __u32 xstate_size ;
   __u32 padding[7] ;
};
struct _fpreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
};
struct _fpxreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
   unsigned short padding[3] ;
};
struct _xmmreg {
   unsigned long element[4] ;
};
union __anonunion____missing_field_name_28 {
   unsigned long padding2[12] ;
   struct _fpx_sw_bytes sw_reserved ;
};
struct _fpstate {
   unsigned long cw ;
   unsigned long sw ;
   unsigned long tag ;
   unsigned long ipoff ;
   unsigned long cssel ;
   unsigned long dataoff ;
   unsigned long datasel ;
   struct _fpreg _st[8] ;
   unsigned short status ;
   unsigned short magic ;
   unsigned long _fxsr_env[6] ;
   unsigned long mxcsr ;
   unsigned long reserved ;
   struct _fpxreg _fxsr_st[8] ;
   struct _xmmreg _xmm[8] ;
   unsigned long padding1[44] ;
   union __anonunion____missing_field_name_28 __annonCompField1 ;
};
struct sigcontext {
   unsigned short gs ;
   unsigned short __gsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned long edi ;
   unsigned long esi ;
   unsigned long ebp ;
   unsigned long esp ;
   unsigned long ebx ;
   unsigned long edx ;
   unsigned long ecx ;
   unsigned long eax ;
   unsigned long trapno ;
   unsigned long err ;
   unsigned long eip ;
   unsigned short cs ;
   unsigned short __csh ;
   unsigned long eflags ;
   unsigned long esp_at_signal ;
   unsigned short ss ;
   unsigned short __ssh ;
   struct _fpstate *fpstate ;
   unsigned long oldmask ;
   unsigned long cr2 ;
};
struct _xsave_hdr {
   __u64 xstate_bv ;
   __u64 reserved1[2] ;
   __u64 reserved2[5] ;
};
struct _ymmh_state {
   __u32 ymmh_space[64] ;
};
struct _xstate {
   struct _fpstate fpstate ;
   struct _xsave_hdr xstate_hdr ;
   struct _ymmh_state ymmh ;
};
struct sigstack {
   void *ss_sp ;
   int ss_onstack ;
};
enum __anonenum_29 {
    SS_ONSTACK = 1,
    SS_DISABLE = 2
} ;
struct sigaltstack {
   void *ss_sp ;
   int ss_flags ;
   size_t ss_size ;
};
typedef struct sigaltstack stack_t;
typedef int greg_t;
typedef greg_t gregset_t[19];
struct _libc_fpreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
};
struct _libc_fpstate {
   unsigned long cw ;
   unsigned long sw ;
   unsigned long tag ;
   unsigned long ipoff ;
   unsigned long cssel ;
   unsigned long dataoff ;
   unsigned long datasel ;
   struct _libc_fpreg _st[8] ;
   unsigned long status ;
};
typedef struct _libc_fpstate *fpregset_t;
struct __anonstruct_mcontext_t_30 {
   gregset_t gregs ;
   fpregset_t fpregs ;
   unsigned long oldmask ;
   unsigned long cr2 ;
};
typedef struct __anonstruct_mcontext_t_30 mcontext_t;
struct ucontext {
   unsigned long uc_flags ;
   struct ucontext *uc_link ;
   stack_t uc_stack ;
   mcontext_t uc_mcontext ;
   __sigset_t uc_sigmask ;
   struct _libc_fpstate __fpregs_mem ;
};
typedef struct ucontext ucontext_t;
typedef unsigned long pthread_t;
union __anonunion_pthread_attr_t_31 {
   char __size[36] ;
   long __align ;
};
typedef union __anonunion_pthread_attr_t_31 pthread_attr_t;
struct __pthread_internal_slist {
   struct __pthread_internal_slist *__next ;
};
typedef struct __pthread_internal_slist __pthread_slist_t;
union __anonunion____missing_field_name_33 {
   int __spins ;
   __pthread_slist_t __list ;
};
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   int __kind ;
   unsigned int __nusers ;
   union __anonunion____missing_field_name_33 __annonCompField2 ;
};
union __anonunion_pthread_mutex_t_32 {
   struct __pthread_mutex_s __data ;
   char __size[24] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_32 pthread_mutex_t;
union __anonunion_pthread_mutexattr_t_34 {
   char __size[4] ;
   long __align ;
};
typedef union __anonunion_pthread_mutexattr_t_34 pthread_mutexattr_t;
struct __anonstruct___data_36 {
   int __lock ;
   unsigned int __futex ;
   unsigned long long __total_seq ;
   unsigned long long __wakeup_seq ;
   unsigned long long __woken_seq ;
   void *__mutex ;
   unsigned int __nwaiters ;
   unsigned int __broadcast_seq ;
};
union __anonunion_pthread_cond_t_35 {
   struct __anonstruct___data_36 __data ;
   char __size[48] ;
   long long __align ;
};
typedef union __anonunion_pthread_cond_t_35 pthread_cond_t;
union __anonunion_pthread_condattr_t_37 {
   char __size[4] ;
   long __align ;
};
typedef union __anonunion_pthread_condattr_t_37 pthread_condattr_t;
typedef unsigned int pthread_key_t;
typedef int pthread_once_t;
struct __anonstruct___data_39 {
   int __lock ;
   unsigned int __nr_readers ;
   unsigned int __readers_wakeup ;
   unsigned int __writer_wakeup ;
   unsigned int __nr_readers_queued ;
   unsigned int __nr_writers_queued ;
   unsigned char __flags ;
   unsigned char __shared ;
   unsigned char __pad1 ;
   unsigned char __pad2 ;
   int __writer ;
};
union __anonunion_pthread_rwlock_t_38 {
   struct __anonstruct___data_39 __data ;
   char __size[32] ;
   long __align ;
};
typedef union __anonunion_pthread_rwlock_t_38 pthread_rwlock_t;
union __anonunion_pthread_rwlockattr_t_40 {
   char __size[8] ;
   long __align ;
};
typedef union __anonunion_pthread_rwlockattr_t_40 pthread_rwlockattr_t;
typedef int volatile   pthread_spinlock_t;
union __anonunion_pthread_barrier_t_41 {
   char __size[20] ;
   long __align ;
};
typedef union __anonunion_pthread_barrier_t_41 pthread_barrier_t;
union __anonunion_pthread_barrierattr_t_42 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_barrierattr_t_42 pthread_barrierattr_t;
typedef long wchar_t;
struct __anonstruct___wait_terminated_43 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
struct __anonstruct___wait_stopped_44 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_43 __wait_terminated ;
   struct __anonstruct___wait_stopped_44 __wait_stopped ;
};
union __anonunion___WAIT_STATUS_45 {
   union wait *__uptr ;
   int *__iptr ;
};
typedef union __anonunion___WAIT_STATUS_45  __attribute__((__transparent_union__)) __WAIT_STATUS;
struct __anonstruct_div_t_46 {
   int quot ;
   int rem ;
};
typedef struct __anonstruct_div_t_46 div_t;
struct __anonstruct_ldiv_t_47 {
   long quot ;
   long rem ;
};
typedef struct __anonstruct_ldiv_t_47 ldiv_t;
struct __anonstruct_lldiv_t_48 {
   long long quot ;
   long long rem ;
};
typedef struct __anonstruct_lldiv_t_48 lldiv_t;
typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;
typedef __loff_t loff_t;
typedef __ino_t ino_t;
typedef __dev_t dev_t;
typedef __gid_t gid_t;
typedef __mode_t mode_t;
typedef __nlink_t nlink_t;
typedef __id_t id_t;
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;
typedef __key_t key_t;
typedef __clock_t clock_t;
typedef __time_t time_t;
typedef __clockid_t clockid_t;
typedef __timer_t timer_t;
typedef unsigned long ulong;
typedef unsigned short ushort;
typedef unsigned int uint;
typedef signed char int8_t;
typedef short int16_t;
typedef int int32_t;
typedef long long int64_t;
typedef unsigned char u_int8_t;
typedef unsigned short u_int16_t;
typedef unsigned int u_int32_t;
typedef unsigned long long u_int64_t;
typedef int register_t;
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
typedef __suseconds_t suseconds_t;
typedef long __fd_mask;
struct __anonstruct_fd_set_49 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
typedef struct __anonstruct_fd_set_49 fd_set;
typedef __fd_mask fd_mask;
typedef __blksize_t blksize_t;
typedef __blkcnt_t blkcnt_t;
typedef __fsblkcnt_t fsblkcnt_t;
typedef __fsfilcnt_t fsfilcnt_t;
struct random_data {
   int32_t *fptr ;
   int32_t *rptr ;
   int32_t *state ;
   int rand_type ;
   int rand_deg ;
   int rand_sep ;
   int32_t *end_ptr ;
};
struct drand48_data {
   unsigned short __x[3] ;
   unsigned short __old_x[3] ;
   unsigned short __c ;
   unsigned short __init ;
   unsigned long long __a ;
};
typedef int (*__compar_fn_t)(void const   * , void const   * );
struct __locale_data;
struct __locale_struct {
   struct __locale_data *__locales[13] ;
   unsigned short const   *__ctype_b ;
   int const   *__ctype_tolower ;
   int const   *__ctype_toupper ;
   char const   *__names[13] ;
};
typedef struct __locale_struct *__locale_t;
typedef __locale_t locale_t;
typedef long double float_t;
typedef long double double_t;
enum __anonenum_50 {
    FP_NAN = 0,
    FP_INFINITE = 1,
    FP_ZERO = 2,
    FP_SUBNORMAL = 3,
    FP_NORMAL = 4
} ;
enum __anonenum__LIB_VERSION_TYPE_51 {
    _IEEE_ = -1,
    _SVID_ = 0,
    _XOPEN_ = 1,
    _POSIX_ = 2,
    _ISOC_ = 3
} ;
typedef enum __anonenum__LIB_VERSION_TYPE_51 _LIB_VERSION_TYPE;
struct exception {
   int type ;
   char *name ;
   double arg1 ;
   double arg2 ;
   double retval ;
};
union __anonunion___u_52 {
   float __f ;
   int __i ;
};
union __anonunion___u_53 {
   double __d ;
   int __i[2] ;
};
union __anonunion___u_54 {
   long double __l ;
   int __i[3] ;
};
union __anonunion___n_55 {
   long double __xld ;
   unsigned int __xi[3] ;
};
union __anonunion_56 {
   double __d ;
   int __i[2] ;
};
typedef long tsrm_intptr_t;
typedef unsigned long tsrm_uintptr_t;
struct _zend_leak_info {
   void *addr ;
   size_t size ;
   char const   *filename ;
   uint lineno ;
   char const   *orig_filename ;
   uint orig_lineno ;
};
typedef struct _zend_leak_info zend_leak_info;
struct _zend_mm_heap;
typedef struct _zend_mm_heap zend_mm_heap;
struct _zend_mm_storage;
typedef struct _zend_mm_storage zend_mm_storage;
struct _zend_mm_segment {
   size_t size ;
   struct _zend_mm_segment *next_segment ;
};
typedef struct _zend_mm_segment zend_mm_segment;
struct _zend_mm_mem_handlers {
   char const   *name ;
   zend_mm_storage *(*init)(void *params ) ;
   void (*dtor)(zend_mm_storage *storage ) ;
   void (*compact)(zend_mm_storage *storage ) ;
   zend_mm_segment *(*_alloc)(zend_mm_storage *storage , size_t size ) ;
   zend_mm_segment *(*_realloc)(zend_mm_storage *storage , zend_mm_segment *ptr , size_t size ) ;
   void (*_free)(zend_mm_storage *storage , zend_mm_segment *ptr ) ;
};
typedef struct _zend_mm_mem_handlers zend_mm_mem_handlers;
struct _zend_mm_storage {
   zend_mm_mem_handlers const   *handlers ;
   void *data ;
};
typedef unsigned char zend_bool;
typedef unsigned char zend_uchar;
typedef unsigned int zend_uint;
typedef unsigned long zend_ulong;
typedef unsigned short zend_ushort;
typedef long long zend_long64;
typedef unsigned long long zend_ulong64;
typedef long zend_intptr_t;
typedef unsigned long zend_uintptr_t;
typedef unsigned int zend_object_handle;
struct _zend_object_handlers;
typedef struct _zend_object_handlers zend_object_handlers;
struct _zend_object_value {
   zend_object_handle handle ;
   zend_object_handlers const   *handlers ;
};
typedef struct _zend_object_value zend_object_value;
typedef ulong (*hash_func_t)(char const   *arKey , uint nKeyLength );
typedef int (*compare_func_t)(void const   * , void const   * );
typedef void (*sort_func_t)(void * , size_t  , size_t  , int (*)(void const   * , void const   * ) );
typedef void (*dtor_func_t)(void *pDest );
typedef void (*copy_ctor_func_t)(void *pElement );
typedef void (*copy_ctor_param_func_t)(void *pElement , void *pParam );
struct _hashtable;
struct _hashtable;
struct bucket {
   ulong h ;
   uint nKeyLength ;
   void *pData ;
   void *pDataPtr ;
   struct bucket *pListNext ;
   struct bucket *pListLast ;
   struct bucket *pNext ;
   struct bucket *pLast ;
   char const   *arKey ;
};
typedef struct bucket Bucket;
struct _hashtable {
   uint nTableSize ;
   uint nTableMask ;
   uint nNumOfElements ;
   ulong nNextFreeElement ;
   Bucket *pInternalPointer ;
   Bucket *pListHead ;
   Bucket *pListTail ;
   Bucket **arBuckets ;
   void (*pDestructor)(void *pDest ) ;
   zend_bool persistent ;
   unsigned char nApplyCount ;
   zend_bool bApplyProtection ;
};
typedef struct _hashtable HashTable;
struct _zend_hash_key {
   char const   *arKey ;
   uint nKeyLength ;
   ulong h ;
};
typedef struct _zend_hash_key zend_hash_key;
typedef zend_bool (*merge_checker_func_t)(HashTable *target_ht , void *source_data , zend_hash_key *hash_key , void *pParam );
typedef Bucket *HashPosition;
typedef int (*apply_func_t)(void *pDest );
typedef int (*apply_func_arg_t)(void *pDest , void *argument );
typedef int (*apply_func_args_t)(void *pDest , int num_args , va_list args , zend_hash_key *hash_key );
struct _HashPointer {
   HashPosition pos ;
   ulong h ;
};
typedef struct _HashPointer HashPointer;
struct _zend_ts_hashtable {
   HashTable hash ;
   zend_uint reader ;
};
typedef struct _zend_ts_hashtable TsHashTable;
struct _zend_llist_element {
   struct _zend_llist_element *next ;
   struct _zend_llist_element *prev ;
   char data[1] ;
};
typedef struct _zend_llist_element zend_llist_element;
typedef void (*llist_dtor_func_t)(void * );
typedef int (*llist_compare_func_t)(zend_llist_element const   ** , zend_llist_element const   ** );
typedef void (*llist_apply_with_args_func_t)(void *data , int num_args , va_list args );
typedef void (*llist_apply_with_arg_func_t)(void *data , void *arg );
typedef void (*llist_apply_func_t)(void * );
struct _zend_llist {
   zend_llist_element *head ;
   zend_llist_element *tail ;
   size_t count ;
   size_t size ;
   void (*dtor)(void * ) ;
   unsigned char persistent ;
   zend_llist_element *traverse_ptr ;
};
typedef struct _zend_llist zend_llist;
typedef zend_llist_element *zend_llist_position;
struct _zval_struct;
typedef struct _zval_struct zval;
struct _zend_class_entry;
typedef struct _zend_class_entry zend_class_entry;
struct _zend_guard {
   zend_bool in_get ;
   zend_bool in_set ;
   zend_bool in_unset ;
   zend_bool in_isset ;
   zend_bool dummy ;
};
typedef struct _zend_guard zend_guard;
struct _zend_object {
   zend_class_entry *ce ;
   HashTable *properties ;
   zval **properties_table ;
   HashTable *guards ;
};
typedef struct _zend_object zend_object;
union _zend_function;
union _zend_function;
struct _zend_property_info;
struct _zend_property_info;
struct _zend_literal;
struct _zend_literal;
typedef zval *(*zend_object_read_property_t)(zval *object , zval *member , int type , struct _zend_literal  const  *key );
typedef zval *(*zend_object_read_dimension_t)(zval *object , zval *offset , int type );
typedef void (*zend_object_write_property_t)(zval *object , zval *member , zval *value , struct _zend_literal  const  *key );
typedef void (*zend_object_write_dimension_t)(zval *object , zval *offset , zval *value );
typedef zval **(*zend_object_get_property_ptr_ptr_t)(zval *object , zval *member , struct _zend_literal  const  *key );
typedef void (*zend_object_set_t)(zval **object , zval *value );
typedef zval *(*zend_object_get_t)(zval *object );
typedef int (*zend_object_has_property_t)(zval *object , zval *member , int has_set_exists , struct _zend_literal  const  *key );
typedef int (*zend_object_has_dimension_t)(zval *object , zval *member , int check_empty );
typedef void (*zend_object_unset_property_t)(zval *object , zval *member , struct _zend_literal  const  *key );
typedef void (*zend_object_unset_dimension_t)(zval *object , zval *offset );
typedef HashTable *(*zend_object_get_properties_t)(zval *object );
typedef HashTable *(*zend_object_get_debug_info_t)(zval *object , int *is_temp );
typedef int (*zend_object_call_method_t)(char const   *method , int ht , zval *return_value , zval **return_value_ptr , zval *this_ptr , int return_value_used );
typedef union _zend_function *(*zend_object_get_method_t)(zval **object_ptr , char *method , int method_len , struct _zend_literal  const  *key );
typedef union _zend_function *(*zend_object_get_constructor_t)(zval *object );
typedef void (*zend_object_add_ref_t)(zval *object );
typedef void (*zend_object_del_ref_t)(zval *object );
typedef void (*zend_object_delete_obj_t)(zval *object );
typedef zend_object_value (*zend_object_clone_obj_t)(zval *object );
typedef zend_class_entry *(*zend_object_get_class_entry_t)(zval const   *object );
typedef int (*zend_object_get_class_name_t)(zval const   *object , char const   **class_name , zend_uint *class_name_len , int parent );
typedef int (*zend_object_compare_t)(zval *object1 , zval *object2 );
typedef int (*zend_object_cast_t)(zval *readobj , zval *retval , int type );
typedef int (*zend_object_count_elements_t)(zval *object , long *count );
typedef int (*zend_object_get_closure_t)(zval *obj , zend_class_entry **ce_ptr , union _zend_function **fptr_ptr , zval **zobj_ptr );
typedef HashTable *(*zend_object_get_gc_t)(zval *object , zval ***table , int *n );
struct _zend_object_handlers {
   void (*add_ref)(zval *object ) ;
   void (*del_ref)(zval *object ) ;
   zend_object_value (*clone_obj)(zval *object ) ;
   zval *(*read_property)(zval *object , zval *member , int type , struct _zend_literal  const  *key ) ;
   void (*write_property)(zval *object , zval *member , zval *value , struct _zend_literal  const  *key ) ;
   zval *(*read_dimension)(zval *object , zval *offset , int type ) ;
   void (*write_dimension)(zval *object , zval *offset , zval *value ) ;
   zval **(*get_property_ptr_ptr)(zval *object , zval *member , struct _zend_literal  const  *key ) ;
   zval *(*get)(zval *object ) ;
   void (*set)(zval **object , zval *value ) ;
   int (*has_property)(zval *object , zval *member , int has_set_exists , struct _zend_literal  const  *key ) ;
   void (*unset_property)(zval *object , zval *member , struct _zend_literal  const  *key ) ;
   int (*has_dimension)(zval *object , zval *member , int check_empty ) ;
   void (*unset_dimension)(zval *object , zval *offset ) ;
   HashTable *(*get_properties)(zval *object ) ;
   union _zend_function *(*get_method)(zval **object_ptr , char *method , int method_len , struct _zend_literal  const  *key ) ;
   int (*call_method)(char const   *method , int ht , zval *return_value , zval **return_value_ptr , zval *this_ptr , int return_value_used ) ;
   union _zend_function *(*get_constructor)(zval *object ) ;
   zend_class_entry *(*get_class_entry)(zval const   *object ) ;
   int (*get_class_name)(zval const   *object , char const   **class_name , zend_uint *class_name_len , int parent ) ;
   int (*compare_objects)(zval *object1 , zval *object2 ) ;
   int (*cast_object)(zval *readobj , zval *retval , int type ) ;
   int (*count_elements)(zval *object , long *count ) ;
   HashTable *(*get_debug_info)(zval *object , int *is_temp ) ;
   int (*get_closure)(zval *obj , zend_class_entry **ce_ptr , union _zend_function **fptr_ptr , zval **zobj_ptr ) ;
   HashTable *(*get_gc)(zval *object , zval ***table , int *n ) ;
};
struct __anonstruct_str_57 {
   char *val ;
   int len ;
};
union _zvalue_value {
   long lval ;
   double dval ;
   struct __anonstruct_str_57 str ;
   HashTable *ht ;
   zend_object_value obj ;
};
typedef union _zvalue_value zvalue_value;
struct _zval_struct {
   zvalue_value value ;
   zend_uint refcount__gc ;
   zend_uchar type ;
   zend_uchar is_ref__gc ;
};
union _zend_function;
struct _zend_object_iterator;
typedef struct _zend_object_iterator zend_object_iterator;
struct _zend_object_iterator_funcs {
   void (*dtor)(zend_object_iterator *iter ) ;
   int (*valid)(zend_object_iterator *iter ) ;
   void (*get_current_data)(zend_object_iterator *iter , zval ***data ) ;
   int (*get_current_key)(zend_object_iterator *iter , char **str_key , uint *str_key_len , ulong *int_key ) ;
   void (*move_forward)(zend_object_iterator *iter ) ;
   void (*rewind)(zend_object_iterator *iter ) ;
   void (*invalidate_current)(zend_object_iterator *iter ) ;
};
typedef struct _zend_object_iterator_funcs zend_object_iterator_funcs;
struct _zend_object_iterator {
   void *data ;
   zend_object_iterator_funcs *funcs ;
   ulong index ;
};
struct _zend_class_iterator_funcs {
   zend_object_iterator_funcs *funcs ;
   union _zend_function *zf_new_iterator ;
   union _zend_function *zf_valid ;
   union _zend_function *zf_current ;
   union _zend_function *zf_key ;
   union _zend_function *zf_next ;
   union _zend_function *zf_rewind ;
};
typedef struct _zend_class_iterator_funcs zend_class_iterator_funcs;
enum zend_object_iterator_kind {
    ZEND_ITER_INVALID = 0,
    ZEND_ITER_PLAIN_ARRAY = 1,
    ZEND_ITER_PLAIN_OBJECT = 2,
    ZEND_ITER_OBJECT = 3
} ;
struct _zend_serialize_data;
struct _zend_serialize_data;
struct _zend_unserialize_data;
struct _zend_unserialize_data;
typedef struct _zend_serialize_data zend_serialize_data;
typedef struct _zend_unserialize_data zend_unserialize_data;
struct _zend_trait_method_reference {
   char const   *method_name ;
   unsigned int mname_len ;
   zend_class_entry *ce ;
   char const   *class_name ;
   unsigned int cname_len ;
};
typedef struct _zend_trait_method_reference zend_trait_method_reference;
struct _zend_trait_precedence {
   zend_trait_method_reference *trait_method ;
   zend_class_entry **exclude_from_classes ;
   union _zend_function *function ;
};
typedef struct _zend_trait_precedence zend_trait_precedence;
struct _zend_trait_alias {
   zend_trait_method_reference *trait_method ;
   char const   *alias ;
   unsigned int alias_len ;
   zend_uint modifiers ;
   union _zend_function *function ;
};
typedef struct _zend_trait_alias zend_trait_alias;
struct __anonstruct_user_59 {
   char const   *filename ;
   zend_uint line_start ;
   zend_uint line_end ;
   char const   *doc_comment ;
   zend_uint doc_comment_len ;
};
struct _zend_function_entry;
struct _zend_module_entry;
struct __anonstruct_internal_60 {
   struct _zend_function_entry  const  *builtin_functions ;
   struct _zend_module_entry *module ;
};
union __anonunion_info_58 {
   struct __anonstruct_user_59 user ;
   struct __anonstruct_internal_60 internal ;
};
struct _zend_class_entry {
   char type ;
   char const   *name ;
   zend_uint name_length ;
   struct _zend_class_entry *parent ;
   int refcount ;
   zend_uint ce_flags ;
   HashTable function_table ;
   HashTable properties_info ;
   zval **default_properties_table ;
   zval **default_static_members_table ;
   zval **static_members_table ;
   HashTable constants_table ;
   int default_properties_count ;
   int default_static_members_count ;
   union _zend_function *constructor ;
   union _zend_function *destructor ;
   union _zend_function *clone ;
   union _zend_function *__get ;
   union _zend_function *__set ;
   union _zend_function *__unset ;
   union _zend_function *__isset ;
   union _zend_function *__call ;
   union _zend_function *__callstatic ;
   union _zend_function *__tostring ;
   union _zend_function *serialize_func ;
   union _zend_function *unserialize_func ;
   zend_class_iterator_funcs iterator_funcs ;
   zend_object_value (*create_object)(zend_class_entry *class_type ) ;
   zend_object_iterator *(*get_iterator)(zend_class_entry *ce , zval *object , int by_ref ) ;
   int (*interface_gets_implemented)(zend_class_entry *iface , zend_class_entry *class_type ) ;
   union _zend_function *(*get_static_method)(zend_class_entry *ce , char *method , int method_len ) ;
   int (*serialize)(zval *object , unsigned char **buffer , zend_uint *buf_len , zend_serialize_data *data ) ;
   int (*unserialize)(zval **object , zend_class_entry *ce , unsigned char const   *buf , zend_uint buf_len , zend_unserialize_data *data ) ;
   zend_class_entry **interfaces ;
   zend_uint num_interfaces ;
   zend_class_entry **traits ;
   zend_uint num_traits ;
   zend_trait_alias **trait_aliases ;
   zend_trait_precedence **trait_precedences ;
   union __anonunion_info_58 info ;
};
typedef size_t (*zend_stream_fsizer_t)(void *handle );
typedef size_t (*zend_stream_reader_t)(void *handle , char *buf , size_t len );
typedef void (*zend_stream_closer_t)(void *handle );
enum __anonenum_zend_stream_type_61 {
    ZEND_HANDLE_FILENAME = 0,
    ZEND_HANDLE_FD = 1,
    ZEND_HANDLE_FP = 2,
    ZEND_HANDLE_STREAM = 3,
    ZEND_HANDLE_MAPPED = 4
} ;
typedef enum __anonenum_zend_stream_type_61 zend_stream_type;
struct _zend_mmap {
   size_t len ;
   size_t pos ;
   void *map ;
   char *buf ;
   void *old_handle ;
   void (*old_closer)(void *handle ) ;
};
typedef struct _zend_mmap zend_mmap;
struct _zend_stream {
   void *handle ;
   int isatty ;
   zend_mmap mmap ;
   size_t (*reader)(void *handle , char *buf , size_t len ) ;
   size_t (*fsizer)(void *handle ) ;
   void (*closer)(void *handle ) ;
};
typedef struct _zend_stream zend_stream;
union __anonunion_handle_62 {
   int fd ;
   FILE *fp ;
   zend_stream stream ;
};
struct _zend_file_handle {
   zend_stream_type type ;
   char const   *filename ;
   char *opened_path ;
   union __anonunion_handle_62 handle ;
   zend_bool free_filename ;
};
typedef struct _zend_file_handle zend_file_handle;
struct _zend_utility_functions {
   void ( /* format attribute */  (*error_function))(int type , char const   *error_filename , uint error_lineno , char const   *format , va_list args ) ;
   int ( /* format attribute */  (*printf_function))(char const   *format  , ...) ;
   int (*write_function)(char const   *str , uint str_length ) ;
   FILE *(*fopen_function)(char const   *filename , char **opened_path ) ;
   void (*message_handler)(long message , void const   *data ) ;
   int (*get_configuration_directive)(char const   *name , uint name_length , zval *contents ) ;
   void (*ticks_function)(int ticks ) ;
   void (*on_timeout)(int seconds ) ;
   int (*stream_open_function)(char const   *filename , zend_file_handle *handle ) ;
   int (*vspprintf_function)(char **pbuf , size_t max_len , char const   *format , va_list ap ) ;
   char *(*getenv_function)(char *name , size_t name_len ) ;
   char *(*resolve_path_function)(char const   *filename , int filename_len ) ;
};
typedef struct _zend_utility_functions zend_utility_functions;
struct _zend_utility_values {
   char *import_use_extension ;
   uint import_use_extension_length ;
   zend_bool html_errors ;
};
typedef struct _zend_utility_values zend_utility_values;
typedef int (*zend_write_func_t)(char const   *str , uint str_length );
struct _zend_signal_entry_t {
   int flags ;
   void *handler ;
};
typedef struct _zend_signal_entry_t zend_signal_entry_t;
struct _zend_signal_t {
   int signo ;
   siginfo_t *siginfo ;
   void *context ;
};
typedef struct _zend_signal_t zend_signal_t;
struct _zend_signal_queue_t {
   zend_signal_t zend_signal ;
   struct _zend_signal_queue_t *next ;
};
typedef struct _zend_signal_queue_t zend_signal_queue_t;
struct _zend_signal_globals_t {
   int depth ;
   int blocked ;
   int running ;
   int active ;
   int initialized ;
   zend_bool check ;
   zend_signal_entry_t handlers[65] ;
   zend_signal_queue_t pstorage[32] ;
   zend_signal_queue_t *phead ;
   zend_signal_queue_t *ptail ;
   zend_signal_queue_t *pavail ;
};
typedef struct _zend_signal_globals_t zend_signal_globals_t;
union __anonunion_u_63 {
   zval *pz ;
   zend_object_handlers const   *handlers ;
};
struct _gc_root_buffer {
   struct _gc_root_buffer *prev ;
   struct _gc_root_buffer *next ;
   zend_object_handle handle ;
   union __anonunion_u_63 u ;
};
typedef struct _gc_root_buffer gc_root_buffer;
union __anonunion_u_64 {
   gc_root_buffer *buffered ;
   struct _zval_gc_info *next ;
};
struct _zval_gc_info {
   zval z ;
   union __anonunion_u_64 u ;
};
typedef struct _zval_gc_info zval_gc_info;
struct _zend_gc_globals {
   zend_bool gc_enabled ;
   zend_bool gc_active ;
   gc_root_buffer *buf ;
   gc_root_buffer roots ;
   gc_root_buffer *unused ;
   gc_root_buffer *first_unused ;
   gc_root_buffer *last_unused ;
   zval_gc_info *zval_to_free ;
   zval_gc_info *free_list ;
   zval_gc_info *next_to_free ;
   zend_uint gc_runs ;
   zend_uint collected ;
};
typedef struct _zend_gc_globals zend_gc_globals;
enum __anonenum_zend_error_handling_t_65 {
    EH_NORMAL = 0,
    EH_SUPPRESS = 1,
    EH_THROW = 2
} ;
typedef enum __anonenum_zend_error_handling_t_65 zend_error_handling_t;
struct __anonstruct_zend_error_handling_66 {
   zend_error_handling_t handling ;
   zend_class_entry *exception ;
   zval *user_handler ;
};
typedef struct __anonstruct_zend_error_handling_66 zend_error_handling;
struct _zend_op_array;
typedef struct _zend_op_array zend_op_array;
struct _zend_op;
typedef struct _zend_op zend_op;
struct _zend_compiler_context {
   zend_uint opcodes_size ;
   int vars_size ;
   int literals_size ;
   int current_brk_cont ;
   int backpatch_count ;
   HashTable *labels ;
};
typedef struct _zend_compiler_context zend_compiler_context;
struct _zend_literal {
   zval constant ;
   zend_ulong hash_value ;
   zend_uint cache_slot ;
};
typedef struct _zend_literal zend_literal;
union _znode_op {
   zend_uint constant ;
   zend_uint var ;
   zend_uint num ;
   zend_ulong hash ;
   zend_uint opline_num ;
   zend_op *jmp_addr ;
   zval *zv ;
   zend_literal *literal ;
   void *ptr ;
};
typedef union _znode_op znode_op;
union __anonunion_u_67 {
   znode_op op ;
   zval constant ;
   zend_op_array *op_array ;
};
struct _znode {
   int op_type ;
   union __anonunion_u_67 u ;
   zend_uint EA ;
};
typedef struct _znode znode;
struct _zend_execute_data;
typedef struct _zend_execute_data zend_execute_data;
typedef int (*user_opcode_handler_t)(zend_execute_data *execute_data );
typedef int ( __attribute__((__fastcall__)) (*opcode_handler_t))(zend_execute_data *execute_data );
struct _zend_op {
   int ( __attribute__((__fastcall__)) (*handler))(zend_execute_data *execute_data ) ;
   znode_op op1 ;
   znode_op op2 ;
   znode_op result ;
   ulong extended_value ;
   uint lineno ;
   zend_uchar opcode ;
   zend_uchar op1_type ;
   zend_uchar op2_type ;
   zend_uchar result_type ;
};
struct _zend_brk_cont_element {
   int start ;
   int cont ;
   int brk ;
   int parent ;
};
typedef struct _zend_brk_cont_element zend_brk_cont_element;
struct _zend_label {
   int brk_cont ;
   zend_uint opline_num ;
};
typedef struct _zend_label zend_label;
struct _zend_try_catch_element {
   zend_uint try_op ;
   zend_uint catch_op ;
};
typedef struct _zend_try_catch_element zend_try_catch_element;
struct _zend_property_info {
   zend_uint flags ;
   char const   *name ;
   int name_length ;
   ulong h ;
   int offset ;
   char const   *doc_comment ;
   int doc_comment_len ;
   zend_class_entry *ce ;
};
typedef struct _zend_property_info zend_property_info;
struct _zend_arg_info {
   char const   *name ;
   zend_uint name_len ;
   char const   *class_name ;
   zend_uint class_name_len ;
   zend_uchar type_hint ;
   zend_bool allow_null ;
   zend_bool pass_by_reference ;
};
typedef struct _zend_arg_info zend_arg_info;
struct _zend_internal_function_info {
   char const   *_name ;
   zend_uint _name_len ;
   char const   *_class_name ;
   zend_uint required_num_args ;
   zend_uchar _type_hint ;
   zend_bool return_reference ;
   zend_bool pass_rest_by_reference ;
};
typedef struct _zend_internal_function_info zend_internal_function_info;
struct _zend_compiled_variable {
   char const   *name ;
   int name_len ;
   ulong hash_value ;
};
typedef struct _zend_compiled_variable zend_compiled_variable;
struct _zend_op_array {
   zend_uchar type ;
   char const   *function_name ;
   zend_class_entry *scope ;
   zend_uint fn_flags ;
   union _zend_function *prototype ;
   zend_uint num_args ;
   zend_uint required_num_args ;
   zend_arg_info *arg_info ;
   zend_uint *refcount ;
   zend_op *opcodes ;
   zend_uint last ;
   zend_compiled_variable *vars ;
   int last_var ;
   zend_uint T ;
   zend_brk_cont_element *brk_cont_array ;
   int last_brk_cont ;
   zend_try_catch_element *try_catch_array ;
   int last_try_catch ;
   HashTable *static_variables ;
   zend_uint this_var ;
   char const   *filename ;
   zend_uint line_start ;
   zend_uint line_end ;
   char const   *doc_comment ;
   zend_uint doc_comment_len ;
   zend_uint early_binding ;
   zend_literal *literals ;
   int last_literal ;
   void **run_time_cache ;
   int last_cache_slot ;
   void *reserved[4] ;
};
struct _zend_internal_function {
   zend_uchar type ;
   char const   *function_name ;
   zend_class_entry *scope ;
   zend_uint fn_flags ;
   union _zend_function *prototype ;
   zend_uint num_args ;
   zend_uint required_num_args ;
   zend_arg_info *arg_info ;
   void (*handler)(int ht , zval *return_value , zval **return_value_ptr , zval *this_ptr , int return_value_used ) ;
   struct _zend_module_entry *module ;
};
typedef struct _zend_internal_function zend_internal_function;
struct __anonstruct_common_68 {
   zend_uchar type ;
   char const   *function_name ;
   zend_class_entry *scope ;
   zend_uint fn_flags ;
   union _zend_function *prototype ;
   zend_uint num_args ;
   zend_uint required_num_args ;
   zend_arg_info *arg_info ;
};
union _zend_function {
   zend_uchar type ;
   struct __anonstruct_common_68 common ;
   zend_op_array op_array ;
   zend_internal_function internal_function ;
};
typedef union _zend_function zend_function;
struct _zend_function_state {
   zend_function *function ;
   void **arguments ;
};
typedef struct _zend_function_state zend_function_state;
struct _zend_switch_entry {
   znode cond ;
   int default_case ;
   int control_var ;
};
typedef struct _zend_switch_entry zend_switch_entry;
struct _list_llist_element {
   znode var ;
   zend_llist dimensions ;
   znode value ;
};
typedef struct _list_llist_element list_llist_element;
union _temp_variable;
union _temp_variable;
struct _zend_execute_data {
   struct _zend_op *opline ;
   zend_function_state function_state ;
   zend_function *fbc ;
   zend_class_entry *called_scope ;
   zend_op_array *op_array ;
   zval *object ;
   union _temp_variable *Ts ;
   zval ***CVs ;
   HashTable *symbol_table ;
   struct _zend_execute_data *prev_execute_data ;
   zval *old_error_reporting ;
   zend_bool nested ;
   zval **original_return_value ;
   zend_class_entry *current_scope ;
   zend_class_entry *current_called_scope ;
   zval *current_this ;
   zval *current_object ;
};
typedef int __jmp_buf[6];
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
typedef struct __jmp_buf_tag jmp_buf[1];
typedef struct __jmp_buf_tag sigjmp_buf[1];
struct _zend_compiler_globals;
typedef struct _zend_compiler_globals zend_compiler_globals;
struct _zend_executor_globals;
typedef struct _zend_executor_globals zend_executor_globals;
struct _zend_php_scanner_globals;
typedef struct _zend_php_scanner_globals zend_php_scanner_globals;
struct _zend_ini_scanner_globals;
typedef struct _zend_ini_scanner_globals zend_ini_scanner_globals;
struct _zend_stack {
   int top ;
   int max ;
   void **elements ;
};
typedef struct _zend_stack zend_stack;
struct _zend_ptr_stack {
   int top ;
   int max ;
   void **elements ;
   void **top_element ;
   zend_bool persistent ;
};
typedef struct _zend_ptr_stack zend_ptr_stack;
typedef void (*zend_objects_store_dtor_t)(void *object , zend_object_handle handle );
typedef void (*zend_objects_free_object_storage_t)(void *object );
typedef void (*zend_objects_store_clone_t)(void *object , void **object_clone );
struct _store_object {
   void *object ;
   void (*dtor)(void *object , zend_object_handle handle ) ;
   void (*free_storage)(void *object ) ;
   void (*clone)(void *object , void **object_clone ) ;
   zend_object_handlers const   *handlers ;
   zend_uint refcount ;
   gc_root_buffer *buffered ;
};
struct __anonstruct_free_list_69 {
   int next ;
};
union _store_bucket {
   struct _store_object obj ;
   struct __anonstruct_free_list_69 free_list ;
};
struct _zend_object_store_bucket {
   zend_bool destructor_called ;
   zend_bool valid ;
   union _store_bucket bucket ;
};
typedef struct _zend_object_store_bucket zend_object_store_bucket;
struct _zend_objects_store {
   zend_object_store_bucket *object_buckets ;
   zend_uint top ;
   zend_uint size ;
   int free_list_head ;
};
typedef struct _zend_objects_store zend_objects_store;
struct _zend_ini_entry;
struct _zend_ini_entry;
typedef struct _zend_module_entry zend_module_entry;
struct _zend_module_dep;
typedef struct _zend_module_dep zend_module_dep;
struct _zend_module_entry {
   unsigned short size ;
   unsigned int zend_api ;
   unsigned char zend_debug ;
   unsigned char zts ;
   struct _zend_ini_entry  const  *ini_entry ;
   struct _zend_module_dep  const  *deps ;
   char const   *name ;
   struct _zend_function_entry  const  *functions ;
   int (*module_startup_func)(int type , int module_number ) ;
   int (*module_shutdown_func)(int type , int module_number ) ;
   int (*request_startup_func)(int type , int module_number ) ;
   int (*request_shutdown_func)(int type , int module_number ) ;
   void (*info_func)(zend_module_entry *zend_module ) ;
   char const   *version ;
   size_t globals_size ;
   void *globals_ptr ;
   void (*globals_ctor)(void *global ) ;
   void (*globals_dtor)(void *global ) ;
   int (*post_deactivate_func)(void) ;
   int module_started ;
   unsigned char type ;
   void *handle ;
   int module_number ;
   char const   *build_id ;
};
struct _zend_module_dep {
   char const   *name ;
   char const   *rel ;
   char const   *version ;
   unsigned char type ;
};
typedef unsigned short fpu_control_t;
struct _zend_encoding;
typedef struct _zend_encoding zend_encoding;
typedef size_t (*zend_encoding_filter)(unsigned char **str , size_t *str_length , unsigned char const   *buf , size_t length );
typedef zend_encoding const   *(*zend_encoding_fetcher)(char const   *encoding_name );
typedef char const   *(*zend_encoding_name_getter)(zend_encoding const   *encoding );
typedef int (*zend_encoding_lexer_compatibility_checker)(zend_encoding const   *encoding );
typedef zend_encoding const   *(*zend_encoding_detector)(unsigned char const   *string , size_t length , zend_encoding const   **list , size_t list_size );
typedef size_t (*zend_encoding_converter)(unsigned char **to , size_t *to_length , unsigned char const   *from , size_t from_length , zend_encoding const   *encoding_to , zend_encoding const   *encoding_from );
typedef int (*zend_encoding_list_parser)(char const   *encoding_list , size_t encoding_list_len , zend_encoding const   ***return_list , size_t *return_size , int persistent );
typedef zend_encoding const   *(*zend_encoding_internal_encoding_getter)(void);
typedef int (*zend_encoding_internal_encoding_setter)(zend_encoding const   *encoding );
struct _zend_multibyte_functions {
   char const   *provider_name ;
   zend_encoding const   *(*encoding_fetcher)(char const   *encoding_name ) ;
   char const   *(*encoding_name_getter)(zend_encoding const   *encoding ) ;
   int (*lexer_compatibility_checker)(zend_encoding const   *encoding ) ;
   zend_encoding const   *(*encoding_detector)(unsigned char const   *string , size_t length , zend_encoding const   **list , size_t list_size ) ;
   size_t (*encoding_converter)(unsigned char **to , size_t *to_length , unsigned char const   *from , size_t from_length , zend_encoding const   *encoding_to , zend_encoding const   *encoding_from ) ;
   int (*encoding_list_parser)(char const   *encoding_list , size_t encoding_list_len , zend_encoding const   ***return_list , size_t *return_size , int persistent ) ;
   zend_encoding const   *(*internal_encoding_getter)(void) ;
   int (*internal_encoding_setter)(zend_encoding const   *encoding ) ;
};
typedef struct _zend_multibyte_functions zend_multibyte_functions;
struct _zend_declarables {
   zval ticks ;
};
typedef struct _zend_declarables zend_declarables;
struct _zend_vm_stack;
typedef struct _zend_vm_stack *zend_vm_stack;
typedef struct _zend_ini_entry zend_ini_entry;
struct _zend_ini_parser_param;
struct _zend_compiler_globals {
   zend_stack bp_stack ;
   zend_stack switch_cond_stack ;
   zend_stack foreach_copy_stack ;
   zend_stack object_stack ;
   zend_stack declare_stack ;
   zend_class_entry *active_class_entry ;
   zend_llist list_llist ;
   zend_llist dimension_llist ;
   zend_stack list_stack ;
   zend_stack function_call_stack ;
   char *compiled_filename ;
   int zend_lineno ;
   char *heredoc ;
   int heredoc_len ;
   zend_op_array *active_op_array ;
   HashTable *function_table ;
   HashTable *class_table ;
   HashTable filenames_table ;
   HashTable *auto_globals ;
   zend_bool parse_error ;
   zend_bool in_compilation ;
   zend_bool short_tags ;
   zend_bool asp_tags ;
   zend_declarables declarables ;
   zend_bool unclean_shutdown ;
   zend_bool ini_parser_unbuffered_errors ;
   zend_llist open_files ;
   long catch_begin ;
   struct _zend_ini_parser_param *ini_parser_param ;
   int interactive ;
   zend_uint start_lineno ;
   zend_bool increment_lineno ;
   znode implementing_class ;
   zend_uint access_type ;
   char *doc_comment ;
   zend_uint doc_comment_len ;
   zend_uint compiler_options ;
   zval *current_namespace ;
   HashTable *current_import ;
   zend_bool in_namespace ;
   zend_bool has_bracketed_namespaces ;
   zend_compiler_context context ;
   zend_stack context_stack ;
   char *interned_strings_start ;
   char *interned_strings_end ;
   char *interned_strings_top ;
   char *interned_strings_snapshot_top ;
   HashTable interned_strings ;
   zend_encoding const   **script_encoding_list ;
   size_t script_encoding_list_size ;
   zend_bool multibyte ;
   zend_bool detect_unicode ;
   zend_bool encoding_declared ;
};
struct _zend_executor_globals {
   zval **return_value_ptr_ptr ;
   zval uninitialized_zval ;
   zval *uninitialized_zval_ptr ;
   zval error_zval ;
   zval *error_zval_ptr ;
   zend_ptr_stack arg_types_stack ;
   HashTable *symtable_cache[32] ;
   HashTable **symtable_cache_limit ;
   HashTable **symtable_cache_ptr ;
   zend_op **opline_ptr ;
   HashTable *active_symbol_table ;
   HashTable symbol_table ;
   HashTable included_files ;
   jmp_buf *bailout ;
   int error_reporting ;
   int orig_error_reporting ;
   int exit_status ;
   zend_op_array *active_op_array ;
   HashTable *function_table ;
   HashTable *class_table ;
   HashTable *zend_constants ;
   zend_class_entry *scope ;
   zend_class_entry *called_scope ;
   zval *This ;
   long precision ;
   int ticks_count ;
   zend_bool in_execution ;
   HashTable *in_autoload ;
   zend_function *autoload_func ;
   zend_bool full_tables_cleanup ;
   zend_bool no_extensions ;
   HashTable regular_list ;
   HashTable persistent_list ;
   zend_vm_stack argument_stack ;
   int user_error_handler_error_reporting ;
   zval *user_error_handler ;
   zval *user_exception_handler ;
   zend_stack user_error_handlers_error_reporting ;
   zend_ptr_stack user_error_handlers ;
   zend_ptr_stack user_exception_handlers ;
   zend_error_handling_t error_handling ;
   zend_class_entry *exception_class ;
   int timeout_seconds ;
   int lambda_count ;
   HashTable *ini_directives ;
   HashTable *modified_ini_directives ;
   zend_ini_entry *error_reporting_ini_entry ;
   zend_objects_store objects_store ;
   zval *exception ;
   zval *prev_exception ;
   zend_op *opline_before_exception ;
   zend_op exception_op[3] ;
   struct _zend_execute_data *current_execute_data ;
   struct _zend_module_entry *current_module ;
   zend_property_info std_property_info ;
   zend_bool active ;
   zend_op *start_op ;
   void *saved_fpu_cw_ptr ;
   fpu_control_t saved_fpu_cw ;
   void *reserved[4] ;
};
struct _zend_ini_scanner_globals {
   zend_file_handle *yy_in ;
   zend_file_handle *yy_out ;
   unsigned int yy_leng ;
   unsigned char *yy_start ;
   unsigned char *yy_text ;
   unsigned char *yy_cursor ;
   unsigned char *yy_marker ;
   unsigned char *yy_limit ;
   int yy_state ;
   zend_stack state_stack ;
   char *filename ;
   int lineno ;
   int scanner_mode ;
};
struct _zend_php_scanner_globals {
   zend_file_handle *yy_in ;
   zend_file_handle *yy_out ;
   unsigned int yy_leng ;
   unsigned char *yy_start ;
   unsigned char *yy_text ;
   unsigned char *yy_cursor ;
   unsigned char *yy_marker ;
   unsigned char *yy_limit ;
   int yy_state ;
   zend_stack state_stack ;
   unsigned char *script_org ;
   size_t script_org_size ;
   unsigned char *script_filtered ;
   size_t script_filtered_size ;
   size_t (*input_filter)(unsigned char **str , size_t *str_length , unsigned char const   *buf , size_t length ) ;
   size_t (*output_filter)(unsigned char **str , size_t *str_length , unsigned char const   *buf , size_t length ) ;
   zend_encoding const   *script_encoding ;
};
typedef int (*unary_op_type)(zval * , zval * );
typedef int (*binary_op_type)(zval * , zval * , zval * );
typedef zend_bool (*zend_auto_global_callback)(char const   *name , uint name_len );
struct _zend_auto_global {
   char const   *name ;
   uint name_len ;
   zend_bool (*auto_global_callback)(char const   *name , uint name_len ) ;
   zend_bool jit ;
   zend_bool armed ;
};
typedef struct _zend_auto_global zend_auto_global;
struct __anonstruct_var_70 {
   zval **ptr_ptr ;
   zval *ptr ;
   zend_bool fcall_returned_reference ;
};
struct __anonstruct_str_offset_71 {
   zval **ptr_ptr ;
   zval *str ;
   zend_uint offset ;
};
struct __anonstruct_fe_72 {
   zval **ptr_ptr ;
   zval *ptr ;
   HashPointer fe_pos ;
};
union _temp_variable {
   zval tmp_var ;
   struct __anonstruct_var_70 var ;
   struct __anonstruct_str_offset_71 str_offset ;
   struct __anonstruct_fe_72 fe ;
   zend_class_entry *class_entry ;
};
typedef union _temp_variable temp_variable;
struct _zend_vm_stack {
   void **top ;
   void **end ;
   zend_vm_stack prev ;
};
struct _zend_free_op {
   zval *var ;
};
typedef struct _zend_free_op zend_free_op;
struct _zend_rsrc_list_entry {
   void *ptr ;
   int type ;
   int refcount ;
};
typedef struct _zend_rsrc_list_entry zend_rsrc_list_entry;
typedef void (*rsrc_dtor_func_t)(zend_rsrc_list_entry *rsrc );
struct _zend_rsrc_list_dtors_entry {
   void (*list_dtor)(void * ) ;
   void (*plist_dtor)(void * ) ;
   void (*list_dtor_ex)(zend_rsrc_list_entry *rsrc ) ;
   void (*plist_dtor_ex)(zend_rsrc_list_entry *rsrc ) ;
   char const   *type_name ;
   int module_number ;
   int resource_id ;
   unsigned char type ;
};
typedef struct _zend_rsrc_list_dtors_entry zend_rsrc_list_dtors_entry;
struct _zend_function_entry {
   char const   *fname ;
   void (*handler)(int ht , zval *return_value , zval **return_value_ptr , zval *this_ptr , int return_value_used ) ;
   struct _zend_arg_info  const  *arg_info ;
   zend_uint num_args ;
   zend_uint flags ;
};
typedef struct _zend_function_entry zend_function_entry;
struct _zend_fcall_info {
   size_t size ;
   HashTable *function_table ;
   zval *function_name ;
   HashTable *symbol_table ;
   zval **retval_ptr_ptr ;
   zend_uint param_count ;
   zval ***params ;
   zval *object_ptr ;
   zend_bool no_separation ;
};
typedef struct _zend_fcall_info zend_fcall_info;
struct _zend_fcall_info_cache {
   zend_bool initialized ;
   zend_function *function_handler ;
   zend_class_entry *calling_scope ;
   zend_class_entry *called_scope ;
   zval *object_ptr ;
};
typedef struct _zend_fcall_info_cache zend_fcall_info_cache;
struct _zend_constant {
   zval value ;
   int flags ;
   char *name ;
   uint name_len ;
   int module_number ;
};
typedef struct _zend_constant zend_constant;
struct _zend_extension_version_info {
   int zend_extension_api_no ;
   char *build_id ;
};
typedef struct _zend_extension_version_info zend_extension_version_info;
struct _zend_extension;
typedef struct _zend_extension zend_extension;
typedef int (*startup_func_t)(zend_extension *extension );
typedef void (*shutdown_func_t)(zend_extension *extension );
typedef void (*activate_func_t)(void);
typedef void (*deactivate_func_t)(void);
typedef void (*message_handler_func_t)(int message , void *arg );
typedef void (*op_array_handler_func_t)(zend_op_array *op_array );
typedef void (*statement_handler_func_t)(zend_op_array *op_array );
typedef void (*fcall_begin_handler_func_t)(zend_op_array *op_array );
typedef void (*fcall_end_handler_func_t)(zend_op_array *op_array );
typedef void (*op_array_ctor_func_t)(zend_op_array *op_array );
typedef void (*op_array_dtor_func_t)(zend_op_array *op_array );
struct _zend_extension {
   char *name ;
   char *version ;
   char *author ;
   char *URL ;
   char *copyright ;
   int (*startup)(zend_extension *extension ) ;
   void (*shutdown)(zend_extension *extension ) ;
   void (*activate)(void) ;
   void (*deactivate)(void) ;
   void (*message_handler)(int message , void *arg ) ;
   void (*op_array_handler)(zend_op_array *op_array ) ;
   void (*statement_handler)(zend_op_array *op_array ) ;
   void (*fcall_begin_handler)(zend_op_array *op_array ) ;
   void (*fcall_end_handler)(zend_op_array *op_array ) ;
   void (*op_array_ctor)(zend_op_array *op_array ) ;
   void (*op_array_dtor)(zend_op_array *op_array ) ;
   int (*api_no_check)(int api_no ) ;
   int (*build_id_check)(char const   *build_id ) ;
   void *reserved3 ;
   void *reserved4 ;
   void *reserved5 ;
   void *reserved6 ;
   void *reserved7 ;
   void *reserved8 ;
   void *handle ;
   int resource_number ;
};
struct _zend_ini_entry {
   int module_number ;
   int modifiable ;
   char *name ;
   uint name_length ;
   int (*on_modify)(zend_ini_entry *entry , char *new_value , uint new_value_length , void *mh_arg1 , void *mh_arg2 , void *mh_arg3 , int stage ) ;
   void *mh_arg1 ;
   void *mh_arg2 ;
   void *mh_arg3 ;
   char *value ;
   uint value_length ;
   char *orig_value ;
   uint orig_value_length ;
   int orig_modifiable ;
   int modified ;
   void (*displayer)(zend_ini_entry *ini_entry , int type ) ;
};
typedef void (*zend_ini_parser_cb_t)(zval *arg1 , zval *arg2 , zval *arg3 , int callback_type , void *arg );
struct _zend_ini_parser_param {
   void (*ini_parser_cb)(zval *arg1 , zval *arg2 , zval *arg3 , int callback_type , void *arg ) ;
   void *arg ;
};
typedef struct _zend_ini_parser_param zend_ini_parser_param;
struct _zend_user_iterator {
   zend_object_iterator it ;
   zend_class_entry *ce ;
   zval *value ;
};
typedef struct _zend_user_iterator zend_user_iterator;
typedef __useconds_t useconds_t;
typedef __intptr_t intptr_t;
typedef __socklen_t socklen_t;
enum __anonenum_73 {
    _PC_LINK_MAX = 0,
    _PC_MAX_CANON = 1,
    _PC_MAX_INPUT = 2,
    _PC_NAME_MAX = 3,
    _PC_PATH_MAX = 4,
    _PC_PIPE_BUF = 5,
    _PC_CHOWN_RESTRICTED = 6,
    _PC_NO_TRUNC = 7,
    _PC_VDISABLE = 8,
    _PC_SYNC_IO = 9,
    _PC_ASYNC_IO = 10,
    _PC_PRIO_IO = 11,
    _PC_SOCK_MAXBUF = 12,
    _PC_FILESIZEBITS = 13,
    _PC_REC_INCR_XFER_SIZE = 14,
    _PC_REC_MAX_XFER_SIZE = 15,
    _PC_REC_MIN_XFER_SIZE = 16,
    _PC_REC_XFER_ALIGN = 17,
    _PC_ALLOC_SIZE_MIN = 18,
    _PC_SYMLINK_MAX = 19,
    _PC_2_SYMLINKS = 20
} ;
enum __anonenum_74 {
    _SC_ARG_MAX = 0,
    _SC_CHILD_MAX = 1,
    _SC_CLK_TCK = 2,
    _SC_NGROUPS_MAX = 3,
    _SC_OPEN_MAX = 4,
    _SC_STREAM_MAX = 5,
    _SC_TZNAME_MAX = 6,
    _SC_JOB_CONTROL = 7,
    _SC_SAVED_IDS = 8,
    _SC_REALTIME_SIGNALS = 9,
    _SC_PRIORITY_SCHEDULING = 10,
    _SC_TIMERS = 11,
    _SC_ASYNCHRONOUS_IO = 12,
    _SC_PRIORITIZED_IO = 13,
    _SC_SYNCHRONIZED_IO = 14,
    _SC_FSYNC = 15,
    _SC_MAPPED_FILES = 16,
    _SC_MEMLOCK = 17,
    _SC_MEMLOCK_RANGE = 18,
    _SC_MEMORY_PROTECTION = 19,
    _SC_MESSAGE_PASSING = 20,
    _SC_SEMAPHORES = 21,
    _SC_SHARED_MEMORY_OBJECTS = 22,
    _SC_AIO_LISTIO_MAX = 23,
    _SC_AIO_MAX = 24,
    _SC_AIO_PRIO_DELTA_MAX = 25,
    _SC_DELAYTIMER_MAX = 26,
    _SC_MQ_OPEN_MAX = 27,
    _SC_MQ_PRIO_MAX = 28,
    _SC_VERSION = 29,
    _SC_PAGESIZE = 30,
    _SC_RTSIG_MAX = 31,
    _SC_SEM_NSEMS_MAX = 32,
    _SC_SEM_VALUE_MAX = 33,
    _SC_SIGQUEUE_MAX = 34,
    _SC_TIMER_MAX = 35,
    _SC_BC_BASE_MAX = 36,
    _SC_BC_DIM_MAX = 37,
    _SC_BC_SCALE_MAX = 38,
    _SC_BC_STRING_MAX = 39,
    _SC_COLL_WEIGHTS_MAX = 40,
    _SC_EQUIV_CLASS_MAX = 41,
    _SC_EXPR_NEST_MAX = 42,
    _SC_LINE_MAX = 43,
    _SC_RE_DUP_MAX = 44,
    _SC_CHARCLASS_NAME_MAX = 45,
    _SC_2_VERSION = 46,
    _SC_2_C_BIND = 47,
    _SC_2_C_DEV = 48,
    _SC_2_FORT_DEV = 49,
    _SC_2_FORT_RUN = 50,
    _SC_2_SW_DEV = 51,
    _SC_2_LOCALEDEF = 52,
    _SC_PII = 53,
    _SC_PII_XTI = 54,
    _SC_PII_SOCKET = 55,
    _SC_PII_INTERNET = 56,
    _SC_PII_OSI = 57,
    _SC_POLL = 58,
    _SC_SELECT = 59,
    _SC_UIO_MAXIOV = 60,
    _SC_IOV_MAX = 60,
    _SC_PII_INTERNET_STREAM = 61,
    _SC_PII_INTERNET_DGRAM = 62,
    _SC_PII_OSI_COTS = 63,
    _SC_PII_OSI_CLTS = 64,
    _SC_PII_OSI_M = 65,
    _SC_T_IOV_MAX = 66,
    _SC_THREADS = 67,
    _SC_THREAD_SAFE_FUNCTIONS = 68,
    _SC_GETGR_R_SIZE_MAX = 69,
    _SC_GETPW_R_SIZE_MAX = 70,
    _SC_LOGIN_NAME_MAX = 71,
    _SC_TTY_NAME_MAX = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS = 73,
    _SC_THREAD_KEYS_MAX = 74,
    _SC_THREAD_STACK_MIN = 75,
    _SC_THREAD_THREADS_MAX = 76,
    _SC_THREAD_ATTR_STACKADDR = 77,
    _SC_THREAD_ATTR_STACKSIZE = 78,
    _SC_THREAD_PRIORITY_SCHEDULING = 79,
    _SC_THREAD_PRIO_INHERIT = 80,
    _SC_THREAD_PRIO_PROTECT = 81,
    _SC_THREAD_PROCESS_SHARED = 82,
    _SC_NPROCESSORS_CONF = 83,
    _SC_NPROCESSORS_ONLN = 84,
    _SC_PHYS_PAGES = 85,
    _SC_AVPHYS_PAGES = 86,
    _SC_ATEXIT_MAX = 87,
    _SC_PASS_MAX = 88,
    _SC_XOPEN_VERSION = 89,
    _SC_XOPEN_XCU_VERSION = 90,
    _SC_XOPEN_UNIX = 91,
    _SC_XOPEN_CRYPT = 92,
    _SC_XOPEN_ENH_I18N = 93,
    _SC_XOPEN_SHM = 94,
    _SC_2_CHAR_TERM = 95,
    _SC_2_C_VERSION = 96,
    _SC_2_UPE = 97,
    _SC_XOPEN_XPG2 = 98,
    _SC_XOPEN_XPG3 = 99,
    _SC_XOPEN_XPG4 = 100,
    _SC_CHAR_BIT = 101,
    _SC_CHAR_MAX = 102,
    _SC_CHAR_MIN = 103,
    _SC_INT_MAX = 104,
    _SC_INT_MIN = 105,
    _SC_LONG_BIT = 106,
    _SC_WORD_BIT = 107,
    _SC_MB_LEN_MAX = 108,
    _SC_NZERO = 109,
    _SC_SSIZE_MAX = 110,
    _SC_SCHAR_MAX = 111,
    _SC_SCHAR_MIN = 112,
    _SC_SHRT_MAX = 113,
    _SC_SHRT_MIN = 114,
    _SC_UCHAR_MAX = 115,
    _SC_UINT_MAX = 116,
    _SC_ULONG_MAX = 117,
    _SC_USHRT_MAX = 118,
    _SC_NL_ARGMAX = 119,
    _SC_NL_LANGMAX = 120,
    _SC_NL_MSGMAX = 121,
    _SC_NL_NMAX = 122,
    _SC_NL_SETMAX = 123,
    _SC_NL_TEXTMAX = 124,
    _SC_XBS5_ILP32_OFF32 = 125,
    _SC_XBS5_ILP32_OFFBIG = 126,
    _SC_XBS5_LP64_OFF64 = 127,
    _SC_XBS5_LPBIG_OFFBIG = 128,
    _SC_XOPEN_LEGACY = 129,
    _SC_XOPEN_REALTIME = 130,
    _SC_XOPEN_REALTIME_THREADS = 131,
    _SC_ADVISORY_INFO = 132,
    _SC_BARRIERS = 133,
    _SC_BASE = 134,
    _SC_C_LANG_SUPPORT = 135,
    _SC_C_LANG_SUPPORT_R = 136,
    _SC_CLOCK_SELECTION = 137,
    _SC_CPUTIME = 138,
    _SC_THREAD_CPUTIME = 139,
    _SC_DEVICE_IO = 140,
    _SC_DEVICE_SPECIFIC = 141,
    _SC_DEVICE_SPECIFIC_R = 142,
    _SC_FD_MGMT = 143,
    _SC_FIFO = 144,
    _SC_PIPE = 145,
    _SC_FILE_ATTRIBUTES = 146,
    _SC_FILE_LOCKING = 147,
    _SC_FILE_SYSTEM = 148,
    _SC_MONOTONIC_CLOCK = 149,
    _SC_MULTI_PROCESS = 150,
    _SC_SINGLE_PROCESS = 151,
    _SC_NETWORKING = 152,
    _SC_READER_WRITER_LOCKS = 153,
    _SC_SPIN_LOCKS = 154,
    _SC_REGEXP = 155,
    _SC_REGEX_VERSION = 156,
    _SC_SHELL = 157,
    _SC_SIGNALS = 158,
    _SC_SPAWN = 159,
    _SC_SPORADIC_SERVER = 160,
    _SC_THREAD_SPORADIC_SERVER = 161,
    _SC_SYSTEM_DATABASE = 162,
    _SC_SYSTEM_DATABASE_R = 163,
    _SC_TIMEOUTS = 164,
    _SC_TYPED_MEMORY_OBJECTS = 165,
    _SC_USER_GROUPS = 166,
    _SC_USER_GROUPS_R = 167,
    _SC_2_PBS = 168,
    _SC_2_PBS_ACCOUNTING = 169,
    _SC_2_PBS_LOCATE = 170,
    _SC_2_PBS_MESSAGE = 171,
    _SC_2_PBS_TRACK = 172,
    _SC_SYMLOOP_MAX = 173,
    _SC_STREAMS = 174,
    _SC_2_PBS_CHECKPOINT = 175,
    _SC_V6_ILP32_OFF32 = 176,
    _SC_V6_ILP32_OFFBIG = 177,
    _SC_V6_LP64_OFF64 = 178,
    _SC_V6_LPBIG_OFFBIG = 179,
    _SC_HOST_NAME_MAX = 180,
    _SC_TRACE = 181,
    _SC_TRACE_EVENT_FILTER = 182,
    _SC_TRACE_INHERIT = 183,
    _SC_TRACE_LOG = 184,
    _SC_LEVEL1_ICACHE_SIZE = 185,
    _SC_LEVEL1_ICACHE_ASSOC = 186,
    _SC_LEVEL1_ICACHE_LINESIZE = 187,
    _SC_LEVEL1_DCACHE_SIZE = 188,
    _SC_LEVEL1_DCACHE_ASSOC = 189,
    _SC_LEVEL1_DCACHE_LINESIZE = 190,
    _SC_LEVEL2_CACHE_SIZE = 191,
    _SC_LEVEL2_CACHE_ASSOC = 192,
    _SC_LEVEL2_CACHE_LINESIZE = 193,
    _SC_LEVEL3_CACHE_SIZE = 194,
    _SC_LEVEL3_CACHE_ASSOC = 195,
    _SC_LEVEL3_CACHE_LINESIZE = 196,
    _SC_LEVEL4_CACHE_SIZE = 197,
    _SC_LEVEL4_CACHE_ASSOC = 198,
    _SC_LEVEL4_CACHE_LINESIZE = 199,
    _SC_IPV6 = 235,
    _SC_RAW_SOCKETS = 236,
    _SC_V7_ILP32_OFF32 = 237,
    _SC_V7_ILP32_OFFBIG = 238,
    _SC_V7_LP64_OFF64 = 239,
    _SC_V7_LPBIG_OFFBIG = 240,
    _SC_SS_REPL_MAX = 241,
    _SC_TRACE_EVENT_NAME_MAX = 242,
    _SC_TRACE_NAME_MAX = 243,
    _SC_TRACE_SYS_MAX = 244,
    _SC_TRACE_USER_EVENT_MAX = 245,
    _SC_XOPEN_STREAMS = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT = 248
} ;
enum __anonenum_75 {
    _CS_PATH = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS = 1,
    _CS_GNU_LIBC_VERSION = 2,
    _CS_GNU_LIBPTHREAD_VERSION = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS = 5,
    _CS_LFS_CFLAGS = 1000,
    _CS_LFS_LDFLAGS = 1001,
    _CS_LFS_LIBS = 1002,
    _CS_LFS_LINTFLAGS = 1003,
    _CS_LFS64_CFLAGS = 1004,
    _CS_LFS64_LDFLAGS = 1005,
    _CS_LFS64_LIBS = 1006,
    _CS_LFS64_LINTFLAGS = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS = 1109,
    _CS_XBS5_LP64_OFF64_LIBS = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS = 1147,
    _CS_V6_ENV = 1148,
    _CS_V7_ENV = 1149
} ;
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
enum __anonenum_76 {
    _ISupper = 256,
    _ISlower = 512,
    _ISalpha = 1024,
    _ISdigit = 2048,
    _ISxdigit = 4096,
    _ISspace = 8192,
    _ISprint = 16384,
    _ISgraph = 32768,
    _ISblank = 1,
    _IScntrl = 2,
    _ISpunct = 4,
    _ISalnum = 8
} ;
struct utimbuf {
   __time_t actime ;
   __time_t modtime ;
};
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
enum __anonenum_77 {
    DT_UNKNOWN = 0,
    DT_FIFO = 1,
    DT_CHR = 2,
    DT_DIR = 4,
    DT_BLK = 6,
    DT_REG = 8,
    DT_LNK = 10,
    DT_SOCK = 12,
    DT_WHT = 14
} ;
struct __dirstream;
typedef struct __dirstream DIR;
struct _cwd_state {
   char *cwd ;
   int cwd_length ;
};
typedef struct _cwd_state cwd_state;
typedef int (*verify_path_func)(cwd_state const   * );
struct _realpath_cache_bucket {
   unsigned long key ;
   char *path ;
   int path_len ;
   char *realpath ;
   int realpath_len ;
   int is_dir ;
   time_t expires ;
   struct _realpath_cache_bucket *next ;
};
typedef struct _realpath_cache_bucket realpath_cache_bucket;
struct _virtual_cwd_globals {
   cwd_state cwd ;
   long realpath_cache_size ;
   long realpath_cache_size_limit ;
   long realpath_cache_ttl ;
   realpath_cache_bucket *realpath_cache[1024] ;
};
typedef struct _virtual_cwd_globals virtual_cwd_globals;
typedef int (*incdec_t)(zval * );
extern struct _IO_FILE_plus _IO_2_1_stdin_ ;
extern struct _IO_FILE_plus _IO_2_1_stdout_ ;
extern struct _IO_FILE_plus _IO_2_1_stderr_ ;
extern int __underflow(_IO_FILE * ) ;
extern int __uflow(_IO_FILE * ) ;
extern int __overflow(_IO_FILE * , int  ) ;
extern int _IO_getc(_IO_FILE *__fp ) ;
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
extern  __attribute__((__nothrow__)) int _IO_feof(_IO_FILE *__fp ) ;
extern  __attribute__((__nothrow__)) int _IO_ferror(_IO_FILE *__fp ) ;
extern int _IO_peekc_locked(_IO_FILE *__fp ) ;
extern  __attribute__((__nothrow__)) void _IO_flockfile(_IO_FILE * ) ;
extern  __attribute__((__nothrow__)) void _IO_funlockfile(_IO_FILE * ) ;
extern  __attribute__((__nothrow__)) int _IO_ftrylockfile(_IO_FILE * ) ;
extern int _IO_vfscanf(_IO_FILE * __restrict   , char const   * __restrict   , __gnuc_va_list  , int * __restrict   ) ;
extern int _IO_vfprintf(_IO_FILE * __restrict   , char const   * __restrict   , __gnuc_va_list  ) ;
extern __ssize_t _IO_padn(_IO_FILE * , int  , __ssize_t  ) ;
extern size_t _IO_sgetn(_IO_FILE * , void * , size_t  ) ;
extern __off64_t _IO_seekoff(_IO_FILE * , __off64_t  , int  , int  ) ;
extern __off64_t _IO_seekpos(_IO_FILE * , __off64_t  , int  ) ;
extern  __attribute__((__nothrow__)) void _IO_free_backup_area(_IO_FILE * ) ;
extern struct _IO_FILE *stdin ;
extern struct _IO_FILE *stdout ;
extern struct _IO_FILE *stderr ;
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
extern  __attribute__((__nothrow__)) int renameat(int __oldfd , char const   *__old , int __newfd , char const   *__new ) ;
extern FILE *tmpfile(void) ;
extern  __attribute__((__nothrow__)) char *tmpnam(char *__s ) ;
extern  __attribute__((__nothrow__)) char *tmpnam_r(char *__s ) ;
extern  __attribute__((__nothrow__)) char *tempnam(char const   *__dir , char const   *__pfx )  __attribute__((__malloc__)) ;
extern int fclose(FILE *__stream ) ;
extern int fflush(FILE *__stream ) ;
extern int fflush_unlocked(FILE *__stream ) ;
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
extern FILE *freopen(char const   * __restrict  __filename , char const   * __restrict  __modes , FILE * __restrict  __stream ) ;
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
extern  __attribute__((__nothrow__)) FILE *fmemopen(void *__s , size_t __len , char const   *__modes ) ;
extern  __attribute__((__nothrow__)) FILE *open_memstream(char **__bufloc , size_t *__sizeloc ) ;
extern  __attribute__((__nothrow__)) void setbuf(FILE * __restrict  __stream , char * __restrict  __buf ) ;
extern  __attribute__((__nothrow__)) int setvbuf(FILE * __restrict  __stream , char * __restrict  __buf , int __modes , size_t __n ) ;
extern  __attribute__((__nothrow__)) void setbuffer(FILE * __restrict  __stream , char * __restrict  __buf , size_t __size ) ;
extern  __attribute__((__nothrow__)) void setlinebuf(FILE *__stream ) ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format  , ...) ;
extern int printf(char const   * __restrict  __format  , ...) ;
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format  , ...) ;
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format , __gnuc_va_list __arg ) ;
__inline extern int vprintf(char const   * __restrict  __fmt , __gnuc_va_list __arg ) ;
extern  __attribute__((__nothrow__)) int vsprintf(char * __restrict  __s , char const   * __restrict  __format , __gnuc_va_list __arg ) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s , size_t __maxlen , char const   * __restrict  __format  , ...) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s , size_t __maxlen , char const   * __restrict  __format , __gnuc_va_list __arg ) ;
extern int ( /* format attribute */  vdprintf)(int __fd , char const   * __restrict  __fmt , __gnuc_va_list __arg ) ;
extern int ( /* format attribute */  dprintf)(int __fd , char const   * __restrict  __fmt  , ...) ;
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format  , ...)  __asm__("__isoc99_fscanf")  ;
extern int scanf(char const   * __restrict  __format  , ...)  __asm__("__isoc99_scanf")  ;
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format  , ...)  __asm__("__isoc99_sscanf")  ;
extern int ( /* format attribute */  vfscanf)(FILE * __restrict  __s , char const   * __restrict  __format , __gnuc_va_list __arg )  __asm__("__isoc99_vfscanf")  ;
extern int ( /* format attribute */  vscanf)(char const   * __restrict  __format , __gnuc_va_list __arg )  __asm__("__isoc99_vscanf")  ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsscanf)(char const   * __restrict  __s , char const   * __restrict  __format , __gnuc_va_list __arg )  __asm__("__isoc99_vsscanf")  ;
extern int fgetc(FILE *__stream ) ;
extern int getc(FILE *__stream ) ;
__inline extern int getchar(void) ;
__inline extern int getc_unlocked(FILE *__fp ) ;
__inline extern int getchar_unlocked(void) ;
__inline extern int fgetc_unlocked(FILE *__fp ) ;
extern int fputc(int __c , FILE *__stream ) ;
extern int putc(int __c , FILE *__stream ) ;
__inline extern int putchar(int __c ) ;
__inline extern int fputc_unlocked(int __c , FILE *__stream ) ;
__inline extern int putc_unlocked(int __c , FILE *__stream ) ;
__inline extern int putchar_unlocked(int __c ) ;
extern int getw(FILE *__stream ) ;
extern int putw(int __w , FILE *__stream ) ;
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
extern char *gets(char *__s ) ;
extern __ssize_t __getdelim(char ** __restrict  __lineptr , size_t * __restrict  __n , int __delimiter , FILE * __restrict  __stream ) ;
extern __ssize_t getdelim(char ** __restrict  __lineptr , size_t * __restrict  __n , int __delimiter , FILE * __restrict  __stream ) ;
extern __ssize_t getline(char ** __restrict  __lineptr , size_t * __restrict  __n , FILE * __restrict  __stream ) ;
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
extern int puts(char const   *__s ) ;
extern int ungetc(int __c , FILE *__stream ) ;
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __s ) ;
extern size_t fread_unlocked(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
extern size_t fwrite_unlocked(void const   * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
extern int fseek(FILE *__stream , long __off , int __whence ) ;
extern long ftell(FILE *__stream ) ;
extern void rewind(FILE *__stream ) ;
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
extern __off_t ftello(FILE *__stream ) ;
extern int fgetpos(FILE * __restrict  __stream , fpos_t * __restrict  __pos ) ;
extern int fsetpos(FILE *__stream , fpos_t const   *__pos ) ;
extern  __attribute__((__nothrow__)) void clearerr(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) void clearerr_unlocked(FILE *__stream ) ;
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream ) ;
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream ) ;
extern void perror(char const   *__s ) ;
extern int sys_nerr ;
extern char const   * const  sys_errlist[] ;
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int fileno_unlocked(FILE *__stream ) ;
extern FILE *popen(char const   *__command , char const   *__modes ) ;
extern int pclose(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) char *ctermid(char *__s ) ;
extern  __attribute__((__nothrow__)) void flockfile(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int ftrylockfile(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) void funlockfile(FILE *__stream ) ;
__inline extern int vprintf(char const   * __restrict  __fmt , __gnuc_va_list __arg ) 
{ int tmp ;

  {
  tmp = vfprintf((FILE */* __restrict  */)stdout, __fmt, __arg);
  return (tmp);
}
}
__inline extern int getchar(void) 
{ int tmp ;

  {
  tmp = _IO_getc(stdin);
  return (tmp);
}
}
__inline extern int fgetc_unlocked(FILE *__fp ) 
{ long tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned int )__fp->_IO_read_ptr >= (unsigned int )__fp->_IO_read_end), 0L);
  if (tmp___3) {
    tmp___0 = __uflow(__fp);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = __fp->_IO_read_ptr;
    (__fp->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int getc_unlocked(FILE *__fp ) 
{ long tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned int )__fp->_IO_read_ptr >= (unsigned int )__fp->_IO_read_end), 0L);
  if (tmp___3) {
    tmp___0 = __uflow(__fp);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = __fp->_IO_read_ptr;
    (__fp->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int getchar_unlocked(void) 
{ long tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned int )stdin->_IO_read_ptr >= (unsigned int )stdin->_IO_read_end), 0L);
  if (tmp___3) {
    tmp___0 = __uflow(stdin);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = stdin->_IO_read_ptr;
    (stdin->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int putchar(int __c ) 
{ int tmp ;

  {
  tmp = _IO_putc(__c, stdout);
  return (tmp);
}
}
__inline extern int fputc_unlocked(int __c , FILE *__stream ) 
{ long tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned int )__stream->_IO_write_ptr >= (unsigned int )__stream->_IO_write_end), 0L);
  if (tmp___4) {
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = __stream->_IO_write_ptr;
    (__stream->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern int putc_unlocked(int __c , FILE *__stream ) 
{ long tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned int )__stream->_IO_write_ptr >= (unsigned int )__stream->_IO_write_end), 0L);
  if (tmp___4) {
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = __stream->_IO_write_ptr;
    (__stream->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern int putchar_unlocked(int __c ) 
{ long tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned int )stdout->_IO_write_ptr >= (unsigned int )stdout->_IO_write_end), 0L);
  if (tmp___4) {
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = stdout->_IO_write_ptr;
    (stdout->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream ) ;
__inline extern int feof_unlocked(FILE *__stream ) 
{ 

  {
  return ((__stream->_flags & 0x10) != 0);
}
}
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream ) ;
__inline extern int ferror_unlocked(FILE *__stream ) 
{ 

  {
  return ((__stream->_flags & 0x20) != 0);
}
}
__inline extern int __sigismember(__sigset_t const   *__set , int __sig ) ;
__inline extern int __sigaddset(__sigset_t *__set , int __sig ) ;
__inline extern int __sigdelset(__sigset_t *__set , int __sig ) ;
__inline extern int __sigismember(__sigset_t const   *__set , int __sig ) 
{ unsigned long __mask ;
  unsigned long __word ;
  int tmp ;

  {
  __mask = 1UL << (unsigned int )(__sig - 1) % (8U * sizeof(unsigned long ));
  __word = (unsigned long )((unsigned int )(__sig - 1) / (8U * sizeof(unsigned long )));
  if (__set->__val[__word] & __mask) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
__inline extern int __sigaddset(__sigset_t *__set , int __sig ) 
{ unsigned long __mask ;
  unsigned long __word ;

  {
  __mask = 1UL << (unsigned int )(__sig - 1) % (8U * sizeof(unsigned long ));
  __word = (unsigned long )((unsigned int )(__sig - 1) / (8U * sizeof(unsigned long )));
  __set->__val[__word] |= __mask;
  return (0);
}
}
__inline extern int __sigdelset(__sigset_t *__set , int __sig ) 
{ unsigned long __mask ;
  unsigned long __word ;

  {
  __mask = 1UL << (unsigned int )(__sig - 1) % (8U * sizeof(unsigned long ));
  __word = (unsigned long )((unsigned int )(__sig - 1) / (8U * sizeof(unsigned long )));
  __set->__val[__word] &= ~ __mask;
  return (0);
}
}
extern  __attribute__((__nothrow__)) __sighandler_t __sysv_signal(int __sig , void (*__handler)(int  ) ) ;
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
extern  __attribute__((__nothrow__)) int killpg(__pid_t __pgrp , int __sig ) ;
extern  __attribute__((__nothrow__)) int raise(int __sig ) ;
extern  __attribute__((__nothrow__)) __sighandler_t ssignal(int __sig , void (*__handler)(int  ) ) ;
extern  __attribute__((__nothrow__)) int gsignal(int __sig ) ;
extern void psignal(int __sig , char const   *__s ) ;
extern void psiginfo(siginfo_t const   *__pinfo , char const   *__s ) ;
extern int __sigpause(int __sig_or_mask , int __is_sig ) ;
extern  __attribute__((__nothrow__)) int sigblock(int __mask )  __attribute__((__deprecated__)) ;
extern  __attribute__((__nothrow__)) int sigsetmask(int __mask )  __attribute__((__deprecated__)) ;
extern  __attribute__((__nothrow__)) int siggetmask(void)  __attribute__((__deprecated__)) ;
extern  __attribute__((__nothrow__)) int sigemptyset(sigset_t *__set )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int sigfillset(sigset_t *__set )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int sigaddset(sigset_t *__set , int __signo )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int sigdelset(sigset_t *__set , int __signo )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int sigismember(sigset_t const   *__set , int __signo )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t const   * __restrict  __set , sigset_t * __restrict  __oset ) ;
extern int sigsuspend(sigset_t const   *__set )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act , struct sigaction * __restrict  __oact ) ;
extern  __attribute__((__nothrow__)) int sigpending(sigset_t *__set )  __attribute__((__nonnull__(1))) ;
extern int sigwait(sigset_t const   * __restrict  __set , int * __restrict  __sig )  __attribute__((__nonnull__(1,2))) ;
extern int sigwaitinfo(sigset_t const   * __restrict  __set , siginfo_t * __restrict  __info )  __attribute__((__nonnull__(1))) ;
extern int sigtimedwait(sigset_t const   * __restrict  __set , siginfo_t * __restrict  __info , struct timespec  const  * __restrict  __timeout )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int sigqueue(__pid_t __pid , int __sig , union sigval __val ) ;
extern char const   * const  _sys_siglist[65] ;
extern char const   * const  sys_siglist[65] ;
extern  __attribute__((__nothrow__)) int sigvec(int __sig , struct sigvec  const  *__vec , struct sigvec *__ovec ) ;
extern  __attribute__((__nothrow__)) int sigreturn(struct sigcontext *__scp ) ;
extern  __attribute__((__nothrow__)) int siginterrupt(int __sig , int __interrupt ) ;
extern  __attribute__((__nothrow__)) int sigstack(struct sigstack *__ss , struct sigstack *__oss )  __attribute__((__deprecated__)) ;
extern  __attribute__((__nothrow__)) int sigaltstack(struct sigaltstack  const  * __restrict  __ss , struct sigaltstack * __restrict  __oss ) ;
extern  __attribute__((__nothrow__)) int pthread_sigmask(int __how , __sigset_t const   * __restrict  __newmask , __sigset_t * __restrict  __oldmask ) ;
extern  __attribute__((__nothrow__)) int pthread_kill(pthread_t __threadid , int __signo ) ;
extern  __attribute__((__nothrow__)) int __libc_current_sigrtmin(void) ;
extern  __attribute__((__nothrow__)) int __libc_current_sigrtmax(void) ;
extern  __attribute__((__nothrow__)) size_t __ctype_get_mb_cur_max(void) ;
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__pure__, __nonnull__(1))) ;
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__, __nonnull__(1))) ;
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__pure__, __nonnull__(1))) ;
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__pure__, __nonnull__(1))) ;
extern  __attribute__((__nothrow__)) double strtod(char const   * __restrict  __nptr , char ** __restrict  __endptr )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) float strtof(char const   * __restrict  __nptr , char ** __restrict  __endptr )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) long double strtold(char const   * __restrict  __nptr , char ** __restrict  __endptr )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr , char ** __restrict  __endptr , int __base )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) unsigned long strtoul(char const   * __restrict  __nptr , char ** __restrict  __endptr , int __base )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) long long strtoq(char const   * __restrict  __nptr , char ** __restrict  __endptr , int __base )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) unsigned long long strtouq(char const   * __restrict  __nptr , char ** __restrict  __endptr , int __base )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) long long strtoll(char const   * __restrict  __nptr , char ** __restrict  __endptr , int __base )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) unsigned long long strtoull(char const   * __restrict  __nptr , char ** __restrict  __endptr , int __base )  __attribute__((__nonnull__(1))) ;
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__pure__, __nonnull__(1))) ;
__inline extern double atof(char const   *__nptr ) 
{ double tmp ;

  {
  tmp = strtod((char const   */* __restrict  */)__nptr, (char **/* __restrict  */)((char **)((void *)0)));
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__, __nonnull__(1))) ;
__inline extern int atoi(char const   *__nptr ) 
{ long tmp ;

  {
  tmp = strtol((char const   */* __restrict  */)__nptr, (char **/* __restrict  */)((char **)((void *)0)), 10);
  return ((int )tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__pure__, __nonnull__(1))) ;
__inline extern long atol(char const   *__nptr ) 
{ long tmp ;

  {
  tmp = strtol((char const   */* __restrict  */)__nptr, (char **/* __restrict  */)((char **)((void *)0)), 10);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__pure__, __nonnull__(1))) ;
__inline extern long long atoll(char const   *__nptr ) 
{ long long tmp ;

  {
  tmp = strtoll((char const   */* __restrict  */)__nptr, (char **/* __restrict  */)((char **)((void *)0)), 10);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) char *l64a(long __n ) ;
extern  __attribute__((__nothrow__)) long a64l(char const   *__s )  __attribute__((__pure__, __nonnull__(1))) ;
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds , fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
extern int pselect(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds , fd_set * __restrict  __exceptfds , struct timespec  const  * __restrict  __timeout , __sigset_t const   * __restrict  __sigmask ) ;
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_major(unsigned long long __dev ) ;
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_minor(unsigned long long __dev ) ;
__inline extern  __attribute__((__nothrow__)) unsigned long long gnu_dev_makedev(unsigned int __major , unsigned int __minor ) ;
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_major(unsigned long long __dev ) ;
__inline extern unsigned int gnu_dev_major(unsigned long long __dev ) 
{ 

  {
  return ((unsigned int )(((__dev >> 8) & 4095ULL) | (unsigned long long )((unsigned int )(__dev >> 32) & 4294963200U)));
}
}
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_minor(unsigned long long __dev ) ;
__inline extern unsigned int gnu_dev_minor(unsigned long long __dev ) 
{ 

  {
  return ((unsigned int )((__dev & 255ULL) | (unsigned long long )((unsigned int )(__dev >> 12) & 4294967040U)));
}
}
__inline extern  __attribute__((__nothrow__)) unsigned long long gnu_dev_makedev(unsigned int __major , unsigned int __minor ) ;
__inline extern unsigned long long gnu_dev_makedev(unsigned int __major , unsigned int __minor ) 
{ 

  {
  return (((unsigned long long )((__minor & 255U) | ((__major & 4095U) << 8)) | ((unsigned long long )(__minor & 4294967040U) << 12)) | ((unsigned long long )(__major & 4294963200U) << 32));
}
}
extern  __attribute__((__nothrow__)) long random(void) ;
extern  __attribute__((__nothrow__)) void srandom(unsigned int __seed ) ;
extern  __attribute__((__nothrow__)) char *initstate(unsigned int __seed , char *__statebuf , size_t __statelen )  __attribute__((__nonnull__(2))) ;
extern  __attribute__((__nothrow__)) char *setstate(char *__statebuf )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int random_r(struct random_data * __restrict  __buf , int32_t * __restrict  __result )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) int srandom_r(unsigned int __seed , struct random_data *__buf )  __attribute__((__nonnull__(2))) ;
extern  __attribute__((__nothrow__)) int initstate_r(unsigned int __seed , char * __restrict  __statebuf , size_t __statelen , struct random_data * __restrict  __buf )  __attribute__((__nonnull__(2,4))) ;
extern  __attribute__((__nothrow__)) int setstate_r(char * __restrict  __statebuf , struct random_data * __restrict  __buf )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) int rand(void) ;
extern  __attribute__((__nothrow__)) void srand(unsigned int __seed ) ;
extern  __attribute__((__nothrow__)) int rand_r(unsigned int *__seed ) ;
extern  __attribute__((__nothrow__)) double drand48(void) ;
extern  __attribute__((__nothrow__)) double erand48(unsigned short *__xsubi )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) long lrand48(void) ;
extern  __attribute__((__nothrow__)) long nrand48(unsigned short *__xsubi )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) long mrand48(void) ;
extern  __attribute__((__nothrow__)) long jrand48(unsigned short *__xsubi )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) void srand48(long __seedval ) ;
extern  __attribute__((__nothrow__)) unsigned short *seed48(unsigned short *__seed16v )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) void lcong48(unsigned short *__param )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int drand48_r(struct drand48_data * __restrict  __buffer , double * __restrict  __result )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) int erand48_r(unsigned short *__xsubi , struct drand48_data * __restrict  __buffer , double * __restrict  __result )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) int lrand48_r(struct drand48_data * __restrict  __buffer , long * __restrict  __result )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) int nrand48_r(unsigned short *__xsubi , struct drand48_data * __restrict  __buffer , long * __restrict  __result )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) int mrand48_r(struct drand48_data * __restrict  __buffer , long * __restrict  __result )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) int jrand48_r(unsigned short *__xsubi , struct drand48_data * __restrict  __buffer , long * __restrict  __result )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) int srand48_r(long __seedval , struct drand48_data *__buffer )  __attribute__((__nonnull__(2))) ;
extern  __attribute__((__nothrow__)) int seed48_r(unsigned short *__seed16v , struct drand48_data *__buffer )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) int lcong48_r(unsigned short *__param , struct drand48_data *__buffer )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size )  __attribute__((__warn_unused_result__)) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
extern  __attribute__((__nothrow__)) void cfree(void *__ptr ) ;
extern  __attribute__((__nothrow__)) void *alloca(size_t __size ) ;
extern  __attribute__((__nothrow__)) void *valloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) int posix_memalign(void **__memptr , size_t __alignment , size_t __size )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
extern  __attribute__((__nothrow__)) int atexit(void (*__func)(void) )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int on_exit(void (*__func)(int __status , void *__arg ) , void *__arg )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void _Exit(int __status ) ;
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) char *__secure_getenv(char const   *__name )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int putenv(char *__string )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int setenv(char const   *__name , char const   *__value , int __replace )  __attribute__((__nonnull__(2))) ;
extern  __attribute__((__nothrow__)) int unsetenv(char const   *__name )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int clearenv(void) ;
extern  __attribute__((__nothrow__)) char *mktemp(char *__template )  __attribute__((__nonnull__(1))) ;
extern int mkstemp(char *__template )  __attribute__((__nonnull__(1))) ;
extern int mkstemps(char *__template , int __suffixlen )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) char *mkdtemp(char *__template )  __attribute__((__nonnull__(1))) ;
extern int system(char const   *__command ) ;
extern  __attribute__((__nothrow__)) char *realpath(char const   * __restrict  __name , char * __restrict  __resolved ) ;
extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb , size_t __size , int (*__compar)(void const   * , void const   * ) )  __attribute__((__nonnull__(1,2,5))) ;
extern void qsort(void *__base , size_t __nmemb , size_t __size , int (*__compar)(void const   * , void const   * ) )  __attribute__((__nonnull__(1,4))) ;
extern  __attribute__((__nothrow__)) int abs(int __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) long labs(long __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) long long llabs(long long __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) div_t div(int __numer , int __denom )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) ldiv_t ldiv(long __numer , long __denom )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) lldiv_t lldiv(long long __numer , long long __denom )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) char *ecvt(double __value , int __ndigit , int * __restrict  __decpt , int * __restrict  __sign )  __attribute__((__nonnull__(3,4))) ;
extern  __attribute__((__nothrow__)) char *fcvt(double __value , int __ndigit , int * __restrict  __decpt , int * __restrict  __sign )  __attribute__((__nonnull__(3,4))) ;
extern  __attribute__((__nothrow__)) char *gcvt(double __value , int __ndigit , char *__buf )  __attribute__((__nonnull__(3))) ;
extern  __attribute__((__nothrow__)) char *qecvt(long double __value , int __ndigit , int * __restrict  __decpt , int * __restrict  __sign )  __attribute__((__nonnull__(3,4))) ;
extern  __attribute__((__nothrow__)) char *qfcvt(long double __value , int __ndigit , int * __restrict  __decpt , int * __restrict  __sign )  __attribute__((__nonnull__(3,4))) ;
extern  __attribute__((__nothrow__)) char *qgcvt(long double __value , int __ndigit , char *__buf )  __attribute__((__nonnull__(3))) ;
extern  __attribute__((__nothrow__)) int ecvt_r(double __value , int __ndigit , int * __restrict  __decpt , int * __restrict  __sign , char * __restrict  __buf , size_t __len )  __attribute__((__nonnull__(3,4,5))) ;
extern  __attribute__((__nothrow__)) int fcvt_r(double __value , int __ndigit , int * __restrict  __decpt , int * __restrict  __sign , char * __restrict  __buf , size_t __len )  __attribute__((__nonnull__(3,4,5))) ;
extern  __attribute__((__nothrow__)) int qecvt_r(long double __value , int __ndigit , int * __restrict  __decpt , int * __restrict  __sign , char * __restrict  __buf , size_t __len )  __attribute__((__nonnull__(3,4,5))) ;
extern  __attribute__((__nothrow__)) int qfcvt_r(long double __value , int __ndigit , int * __restrict  __decpt , int * __restrict  __sign , char * __restrict  __buf , size_t __len )  __attribute__((__nonnull__(3,4,5))) ;
extern  __attribute__((__nothrow__)) int mblen(char const   *__s , size_t __n ) ;
extern  __attribute__((__nothrow__)) int mbtowc(wchar_t * __restrict  __pwc , char const   * __restrict  __s , size_t __n ) ;
extern  __attribute__((__nothrow__)) int wctomb(char *__s , wchar_t __wchar ) ;
extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t * __restrict  __pwcs , char const   * __restrict  __s , size_t __n ) ;
extern  __attribute__((__nothrow__)) size_t wcstombs(char * __restrict  __s , wchar_t const   * __restrict  __pwcs , size_t __n ) ;
extern  __attribute__((__nothrow__)) int rpmatch(char const   *__response )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int getsubopt(char ** __restrict  __optionp , char * const  * __restrict  __tokens , char ** __restrict  __valuep )  __attribute__((__nonnull__(1,2,3))) ;
extern  __attribute__((__nothrow__)) int getloadavg(double *__loadavg , int __nelem )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) void *memcpy(void * __restrict  __dest , void const   * __restrict  __src , size_t __n )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src , size_t __n )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) void *memccpy(void * __restrict  __dest , void const   * __restrict  __src , int __c , size_t __n )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 , size_t __n )  __attribute__((__pure__, __nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) void *memchr(void const   *__s , int __c , size_t __n )  __attribute__((__pure__, __nonnull__(1))) ;
extern  __attribute__((__nothrow__)) char *strcpy(char * __restrict  __dest , char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) char *strncpy(char * __restrict  __dest , char const   * __restrict  __src , size_t __n )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) char *strcat(char * __restrict  __dest , char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) char *strncat(char * __restrict  __dest , char const   * __restrict  __src , size_t __n )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__, __nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 , size_t __n )  __attribute__((__pure__, __nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) int strcoll(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__, __nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) size_t strxfrm(char * __restrict  __dest , char const   * __restrict  __src , size_t __n )  __attribute__((__nonnull__(2))) ;
extern  __attribute__((__nothrow__)) int strcoll_l(char const   *__s1 , char const   *__s2 , __locale_t __l )  __attribute__((__pure__, __nonnull__(1,2,3))) ;
extern  __attribute__((__nothrow__)) size_t strxfrm_l(char *__dest , char const   *__src , size_t __n , __locale_t __l )  __attribute__((__nonnull__(2,4))) ;
extern  __attribute__((__nothrow__)) char *strdup(char const   *__s )  __attribute__((__nonnull__(1), __malloc__)) ;
extern  __attribute__((__nothrow__)) char *strndup(char const   *__string , size_t __n )  __attribute__((__nonnull__(1), __malloc__)) ;
extern  __attribute__((__nothrow__)) char *strchr(char const   *__s , int __c )  __attribute__((__pure__, __nonnull__(1))) ;
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c )  __attribute__((__pure__, __nonnull__(1))) ;
extern  __attribute__((__nothrow__)) size_t strcspn(char const   *__s , char const   *__reject )  __attribute__((__pure__, __nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) size_t strspn(char const   *__s , char const   *__accept )  __attribute__((__pure__, __nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) char *strpbrk(char const   *__s , char const   *__accept )  __attribute__((__pure__, __nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle )  __attribute__((__pure__, __nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) char *strtok(char * __restrict  __s , char const   * __restrict  __delim )  __attribute__((__nonnull__(2))) ;
extern  __attribute__((__nothrow__)) char *__strtok_r(char * __restrict  __s , char const   * __restrict  __delim , char ** __restrict  __save_ptr )  __attribute__((__nonnull__(2,3))) ;
extern  __attribute__((__nothrow__)) char *strtok_r(char * __restrict  __s , char const   * __restrict  __delim , char ** __restrict  __save_ptr )  __attribute__((__nonnull__(2,3))) ;
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s )  __attribute__((__pure__, __nonnull__(1))) ;
extern  __attribute__((__nothrow__)) size_t strnlen(char const   *__string , size_t __maxlen )  __attribute__((__pure__, __nonnull__(1))) ;
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
extern  __attribute__((__nothrow__)) int strerror_r(int __errnum , char *__buf , size_t __buflen )  __asm__("__xpg_strerror_r") __attribute__((__nonnull__(2))) ;
extern  __attribute__((__nothrow__)) char *strerror_l(int __errnum , __locale_t __l ) ;
extern  __attribute__((__nothrow__)) void __bzero(void *__s , size_t __n )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest , size_t __n )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) void bzero(void *__s , size_t __n )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int bcmp(void const   *__s1 , void const   *__s2 , size_t __n )  __attribute__((__pure__, __nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) char *index(char const   *__s , int __c )  __attribute__((__pure__, __nonnull__(1))) ;
extern  __attribute__((__nothrow__)) char *rindex(char const   *__s , int __c )  __attribute__((__pure__, __nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int ffs(int __i )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__, __nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) int strncasecmp(char const   *__s1 , char const   *__s2 , size_t __n )  __attribute__((__pure__, __nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) char *strsep(char ** __restrict  __stringp , char const   * __restrict  __delim )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) char *strsignal(int __sig ) ;
extern  __attribute__((__nothrow__)) char *__stpcpy(char * __restrict  __dest , char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) char *stpcpy(char * __restrict  __dest , char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) char *__stpncpy(char * __restrict  __dest , char const   * __restrict  __src , size_t __n )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) char *stpncpy(char * __restrict  __dest , char const   * __restrict  __src , size_t __n )  __attribute__((__nonnull__(1,2))) ;
extern void *__rawmemchr(void const   *__s , int __c ) ;
__inline extern size_t __strcspn_c1(char const   *__s , int __reject ) ;
__inline extern size_t __strcspn_c1(char const   *__s , int __reject ) 
{ register size_t __result ;

  {
  __result = (size_t )0;
  while (1) {
    if ((int const   )*(__s + __result) != 0) {
      if ((int const   )*(__s + __result) != (int const   )__reject) {

      } else {
        break;
      }
    } else {
      break;
    }
    __result ++;
  }
  return (__result);
}
}
__inline extern size_t __strcspn_c2(char const   *__s , int __reject1 , int __reject2 ) ;
__inline extern size_t __strcspn_c2(char const   *__s , int __reject1 , int __reject2 ) 
{ register size_t __result ;

  {
  __result = (size_t )0;
  while (1) {
    if ((int const   )*(__s + __result) != 0) {
      if ((int const   )*(__s + __result) != (int const   )__reject1) {
        if ((int const   )*(__s + __result) != (int const   )__reject2) {

        } else {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    __result ++;
  }
  return (__result);
}
}
__inline extern size_t __strcspn_c3(char const   *__s , int __reject1 , int __reject2 , int __reject3 ) ;
__inline extern size_t __strcspn_c3(char const   *__s , int __reject1 , int __reject2 , int __reject3 ) 
{ register size_t __result ;

  {
  __result = (size_t )0;
  while (1) {
    if ((int const   )*(__s + __result) != 0) {
      if ((int const   )*(__s + __result) != (int const   )__reject1) {
        if ((int const   )*(__s + __result) != (int const   )__reject2) {
          if ((int const   )*(__s + __result) != (int const   )__reject3) {

          } else {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    __result ++;
  }
  return (__result);
}
}
__inline extern size_t __strspn_c1(char const   *__s , int __accept ) ;
__inline extern size_t __strspn_c1(char const   *__s , int __accept ) 
{ register size_t __result ;

  {
  __result = (size_t )0;
  while ((int const   )*(__s + __result) == (int const   )__accept) {
    __result ++;
  }
  return (__result);
}
}
__inline extern size_t __strspn_c2(char const   *__s , int __accept1 , int __accept2 ) ;
__inline extern size_t __strspn_c2(char const   *__s , int __accept1 , int __accept2 ) 
{ register size_t __result ;

  {
  __result = (size_t )0;
  while (1) {
    if ((int const   )*(__s + __result) == (int const   )__accept1) {

    } else {
      if ((int const   )*(__s + __result) == (int const   )__accept2) {

      } else {
        break;
      }
    }
    __result ++;
  }
  return (__result);
}
}
__inline extern size_t __strspn_c3(char const   *__s , int __accept1 , int __accept2 , int __accept3 ) ;
__inline extern size_t __strspn_c3(char const   *__s , int __accept1 , int __accept2 , int __accept3 ) 
{ register size_t __result ;

  {
  __result = (size_t )0;
  while (1) {
    if ((int const   )*(__s + __result) == (int const   )__accept1) {

    } else {
      if ((int const   )*(__s + __result) == (int const   )__accept2) {

      } else {
        if ((int const   )*(__s + __result) == (int const   )__accept3) {

        } else {
          break;
        }
      }
    }
    __result ++;
  }
  return (__result);
}
}
__inline extern char *__strpbrk_c2(char const   *__s , int __accept1 , int __accept2 ) ;
__inline extern char *__strpbrk_c2(char const   *__s , int __accept1 , int __accept2 ) 
{ char *tmp ;

  {
  while (1) {
    if ((int const   )*__s != 0) {
      if ((int const   )*__s != (int const   )__accept1) {
        if ((int const   )*__s != (int const   )__accept2) {

        } else {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    __s ++;
  }
  if ((int const   )*__s == 0) {
    tmp = (char *)((void *)0);
  } else {
    tmp = (char *)((unsigned int )__s);
  }
  return (tmp);
}
}
__inline extern char *__strpbrk_c3(char const   *__s , int __accept1 , int __accept2 , int __accept3 ) ;
__inline extern char *__strpbrk_c3(char const   *__s , int __accept1 , int __accept2 , int __accept3 ) 
{ char *tmp ;

  {
  while (1) {
    if ((int const   )*__s != 0) {
      if ((int const   )*__s != (int const   )__accept1) {
        if ((int const   )*__s != (int const   )__accept2) {
          if ((int const   )*__s != (int const   )__accept3) {

          } else {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    __s ++;
  }
  if ((int const   )*__s == 0) {
    tmp = (char *)((void *)0);
  } else {
    tmp = (char *)((unsigned int )__s);
  }
  return (tmp);
}
}
__inline extern char *__strtok_r_1c(char *__s , char __sep , char **__nextp ) ;
__inline extern char *__strtok_r_1c(char *__s , char __sep , char **__nextp ) 
{ char *__result ;
  char *tmp ;
  char *tmp___0 ;

  {
  if ((unsigned int )__s == (unsigned int )((void *)0)) {
    __s = *__nextp;
  } else {

  }
  while ((int )*__s == (int )__sep) {
    __s ++;
  }
  __result = (char *)((void *)0);
  if ((int )*__s != 0) {
    tmp = __s;
    __s ++;
    __result = tmp;
    while ((int )*__s != 0) {
      tmp___0 = __s;
      __s ++;
      if ((int )*tmp___0 == (int )__sep) {
        *(__s + -1) = (char )'\000';
        break;
      } else {

      }
    }
  } else {

  }
  *__nextp = __s;
  return (__result);
}
}
extern char *__strsep_g(char **__stringp , char const   *__delim ) ;
__inline extern char *__strsep_1c(char **__s , char __reject ) ;
__inline extern char *__strsep_1c(char **__s , char __reject ) 
{ register char *__retval ;
  char *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;

  {
  __retval = *__s;
  if ((unsigned int )__retval != (unsigned int )((void *)0)) {
    tmp___2 = __builtin_strchr(__retval, (int )__reject);
    tmp___0 = tmp___2;
    *__s = tmp___0;
    if ((unsigned int )tmp___0 != (unsigned int )((void *)0)) {
      tmp = *__s;
      (*__s) ++;
      *tmp = (char )'\000';
    } else {

    }
  } else {

  }
  return (__retval);
}
}
__inline extern char *__strsep_2c(char **__s , char __reject1 , char __reject2 ) ;
__inline extern char *__strsep_2c(char **__s , char __reject1 , char __reject2 ) 
{ register char *__retval ;
  register char *__cp ;
  char *tmp ;

  {
  __retval = *__s;
  if ((unsigned int )__retval != (unsigned int )((void *)0)) {
    __cp = __retval;
    while (1) {
      if ((int )*__cp == 0) {
        __cp = (char *)((void *)0);
        break;
      } else {

      }
      if ((int )*__cp == (int )__reject1) {
        tmp = __cp;
        __cp ++;
        *tmp = (char )'\000';
        break;
      } else {
        if ((int )*__cp == (int )__reject2) {
          tmp = __cp;
          __cp ++;
          *tmp = (char )'\000';
          break;
        } else {

        }
      }
      __cp ++;
    }
    *__s = __cp;
  } else {

  }
  return (__retval);
}
}
__inline extern char *__strsep_3c(char **__s , char __reject1 , char __reject2 , char __reject3 ) ;
__inline extern char *__strsep_3c(char **__s , char __reject1 , char __reject2 , char __reject3 ) 
{ register char *__retval ;
  register char *__cp ;
  char *tmp ;

  {
  __retval = *__s;
  if ((unsigned int )__retval != (unsigned int )((void *)0)) {
    __cp = __retval;
    while (1) {
      if ((int )*__cp == 0) {
        __cp = (char *)((void *)0);
        break;
      } else {

      }
      if ((int )*__cp == (int )__reject1) {
        tmp = __cp;
        __cp ++;
        *tmp = (char )'\000';
        break;
      } else {
        if ((int )*__cp == (int )__reject2) {
          tmp = __cp;
          __cp ++;
          *tmp = (char )'\000';
          break;
        } else {
          if ((int )*__cp == (int )__reject3) {
            tmp = __cp;
            __cp ++;
            *tmp = (char )'\000';
            break;
          } else {

          }
        }
      }
      __cp ++;
    }
    *__s = __cp;
  } else {

  }
  return (__retval);
}
}
extern  __attribute__((__nothrow__)) char *__strdup(char const   *__string )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) char *__strndup(char const   *__string , size_t __n )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) double acos(double __x ) ;
extern  __attribute__((__nothrow__)) double __acos(double __x ) ;
extern  __attribute__((__nothrow__)) double asin(double __x ) ;
extern  __attribute__((__nothrow__)) double __asin(double __x ) ;
extern  __attribute__((__nothrow__)) double atan(double __x ) ;
extern  __attribute__((__nothrow__)) double __atan(double __x ) ;
extern  __attribute__((__nothrow__)) double atan2(double __y , double __x ) ;
extern  __attribute__((__nothrow__)) double __atan2(double __y , double __x ) ;
extern  __attribute__((__nothrow__)) double cos(double __x ) ;
extern  __attribute__((__nothrow__)) double __cos(double __x ) ;
extern  __attribute__((__nothrow__)) double sin(double __x ) ;
extern  __attribute__((__nothrow__)) double __sin(double __x ) ;
extern  __attribute__((__nothrow__)) double tan(double __x ) ;
extern  __attribute__((__nothrow__)) double __tan(double __x ) ;
extern  __attribute__((__nothrow__)) double cosh(double __x ) ;
extern  __attribute__((__nothrow__)) double __cosh(double __x ) ;
extern  __attribute__((__nothrow__)) double sinh(double __x ) ;
extern  __attribute__((__nothrow__)) double __sinh(double __x ) ;
extern  __attribute__((__nothrow__)) double tanh(double __x ) ;
extern  __attribute__((__nothrow__)) double __tanh(double __x ) ;
extern  __attribute__((__nothrow__)) double acosh(double __x ) ;
extern  __attribute__((__nothrow__)) double __acosh(double __x ) ;
extern  __attribute__((__nothrow__)) double asinh(double __x ) ;
extern  __attribute__((__nothrow__)) double __asinh(double __x ) ;
extern  __attribute__((__nothrow__)) double atanh(double __x ) ;
extern  __attribute__((__nothrow__)) double __atanh(double __x ) ;
extern  __attribute__((__nothrow__)) double exp(double __x ) ;
extern  __attribute__((__nothrow__)) double __exp(double __x ) ;
extern  __attribute__((__nothrow__)) double frexp(double __x , int *__exponent ) ;
extern  __attribute__((__nothrow__)) double __frexp(double __x , int *__exponent ) ;
extern  __attribute__((__nothrow__)) double ldexp(double __x , int __exponent ) ;
extern  __attribute__((__nothrow__)) double __ldexp(double __x , int __exponent ) ;
extern  __attribute__((__nothrow__)) double log(double __x ) ;
extern  __attribute__((__nothrow__)) double __log(double __x ) ;
extern  __attribute__((__nothrow__)) double log10(double __x ) ;
extern  __attribute__((__nothrow__)) double __log10(double __x ) ;
extern  __attribute__((__nothrow__)) double modf(double __x , double *__iptr ) ;
extern  __attribute__((__nothrow__)) double __modf(double __x , double *__iptr ) ;
extern  __attribute__((__nothrow__)) double expm1(double __x ) ;
extern  __attribute__((__nothrow__)) double __expm1(double __x ) ;
extern  __attribute__((__nothrow__)) double log1p(double __x ) ;
extern  __attribute__((__nothrow__)) double __log1p(double __x ) ;
extern  __attribute__((__nothrow__)) double logb(double __x ) ;
extern  __attribute__((__nothrow__)) double __logb(double __x ) ;
extern  __attribute__((__nothrow__)) double exp2(double __x ) ;
extern  __attribute__((__nothrow__)) double __exp2(double __x ) ;
extern  __attribute__((__nothrow__)) double log2(double __x ) ;
extern  __attribute__((__nothrow__)) double __log2(double __x ) ;
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
extern  __attribute__((__nothrow__)) double __pow(double __x , double __y ) ;
extern  __attribute__((__nothrow__)) double sqrt(double __x ) ;
extern  __attribute__((__nothrow__)) double __sqrt(double __x ) ;
extern  __attribute__((__nothrow__)) double hypot(double __x , double __y ) ;
extern  __attribute__((__nothrow__)) double __hypot(double __x , double __y ) ;
extern  __attribute__((__nothrow__)) double cbrt(double __x ) ;
extern  __attribute__((__nothrow__)) double __cbrt(double __x ) ;
__inline extern  __attribute__((__nothrow__)) double ceil(double __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) double __ceil(double __x )  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) double fabs(double __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) double __fabs(double __x )  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) double floor(double __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) double __floor(double __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) double fmod(double __x , double __y ) ;
extern  __attribute__((__nothrow__)) double __fmod(double __x , double __y ) ;
extern  __attribute__((__nothrow__)) int __isinf(double __value )  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) int __finite(double __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int isinf(double __value )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int finite(double __value )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) double drem(double __x , double __y ) ;
extern  __attribute__((__nothrow__)) double __drem(double __x , double __y ) ;
extern  __attribute__((__nothrow__)) double significand(double __x ) ;
extern  __attribute__((__nothrow__)) double __significand(double __x ) ;
extern  __attribute__((__nothrow__)) double copysign(double __x , double __y )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) double __copysign(double __x , double __y )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) double nan(char const   *__tagb )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) double __nan(char const   *__tagb )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int __isnan(double __value )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int isnan(double __value )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) double j0(double  ) ;
extern  __attribute__((__nothrow__)) double __j0(double  ) ;
extern  __attribute__((__nothrow__)) double j1(double  ) ;
extern  __attribute__((__nothrow__)) double __j1(double  ) ;
extern  __attribute__((__nothrow__)) double jn(int  , double  ) ;
extern  __attribute__((__nothrow__)) double __jn(int  , double  ) ;
extern  __attribute__((__nothrow__)) double y0(double  ) ;
extern  __attribute__((__nothrow__)) double __y0(double  ) ;
extern  __attribute__((__nothrow__)) double y1(double  ) ;
extern  __attribute__((__nothrow__)) double __y1(double  ) ;
extern  __attribute__((__nothrow__)) double yn(int  , double  ) ;
extern  __attribute__((__nothrow__)) double __yn(int  , double  ) ;
extern  __attribute__((__nothrow__)) double erf(double  ) ;
extern  __attribute__((__nothrow__)) double __erf(double  ) ;
extern  __attribute__((__nothrow__)) double erfc(double  ) ;
extern  __attribute__((__nothrow__)) double __erfc(double  ) ;
extern  __attribute__((__nothrow__)) double lgamma(double  ) ;
extern  __attribute__((__nothrow__)) double __lgamma(double  ) ;
extern  __attribute__((__nothrow__)) double tgamma(double  ) ;
extern  __attribute__((__nothrow__)) double __tgamma(double  ) ;
extern  __attribute__((__nothrow__)) double gamma(double  ) ;
extern  __attribute__((__nothrow__)) double __gamma(double  ) ;
extern  __attribute__((__nothrow__)) double lgamma_r(double  , int *__signgamp ) ;
extern  __attribute__((__nothrow__)) double __lgamma_r(double  , int *__signgamp ) ;
extern  __attribute__((__nothrow__)) double rint(double __x ) ;
extern  __attribute__((__nothrow__)) double __rint(double __x ) ;
extern  __attribute__((__nothrow__)) double nextafter(double __x , double __y )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) double __nextafter(double __x , double __y )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) double nexttoward(double __x , long double __y )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) double __nexttoward(double __x , long double __y )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) double remainder(double __x , double __y ) ;
extern  __attribute__((__nothrow__)) double __remainder(double __x , double __y ) ;
extern  __attribute__((__nothrow__)) double scalbn(double __x , int __n ) ;
extern  __attribute__((__nothrow__)) double __scalbn(double __x , int __n ) ;
extern  __attribute__((__nothrow__)) int ilogb(double __x ) ;
extern  __attribute__((__nothrow__)) int __ilogb(double __x ) ;
extern  __attribute__((__nothrow__)) double scalbln(double __x , long __n ) ;
extern  __attribute__((__nothrow__)) double __scalbln(double __x , long __n ) ;
extern  __attribute__((__nothrow__)) double nearbyint(double __x ) ;
extern  __attribute__((__nothrow__)) double __nearbyint(double __x ) ;
extern  __attribute__((__nothrow__)) double round(double __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) double __round(double __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) double trunc(double __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) double __trunc(double __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) double remquo(double __x , double __y , int *__quo ) ;
extern  __attribute__((__nothrow__)) double __remquo(double __x , double __y , int *__quo ) ;
__inline extern  __attribute__((__nothrow__)) long lrint(double __x ) ;
extern  __attribute__((__nothrow__)) long __lrint(double __x ) ;
__inline extern  __attribute__((__nothrow__)) long long llrint(double __x ) ;
extern  __attribute__((__nothrow__)) long long __llrint(double __x ) ;
extern  __attribute__((__nothrow__)) long lround(double __x ) ;
extern  __attribute__((__nothrow__)) long __lround(double __x ) ;
extern  __attribute__((__nothrow__)) long long llround(double __x ) ;
extern  __attribute__((__nothrow__)) long long __llround(double __x ) ;
extern  __attribute__((__nothrow__)) double fdim(double __x , double __y ) ;
extern  __attribute__((__nothrow__)) double __fdim(double __x , double __y ) ;
extern  __attribute__((__nothrow__)) double fmax(double __x , double __y ) ;
extern  __attribute__((__nothrow__)) double __fmax(double __x , double __y ) ;
extern  __attribute__((__nothrow__)) double fmin(double __x , double __y ) ;
extern  __attribute__((__nothrow__)) double __fmin(double __x , double __y ) ;
extern  __attribute__((__nothrow__)) int __fpclassify(double __value )  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) int __signbit(double __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) double fma(double __x , double __y , double __z ) ;
extern  __attribute__((__nothrow__)) double __fma(double __x , double __y , double __z ) ;
extern  __attribute__((__nothrow__)) double scalb(double __x , double __n ) ;
extern  __attribute__((__nothrow__)) double __scalb(double __x , double __n ) ;
extern  __attribute__((__nothrow__)) float acosf(float __x ) ;
extern  __attribute__((__nothrow__)) float __acosf(float __x ) ;
extern  __attribute__((__nothrow__)) float asinf(float __x ) ;
extern  __attribute__((__nothrow__)) float __asinf(float __x ) ;
extern  __attribute__((__nothrow__)) float atanf(float __x ) ;
extern  __attribute__((__nothrow__)) float __atanf(float __x ) ;
extern  __attribute__((__nothrow__)) float atan2f(float __y , float __x ) ;
extern  __attribute__((__nothrow__)) float __atan2f(float __y , float __x ) ;
extern  __attribute__((__nothrow__)) float cosf(float __x ) ;
extern  __attribute__((__nothrow__)) float __cosf(float __x ) ;
extern  __attribute__((__nothrow__)) float sinf(float __x ) ;
extern  __attribute__((__nothrow__)) float __sinf(float __x ) ;
extern  __attribute__((__nothrow__)) float tanf(float __x ) ;
extern  __attribute__((__nothrow__)) float __tanf(float __x ) ;
extern  __attribute__((__nothrow__)) float coshf(float __x ) ;
extern  __attribute__((__nothrow__)) float __coshf(float __x ) ;
extern  __attribute__((__nothrow__)) float sinhf(float __x ) ;
extern  __attribute__((__nothrow__)) float __sinhf(float __x ) ;
extern  __attribute__((__nothrow__)) float tanhf(float __x ) ;
extern  __attribute__((__nothrow__)) float __tanhf(float __x ) ;
extern  __attribute__((__nothrow__)) float acoshf(float __x ) ;
extern  __attribute__((__nothrow__)) float __acoshf(float __x ) ;
extern  __attribute__((__nothrow__)) float asinhf(float __x ) ;
extern  __attribute__((__nothrow__)) float __asinhf(float __x ) ;
extern  __attribute__((__nothrow__)) float atanhf(float __x ) ;
extern  __attribute__((__nothrow__)) float __atanhf(float __x ) ;
extern  __attribute__((__nothrow__)) float expf(float __x ) ;
extern  __attribute__((__nothrow__)) float __expf(float __x ) ;
extern  __attribute__((__nothrow__)) float frexpf(float __x , int *__exponent ) ;
extern  __attribute__((__nothrow__)) float __frexpf(float __x , int *__exponent ) ;
extern  __attribute__((__nothrow__)) float ldexpf(float __x , int __exponent ) ;
extern  __attribute__((__nothrow__)) float __ldexpf(float __x , int __exponent ) ;
extern  __attribute__((__nothrow__)) float logf(float __x ) ;
extern  __attribute__((__nothrow__)) float __logf(float __x ) ;
extern  __attribute__((__nothrow__)) float log10f(float __x ) ;
extern  __attribute__((__nothrow__)) float __log10f(float __x ) ;
extern  __attribute__((__nothrow__)) float modff(float __x , float *__iptr ) ;
extern  __attribute__((__nothrow__)) float __modff(float __x , float *__iptr ) ;
extern  __attribute__((__nothrow__)) float expm1f(float __x ) ;
extern  __attribute__((__nothrow__)) float __expm1f(float __x ) ;
extern  __attribute__((__nothrow__)) float log1pf(float __x ) ;
extern  __attribute__((__nothrow__)) float __log1pf(float __x ) ;
extern  __attribute__((__nothrow__)) float logbf(float __x ) ;
extern  __attribute__((__nothrow__)) float __logbf(float __x ) ;
extern  __attribute__((__nothrow__)) float exp2f(float __x ) ;
extern  __attribute__((__nothrow__)) float __exp2f(float __x ) ;
extern  __attribute__((__nothrow__)) float log2f(float __x ) ;
extern  __attribute__((__nothrow__)) float __log2f(float __x ) ;
extern  __attribute__((__nothrow__)) float powf(float __x , float __y ) ;
extern  __attribute__((__nothrow__)) float __powf(float __x , float __y ) ;
extern  __attribute__((__nothrow__)) float sqrtf(float __x ) ;
extern  __attribute__((__nothrow__)) float __sqrtf(float __x ) ;
extern  __attribute__((__nothrow__)) float hypotf(float __x , float __y ) ;
extern  __attribute__((__nothrow__)) float __hypotf(float __x , float __y ) ;
extern  __attribute__((__nothrow__)) float cbrtf(float __x ) ;
extern  __attribute__((__nothrow__)) float __cbrtf(float __x ) ;
__inline extern  __attribute__((__nothrow__)) float ceilf(float __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) float __ceilf(float __x )  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) float fabsf(float __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) float __fabsf(float __x )  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) float floorf(float __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) float __floorf(float __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) float fmodf(float __x , float __y ) ;
extern  __attribute__((__nothrow__)) float __fmodf(float __x , float __y ) ;
extern  __attribute__((__nothrow__)) int __isinff(float __value )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int __finitef(float __value )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int isinff(float __value )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int finitef(float __value )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) float dremf(float __x , float __y ) ;
extern  __attribute__((__nothrow__)) float __dremf(float __x , float __y ) ;
extern  __attribute__((__nothrow__)) float significandf(float __x ) ;
extern  __attribute__((__nothrow__)) float __significandf(float __x ) ;
extern  __attribute__((__nothrow__)) float copysignf(float __x , float __y )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) float __copysignf(float __x , float __y )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) float nanf(char const   *__tagb )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) float __nanf(char const   *__tagb )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int __isnanf(float __value )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int isnanf(float __value )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) float j0f(float  ) ;
extern  __attribute__((__nothrow__)) float __j0f(float  ) ;
extern  __attribute__((__nothrow__)) float j1f(float  ) ;
extern  __attribute__((__nothrow__)) float __j1f(float  ) ;
extern  __attribute__((__nothrow__)) float jnf(int  , float  ) ;
extern  __attribute__((__nothrow__)) float __jnf(int  , float  ) ;
extern  __attribute__((__nothrow__)) float y0f(float  ) ;
extern  __attribute__((__nothrow__)) float __y0f(float  ) ;
extern  __attribute__((__nothrow__)) float y1f(float  ) ;
extern  __attribute__((__nothrow__)) float __y1f(float  ) ;
extern  __attribute__((__nothrow__)) float ynf(int  , float  ) ;
extern  __attribute__((__nothrow__)) float __ynf(int  , float  ) ;
extern  __attribute__((__nothrow__)) float erff(float  ) ;
extern  __attribute__((__nothrow__)) float __erff(float  ) ;
extern  __attribute__((__nothrow__)) float erfcf(float  ) ;
extern  __attribute__((__nothrow__)) float __erfcf(float  ) ;
extern  __attribute__((__nothrow__)) float lgammaf(float  ) ;
extern  __attribute__((__nothrow__)) float __lgammaf(float  ) ;
extern  __attribute__((__nothrow__)) float tgammaf(float  ) ;
extern  __attribute__((__nothrow__)) float __tgammaf(float  ) ;
extern  __attribute__((__nothrow__)) float gammaf(float  ) ;
extern  __attribute__((__nothrow__)) float __gammaf(float  ) ;
extern  __attribute__((__nothrow__)) float lgammaf_r(float  , int *__signgamp ) ;
extern  __attribute__((__nothrow__)) float __lgammaf_r(float  , int *__signgamp ) ;
extern  __attribute__((__nothrow__)) float rintf(float __x ) ;
extern  __attribute__((__nothrow__)) float __rintf(float __x ) ;
extern  __attribute__((__nothrow__)) float nextafterf(float __x , float __y )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) float __nextafterf(float __x , float __y )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) float nexttowardf(float __x , long double __y )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) float __nexttowardf(float __x , long double __y )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) float remainderf(float __x , float __y ) ;
extern  __attribute__((__nothrow__)) float __remainderf(float __x , float __y ) ;
extern  __attribute__((__nothrow__)) float scalbnf(float __x , int __n ) ;
extern  __attribute__((__nothrow__)) float __scalbnf(float __x , int __n ) ;
extern  __attribute__((__nothrow__)) int ilogbf(float __x ) ;
extern  __attribute__((__nothrow__)) int __ilogbf(float __x ) ;
extern  __attribute__((__nothrow__)) float scalblnf(float __x , long __n ) ;
extern  __attribute__((__nothrow__)) float __scalblnf(float __x , long __n ) ;
extern  __attribute__((__nothrow__)) float nearbyintf(float __x ) ;
extern  __attribute__((__nothrow__)) float __nearbyintf(float __x ) ;
extern  __attribute__((__nothrow__)) float roundf(float __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) float __roundf(float __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) float truncf(float __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) float __truncf(float __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) float remquof(float __x , float __y , int *__quo ) ;
extern  __attribute__((__nothrow__)) float __remquof(float __x , float __y , int *__quo ) ;
__inline extern  __attribute__((__nothrow__)) long lrintf(float __x ) ;
extern  __attribute__((__nothrow__)) long __lrintf(float __x ) ;
__inline extern  __attribute__((__nothrow__)) long long llrintf(float __x ) ;
extern  __attribute__((__nothrow__)) long long __llrintf(float __x ) ;
extern  __attribute__((__nothrow__)) long lroundf(float __x ) ;
extern  __attribute__((__nothrow__)) long __lroundf(float __x ) ;
extern  __attribute__((__nothrow__)) long long llroundf(float __x ) ;
extern  __attribute__((__nothrow__)) long long __llroundf(float __x ) ;
extern  __attribute__((__nothrow__)) float fdimf(float __x , float __y ) ;
extern  __attribute__((__nothrow__)) float __fdimf(float __x , float __y ) ;
extern  __attribute__((__nothrow__)) float fmaxf(float __x , float __y ) ;
extern  __attribute__((__nothrow__)) float __fmaxf(float __x , float __y ) ;
extern  __attribute__((__nothrow__)) float fminf(float __x , float __y ) ;
extern  __attribute__((__nothrow__)) float __fminf(float __x , float __y ) ;
extern  __attribute__((__nothrow__)) int __fpclassifyf(float __value )  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) int __signbitf(float __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) float fmaf(float __x , float __y , float __z ) ;
extern  __attribute__((__nothrow__)) float __fmaf(float __x , float __y , float __z ) ;
extern  __attribute__((__nothrow__)) float scalbf(float __x , float __n ) ;
extern  __attribute__((__nothrow__)) float __scalbf(float __x , float __n ) ;
extern  __attribute__((__nothrow__)) long double acosl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double __acosl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double asinl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double __asinl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double atanl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double __atanl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double atan2l(long double __y , long double __x ) ;
__inline extern  __attribute__((__nothrow__)) long double __atan2l(long double __y , long double __x ) ;
extern  __attribute__((__nothrow__)) long double cosl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double __cosl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double sinl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double __sinl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double tanl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double __tanl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double coshl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double __coshl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double sinhl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double __sinhl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double tanhl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double __tanhl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double acoshl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double __acoshl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double asinhl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double __asinhl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double atanhl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double __atanhl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double expl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double __expl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double frexpl(long double __x , int *__exponent ) ;
extern  __attribute__((__nothrow__)) long double __frexpl(long double __x , int *__exponent ) ;
extern  __attribute__((__nothrow__)) long double ldexpl(long double __x , int __exponent ) ;
extern  __attribute__((__nothrow__)) long double __ldexpl(long double __x , int __exponent ) ;
extern  __attribute__((__nothrow__)) long double logl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double __logl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double log10l(long double __x ) ;
extern  __attribute__((__nothrow__)) long double __log10l(long double __x ) ;
extern  __attribute__((__nothrow__)) long double modfl(long double __x , long double *__iptr ) ;
extern  __attribute__((__nothrow__)) long double __modfl(long double __x , long double *__iptr ) ;
extern  __attribute__((__nothrow__)) long double expm1l(long double __x ) ;
extern  __attribute__((__nothrow__)) long double __expm1l(long double __x ) ;
extern  __attribute__((__nothrow__)) long double log1pl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double __log1pl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double logbl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double __logbl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double exp2l(long double __x ) ;
extern  __attribute__((__nothrow__)) long double __exp2l(long double __x ) ;
extern  __attribute__((__nothrow__)) long double log2l(long double __x ) ;
extern  __attribute__((__nothrow__)) long double __log2l(long double __x ) ;
extern  __attribute__((__nothrow__)) long double powl(long double __x , long double __y ) ;
extern  __attribute__((__nothrow__)) long double __powl(long double __x , long double __y ) ;
extern  __attribute__((__nothrow__)) long double sqrtl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double __sqrtl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double hypotl(long double __x , long double __y ) ;
extern  __attribute__((__nothrow__)) long double __hypotl(long double __x , long double __y ) ;
extern  __attribute__((__nothrow__)) long double cbrtl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double __cbrtl(long double __x ) ;
__inline extern  __attribute__((__nothrow__)) long double ceill(long double __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) long double __ceill(long double __x )  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) long double fabsl(long double __x )  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) long double __fabsl(long double __x )  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) long double floorl(long double __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) long double __floorl(long double __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) long double fmodl(long double __x , long double __y ) ;
extern  __attribute__((__nothrow__)) long double __fmodl(long double __x , long double __y ) ;
extern  __attribute__((__nothrow__)) int __isinfl(long double __value )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int __finitel(long double __value )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int isinfl(long double __value )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int finitel(long double __value )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) long double dreml(long double __x , long double __y ) ;
extern  __attribute__((__nothrow__)) long double __dreml(long double __x , long double __y ) ;
extern  __attribute__((__nothrow__)) long double significandl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double __significandl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double copysignl(long double __x , long double __y )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) long double __copysignl(long double __x , long double __y )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) long double nanl(char const   *__tagb )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) long double __nanl(char const   *__tagb )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int __isnanl(long double __value )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int isnanl(long double __value )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) long double j0l(long double  ) ;
extern  __attribute__((__nothrow__)) long double __j0l(long double  ) ;
extern  __attribute__((__nothrow__)) long double j1l(long double  ) ;
extern  __attribute__((__nothrow__)) long double __j1l(long double  ) ;
extern  __attribute__((__nothrow__)) long double jnl(int  , long double  ) ;
extern  __attribute__((__nothrow__)) long double __jnl(int  , long double  ) ;
extern  __attribute__((__nothrow__)) long double y0l(long double  ) ;
extern  __attribute__((__nothrow__)) long double __y0l(long double  ) ;
extern  __attribute__((__nothrow__)) long double y1l(long double  ) ;
extern  __attribute__((__nothrow__)) long double __y1l(long double  ) ;
extern  __attribute__((__nothrow__)) long double ynl(int  , long double  ) ;
extern  __attribute__((__nothrow__)) long double __ynl(int  , long double  ) ;
extern  __attribute__((__nothrow__)) long double erfl(long double  ) ;
extern  __attribute__((__nothrow__)) long double __erfl(long double  ) ;
extern  __attribute__((__nothrow__)) long double erfcl(long double  ) ;
extern  __attribute__((__nothrow__)) long double __erfcl(long double  ) ;
extern  __attribute__((__nothrow__)) long double lgammal(long double  ) ;
extern  __attribute__((__nothrow__)) long double __lgammal(long double  ) ;
extern  __attribute__((__nothrow__)) long double tgammal(long double  ) ;
extern  __attribute__((__nothrow__)) long double __tgammal(long double  ) ;
extern  __attribute__((__nothrow__)) long double gammal(long double  ) ;
extern  __attribute__((__nothrow__)) long double __gammal(long double  ) ;
extern  __attribute__((__nothrow__)) long double lgammal_r(long double  , int *__signgamp ) ;
extern  __attribute__((__nothrow__)) long double __lgammal_r(long double  , int *__signgamp ) ;
extern  __attribute__((__nothrow__)) long double rintl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double __rintl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double nextafterl(long double __x , long double __y )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) long double __nextafterl(long double __x , long double __y )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) long double nexttowardl(long double __x , long double __y )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) long double __nexttowardl(long double __x , long double __y )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) long double remainderl(long double __x , long double __y ) ;
extern  __attribute__((__nothrow__)) long double __remainderl(long double __x , long double __y ) ;
extern  __attribute__((__nothrow__)) long double scalbnl(long double __x , int __n ) ;
extern  __attribute__((__nothrow__)) long double __scalbnl(long double __x , int __n ) ;
extern  __attribute__((__nothrow__)) int ilogbl(long double __x ) ;
extern  __attribute__((__nothrow__)) int __ilogbl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double scalblnl(long double __x , long __n ) ;
extern  __attribute__((__nothrow__)) long double __scalblnl(long double __x , long __n ) ;
extern  __attribute__((__nothrow__)) long double nearbyintl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double __nearbyintl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double roundl(long double __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) long double __roundl(long double __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) long double truncl(long double __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) long double __truncl(long double __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) long double remquol(long double __x , long double __y , int *__quo ) ;
extern  __attribute__((__nothrow__)) long double __remquol(long double __x , long double __y , int *__quo ) ;
__inline extern  __attribute__((__nothrow__)) long lrintl(long double __x ) ;
extern  __attribute__((__nothrow__)) long __lrintl(long double __x ) ;
__inline extern  __attribute__((__nothrow__)) long long llrintl(long double __x ) ;
extern  __attribute__((__nothrow__)) long long __llrintl(long double __x ) ;
extern  __attribute__((__nothrow__)) long lroundl(long double __x ) ;
extern  __attribute__((__nothrow__)) long __lroundl(long double __x ) ;
extern  __attribute__((__nothrow__)) long long llroundl(long double __x ) ;
extern  __attribute__((__nothrow__)) long long __llroundl(long double __x ) ;
extern  __attribute__((__nothrow__)) long double fdiml(long double __x , long double __y ) ;
extern  __attribute__((__nothrow__)) long double __fdiml(long double __x , long double __y ) ;
extern  __attribute__((__nothrow__)) long double fmaxl(long double __x , long double __y ) ;
extern  __attribute__((__nothrow__)) long double __fmaxl(long double __x , long double __y ) ;
extern  __attribute__((__nothrow__)) long double fminl(long double __x , long double __y ) ;
extern  __attribute__((__nothrow__)) long double __fminl(long double __x , long double __y ) ;
extern  __attribute__((__nothrow__)) int __fpclassifyl(long double __value )  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) int __signbitl(long double __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) long double fmal(long double __x , long double __y , long double __z ) ;
extern  __attribute__((__nothrow__)) long double __fmal(long double __x , long double __y , long double __z ) ;
extern  __attribute__((__nothrow__)) long double scalbl(long double __x , long double __n ) ;
extern  __attribute__((__nothrow__)) long double __scalbl(long double __x , long double __n ) ;
extern int signgam ;
extern _LIB_VERSION_TYPE _LIB_VERSION ;
extern int matherr(struct exception *__exc ) ;
__inline extern  __attribute__((__nothrow__)) int __signbitf(float __x )  __attribute__((__const__)) ;
__inline extern int __signbitf(float __x ) 
{ union __anonunion___u_52 __u ;

  {
  __u.__f = __x;
  return (__u.__i < 0);
}
}
__inline extern  __attribute__((__nothrow__)) int __signbit(double __x )  __attribute__((__const__)) ;
__inline extern int __signbit(double __x ) 
{ union __anonunion___u_53 __u ;

  {
  __u.__d = __x;
  return (__u.__i[1] < 0);
}
}
__inline extern  __attribute__((__nothrow__)) int __signbitl(long double __x )  __attribute__((__const__)) ;
__inline extern int __signbitl(long double __x ) 
{ union __anonunion___u_54 __u ;

  {
  __u.__l = __x;
  return ((__u.__i[2] & 0x8000) != 0);
}
}
__inline extern  __attribute__((__nothrow__)) double __sgn(double __x ) ;
__inline extern  __attribute__((__nothrow__)) double __sgn(double __x ) ;
__inline extern double __sgn(double __x ) 
{ double tmp ;
  double tmp___0 ;

  {
  if (__x == 0.0) {
    tmp___0 = 0.0;
  } else {
    if (__x > 0.0) {
      tmp = 1.0;
    } else {
      tmp = - 1.0;
    }
    tmp___0 = tmp;
  }
  return (tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) float __sgnf(float __x ) ;
__inline extern  __attribute__((__nothrow__)) float __sgnf(float __x ) ;
__inline extern float __sgnf(float __x ) 
{ double tmp ;
  double tmp___0 ;

  {
  if ((double )__x == 0.0) {
    tmp___0 = 0.0;
  } else {
    if ((double )__x > 0.0) {
      tmp = 1.0;
    } else {
      tmp = - 1.0;
    }
    tmp___0 = tmp;
  }
  return ((float )tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) long double __sgnl(long double __x ) ;
__inline extern  __attribute__((__nothrow__)) long double __sgnl(long double __x ) ;
__inline extern long double __sgnl(long double __x ) 
{ double tmp ;
  double tmp___0 ;

  {
  if (__x == (long double )0.0) {
    tmp___0 = 0.0;
  } else {
    if (__x > (long double )0.0) {
      tmp = 1.0;
    } else {
      tmp = - 1.0;
    }
    tmp___0 = tmp;
  }
  return ((long double )tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) long double __atan2l(long double __y , long double __x ) ;
__inline extern long double __atan2l(long double __y , long double __x ) 
{ long double tmp ;

  {
  tmp = __builtin_atan2l(__y, __x);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) double fabs(double __x )  __attribute__((__const__)) ;
__inline extern double fabs(double __x ) 
{ double tmp ;

  {
  tmp = __builtin_fabs(__x);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) float fabsf(float __x )  __attribute__((__const__)) ;
__inline extern float fabsf(float __x ) 
{ float tmp ;

  {
  tmp = __builtin_fabsf(__x);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long double fabsl(long double __x )  __attribute__((__const__)) ;
__inline extern long double fabsl(long double __x ) 
{ long double tmp ;

  {
  tmp = __builtin_fabsl(__x);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long double __fabsl(long double __x )  __attribute__((__const__)) ;
__inline extern long double __fabsl(long double __x ) 
{ long double tmp ;

  {
  tmp = __builtin_fabsl(__x);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long double __sgn1l(long double __x ) ;
__inline extern  __attribute__((__nothrow__)) long double __sgn1l(long double __x ) ;
__inline extern long double __sgn1l(long double __x ) 
{ union __anonunion___n_55 __n ;

  {
  __n.__xld = __x;
  __n.__xi[2] = (__n.__xi[2] & 32768U) | 16383U;
  __n.__xi[1] = 0x80000000;
  __n.__xi[0] = 0U;
  return (__n.__xld);
}
}
__inline extern  __attribute__((__nothrow__)) double floor(double __x )  __attribute__((__const__)) ;
__inline extern double floor(double __x ) 
{ register long double __value ;
  register int __ignore ;
  unsigned short __cw ;
  unsigned short __cwtmp ;

  {
  __asm__  volatile   ("fnstcw %3\n\t"
                       "movzwl %3, %1\n\t"
                       "andl $0xf3ff, %1\n\t"
                       "orl $0x0400, %1\n\t"
                       "movw %w1, %2\n\t"
                       "fldcw %2\n\t"
                       "frndint\n\t"
                       "fldcw %3": "=t" (__value), "=&q" (__ignore), "=m" (__cwtmp), "=m" (__cw): "0" (__x));
  return ((double )__value);
}
}
__inline extern  __attribute__((__nothrow__)) float floorf(float __x )  __attribute__((__const__)) ;
__inline extern float floorf(float __x ) 
{ register long double __value ;
  register int __ignore ;
  unsigned short __cw ;
  unsigned short __cwtmp ;

  {
  __asm__  volatile   ("fnstcw %3\n\t"
                       "movzwl %3, %1\n\t"
                       "andl $0xf3ff, %1\n\t"
                       "orl $0x0400, %1\n\t"
                       "movw %w1, %2\n\t"
                       "fldcw %2\n\t"
                       "frndint\n\t"
                       "fldcw %3": "=t" (__value), "=&q" (__ignore), "=m" (__cwtmp), "=m" (__cw): "0" (__x));
  return ((float )__value);
}
}
__inline extern  __attribute__((__nothrow__)) long double floorl(long double __x )  __attribute__((__const__)) ;
__inline extern long double floorl(long double __x ) 
{ register long double __value ;
  register int __ignore ;
  unsigned short __cw ;
  unsigned short __cwtmp ;

  {
  __asm__  volatile   ("fnstcw %3\n\t"
                       "movzwl %3, %1\n\t"
                       "andl $0xf3ff, %1\n\t"
                       "orl $0x0400, %1\n\t"
                       "movw %w1, %2\n\t"
                       "fldcw %2\n\t"
                       "frndint\n\t"
                       "fldcw %3": "=t" (__value), "=&q" (__ignore), "=m" (__cwtmp), "=m" (__cw): "0" (__x));
  return (__value);
}
}
__inline extern  __attribute__((__nothrow__)) double ceil(double __x )  __attribute__((__const__)) ;
__inline extern double ceil(double __x ) 
{ register long double __value ;
  register int __ignore ;
  unsigned short __cw ;
  unsigned short __cwtmp ;

  {
  __asm__  volatile   ("fnstcw %3\n\t"
                       "movzwl %3, %1\n\t"
                       "andl $0xf3ff, %1\n\t"
                       "orl $0x0800, %1\n\t"
                       "movw %w1, %2\n\t"
                       "fldcw %2\n\t"
                       "frndint\n\t"
                       "fldcw %3": "=t" (__value), "=&q" (__ignore), "=m" (__cwtmp), "=m" (__cw): "0" (__x));
  return ((double )__value);
}
}
__inline extern  __attribute__((__nothrow__)) float ceilf(float __x )  __attribute__((__const__)) ;
__inline extern float ceilf(float __x ) 
{ register long double __value ;
  register int __ignore ;
  unsigned short __cw ;
  unsigned short __cwtmp ;

  {
  __asm__  volatile   ("fnstcw %3\n\t"
                       "movzwl %3, %1\n\t"
                       "andl $0xf3ff, %1\n\t"
                       "orl $0x0800, %1\n\t"
                       "movw %w1, %2\n\t"
                       "fldcw %2\n\t"
                       "frndint\n\t"
                       "fldcw %3": "=t" (__value), "=&q" (__ignore), "=m" (__cwtmp), "=m" (__cw): "0" (__x));
  return ((float )__value);
}
}
__inline extern  __attribute__((__nothrow__)) long double ceill(long double __x )  __attribute__((__const__)) ;
__inline extern long double ceill(long double __x ) 
{ register long double __value ;
  register int __ignore ;
  unsigned short __cw ;
  unsigned short __cwtmp ;

  {
  __asm__  volatile   ("fnstcw %3\n\t"
                       "movzwl %3, %1\n\t"
                       "andl $0xf3ff, %1\n\t"
                       "orl $0x0800, %1\n\t"
                       "movw %w1, %2\n\t"
                       "fldcw %2\n\t"
                       "frndint\n\t"
                       "fldcw %3": "=t" (__value), "=&q" (__ignore), "=m" (__cwtmp), "=m" (__cw): "0" (__x));
  return (__value);
}
}
__inline extern  __attribute__((__nothrow__)) long lrintf(float __x ) ;
__inline extern long lrintf(float __x ) 
{ long __lrintres ;

  {
  __asm__  volatile   ("fistpl %0": "=m" (__lrintres): "t" (__x): "st");
  return (__lrintres);
}
}
__inline extern  __attribute__((__nothrow__)) long lrint(double __x ) ;
__inline extern long lrint(double __x ) 
{ long __lrintres ;

  {
  __asm__  volatile   ("fistpl %0": "=m" (__lrintres): "t" (__x): "st");
  return (__lrintres);
}
}
__inline extern  __attribute__((__nothrow__)) long lrintl(long double __x ) ;
__inline extern long lrintl(long double __x ) 
{ long __lrintres ;

  {
  __asm__  volatile   ("fistpl %0": "=m" (__lrintres): "t" (__x): "st");
  return (__lrintres);
}
}
__inline extern  __attribute__((__nothrow__)) long long llrintf(float __x ) ;
__inline extern long long llrintf(float __x ) 
{ long long __llrintres ;

  {
  __asm__  volatile   ("fistpll %0": "=m" (__llrintres): "t" (__x): "st");
  return (__llrintres);
}
}
__inline extern  __attribute__((__nothrow__)) long long llrint(double __x ) ;
__inline extern long long llrint(double __x ) 
{ long long __llrintres ;

  {
  __asm__  volatile   ("fistpll %0": "=m" (__llrintres): "t" (__x): "st");
  return (__llrintres);
}
}
__inline extern  __attribute__((__nothrow__)) long long llrintl(long double __x ) ;
__inline extern long long llrintl(long double __x ) 
{ long long __llrintres ;

  {
  __asm__  volatile   ("fistpll %0": "=m" (__llrintres): "t" (__x): "st");
  return (__llrintres);
}
}
__inline extern  __attribute__((__nothrow__)) int __finite(double __x )  __attribute__((__const__)) ;
__inline extern int __finite(double __x ) 
{ union __anonunion_56 __constr_expr_0 ;

  {
  __constr_expr_0.__d = __x;
  return ((int )((((unsigned int )__constr_expr_0.__i[1] | 0x800fffffu) + 1U) >> 31));
}
}
extern  __attribute__((__nothrow__)) void *dlopen(char const   *__file , int __mode ) ;
extern  __attribute__((__nothrow__)) int dlclose(void *__handle )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) void *dlsym(void * __restrict  __handle , char const   * __restrict  __name )  __attribute__((__nonnull__(2))) ;
extern  __attribute__((__nothrow__)) char *dlerror(void) ;
extern char __attribute__((__visibility__("default")))  *zend_strndup(char const   *s , unsigned int length )  __attribute__((__malloc__)) ;
extern void __attribute__((__visibility__("default")))  *_emalloc(size_t size )  __attribute__((__malloc__)) ;
extern void __attribute__((__visibility__("default")))  *_safe_emalloc(size_t nmemb , size_t size , size_t offset )  __attribute__((__malloc__)) ;
extern void __attribute__((__visibility__("default")))  *_safe_malloc(size_t nmemb , size_t size , size_t offset )  __attribute__((__malloc__)) ;
extern void __attribute__((__visibility__("default")))  _efree(void *ptr ) ;
extern void __attribute__((__visibility__("default")))  *_ecalloc(size_t nmemb , size_t size )  __attribute__((__malloc__)) ;
extern void __attribute__((__visibility__("default")))  *_erealloc(void *ptr , size_t size , int allow_failure ) ;
extern void __attribute__((__visibility__("default")))  *_safe_erealloc(void *ptr , size_t nmemb , size_t size , size_t offset ) ;
extern void __attribute__((__visibility__("default")))  *_safe_realloc(void *ptr , size_t nmemb , size_t size , size_t offset ) ;
extern char __attribute__((__visibility__("default")))  *_estrdup(char const   *s )  __attribute__((__malloc__)) ;
extern char __attribute__((__visibility__("default")))  *_estrndup(char const   *s , unsigned int length )  __attribute__((__malloc__)) ;
extern size_t __attribute__((__visibility__("default")))  _zend_mem_block_size(void *ptr ) ;
__inline static void *__zend_malloc(size_t len ) 
{ void *tmp ;
  void *tmp___0 ;

  {
  tmp___0 = malloc(len);
  tmp = tmp___0;
  if (tmp) {
    return (tmp);
  } else {

  }
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory\n");
  exit(1);
}
}
__inline static void *__zend_calloc(size_t nmemb , size_t len ) 
{ void *tmp ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;

  {
  tmp___0 = _safe_malloc(nmemb, len, 0U);
  tmp = (void *)tmp___0;
  memset(tmp, 0, nmemb * len);
  return (tmp);
}
}
__inline static void *__zend_realloc(void *p , size_t len ) 
{ 

  {
  p = realloc(p, len);
  if (p) {
    return (p);
  } else {

  }
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory\n");
  exit(1);
}
}
extern int __attribute__((__visibility__("default")))  zend_set_memory_limit(size_t memory_limit ) ;
extern void __attribute__((__visibility__("default")))  start_memory_manager(void) ;
extern void __attribute__((__visibility__("default")))  shutdown_memory_manager(int silent , int full_shutdown ) ;
extern int __attribute__((__visibility__("default")))  is_zend_mm(void) ;
extern size_t __attribute__((__visibility__("default")))  zend_memory_usage(int real_usage ) ;
extern size_t __attribute__((__visibility__("default")))  zend_memory_peak_usage(int real_usage ) ;
extern zend_mm_heap __attribute__((__visibility__("default")))  *zend_mm_startup(void) ;
extern void __attribute__((__visibility__("default")))  zend_mm_shutdown(zend_mm_heap *heap , int full_shutdown , int silent ) ;
extern void __attribute__((__visibility__("default")))  *_zend_mm_alloc(zend_mm_heap *heap , size_t size )  __attribute__((__malloc__)) ;
extern void __attribute__((__visibility__("default")))  _zend_mm_free(zend_mm_heap *heap , void *p ) ;
extern void __attribute__((__visibility__("default")))  *_zend_mm_realloc(zend_mm_heap *heap , void *p , size_t size ) ;
extern size_t __attribute__((__visibility__("default")))  _zend_mm_block_size(zend_mm_heap *heap , void *p ) ;
extern zend_mm_heap __attribute__((__visibility__("default")))  *zend_mm_startup_ex(zend_mm_mem_handlers const   *handlers , size_t block_size , size_t reserve_size , int internal , void *params ) ;
extern zend_mm_heap __attribute__((__visibility__("default")))  *zend_mm_set_heap(zend_mm_heap *new_heap ) ;
extern zend_mm_storage __attribute__((__visibility__("default")))  *zend_mm_get_storage(zend_mm_heap *heap ) ;
extern void __attribute__((__visibility__("default")))  zend_mm_set_custom_handlers(zend_mm_heap *heap , void *(*_malloc)(size_t  ) , void (*_free)(void * ) , void *(*_realloc)(void * , size_t  ) ) ;
extern char const __attribute__((__visibility__("default")))  *(*zend_new_interned_string)(char const   *str , int len , int free_src ) ;
extern void __attribute__((__visibility__("default")))  (*zend_interned_strings_snapshot)(void) ;
extern void __attribute__((__visibility__("default")))  (*zend_interned_strings_restore)(void) ;
extern void zend_interned_strings_init(void) ;
extern void zend_interned_strings_dtor(void) ;
static char const   long_min_digits[11]  = 
  {      (char const   )'2',      (char const   )'1',      (char const   )'4',      (char const   )'7', 
        (char const   )'4',      (char const   )'8',      (char const   )'3',      (char const   )'6', 
        (char const   )'4',      (char const   )'8',      (char const   )'\000'};
extern int __attribute__((__visibility__("default")))  _zend_hash_init(HashTable *ht , uint nSize , ulong (*pHashFunction)(char const   *arKey , uint nKeyLength ) , void (*pDestructor)(void *pDest ) , zend_bool persistent ) ;
extern int __attribute__((__visibility__("default")))  _zend_hash_init_ex(HashTable *ht , uint nSize , ulong (*pHashFunction)(char const   *arKey , uint nKeyLength ) , void (*pDestructor)(void *pDest ) , zend_bool persistent , zend_bool bApplyProtection ) ;
extern void __attribute__((__visibility__("default")))  zend_hash_destroy(HashTable *ht ) ;
extern void __attribute__((__visibility__("default")))  zend_hash_clean(HashTable *ht ) ;
extern int __attribute__((__visibility__("default")))  _zend_hash_add_or_update(HashTable *ht , char const   *arKey , uint nKeyLength , void *pData , uint nDataSize , void **pDest , int flag ) ;
extern int __attribute__((__visibility__("default")))  _zend_hash_quick_add_or_update(HashTable *ht , char const   *arKey , uint nKeyLength , ulong h , void *pData , uint nDataSize , void **pDest , int flag ) ;
extern int __attribute__((__visibility__("default")))  _zend_hash_index_update_or_next_insert(HashTable *ht , ulong h , void *pData , uint nDataSize , void **pDest , int flag ) ;
extern int __attribute__((__visibility__("default")))  zend_hash_add_empty_element(HashTable *ht , char const   *arKey , uint nKeyLength ) ;
extern void __attribute__((__visibility__("default")))  zend_hash_graceful_destroy(HashTable *ht ) ;
extern void __attribute__((__visibility__("default")))  zend_hash_graceful_reverse_destroy(HashTable *ht ) ;
extern void __attribute__((__visibility__("default")))  zend_hash_apply(HashTable *ht , int (*apply_func)(void *pDest ) ) ;
extern void __attribute__((__visibility__("default")))  zend_hash_apply_with_argument(HashTable *ht , int (*apply_func)(void *pDest , void *argument ) , void * ) ;
extern void __attribute__((__visibility__("default")))  zend_hash_apply_with_arguments(HashTable *ht , int (*apply_func)(void *pDest , int num_args , va_list args , zend_hash_key *hash_key ) , int   , ...) ;
extern void __attribute__((__visibility__("default")))  zend_hash_reverse_apply(HashTable *ht , int (*apply_func)(void *pDest ) ) ;
extern int __attribute__((__visibility__("default")))  zend_hash_del_key_or_index(HashTable *ht , char const   *arKey , uint nKeyLength , ulong h , int flag ) ;
extern ulong __attribute__((__visibility__("default")))  zend_get_hash_value(char const   *arKey , uint nKeyLength ) ;
extern int __attribute__((__visibility__("default")))  zend_hash_find(HashTable const   *ht , char const   *arKey , uint nKeyLength , void **pData ) ;
extern int __attribute__((__visibility__("default")))  zend_hash_quick_find(HashTable const   *ht , char const   *arKey , uint nKeyLength , ulong h , void **pData ) ;
extern int __attribute__((__visibility__("default")))  zend_hash_index_find(HashTable const   *ht , ulong h , void **pData ) ;
extern int __attribute__((__visibility__("default")))  zend_hash_exists(HashTable const   *ht , char const   *arKey , uint nKeyLength ) ;
extern int __attribute__((__visibility__("default")))  zend_hash_quick_exists(HashTable const   *ht , char const   *arKey , uint nKeyLength , ulong h ) ;
extern int __attribute__((__visibility__("default")))  zend_hash_index_exists(HashTable const   *ht , ulong h ) ;
extern ulong __attribute__((__visibility__("default")))  zend_hash_next_free_element(HashTable const   *ht ) ;
extern int __attribute__((__visibility__("default")))  zend_hash_move_forward_ex(HashTable *ht , HashPosition *pos ) ;
extern int __attribute__((__visibility__("default")))  zend_hash_move_backwards_ex(HashTable *ht , HashPosition *pos ) ;
extern int __attribute__((__visibility__("default")))  zend_hash_get_current_key_ex(HashTable const   *ht , char **str_index , uint *str_length , ulong *num_index , zend_bool duplicate , HashPosition *pos ) ;
extern int __attribute__((__visibility__("default")))  zend_hash_get_current_key_type_ex(HashTable *ht , HashPosition *pos ) ;
extern int __attribute__((__visibility__("default")))  zend_hash_get_current_data_ex(HashTable *ht , void **pData , HashPosition *pos ) ;
extern void __attribute__((__visibility__("default")))  zend_hash_internal_pointer_reset_ex(HashTable *ht , HashPosition *pos ) ;
extern void __attribute__((__visibility__("default")))  zend_hash_internal_pointer_end_ex(HashTable *ht , HashPosition *pos ) ;
extern int __attribute__((__visibility__("default")))  zend_hash_update_current_key_ex(HashTable *ht , int key_type , char const   *str_index , uint str_length , ulong num_index , int mode , HashPosition *pos ) ;
extern int __attribute__((__visibility__("default")))  zend_hash_get_pointer(HashTable const   *ht , HashPointer *ptr ) ;
extern int __attribute__((__visibility__("default")))  zend_hash_set_pointer(HashTable *ht , HashPointer const   *ptr ) ;
extern void __attribute__((__visibility__("default")))  zend_hash_copy(HashTable *target , HashTable *source , void (*pCopyConstructor)(void *pElement ) , void *tmp , uint size ) ;
extern void __attribute__((__visibility__("default")))  _zend_hash_merge(HashTable *target , HashTable *source , void (*pCopyConstructor)(void *pElement ) , void *tmp , uint size , int overwrite ) ;
extern void __attribute__((__visibility__("default")))  zend_hash_merge_ex(HashTable *target , HashTable *source , void (*pCopyConstructor)(void *pElement ) , uint size , zend_bool (*pMergeSource)(HashTable *target_ht , void *source_data , zend_hash_key *hash_key , void *pParam ) , void *pParam ) ;
extern int __attribute__((__visibility__("default")))  zend_hash_sort(HashTable *ht , void (*sort_func)(void * , size_t  , size_t  , int (*)(void const   * , void const   * ) ) , int (*compare_func)(void const   * , void const   * ) , int renumber ) ;
extern int __attribute__((__visibility__("default")))  zend_hash_compare(HashTable *ht1 , HashTable *ht2 , int (*compar)(void const   * , void const   * ) , zend_bool ordered ) ;
extern int __attribute__((__visibility__("default")))  zend_hash_minmax(HashTable const   *ht , int (*compar)(void const   * , void const   * ) , int flag , void **pData ) ;
extern int __attribute__((__visibility__("default")))  zend_hash_num_elements(HashTable const   *ht ) ;
extern int __attribute__((__visibility__("default")))  zend_hash_rehash(HashTable *ht ) ;
__inline static ulong zend_inline_hash_func(char const   *arKey , uint nKeyLength ) 
{ register ulong hash ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;

  {
  hash = (ulong )5381;
  while (nKeyLength >= 8U) {
    tmp = arKey;
    arKey ++;
    hash = ((hash << 5) + hash) + (ulong )*tmp;
    tmp___0 = arKey;
    arKey ++;
    hash = ((hash << 5) + hash) + (ulong )*tmp___0;
    tmp___1 = arKey;
    arKey ++;
    hash = ((hash << 5) + hash) + (ulong )*tmp___1;
    tmp___2 = arKey;
    arKey ++;
    hash = ((hash << 5) + hash) + (ulong )*tmp___2;
    tmp___3 = arKey;
    arKey ++;
    hash = ((hash << 5) + hash) + (ulong )*tmp___3;
    tmp___4 = arKey;
    arKey ++;
    hash = ((hash << 5) + hash) + (ulong )*tmp___4;
    tmp___5 = arKey;
    arKey ++;
    hash = ((hash << 5) + hash) + (ulong )*tmp___5;
    tmp___6 = arKey;
    arKey ++;
    hash = ((hash << 5) + hash) + (ulong )*tmp___6;
    nKeyLength -= 8U;
  }
  switch ((int )nKeyLength) {
  case 7: 
  tmp___7 = arKey;
  arKey ++;
  hash = ((hash << 5) + hash) + (ulong )*tmp___7;
  case 6: 
  tmp___8 = arKey;
  arKey ++;
  hash = ((hash << 5) + hash) + (ulong )*tmp___8;
  case 5: 
  tmp___9 = arKey;
  arKey ++;
  hash = ((hash << 5) + hash) + (ulong )*tmp___9;
  case 4: 
  tmp___10 = arKey;
  arKey ++;
  hash = ((hash << 5) + hash) + (ulong )*tmp___10;
  case 3: 
  tmp___11 = arKey;
  arKey ++;
  hash = ((hash << 5) + hash) + (ulong )*tmp___11;
  case 2: 
  tmp___12 = arKey;
  arKey ++;
  hash = ((hash << 5) + hash) + (ulong )*tmp___12;
  case 1: 
  tmp___13 = arKey;
  arKey ++;
  hash = ((hash << 5) + hash) + (ulong )*tmp___13;
  break;
  case 0: 
  break;
  }
  return (hash);
}
}
extern ulong __attribute__((__visibility__("default")))  zend_hash_func(char const   *arKey , uint nKeyLength ) ;
__inline static int zend_symtable_update(HashTable *ht , char const   *arKey , uint nKeyLength , void *pData , uint nDataSize , void **pDest ) 
{ ulong idx ;
  register char const   *tmp ;
  char const   *end ;
  int __attribute__((__visibility__("default")))  tmp___0 ;
  int __attribute__((__visibility__("default")))  tmp___1 ;

  {
  while (1) {
    while (1) {
      tmp = arKey;
      if ((int const   )*tmp == 45) {
        tmp ++;
      } else {

      }
      if ((int const   )*tmp >= 48) {
        if ((int const   )*tmp <= 57) {
          end = (arKey + nKeyLength) - 1;
          if ((int const   )*end != 0) {
            break;
          } else {
            if ((int const   )*tmp == 48) {
              if (nKeyLength > 2U) {
                break;
              } else {
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
              if (end - tmp > 10) {
                break;
              } else {
                if (end - tmp == 10) {
                  if ((int const   )*tmp > 50) {
                    break;
                  } else {

                  }
                } else {

                }
              }
            }
          }
          idx = (unsigned long )((int const   )*tmp - 48);
          while (1) {
            tmp ++;
            if ((unsigned int )tmp != (unsigned int )end) {
              if ((int const   )*tmp >= 48) {
                if ((int const   )*tmp <= 57) {

                } else {
                  break;
                }
              } else {
                break;
              }
            } else {
              break;
            }
            idx = idx * 10UL + (ulong )((int const   )*tmp - 48);
          }
          if ((unsigned int )tmp == (unsigned int )end) {
            if ((int const   )*arKey == 45) {
              if (idx - 1UL > 2147483647UL) {
                break;
              } else {

              }
              idx = (unsigned long )(- ((long )idx));
            } else {
              if (idx > 2147483647UL) {
                break;
              } else {

              }
            }
            tmp___0 = _zend_hash_index_update_or_next_insert(ht, idx, pData, nDataSize, pDest, 1);
            return ((int )tmp___0);
          } else {

          }
        } else {

        }
      } else {

      }
      break;
    }
    break;
  }
  tmp___1 = _zend_hash_add_or_update(ht, arKey, nKeyLength, pData, nDataSize, pDest, 1);
  return ((int )tmp___1);
}
}
__inline static int zend_symtable_del(HashTable *ht , char const   *arKey , uint nKeyLength ) 
{ ulong idx ;
  register char const   *tmp ;
  char const   *end ;
  int __attribute__((__visibility__("default")))  tmp___0 ;
  int __attribute__((__visibility__("default")))  tmp___1 ;

  {
  while (1) {
    while (1) {
      tmp = arKey;
      if ((int const   )*tmp == 45) {
        tmp ++;
      } else {

      }
      if ((int const   )*tmp >= 48) {
        if ((int const   )*tmp <= 57) {
          end = (arKey + nKeyLength) - 1;
          if ((int const   )*end != 0) {
            break;
          } else {
            if ((int const   )*tmp == 48) {
              if (nKeyLength > 2U) {
                break;
              } else {
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
              if (end - tmp > 10) {
                break;
              } else {
                if (end - tmp == 10) {
                  if ((int const   )*tmp > 50) {
                    break;
                  } else {

                  }
                } else {

                }
              }
            }
          }
          idx = (unsigned long )((int const   )*tmp - 48);
          while (1) {
            tmp ++;
            if ((unsigned int )tmp != (unsigned int )end) {
              if ((int const   )*tmp >= 48) {
                if ((int const   )*tmp <= 57) {

                } else {
                  break;
                }
              } else {
                break;
              }
            } else {
              break;
            }
            idx = idx * 10UL + (ulong )((int const   )*tmp - 48);
          }
          if ((unsigned int )tmp == (unsigned int )end) {
            if ((int const   )*arKey == 45) {
              if (idx - 1UL > 2147483647UL) {
                break;
              } else {

              }
              idx = (unsigned long )(- ((long )idx));
            } else {
              if (idx > 2147483647UL) {
                break;
              } else {

              }
            }
            tmp___0 = zend_hash_del_key_or_index(ht, (char const   *)((void *)0), 0U, idx, 1);
            return ((int )tmp___0);
          } else {

          }
        } else {

        }
      } else {

      }
      break;
    }
    break;
  }
  tmp___1 = zend_hash_del_key_or_index(ht, arKey, nKeyLength, 0UL, 0);
  return ((int )tmp___1);
}
}
__inline static int zend_symtable_find(HashTable *ht , char const   *arKey , uint nKeyLength , void **pData ) 
{ ulong idx ;
  register char const   *tmp ;
  char const   *end ;
  int __attribute__((__visibility__("default")))  tmp___0 ;
  int __attribute__((__visibility__("default")))  tmp___1 ;

  {
  while (1) {
    while (1) {
      tmp = arKey;
      if ((int const   )*tmp == 45) {
        tmp ++;
      } else {

      }
      if ((int const   )*tmp >= 48) {
        if ((int const   )*tmp <= 57) {
          end = (arKey + nKeyLength) - 1;
          if ((int const   )*end != 0) {
            break;
          } else {
            if ((int const   )*tmp == 48) {
              if (nKeyLength > 2U) {
                break;
              } else {
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
              if (end - tmp > 10) {
                break;
              } else {
                if (end - tmp == 10) {
                  if ((int const   )*tmp > 50) {
                    break;
                  } else {

                  }
                } else {

                }
              }
            }
          }
          idx = (unsigned long )((int const   )*tmp - 48);
          while (1) {
            tmp ++;
            if ((unsigned int )tmp != (unsigned int )end) {
              if ((int const   )*tmp >= 48) {
                if ((int const   )*tmp <= 57) {

                } else {
                  break;
                }
              } else {
                break;
              }
            } else {
              break;
            }
            idx = idx * 10UL + (ulong )((int const   )*tmp - 48);
          }
          if ((unsigned int )tmp == (unsigned int )end) {
            if ((int const   )*arKey == 45) {
              if (idx - 1UL > 2147483647UL) {
                break;
              } else {

              }
              idx = (unsigned long )(- ((long )idx));
            } else {
              if (idx > 2147483647UL) {
                break;
              } else {

              }
            }
            tmp___0 = zend_hash_index_find((HashTable const   *)ht, idx, pData);
            return ((int )tmp___0);
          } else {

          }
        } else {

        }
      } else {

      }
      break;
    }
    break;
  }
  tmp___1 = zend_hash_find((HashTable const   *)ht, arKey, nKeyLength, pData);
  return ((int )tmp___1);
}
}
__inline static int zend_symtable_exists(HashTable *ht , char const   *arKey , uint nKeyLength ) 
{ ulong idx ;
  register char const   *tmp ;
  char const   *end ;
  int __attribute__((__visibility__("default")))  tmp___0 ;
  int __attribute__((__visibility__("default")))  tmp___1 ;

  {
  while (1) {
    while (1) {
      tmp = arKey;
      if ((int const   )*tmp == 45) {
        tmp ++;
      } else {

      }
      if ((int const   )*tmp >= 48) {
        if ((int const   )*tmp <= 57) {
          end = (arKey + nKeyLength) - 1;
          if ((int const   )*end != 0) {
            break;
          } else {
            if ((int const   )*tmp == 48) {
              if (nKeyLength > 2U) {
                break;
              } else {
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
              if (end - tmp > 10) {
                break;
              } else {
                if (end - tmp == 10) {
                  if ((int const   )*tmp > 50) {
                    break;
                  } else {

                  }
                } else {

                }
              }
            }
          }
          idx = (unsigned long )((int const   )*tmp - 48);
          while (1) {
            tmp ++;
            if ((unsigned int )tmp != (unsigned int )end) {
              if ((int const   )*tmp >= 48) {
                if ((int const   )*tmp <= 57) {

                } else {
                  break;
                }
              } else {
                break;
              }
            } else {
              break;
            }
            idx = idx * 10UL + (ulong )((int const   )*tmp - 48);
          }
          if ((unsigned int )tmp == (unsigned int )end) {
            if ((int const   )*arKey == 45) {
              if (idx - 1UL > 2147483647UL) {
                break;
              } else {

              }
              idx = (unsigned long )(- ((long )idx));
            } else {
              if (idx > 2147483647UL) {
                break;
              } else {

              }
            }
            tmp___0 = zend_hash_index_exists((HashTable const   *)ht, idx);
            return ((int )tmp___0);
          } else {

          }
        } else {

        }
      } else {

      }
      break;
    }
    break;
  }
  tmp___1 = zend_hash_exists((HashTable const   *)ht, arKey, nKeyLength);
  return ((int )tmp___1);
}
}
__inline static int zend_symtable_update_current_key_ex(HashTable *ht , char const   *arKey , uint nKeyLength , int mode , HashPosition *pos ) 
{ ulong idx ;
  register char const   *tmp ;
  char const   *end ;
  int __attribute__((__visibility__("default")))  tmp___0 ;
  int __attribute__((__visibility__("default")))  tmp___1 ;

  {
  while (1) {
    while (1) {
      tmp = arKey;
      if ((int const   )*tmp == 45) {
        tmp ++;
      } else {

      }
      if ((int const   )*tmp >= 48) {
        if ((int const   )*tmp <= 57) {
          end = (arKey + nKeyLength) - 1;
          if ((int const   )*end != 0) {
            break;
          } else {
            if ((int const   )*tmp == 48) {
              if (nKeyLength > 2U) {
                break;
              } else {
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
              if (end - tmp > 10) {
                break;
              } else {
                if (end - tmp == 10) {
                  if ((int const   )*tmp > 50) {
                    break;
                  } else {

                  }
                } else {

                }
              }
            }
          }
          idx = (unsigned long )((int const   )*tmp - 48);
          while (1) {
            tmp ++;
            if ((unsigned int )tmp != (unsigned int )end) {
              if ((int const   )*tmp >= 48) {
                if ((int const   )*tmp <= 57) {

                } else {
                  break;
                }
              } else {
                break;
              }
            } else {
              break;
            }
            idx = idx * 10UL + (ulong )((int const   )*tmp - 48);
          }
          if ((unsigned int )tmp == (unsigned int )end) {
            if ((int const   )*arKey == 45) {
              if (idx - 1UL > 2147483647UL) {
                break;
              } else {

              }
              idx = (unsigned long )(- ((long )idx));
            } else {
              if (idx > 2147483647UL) {
                break;
              } else {

              }
            }
            tmp___0 = zend_hash_update_current_key_ex(ht, 2, (char const   *)((void *)0), 0U, idx, mode, pos);
            return ((int )tmp___0);
          } else {

          }
        } else {

        }
      } else {

      }
      break;
    }
    break;
  }
  tmp___1 = zend_hash_update_current_key_ex(ht, 1, arKey, nKeyLength, 0UL, mode, pos);
  return ((int )tmp___1);
}
}
extern int __attribute__((__visibility__("default")))  _zend_ts_hash_init(TsHashTable *ht , uint nSize , ulong (*pHashFunction)(char const   *arKey , uint nKeyLength ) , void (*pDestructor)(void *pDest ) , zend_bool persistent ) ;
extern int __attribute__((__visibility__("default")))  _zend_ts_hash_init_ex(TsHashTable *ht , uint nSize , ulong (*pHashFunction)(char const   *arKey , uint nKeyLength ) , void (*pDestructor)(void *pDest ) , zend_bool persistent , zend_bool bApplyProtection ) ;
extern void __attribute__((__visibility__("default")))  zend_ts_hash_destroy(TsHashTable *ht ) ;
extern void __attribute__((__visibility__("default")))  zend_ts_hash_clean(TsHashTable *ht ) ;
extern int __attribute__((__visibility__("default")))  _zend_ts_hash_add_or_update(TsHashTable *ht , char *arKey , uint nKeyLength , void *pData , uint nDataSize , void **pDest , int flag ) ;
extern int __attribute__((__visibility__("default")))  _zend_ts_hash_quick_add_or_update(TsHashTable *ht , char *arKey , uint nKeyLength , ulong h , void *pData , uint nDataSize , void **pDest , int flag ) ;
extern int __attribute__((__visibility__("default")))  _zend_ts_hash_index_update_or_next_insert(TsHashTable *ht , ulong h , void *pData , uint nDataSize , void **pDest , int flag ) ;
extern int __attribute__((__visibility__("default")))  zend_ts_hash_add_empty_element(TsHashTable *ht , char *arKey , uint nKeyLength ) ;
extern void __attribute__((__visibility__("default")))  zend_ts_hash_graceful_destroy(TsHashTable *ht ) ;
extern void __attribute__((__visibility__("default")))  zend_ts_hash_apply(TsHashTable *ht , int (*apply_func)(void *pDest ) ) ;
extern void __attribute__((__visibility__("default")))  zend_ts_hash_apply_with_argument(TsHashTable *ht , int (*apply_func)(void *pDest , void *argument ) , void * ) ;
extern void __attribute__((__visibility__("default")))  zend_ts_hash_apply_with_arguments(TsHashTable *ht , int (*apply_func)(void *pDest , int num_args , va_list args , zend_hash_key *hash_key ) , int   , ...) ;
extern void __attribute__((__visibility__("default")))  zend_ts_hash_reverse_apply(TsHashTable *ht , int (*apply_func)(void *pDest ) ) ;
extern int __attribute__((__visibility__("default")))  zend_ts_hash_del_key_or_index(TsHashTable *ht , char *arKey , uint nKeyLength , ulong h , int flag ) ;
extern ulong __attribute__((__visibility__("default")))  zend_ts_get_hash_value(TsHashTable *ht , char *arKey , uint nKeyLength ) ;
extern int __attribute__((__visibility__("default")))  zend_ts_hash_find(TsHashTable *ht , char *arKey , uint nKeyLength , void **pData ) ;
extern int __attribute__((__visibility__("default")))  zend_ts_hash_quick_find(TsHashTable *ht , char *arKey , uint nKeyLength , ulong h , void **pData ) ;
extern int __attribute__((__visibility__("default")))  zend_ts_hash_index_find(TsHashTable *ht , ulong h , void **pData ) ;
extern int __attribute__((__visibility__("default")))  zend_ts_hash_exists(TsHashTable *ht , char *arKey , uint nKeyLength ) ;
extern int __attribute__((__visibility__("default")))  zend_ts_hash_index_exists(TsHashTable *ht , ulong h ) ;
extern void __attribute__((__visibility__("default")))  zend_ts_hash_copy(TsHashTable *target , TsHashTable *source , void (*pCopyConstructor)(void *pElement ) , void *tmp , uint size ) ;
extern void __attribute__((__visibility__("default")))  zend_ts_hash_copy_to_hash(HashTable *target , TsHashTable *source , void (*pCopyConstructor)(void *pElement ) , void *tmp , uint size ) ;
extern void __attribute__((__visibility__("default")))  zend_ts_hash_merge(TsHashTable *target , TsHashTable *source , void (*pCopyConstructor)(void *pElement ) , void *tmp , uint size , int overwrite ) ;
extern void __attribute__((__visibility__("default")))  zend_ts_hash_merge_ex(TsHashTable *target , TsHashTable *source , void (*pCopyConstructor)(void *pElement ) , uint size , zend_bool (*pMergeSource)(HashTable *target_ht , void *source_data , zend_hash_key *hash_key , void *pParam ) , void *pParam ) ;
extern int __attribute__((__visibility__("default")))  zend_ts_hash_sort(TsHashTable *ht , void (*sort_func)(void * , size_t  , size_t  , int (*)(void const   * , void const   * ) ) , int (*compare_func)(void const   * , void const   * ) , int renumber ) ;
extern int __attribute__((__visibility__("default")))  zend_ts_hash_compare(TsHashTable *ht1 , TsHashTable *ht2 , int (*compar)(void const   * , void const   * ) , zend_bool ordered ) ;
extern int __attribute__((__visibility__("default")))  zend_ts_hash_minmax(TsHashTable *ht , int (*compar)(void const   * , void const   * ) , int flag , void **pData ) ;
extern int __attribute__((__visibility__("default")))  zend_ts_hash_num_elements(TsHashTable *ht ) ;
extern int __attribute__((__visibility__("default")))  zend_ts_hash_rehash(TsHashTable *ht ) ;
extern ulong __attribute__((__visibility__("default")))  zend_ts_hash_func(char *arKey , uint nKeyLength ) ;
extern void __attribute__((__visibility__("default")))  zend_llist_init(zend_llist *l , size_t size , void (*dtor)(void * ) , unsigned char persistent ) ;
extern void __attribute__((__visibility__("default")))  zend_llist_add_element(zend_llist *l , void *element ) ;
extern void __attribute__((__visibility__("default")))  zend_llist_prepend_element(zend_llist *l , void *element ) ;
extern void __attribute__((__visibility__("default")))  zend_llist_del_element(zend_llist *l , void *element , int (*compare)(void *element1 , void *element2 ) ) ;
extern void __attribute__((__visibility__("default")))  zend_llist_destroy(zend_llist *l ) ;
extern void __attribute__((__visibility__("default")))  zend_llist_clean(zend_llist *l ) ;
extern void __attribute__((__visibility__("default")))  *zend_llist_remove_tail(zend_llist *l ) ;
extern void __attribute__((__visibility__("default")))  zend_llist_copy(zend_llist *dst , zend_llist *src ) ;
extern void __attribute__((__visibility__("default")))  zend_llist_apply(zend_llist *l , void (*func)(void * ) ) ;
extern void __attribute__((__visibility__("default")))  zend_llist_apply_with_del(zend_llist *l , int (*func)(void *data ) ) ;
extern void __attribute__((__visibility__("default")))  zend_llist_apply_with_argument(zend_llist *l , void (*func)(void *data , void *arg ) , void *arg ) ;
extern void __attribute__((__visibility__("default")))  zend_llist_apply_with_arguments(zend_llist *l , void (*func)(void *data , int num_args , va_list args ) , int num_args  , ...) ;
extern int __attribute__((__visibility__("default")))  zend_llist_count(zend_llist *l ) ;
extern void __attribute__((__visibility__("default")))  zend_llist_sort(zend_llist *l , int (*comp_func)(zend_llist_element const   ** , zend_llist_element const   ** ) ) ;
extern void __attribute__((__visibility__("default")))  *zend_llist_get_first_ex(zend_llist *l , zend_llist_position *pos ) ;
extern void __attribute__((__visibility__("default")))  *zend_llist_get_last_ex(zend_llist *l , zend_llist_position *pos ) ;
extern void __attribute__((__visibility__("default")))  *zend_llist_get_next_ex(zend_llist *l , zend_llist_position *pos ) ;
extern void __attribute__((__visibility__("default")))  *zend_llist_get_prev_ex(zend_llist *l , zend_llist_position *pos ) ;
extern  __attribute__((__noreturn__)) void zend_error_noreturn(int type , char const   *format  , ...) ;
extern zend_object_handlers __attribute__((__visibility__("default")))  std_object_handlers ;
extern union _zend_function  __attribute__((__visibility__("default"))) *zend_std_get_static_method(zend_class_entry *ce , char const   *function_name_strval , int function_name_strlen , struct _zend_literal  const  *key ) ;
extern zval __attribute__((__visibility__("default")))  **zend_std_get_static_property(zend_class_entry *ce , char const   *property_name , int property_name_len , zend_bool silent , struct _zend_literal  const  *key ) ;
extern zend_bool __attribute__((__visibility__("default")))  zend_std_unset_static_property(zend_class_entry *ce , char const   *property_name , int property_name_len , struct _zend_literal  const  *key ) ;
extern union _zend_function  __attribute__((__visibility__("default"))) *zend_std_get_constructor(zval *object ) ;
extern struct _zend_property_info  __attribute__((__visibility__("default"))) *zend_get_property_info(zend_class_entry *ce , zval *member , int silent ) ;
extern HashTable __attribute__((__visibility__("default")))  *zend_std_get_properties(zval *object ) ;
extern HashTable __attribute__((__visibility__("default")))  *zend_std_get_debug_info(zval *object , int *is_temp ) ;
extern int __attribute__((__visibility__("default")))  zend_std_cast_object_tostring(zval *readobj , zval *writeobj , int type ) ;
extern void __attribute__((__visibility__("default")))  zend_std_write_property(zval *object , zval *member , zval *value , struct _zend_literal  const  *key ) ;
extern void __attribute__((__visibility__("default")))  rebuild_object_properties(zend_object *zobj ) ;
extern int __attribute__((__visibility__("default")))  zend_check_private(union _zend_function *fbc , zend_class_entry *ce , char *function_name_strval , int function_name_strlen ) ;
extern int __attribute__((__visibility__("default")))  zend_check_protected(zend_class_entry *ce , zend_class_entry *scope ) ;
extern int __attribute__((__visibility__("default")))  zend_check_property_access(zend_object *zobj , char const   *prop_info_name , int prop_info_name_len ) ;
extern void __attribute__((__visibility__("default")))  zend_std_call_user_call(int ht , zval *return_value , zval **return_value_ptr , zval *this_ptr , int return_value_used ) ;
__inline static zend_uint ( __attribute__((__always_inline__)) zval_refcount_p)(zval *pz ) 
{ 

  {
  return (pz->refcount__gc);
}
}
__inline static zend_uint ( __attribute__((__always_inline__)) zval_set_refcount_p)(zval *pz , zend_uint rc ) 
{ zend_uint tmp ;

  {
  tmp = rc;
  pz->refcount__gc = tmp;
  return (tmp);
}
}
__inline static zend_uint ( __attribute__((__always_inline__)) zval_addref_p)(zval *pz ) 
{ 

  {
  (pz->refcount__gc) ++;
  return (pz->refcount__gc);
}
}
__inline static zend_uint ( __attribute__((__always_inline__)) zval_delref_p)(zval *pz ) 
{ 

  {
  (pz->refcount__gc) --;
  return (pz->refcount__gc);
}
}
__inline static zend_bool ( __attribute__((__always_inline__)) zval_isref_p)(zval *pz ) 
{ 

  {
  return (pz->is_ref__gc);
}
}
__inline static zend_bool ( __attribute__((__always_inline__)) zval_set_isref_p)(zval *pz ) 
{ zend_uchar tmp ;

  {
  tmp = (unsigned char)1;
  pz->is_ref__gc = tmp;
  return (tmp);
}
}
__inline static zend_bool ( __attribute__((__always_inline__)) zval_unset_isref_p)(zval *pz ) 
{ zend_uchar tmp ;

  {
  tmp = (unsigned char)0;
  pz->is_ref__gc = tmp;
  return (tmp);
}
}
__inline static zend_bool ( __attribute__((__always_inline__)) zval_set_isref_to_p)(zval *pz , zend_bool isref ) 
{ zend_uchar tmp ;

  {
  tmp = isref;
  pz->is_ref__gc = tmp;
  return (tmp);
}
}
extern enum zend_object_iterator_kind  __attribute__((__visibility__("default"))) zend_iterator_unwrap(zval *array_ptr , zend_object_iterator **iter ) ;
extern zval __attribute__((__visibility__("default")))  *zend_iterator_wrap(zend_object_iterator *iter ) ;
extern void __attribute__((__visibility__("default")))  zend_register_iterator_wrapper(void) ;
extern int __attribute__((__visibility__("default")))  zend_stream_open(char const   *filename , zend_file_handle *handle ) ;
extern int __attribute__((__visibility__("default")))  zend_stream_fixup(zend_file_handle *file_handle , char **buf , size_t *len ) ;
extern void __attribute__((__visibility__("default")))  zend_file_handle_dtor(zend_file_handle *fh ) ;
extern int __attribute__((__visibility__("default")))  zend_compare_file_handles(zend_file_handle *fh1 , zend_file_handle *fh2 ) ;
extern int zend_startup(zend_utility_functions *utility_functions , char **extensions ) ;
extern void zend_shutdown(void) ;
extern void zend_register_standard_ini_entries(void) ;
extern void zend_post_startup(void) ;
extern void zend_set_utility_values(zend_utility_values *utility_values ) ;
extern void __attribute__((__visibility__("default")))  _zend_bailout(char *filename , uint lineno ) ;
extern char __attribute__((__visibility__("default")))  *get_zend_version(void) ;
extern void __attribute__((__visibility__("default")))  zend_make_printable_zval(zval *expr , zval *expr_copy , int *use_copy ) ;
extern int __attribute__((__visibility__("default")))  zend_print_zval(zval *expr , int indent ) ;
extern int __attribute__((__visibility__("default")))  zend_print_zval_ex(int (*write_func)(char const   *str , uint str_length ) , zval *expr , int indent ) ;
extern void __attribute__((__visibility__("default")))  zend_print_zval_r(zval *expr , int indent ) ;
extern void __attribute__((__visibility__("default")))  zend_print_flat_zval_r(zval *expr ) ;
extern void __attribute__((__visibility__("default")))  zend_print_zval_r_ex(int (*write_func)(char const   *str , uint str_length ) , zval *expr , int indent ) ;
extern void __attribute__((__visibility__("default")))  ( /* format attribute */  zend_output_debug_string)(zend_bool trigger_break , char const   *format  , ...) ;
extern void zend_activate(void) ;
extern void zend_deactivate(void) ;
extern void zend_call_destructors(void) ;
extern void zend_activate_modules(void) ;
extern void zend_deactivate_modules(void) ;
extern void zend_post_deactivate_modules(void) ;
extern void __attribute__((__visibility__("default")))  free_estring(char **str_p ) ;
extern int __attribute__((__visibility__("default")))  ( /* format attribute */  (*zend_printf))(char const   *format  , ...) ;
extern int (* __attribute__((__visibility__("default"))) zend_write)(char const   *str , uint str_length ) ;
extern FILE __attribute__((__visibility__("default")))  *(*zend_fopen)(char const   *filename , char **opened_path ) ;
extern void __attribute__((__visibility__("default")))  (*zend_ticks_function)(int ticks ) ;
extern void __attribute__((__visibility__("default")))  ( /* format attribute */  (*zend_error_cb))(int type , char const   *error_filename , uint error_lineno , char const   *format , va_list args ) ;
extern void __attribute__((__visibility__("default")))  (*zend_on_timeout)(int seconds ) ;
extern int __attribute__((__visibility__("default")))  (*zend_stream_open_function)(char const   *filename , zend_file_handle *handle ) ;
extern int (*zend_vspprintf)(char **pbuf , size_t max_len , char const   *format , va_list ap ) ;
extern char __attribute__((__visibility__("default")))  *(*zend_getenv)(char *name , size_t name_len ) ;
extern char __attribute__((__visibility__("default")))  *(*zend_resolve_path)(char const   *filename , int filename_len ) ;
extern void __attribute__((__visibility__("default")))  ( /* format attribute */  zend_error)(int type , char const   *format  , ...) ;
extern void zenderror(char const   *error ) ;
extern zend_class_entry __attribute__((__visibility__("default")))  *zend_standard_class_def ;
extern zend_utility_values __attribute__((__visibility__("default")))  zend_uv ;
extern zval __attribute__((__visibility__("default")))  zval_used_for_init ;
extern zend_signal_globals_t __attribute__((__visibility__("default")))  zend_signal_globals ;
extern void zend_signal_handler_defer(int signo , siginfo_t *siginfo , void *context ) ;
extern void __attribute__((__visibility__("default")))  zend_signal_handler_unblock() ;
extern void zend_signal_activate(void) ;
extern void zend_signal_deactivate(void) ;
extern void zend_signal_startup() ;
extern void zend_signal_shutdown(void) ;
extern int __attribute__((__visibility__("default")))  zend_signal(int signo , void (*handler)(int  ) ) ;
extern int __attribute__((__visibility__("default")))  zend_sigaction(int signo , struct sigaction  const  *act , struct sigaction *oldact ) ;
extern void __attribute__((__visibility__("default")))  zend_message_dispatcher(long message , void const   *data ) ;
extern int __attribute__((__visibility__("default")))  zend_get_configuration_directive(char const   *name , uint name_length , zval *contents ) ;
extern zend_gc_globals __attribute__((__visibility__("default")))  gc_globals ;
extern int __attribute__((__visibility__("default")))  gc_collect_cycles(void) ;
extern void __attribute__((__visibility__("default")))  gc_zval_possible_root(zval *zv ) ;
extern void __attribute__((__visibility__("default")))  gc_zobj_possible_root(zval *zv ) ;
extern void __attribute__((__visibility__("default")))  gc_remove_zval_from_buffer(zval *zv ) ;
extern void __attribute__((__visibility__("default")))  gc_globals_ctor(void) ;
extern void __attribute__((__visibility__("default")))  gc_globals_dtor(void) ;
extern void __attribute__((__visibility__("default")))  gc_init(void) ;
extern void __attribute__((__visibility__("default")))  gc_reset(void) ;
__inline static void ( __attribute__((__always_inline__)) gc_zval_check_possible_root)(zval *z ) 
{ 

  {
  if ((int )z->type == 4) {
    gc_zval_possible_root(z);
  } else {
    if ((int )z->type == 5) {
      gc_zval_possible_root(z);
    } else {

    }
  }
  return;
}
}
__inline static void ( __attribute__((__always_inline__)) gc_remove_from_buffer)(gc_root_buffer *root ) 
{ 

  {
  (root->next)->prev = root->prev;
  (root->prev)->next = root->next;
  root->prev = gc_globals.unused;
  gc_globals.unused = root;
  return;
}
}
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion , char const   *__file , unsigned int __line , char const   *__function ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_perror_fail(int __errnum , char const   *__file , unsigned int __line , char const   *__function ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void __assert(char const   *__assertion , char const   *__file , int __line ) ;
extern void __attribute__((__visibility__("default")))  zend_freedtoa(char *s ) ;
extern char __attribute__((__visibility__("default")))  *zend_dtoa(double _d , int mode , int ndigits , int *decpt , int *sign , char **rve ) ;
extern double __attribute__((__visibility__("default")))  zend_strtod(char const   *s00 , char const   **se ) ;
extern double __attribute__((__visibility__("default")))  zend_hex_strtod(char const   *str , char const   **endptr ) ;
extern double __attribute__((__visibility__("default")))  zend_oct_strtod(char const   *str , char const   **endptr ) ;
extern double __attribute__((__visibility__("default")))  zend_bin_strtod(char const   *str , char const   **endptr ) ;
extern int __attribute__((__visibility__("default")))  zend_startup_strtod(void) ;
extern int __attribute__((__visibility__("default")))  zend_shutdown_strtod(void) ;
extern int __attribute__((__visibility__("default")))  add_function(zval *result , zval *op1 , zval *op2 ) ;
extern int __attribute__((__visibility__("default")))  sub_function(zval *result , zval *op1 , zval *op2 ) ;
extern int __attribute__((__visibility__("default")))  mul_function(zval *result , zval *op1 , zval *op2 ) ;
extern int __attribute__((__visibility__("default")))  div_function(zval *result , zval *op1 , zval *op2 ) ;
extern int __attribute__((__visibility__("default")))  mod_function(zval *result , zval *op1 , zval *op2 ) ;
extern int __attribute__((__visibility__("default")))  boolean_xor_function(zval *result , zval *op1 , zval *op2 ) ;
extern int __attribute__((__visibility__("default")))  boolean_not_function(zval *result , zval *op1 ) ;
extern int __attribute__((__visibility__("default")))  bitwise_not_function(zval *result , zval *op1 ) ;
extern int __attribute__((__visibility__("default")))  bitwise_or_function(zval *result , zval *op1 , zval *op2 ) ;
extern int __attribute__((__visibility__("default")))  bitwise_and_function(zval *result , zval *op1 , zval *op2 ) ;
extern int __attribute__((__visibility__("default")))  bitwise_xor_function(zval *result , zval *op1 , zval *op2 ) ;
extern int __attribute__((__visibility__("default")))  shift_left_function(zval *result , zval *op1 , zval *op2 ) ;
extern int __attribute__((__visibility__("default")))  shift_right_function(zval *result , zval *op1 , zval *op2 ) ;
extern int __attribute__((__visibility__("default")))  concat_function(zval *result , zval *op1 , zval *op2 ) ;
extern int __attribute__((__visibility__("default")))  is_equal_function(zval *result , zval *op1 , zval *op2 ) ;
extern int __attribute__((__visibility__("default")))  is_identical_function(zval *result , zval *op1 , zval *op2 ) ;
extern int __attribute__((__visibility__("default")))  is_not_identical_function(zval *result , zval *op1 , zval *op2 ) ;
extern int __attribute__((__visibility__("default")))  is_not_equal_function(zval *result , zval *op1 , zval *op2 ) ;
extern int __attribute__((__visibility__("default")))  is_smaller_function(zval *result , zval *op1 , zval *op2 ) ;
extern int __attribute__((__visibility__("default")))  is_smaller_or_equal_function(zval *result , zval *op1 , zval *op2 ) ;
extern zend_bool __attribute__((__visibility__("default")))  instanceof_function_ex(zend_class_entry const   *instance_ce , zend_class_entry const   *ce , zend_bool interfaces_only ) ;
extern zend_bool __attribute__((__visibility__("default")))  instanceof_function(zend_class_entry const   *instance_ce , zend_class_entry const   *ce ) ;
__inline static long ( __attribute__((__always_inline__)) zend_dval_to_lval)(double d ) 
{ 

  {
  if (d > (double )2147483647L) {
    return ((long )((unsigned long )((long long )d)));
  } else {
    if (d < (double )(-0x7FFFFFFF-1)) {
      return ((long )((unsigned long )((long long )d)));
    } else {

    }
  }
  return ((long )d);
}
}
__inline static zend_uchar is_numeric_string(char const   *str , int length , long *lval , double *dval , int allow_errors ) 
{ char const   *ptr ;
  int base ;
  int digits ;
  int dp_or_e ;
  double local_dval ;
  zend_uchar type ;
  char const   *e ;
  char const   *tmp ;
  double __attribute__((__visibility__("default")))  tmp___0 ;
  double __attribute__((__visibility__("default")))  tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int cmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned char const   *__s2 ;
  register int __result ;
  int tmp___7 ;
  unsigned char const   *__s1 ;
  register int __result___0 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  double __attribute__((__visibility__("default")))  tmp___11 ;

  {
  base = 10;
  digits = 0;
  dp_or_e = 0;
  if (! length) {
    return ((unsigned char)0);
  } else {

  }
  while (1) {
    if ((int const   )*str == 32) {

    } else {
      if ((int const   )*str == 9) {

      } else {
        if ((int const   )*str == 10) {

        } else {
          if ((int const   )*str == 13) {

          } else {
            if ((int const   )*str == 11) {

            } else {
              if ((int const   )*str == 12) {

              } else {
                break;
              }
            }
          }
        }
      }
    }
    str ++;
    length --;
  }
  ptr = str;
  if ((int const   )*ptr == 45) {
    ptr ++;
  } else {
    if ((int const   )*ptr == 43) {
      ptr ++;
    } else {

    }
  }
  if ((int const   )*ptr >= 48) {
    if ((int const   )*ptr <= 57) {
      if (length > 2) {
        if ((int const   )*str == 48) {
          if ((int const   )*(str + 1) == 120) {
            base = 16;
            ptr += 2;
          } else {
            if ((int const   )*(str + 1) == 88) {
              base = 16;
              ptr += 2;
            } else {

            }
          }
        } else {

        }
      } else {

      }
      while ((int const   )*ptr == 48) {
        ptr ++;
      }
      type = (unsigned char)1;
      while (1) {
        if (digits >= 11) {
          if (dval) {
            break;
          } else {
            if (allow_errors == 1) {
              break;
            } else {

            }
          }
        } else {

        }
        check_digits: 
        if ((int const   )*ptr >= 48) {
          if ((int const   )*ptr <= 57) {
            goto __Cont;
          } else {
            goto _L___3;
          }
        } else {
          _L___3: /* CIL Label */ 
          if (base == 16) {
            if ((int const   )*ptr >= 65) {
              if ((int const   )*ptr <= 70) {
                goto __Cont;
              } else {
                goto _L___2;
              }
            } else {
              _L___2: /* CIL Label */ 
              if ((int const   )*ptr >= 97) {
                if ((int const   )*ptr <= 102) {
                  goto __Cont;
                } else {
                  goto _L___1;
                }
              } else {
                goto _L___1;
              }
            }
          } else {
            _L___1: /* CIL Label */ 
            if (base == 10) {
              if ((int const   )*ptr == 46) {
                if (dp_or_e < 1) {
                  goto process_double;
                } else {
                  goto _L___0;
                }
              } else {
                _L___0: /* CIL Label */ 
                if ((int const   )*ptr == 101) {
                  goto _L;
                } else {
                  if ((int const   )*ptr == 69) {
                    _L: /* CIL Label */ 
                    if (dp_or_e < 2) {
                      e = ptr + 1;
                      if ((int const   )*e == 45) {
                        tmp = e;
                        e ++;
                        ptr = tmp;
                      } else {
                        if ((int const   )*e == 43) {
                          tmp = e;
                          e ++;
                          ptr = tmp;
                        } else {

                        }
                      }
                      if ((int const   )*e >= 48) {
                        if ((int const   )*e <= 57) {
                          goto process_double;
                        } else {

                        }
                      } else {

                      }
                    } else {

                    }
                  } else {

                  }
                }
              }
            } else {

            }
          }
        }
        break;
        __Cont: /* CIL Label */ 
        digits ++;
        ptr ++;
      }
      if (base == 10) {
        if (digits >= 11) {
          dp_or_e = -1;
          goto process_double;
        } else {

        }
      } else {
        if (digits < 8) {

        } else {
          if (digits == 8) {
            if ((int const   )*(ptr + - digits) <= 55) {

            } else {
              goto _L___4;
            }
          } else {
            _L___4: /* CIL Label */ 
            if (dval) {
              tmp___0 = zend_hex_strtod(str, & ptr);
              local_dval = (double )tmp___0;
            } else {

            }
            type = (unsigned char)2;
          }
        }
      }
    } else {
      goto _L___5;
    }
  } else {
    _L___5: /* CIL Label */ 
    if ((int const   )*ptr == 46) {
      if ((int const   )*(ptr + 1) >= 48) {
        if ((int const   )*(ptr + 1) <= 57) {
          process_double: 
          type = (unsigned char)2;
          if (dval) {
            tmp___1 = zend_strtod(str, & ptr);
            local_dval = (double )tmp___1;
          } else {
            if (allow_errors != 1) {
              if (dp_or_e != -1) {
                tmp___3 = ptr;
                ptr ++;
                if ((int const   )*tmp___3 == 46) {
                  dp_or_e = 1;
                } else {
                  dp_or_e = 2;
                }
                goto check_digits;
              } else {

              }
            } else {

            }
          }
        } else {
          return ((unsigned char)0);
        }
      } else {
        return ((unsigned char)0);
      }
    } else {
      return ((unsigned char)0);
    }
  }
  if ((unsigned int )ptr != (unsigned int )(str + length)) {
    if (! allow_errors) {
      return ((unsigned char)0);
    } else {

    }
    if (allow_errors == -1) {
      zend_error(1 << 3L, "A non well formed numeric value encountered");
    } else {

    }
  } else {

  }
  if ((int )type == 1) {
    if (digits == 10) {
      if (0) {
        __s1_len = strlen(ptr + - digits);
        __s2_len = strlen(long_min_digits);
        if (! ((unsigned int )((void const   *)((ptr + - digits) + 1)) - (unsigned int )((void const   *)(ptr + - digits)) == 1U)) {
          goto _L___7;
        } else {
          if (__s1_len >= 4U) {
            _L___7: /* CIL Label */ 
            if (! ((unsigned int )((void const   *)(long_min_digits + 1)) - (unsigned int )((void const   *)(long_min_digits)) == 1U)) {
              tmp___10 = 1;
            } else {
              if (__s2_len >= 4U) {
                tmp___10 = 1;
              } else {
                tmp___10 = 0;
              }
            }
          } else {
            tmp___10 = 0;
          }
        }
        if (tmp___10) {
          tmp___5 = __builtin_strcmp(ptr + - digits, long_min_digits);
          tmp___9 = tmp___5;
        } else {
          tmp___8 = __builtin_strcmp(ptr + - digits, long_min_digits);
          tmp___9 = tmp___8;
        }
      } else {
        tmp___8 = __builtin_strcmp(ptr + - digits, long_min_digits);
        tmp___9 = tmp___8;
      }
      cmp = tmp___9;
      if (cmp < 0) {

      } else {
        if (cmp == 0) {
          if ((int const   )*str == 45) {

          } else {
            goto _L___8;
          }
        } else {
          _L___8: /* CIL Label */ 
          if (dval) {
            tmp___11 = zend_strtod(str, (char const   **)((void *)0));
            *dval = (double )tmp___11;
          } else {

          }
          return ((unsigned char)2);
        }
      }
    } else {

    }
    if (lval) {
      *lval = strtol((char const   */* __restrict  */)str, (char **/* __restrict  */)((void *)0), base);
    } else {

    }
    return ((unsigned char)1);
  } else {
    if (dval) {
      *dval = local_dval;
    } else {

    }
    return ((unsigned char)2);
  }
}
}
__inline static char *zend_memnstr(char *haystack , char *needle , int needle_len , char *end ) 
{ char *p ;
  char ne ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  p = haystack;
  ne = *(needle + (needle_len - 1));
  if (needle_len == 1) {
    tmp = memchr((void const   *)p, (int )*needle, (unsigned int )(end - p));
    return ((char *)tmp);
  } else {

  }
  if (needle_len > end - haystack) {
    return ((char *)((void *)0));
  } else {

  }
  end -= needle_len;
  while ((unsigned int )p <= (unsigned int )end) {
    tmp___1 = memchr((void const   *)p, (int )*needle, (unsigned int )((end - p) + 1));
    p = (char *)tmp___1;
    if (p) {
      if ((int )ne == (int )*(p + (needle_len - 1))) {
        tmp___0 = memcmp((void const   *)needle, (void const   *)p, (unsigned int )(needle_len - 1));
        if (tmp___0) {

        } else {
          return (p);
        }
      } else {

      }
    } else {

    }
    if ((unsigned int )p == (unsigned int )((void *)0)) {
      return ((char *)((void *)0));
    } else {

    }
    p ++;
  }
  return ((char *)((void *)0));
}
}
__inline static void const   *zend_memrchr(void const   *s , int c , size_t n ) 
{ register unsigned char const   *e ;

  {
  if (n <= 0U) {
    return ((void const   *)((void *)0));
  } else {

  }
  e = ((unsigned char const   *)s + n) - 1;
  while ((unsigned int )e >= (unsigned int )((unsigned char const   *)s)) {
    if ((int const   )*e == (int const   )((unsigned char const   )c)) {
      return ((void const   *)e);
    } else {

    }
    e --;
  }
  return ((void const   *)((void *)0));
}
}
extern int __attribute__((__visibility__("default")))  increment_function(zval *op1 ) ;
extern int __attribute__((__visibility__("default")))  decrement_function(zval *op2 ) ;
extern void __attribute__((__visibility__("default")))  convert_scalar_to_number(zval *op ) ;
extern void __attribute__((__visibility__("default")))  _convert_to_string(zval *op ) ;
extern void __attribute__((__visibility__("default")))  convert_to_long(zval *op ) ;
extern void __attribute__((__visibility__("default")))  convert_to_double(zval *op ) ;
extern void __attribute__((__visibility__("default")))  convert_to_long_base(zval *op , int base ) ;
extern void __attribute__((__visibility__("default")))  convert_to_null(zval *op ) ;
extern void __attribute__((__visibility__("default")))  convert_to_boolean(zval *op ) ;
extern void __attribute__((__visibility__("default")))  convert_to_array(zval *op ) ;
extern void __attribute__((__visibility__("default")))  convert_to_object(zval *op ) ;
extern void __attribute__((__visibility__("default")))  multi_convert_to_long_ex(int argc  , ...) ;
extern void __attribute__((__visibility__("default")))  multi_convert_to_double_ex(int argc  , ...) ;
extern void __attribute__((__visibility__("default")))  multi_convert_to_string_ex(int argc  , ...) ;
extern int __attribute__((__visibility__("default")))  add_char_to_string(zval *result , zval const   *op1 , zval const   *op2 ) ;
extern int __attribute__((__visibility__("default")))  add_string_to_string(zval *result , zval const   *op1 , zval const   *op2 ) ;
extern double __attribute__((__visibility__("default")))  zend_string_to_double(char const   *number , zend_uint length ) ;
extern int __attribute__((__visibility__("default")))  zval_is_true(zval *op ) ;
extern int __attribute__((__visibility__("default")))  compare_function(zval *result , zval *op1 , zval *op2 ) ;
extern int __attribute__((__visibility__("default")))  numeric_compare_function(zval *result , zval *op1 , zval *op2 ) ;
extern int __attribute__((__visibility__("default")))  string_compare_function_ex(zval *result , zval *op1 , zval *op2 , zend_bool case_insensitive ) ;
extern int __attribute__((__visibility__("default")))  string_compare_function(zval *result , zval *op1 , zval *op2 ) ;
extern int __attribute__((__visibility__("default")))  string_case_compare_function(zval *result , zval *op1 , zval *op2 ) ;
extern int __attribute__((__visibility__("default")))  string_locale_compare_function(zval *result , zval *op1 , zval *op2 ) ;
extern void __attribute__((__visibility__("default")))  zend_str_tolower(char *str , unsigned int length ) ;
extern char __attribute__((__visibility__("default")))  *zend_str_tolower_copy(char *dest , char const   *source , unsigned int length ) ;
extern char __attribute__((__visibility__("default")))  *zend_str_tolower_dup(char const   *source , unsigned int length ) ;
extern int __attribute__((__visibility__("default")))  zend_binary_zval_strcmp(zval *s1 , zval *s2 ) ;
extern int __attribute__((__visibility__("default")))  zend_binary_zval_strncmp(zval *s1 , zval *s2 , zval *s3 ) ;
extern int __attribute__((__visibility__("default")))  zend_binary_zval_strcasecmp(zval *s1 , zval *s2 ) ;
extern int __attribute__((__visibility__("default")))  zend_binary_zval_strncasecmp(zval *s1 , zval *s2 , zval *s3 ) ;
extern int __attribute__((__visibility__("default")))  zend_binary_strcmp(char const   *s1 , uint len1 , char const   *s2 , uint len2 ) ;
extern int __attribute__((__visibility__("default")))  zend_binary_strncmp(char const   *s1 , uint len1 , char const   *s2 , uint len2 , uint length ) ;
extern int __attribute__((__visibility__("default")))  zend_binary_strcasecmp(char const   *s1 , uint len1 , char const   *s2 , uint len2 ) ;
extern int __attribute__((__visibility__("default")))  zend_binary_strncasecmp(char const   *s1 , uint len1 , char const   *s2 , uint len2 , uint length ) ;
extern void __attribute__((__visibility__("default")))  zendi_smart_strcmp(zval *result , zval *s1 , zval *s2 ) ;
extern void __attribute__((__visibility__("default")))  zend_compare_symbol_tables(zval *result , HashTable *ht1 , HashTable *ht2 ) ;
extern void __attribute__((__visibility__("default")))  zend_compare_arrays(zval *result , zval *a1 , zval *a2 ) ;
extern void __attribute__((__visibility__("default")))  zend_compare_objects(zval *result , zval *o1 , zval *o2 ) ;
extern int __attribute__((__visibility__("default")))  zend_atoi(char const   *str , int str_len ) ;
extern long __attribute__((__visibility__("default")))  zend_atol(char const   *str , int str_len ) ;
extern void __attribute__((__visibility__("default")))  zend_locale_sprintf_double(zval *op ) ;
__inline static int ( __attribute__((__always_inline__)) fast_increment_function)(zval *op1 ) 
{ long tmp ;
  int __attribute__((__visibility__("default")))  tmp___0 ;

  {
  tmp = __builtin_expect((long )((int )op1->type == 1), 1L);
  if (tmp) {
    __asm__  ("incl (%0)\n\t"
              "jno  0f\n\t"
              "movl $0x0, (%0)\n\t"
              "movl $0x41e00000, 0x4(%0)\n\t"
              "movb $0x2,0xc(%0)\n"
              "0:": : "r" (op1));
    return (0);
  } else {

  }
  tmp___0 = increment_function(op1);
  return ((int )tmp___0);
}
}
__inline static int ( __attribute__((__always_inline__)) fast_decrement_function)(zval *op1 ) 
{ long tmp ;
  int __attribute__((__visibility__("default")))  tmp___0 ;

  {
  tmp = __builtin_expect((long )((int )op1->type == 1), 1L);
  if (tmp) {
    __asm__  ("decl (%0)\n\t"
              "jno  0f\n\t"
              "movl $0x00200000, (%0)\n\t"
              "movl $0xc1e00000, 0x4(%0)\n\t"
              "movb $0x2,0xc(%0)\n"
              "0:": : "r" (op1));
    return (0);
  } else {

  }
  tmp___0 = decrement_function(op1);
  return ((int )tmp___0);
}
}
__inline static int ( __attribute__((__always_inline__)) fast_add_function)(zval *result , zval *op1 , zval *op2 ) 
{ long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  int __attribute__((__visibility__("default")))  tmp___5 ;

  {
  tmp___4 = __builtin_expect((long )((int )op1->type == 1), 1L);
  if (tmp___4) {
    tmp___0 = __builtin_expect((long )((int )op2->type == 1), 1L);
    if (tmp___0) {
      __asm__  ("movl\t(%1), %%eax\n\t"
                "addl   (%2), %%eax\n\t"
                "jo     0f\n\t"
                "movl   %%eax, (%0)\n\t"
                "movb   $0x1,0xc(%0)\n\t"
                "jmp    1f\n"
                "0:\n\t"
                "fildl\t(%1)\n\t"
                "fildl\t(%2)\n\t"
                "faddp\t%%st, %%st(1)\n\t"
                "movb   $0x2,0xc(%0)\n\t"
                "fstpl\t(%0)\n"
                "1:": : "r" (result), "r" (op1), "r" (op2): "eax");
      return (0);
    } else {
      tmp = __builtin_expect((long )((int )op2->type == 2), 1L);
      if (tmp) {
        result->value.dval = (double )op1->value.lval + op2->value.dval;
        result->type = (unsigned char)2;
        return (0);
      } else {

      }
    }
  } else {
    tmp___3 = __builtin_expect((long )((int )op1->type == 2), 1L);
    if (tmp___3) {
      tmp___2 = __builtin_expect((long )((int )op2->type == 2), 1L);
      if (tmp___2) {
        result->value.dval = op1->value.dval + op2->value.dval;
        result->type = (unsigned char)2;
        return (0);
      } else {
        tmp___1 = __builtin_expect((long )((int )op2->type == 1), 1L);
        if (tmp___1) {
          result->value.dval = op1->value.dval + (double )op2->value.lval;
          result->type = (unsigned char)2;
          return (0);
        } else {

        }
      }
    } else {

    }
  }
  tmp___5 = add_function(result, op1, op2);
  return ((int )tmp___5);
}
}
__inline static int ( __attribute__((__always_inline__)) fast_sub_function)(zval *result , zval *op1 , zval *op2 ) 
{ long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  int __attribute__((__visibility__("default")))  tmp___5 ;

  {
  tmp___4 = __builtin_expect((long )((int )op1->type == 1), 1L);
  if (tmp___4) {
    tmp___0 = __builtin_expect((long )((int )op2->type == 1), 1L);
    if (tmp___0) {
      __asm__  ("movl\t(%1), %%eax\n\t"
                "subl   (%2), %%eax\n\t"
                "jo     0f\n\t"
                "movl   %%eax, (%0)\n\t"
                "movb   $0x1,0xc(%0)\n\t"
                "jmp    1f\n"
                "0:\n\t"
                "fildl\t(%2)\n\t"
                "fildl\t(%1)\n\t"
                "fsubp\t%%st, %%st(1)\n\t"
                "movb   $0x2,0xc(%0)\n\t"
                "fstpl\t(%0)\n"
                "1:": : "r" (result), "r" (op1), "r" (op2): "eax");
      return (0);
    } else {
      tmp = __builtin_expect((long )((int )op2->type == 2), 1L);
      if (tmp) {
        result->value.dval = (double )op1->value.lval - op2->value.dval;
        result->type = (unsigned char)2;
        return (0);
      } else {

      }
    }
  } else {
    tmp___3 = __builtin_expect((long )((int )op1->type == 2), 1L);
    if (tmp___3) {
      tmp___2 = __builtin_expect((long )((int )op2->type == 2), 1L);
      if (tmp___2) {
        result->value.dval = op1->value.dval - op2->value.dval;
        result->type = (unsigned char)2;
        return (0);
      } else {
        tmp___1 = __builtin_expect((long )((int )op2->type == 1), 1L);
        if (tmp___1) {
          result->value.dval = op1->value.dval - (double )op2->value.lval;
          result->type = (unsigned char)2;
          return (0);
        } else {

        }
      }
    } else {

    }
  }
  tmp___5 = sub_function(result, op1, op2);
  return ((int )tmp___5);
}
}
__inline static int ( __attribute__((__always_inline__)) fast_mul_function)(zval *result , zval *op1 , zval *op2 ) 
{ long overflow ;
  long __tmpvar ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  int __attribute__((__visibility__("default")))  tmp___5 ;

  {
  tmp___4 = __builtin_expect((long )((int )op1->type == 1), 1L);
  if (tmp___4) {
    tmp___0 = __builtin_expect((long )((int )op2->type == 1), 1L);
    if (tmp___0) {
      while (1) {
        __asm__  ("imul %3,%0\n"
                  "adc $0,%1": "=r" (__tmpvar), "=r" (overflow): "0" (op1->value.lval), "r" (op2->value.lval), "1" (0));
        if (overflow) {
          result->value.dval = (double )op1->value.lval * (double )op2->value.lval;
        } else {
          result->value.lval = __tmpvar;
        }
        break;
      }
      if (overflow) {
        result->type = (unsigned char)2;
      } else {
        result->type = (unsigned char)1;
      }
      return (0);
    } else {
      tmp = __builtin_expect((long )((int )op2->type == 2), 1L);
      if (tmp) {
        result->value.dval = (double )op1->value.lval * op2->value.dval;
        result->type = (unsigned char)2;
        return (0);
      } else {

      }
    }
  } else {
    tmp___3 = __builtin_expect((long )((int )op1->type == 2), 1L);
    if (tmp___3) {
      tmp___2 = __builtin_expect((long )((int )op2->type == 2), 1L);
      if (tmp___2) {
        result->value.dval = op1->value.dval * op2->value.dval;
        result->type = (unsigned char)2;
        return (0);
      } else {
        tmp___1 = __builtin_expect((long )((int )op2->type == 1), 1L);
        if (tmp___1) {
          result->value.dval = op1->value.dval * (double )op2->value.lval;
          result->type = (unsigned char)2;
          return (0);
        } else {

        }
      }
    } else {

    }
  }
  tmp___5 = mul_function(result, op1, op2);
  return ((int )tmp___5);
}
}
__inline static int ( __attribute__((__always_inline__)) fast_div_function)(zval *result , zval *op1 , zval *op2 ) 
{ long tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  int __attribute__((__visibility__("default")))  tmp___12 ;

  {
  tmp___11 = __builtin_expect((long )((int )op1->type == 1), 1L);
  if (tmp___11) {
    goto _L;
  } else {
    _L: /* CIL Label */ 
    tmp___10 = __builtin_expect((long )((int )op1->type == 2), 1L);
    if (tmp___10) {

    } else {

    }
  }
  tmp___12 = div_function(result, op1, op2);
  return ((int )tmp___12);
}
}
__inline static int ( __attribute__((__always_inline__)) fast_mod_function)(zval *result , zval *op1 , zval *op2 ) 
{ long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int __attribute__((__visibility__("default")))  tmp___3 ;

  {
  tmp___2 = __builtin_expect((long )((int )op1->type == 1), 1L);
  if (tmp___2) {
    tmp___1 = __builtin_expect((long )((int )op2->type == 1), 1L);
    if (tmp___1) {
      tmp___0 = __builtin_expect((long )(op2->value.lval == 0L), 0L);
      if (tmp___0) {
        zend_error(1 << 1L, "Division by zero");
        result->value.lval = 0L;
        result->type = (unsigned char)3;
        return (-1);
      } else {
        tmp = __builtin_expect((long )(op2->value.lval == -1L), 0L);
        if (tmp) {
          result->value.lval = 0L;
          result->type = (unsigned char)1;
          return (0);
        } else {

        }
      }
      result->value.lval = op1->value.lval % op2->value.lval;
      result->type = (unsigned char)1;
      return (0);
    } else {

    }
  } else {

  }
  tmp___3 = mod_function(result, op1, op2);
  return ((int )tmp___3);
}
}
__inline static int ( __attribute__((__always_inline__)) fast_equal_function)(zval *result , zval *op1 , zval *op2 ) 
{ long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((int )op1->type == 1), 1L);
  if (tmp___4) {
    tmp___0 = __builtin_expect((long )((int )op2->type == 1), 1L);
    if (tmp___0) {
      return (op1->value.lval == op2->value.lval);
    } else {
      tmp = __builtin_expect((long )((int )op2->type == 2), 1L);
      if (tmp) {
        return ((double )op1->value.lval == op2->value.dval);
      } else {

      }
    }
  } else {
    tmp___3 = __builtin_expect((long )((int )op1->type == 2), 1L);
    if (tmp___3) {
      tmp___2 = __builtin_expect((long )((int )op2->type == 2), 1L);
      if (tmp___2) {
        return (op1->value.dval == op2->value.dval);
      } else {
        tmp___1 = __builtin_expect((long )((int )op2->type == 1), 1L);
        if (tmp___1) {
          return (op1->value.dval == (double )op2->value.lval);
        } else {

        }
      }
    } else {

    }
  }
  compare_function(result, op1, op2);
  return (result->value.lval == 0L);
}
}
__inline static int ( __attribute__((__always_inline__)) fast_not_equal_function)(zval *result , zval *op1 , zval *op2 ) 
{ long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((int )op1->type == 1), 1L);
  if (tmp___4) {
    tmp___0 = __builtin_expect((long )((int )op2->type == 1), 1L);
    if (tmp___0) {
      return (op1->value.lval != op2->value.lval);
    } else {
      tmp = __builtin_expect((long )((int )op2->type == 2), 1L);
      if (tmp) {
        return ((double )op1->value.lval != op2->value.dval);
      } else {

      }
    }
  } else {
    tmp___3 = __builtin_expect((long )((int )op1->type == 2), 1L);
    if (tmp___3) {
      tmp___2 = __builtin_expect((long )((int )op2->type == 2), 1L);
      if (tmp___2) {
        return (op1->value.dval != op2->value.dval);
      } else {
        tmp___1 = __builtin_expect((long )((int )op2->type == 1), 1L);
        if (tmp___1) {
          return (op1->value.dval != (double )op2->value.lval);
        } else {

        }
      }
    } else {

    }
  }
  compare_function(result, op1, op2);
  return (result->value.lval != 0L);
}
}
__inline static int ( __attribute__((__always_inline__)) fast_is_smaller_function)(zval *result , zval *op1 , zval *op2 ) 
{ long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((int )op1->type == 1), 1L);
  if (tmp___4) {
    tmp___0 = __builtin_expect((long )((int )op2->type == 1), 1L);
    if (tmp___0) {
      return (op1->value.lval < op2->value.lval);
    } else {
      tmp = __builtin_expect((long )((int )op2->type == 2), 1L);
      if (tmp) {
        return ((double )op1->value.lval < op2->value.dval);
      } else {

      }
    }
  } else {
    tmp___3 = __builtin_expect((long )((int )op1->type == 2), 1L);
    if (tmp___3) {
      tmp___2 = __builtin_expect((long )((int )op2->type == 2), 1L);
      if (tmp___2) {
        return (op1->value.dval < op2->value.dval);
      } else {
        tmp___1 = __builtin_expect((long )((int )op2->type == 1), 1L);
        if (tmp___1) {
          return (op1->value.dval < (double )op2->value.lval);
        } else {

        }
      }
    } else {

    }
  }
  compare_function(result, op1, op2);
  return (result->value.lval < 0L);
}
}
__inline static int ( __attribute__((__always_inline__)) fast_is_smaller_or_equal_function)(zval *result , zval *op1 , zval *op2 ) 
{ long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((int )op1->type == 1), 1L);
  if (tmp___4) {
    tmp___0 = __builtin_expect((long )((int )op2->type == 1), 1L);
    if (tmp___0) {
      return (op1->value.lval <= op2->value.lval);
    } else {
      tmp = __builtin_expect((long )((int )op2->type == 2), 1L);
      if (tmp) {
        return ((double )op1->value.lval <= op2->value.dval);
      } else {

      }
    }
  } else {
    tmp___3 = __builtin_expect((long )((int )op1->type == 2), 1L);
    if (tmp___3) {
      tmp___2 = __builtin_expect((long )((int )op2->type == 2), 1L);
      if (tmp___2) {
        return (op1->value.dval <= op2->value.dval);
      } else {
        tmp___1 = __builtin_expect((long )((int )op2->type == 1), 1L);
        if (tmp___1) {
          return (op1->value.dval <= (double )op2->value.lval);
        } else {

        }
      }
    } else {

    }
  }
  compare_function(result, op1, op2);
  return (result->value.lval <= 0L);
}
}
extern void __attribute__((__visibility__("default")))  _zval_dtor_func(zval *zvalue ) ;
__inline static void ( __attribute__((__always_inline__)) _zval_dtor)(zval *zvalue ) 
{ 

  {
  if ((int )zvalue->type <= 3) {
    return;
  } else {

  }
  _zval_dtor_func(zvalue);
  return;
}
}
extern void __attribute__((__visibility__("default")))  _zval_copy_ctor_func(zval *zvalue ) ;
__inline static void ( __attribute__((__always_inline__)) _zval_copy_ctor)(zval *zvalue ) 
{ 

  {
  if ((int )zvalue->type <= 3) {
    return;
  } else {

  }
  _zval_copy_ctor_func(zvalue);
  return;
}
}
extern int __attribute__((__visibility__("default")))  zval_copy_static_var(zval **p , int num_args , va_list args , zend_hash_key *key ) ;
extern int __attribute__((__visibility__("default")))  zend_print_variable(zval *var ) ;
extern void __attribute__((__visibility__("default")))  _zval_ptr_dtor(zval **zval_ptr ) ;
extern void __attribute__((__visibility__("default")))  _zval_internal_dtor(zval *zvalue ) ;
extern void __attribute__((__visibility__("default")))  _zval_internal_ptr_dtor(zval **zvalue ) ;
extern void __attribute__((__visibility__("default")))  _zval_dtor_wrapper(zval *zvalue ) ;
extern void __attribute__((__visibility__("default")))  zval_add_ref(zval **p ) ;
extern void __attribute__((__visibility__("default")))  zend_save_error_handling(zend_error_handling *current ) ;
extern void __attribute__((__visibility__("default")))  zend_replace_error_handling(zend_error_handling_t error_handling , zend_class_entry *exception_class , zend_error_handling *current ) ;
extern void __attribute__((__visibility__("default")))  zend_restore_error_handling(zend_error_handling *saved ) ;
opcode_handler_t __attribute__((__visibility__("default")))  *zend_opcode_handlers  ;
extern char *zend_visibility_string(zend_uint fn_flags ) ;
extern  __attribute__((__nothrow__)) int setjmp(struct __jmp_buf_tag *__env ) ;
extern  __attribute__((__nothrow__)) int __sigsetjmp(struct __jmp_buf_tag *__env , int __savemask ) ;
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag *__env ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void longjmp(struct __jmp_buf_tag *__env , int __val ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void _longjmp(struct __jmp_buf_tag *__env , int __val ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void siglongjmp(struct __jmp_buf_tag *__env , int __val ) ;
extern struct _zend_compiler_globals  __attribute__((__visibility__("default"))) compiler_globals ;
extern int zendparse(void) ;
extern zend_executor_globals __attribute__((__visibility__("default")))  executor_globals ;
extern zend_php_scanner_globals __attribute__((__visibility__("default")))  language_scanner_globals ;
extern zend_ini_scanner_globals __attribute__((__visibility__("default")))  ini_scanner_globals ;
extern int __attribute__((__visibility__("default")))  zend_stack_init(zend_stack *stack ) ;
extern int __attribute__((__visibility__("default")))  zend_stack_push(zend_stack *stack , void const   *element , int size ) ;
extern int __attribute__((__visibility__("default")))  zend_stack_top(zend_stack const   *stack , void **element ) ;
extern int __attribute__((__visibility__("default")))  zend_stack_del_top(zend_stack *stack ) ;
extern int __attribute__((__visibility__("default")))  zend_stack_int_top(zend_stack const   *stack ) ;
extern int __attribute__((__visibility__("default")))  zend_stack_is_empty(zend_stack const   *stack ) ;
extern int __attribute__((__visibility__("default")))  zend_stack_destroy(zend_stack *stack ) ;
extern void __attribute__((__visibility__("default")))  **zend_stack_base(zend_stack const   *stack ) ;
extern int __attribute__((__visibility__("default")))  zend_stack_count(zend_stack const   *stack ) ;
extern void __attribute__((__visibility__("default")))  zend_stack_apply(zend_stack *stack , int type , int (*apply_function)(void *element ) ) ;
extern void __attribute__((__visibility__("default")))  zend_stack_apply_with_argument(zend_stack *stack , int type , int (*apply_function)(void *element , void *arg ) , void *arg ) ;
extern void __attribute__((__visibility__("default")))  zend_ptr_stack_init(zend_ptr_stack *stack ) ;
extern void __attribute__((__visibility__("default")))  zend_ptr_stack_init_ex(zend_ptr_stack *stack , zend_bool persistent ) ;
extern void __attribute__((__visibility__("default")))  zend_ptr_stack_n_push(zend_ptr_stack *stack , int count  , ...) ;
extern void __attribute__((__visibility__("default")))  zend_ptr_stack_n_pop(zend_ptr_stack *stack , int count  , ...) ;
extern void __attribute__((__visibility__("default")))  zend_ptr_stack_destroy(zend_ptr_stack *stack ) ;
extern void __attribute__((__visibility__("default")))  zend_ptr_stack_apply(zend_ptr_stack *stack , void (*func)(void * ) ) ;
extern void __attribute__((__visibility__("default")))  zend_ptr_stack_clean(zend_ptr_stack *stack , void (*func)(void * ) , zend_bool free_elements ) ;
extern int __attribute__((__visibility__("default")))  zend_ptr_stack_num_elements(zend_ptr_stack *stack ) ;
__inline static void ( __attribute__((__always_inline__)) zend_ptr_stack_3_push)(zend_ptr_stack *stack , void *a , void *b , void *c ) 
{ void *tmp ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  void *tmp___1 ;
  void **tmp___2 ;
  void **tmp___3 ;
  void **tmp___4 ;

  {
  if (stack->top + 3 > stack->max) {
    while (1) {
      stack->max += 64;
      if (stack->top + 3 > stack->max) {

      } else {
        break;
      }
    }
    if (stack->persistent) {
      tmp = __zend_realloc((void *)stack->elements, sizeof(void *) * (unsigned int )stack->max);
      tmp___1 = tmp;
    } else {
      tmp___0 = _erealloc((void *)stack->elements, sizeof(void *) * (unsigned int )stack->max, 0);
      tmp___1 = (void *)tmp___0;
    }
    stack->elements = (void **)tmp___1;
    stack->top_element = stack->elements + stack->top;
  } else {

  }
  stack->top += 3;
  tmp___2 = stack->top_element;
  (stack->top_element) ++;
  *tmp___2 = a;
  tmp___3 = stack->top_element;
  (stack->top_element) ++;
  *tmp___3 = b;
  tmp___4 = stack->top_element;
  (stack->top_element) ++;
  *tmp___4 = c;
  return;
}
}
__inline static void ( __attribute__((__always_inline__)) zend_ptr_stack_2_push)(zend_ptr_stack *stack , void *a , void *b ) 
{ void *tmp ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  void *tmp___1 ;
  void **tmp___2 ;
  void **tmp___3 ;

  {
  if (stack->top + 2 > stack->max) {
    while (1) {
      stack->max += 64;
      if (stack->top + 2 > stack->max) {

      } else {
        break;
      }
    }
    if (stack->persistent) {
      tmp = __zend_realloc((void *)stack->elements, sizeof(void *) * (unsigned int )stack->max);
      tmp___1 = tmp;
    } else {
      tmp___0 = _erealloc((void *)stack->elements, sizeof(void *) * (unsigned int )stack->max, 0);
      tmp___1 = (void *)tmp___0;
    }
    stack->elements = (void **)tmp___1;
    stack->top_element = stack->elements + stack->top;
  } else {

  }
  stack->top += 2;
  tmp___2 = stack->top_element;
  (stack->top_element) ++;
  *tmp___2 = a;
  tmp___3 = stack->top_element;
  (stack->top_element) ++;
  *tmp___3 = b;
  return;
}
}
__inline static void ( __attribute__((__always_inline__)) zend_ptr_stack_3_pop)(zend_ptr_stack *stack , void **a , void **b , void **c ) 
{ 

  {
  (stack->top_element) --;
  *a = *(stack->top_element);
  (stack->top_element) --;
  *b = *(stack->top_element);
  (stack->top_element) --;
  *c = *(stack->top_element);
  stack->top -= 3;
  return;
}
}
__inline static void ( __attribute__((__always_inline__)) zend_ptr_stack_2_pop)(zend_ptr_stack *stack , void **a , void **b ) 
{ 

  {
  (stack->top_element) --;
  *a = *(stack->top_element);
  (stack->top_element) --;
  *b = *(stack->top_element);
  stack->top -= 2;
  return;
}
}
__inline static void ( __attribute__((__always_inline__)) zend_ptr_stack_push)(zend_ptr_stack *stack , void *ptr ) 
{ void *tmp ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  void *tmp___1 ;
  void **tmp___2 ;

  {
  if (stack->top + 1 > stack->max) {
    while (1) {
      stack->max += 64;
      if (stack->top + 1 > stack->max) {

      } else {
        break;
      }
    }
    if (stack->persistent) {
      tmp = __zend_realloc((void *)stack->elements, sizeof(void *) * (unsigned int )stack->max);
      tmp___1 = tmp;
    } else {
      tmp___0 = _erealloc((void *)stack->elements, sizeof(void *) * (unsigned int )stack->max, 0);
      tmp___1 = (void *)tmp___0;
    }
    stack->elements = (void **)tmp___1;
    stack->top_element = stack->elements + stack->top;
  } else {

  }
  (stack->top) ++;
  tmp___2 = stack->top_element;
  (stack->top_element) ++;
  *tmp___2 = ptr;
  return;
}
}
__inline static void *( __attribute__((__always_inline__)) zend_ptr_stack_pop)(zend_ptr_stack *stack ) 
{ 

  {
  (stack->top) --;
  (stack->top_element) --;
  return (*(stack->top_element));
}
}
extern void __attribute__((__visibility__("default")))  zend_object_std_init(zend_object *object , zend_class_entry *ce ) ;
extern void __attribute__((__visibility__("default")))  zend_object_std_dtor(zend_object *object ) ;
extern zend_object_value __attribute__((__visibility__("default")))  zend_objects_new(zend_object **object , zend_class_entry *class_type ) ;
extern void __attribute__((__visibility__("default")))  zend_objects_destroy_object(zend_object *object , zend_object_handle handle ) ;
extern zend_object __attribute__((__visibility__("default")))  *zend_objects_get_address(zval const   *object ) ;
extern void __attribute__((__visibility__("default")))  zend_objects_clone_members(zend_object *new_object , zend_object_value new_obj_val , zend_object *old_object , zend_object_handle handle ) ;
extern zend_object_value __attribute__((__visibility__("default")))  zend_objects_clone_obj(zval *object ) ;
extern void __attribute__((__visibility__("default")))  zend_objects_free_object_storage(zend_object *object ) ;
extern void __attribute__((__visibility__("default")))  zend_objects_store_init(zend_objects_store *objects , zend_uint init_size ) ;
extern void __attribute__((__visibility__("default")))  zend_objects_store_call_destructors(zend_objects_store *objects ) ;
extern void __attribute__((__visibility__("default")))  zend_objects_store_mark_destructed(zend_objects_store *objects ) ;
extern void __attribute__((__visibility__("default")))  zend_objects_store_destroy(zend_objects_store *objects ) ;
extern zend_object_handle __attribute__((__visibility__("default")))  zend_objects_store_put(void *object , void (*dtor)(void *object , zend_object_handle handle ) , void (*storage)(void *object ) , void (*clone)(void *object , void **object_clone ) ) ;
extern void __attribute__((__visibility__("default")))  zend_objects_store_add_ref(zval *object ) ;
extern void __attribute__((__visibility__("default")))  zend_objects_store_del_ref(zval *object ) ;
extern void __attribute__((__visibility__("default")))  zend_objects_store_add_ref_by_handle(zend_object_handle handle ) ;
extern void __attribute__((__visibility__("default")))  zend_objects_store_del_ref_by_handle_ex(zend_object_handle handle , zend_object_handlers const   *handlers ) ;
__inline static void ( __attribute__((__always_inline__)) zend_objects_store_del_ref_by_handle)(zend_object_handle handle ) 
{ 

  {
  zend_objects_store_del_ref_by_handle_ex(handle, (zend_object_handlers const   *)((void *)0));
  return;
}
}
extern zend_uint __attribute__((__visibility__("default")))  zend_objects_store_get_refcount(zval *object ) ;
extern zend_object_value __attribute__((__visibility__("default")))  zend_objects_store_clone_obj(zval *object ) ;
extern void __attribute__((__visibility__("default")))  *zend_object_store_get_object(zval const   *object ) ;
extern void __attribute__((__visibility__("default")))  *zend_object_store_get_object_by_handle(zend_object_handle handle ) ;
extern void __attribute__((__visibility__("default")))  zend_object_store_set_object(zval *zobject , void *object ) ;
extern void __attribute__((__visibility__("default")))  zend_object_store_ctor_failed(zval *zobject ) ;
extern void __attribute__((__visibility__("default")))  zend_objects_store_free_object_storage(zend_objects_store *objects ) ;
extern zval __attribute__((__visibility__("default")))  *zend_object_create_proxy(zval *object , zval *member ) ;
extern zend_object_handlers __attribute__((__visibility__("default")))  *zend_get_std_object_handlers(void) ;
extern HashTable __attribute__((__visibility__("default")))  module_registry ;
extern void module_destructor(zend_module_entry *module ) ;
extern int module_registry_cleanup(zend_module_entry *module ) ;
extern int module_registry_request_startup(zend_module_entry *module ) ;
extern int module_registry_unload_temp(zend_module_entry const   *module ) ;
extern void __attribute__((__visibility__("default")))  zend_init_fpu(void) ;
extern void __attribute__((__visibility__("default")))  zend_shutdown_fpu(void) ;
extern void __attribute__((__visibility__("default")))  zend_ensure_fpu_mode(void) ;
extern fpu_control_t __fpu_control ;
extern zend_encoding const __attribute__((__visibility__("default")))  *zend_multibyte_encoding_utf32be ;
extern zend_encoding const __attribute__((__visibility__("default")))  *zend_multibyte_encoding_utf32le ;
extern zend_encoding const __attribute__((__visibility__("default")))  *zend_multibyte_encoding_utf16be ;
extern zend_encoding const __attribute__((__visibility__("default")))  *zend_multibyte_encoding_utf16le ;
extern zend_encoding const __attribute__((__visibility__("default")))  *zend_multibyte_encoding_utf8 ;
extern int __attribute__((__visibility__("default")))  zend_multibyte_set_functions(zend_multibyte_functions const   *functions ) ;
extern zend_multibyte_functions const __attribute__((__visibility__("default")))  *zend_multibyte_get_functions(void) ;
extern zend_encoding const __attribute__((__visibility__("default")))  *zend_multibyte_fetch_encoding(char const   *name ) ;
extern char const __attribute__((__visibility__("default")))  *zend_multibyte_get_encoding_name(zend_encoding const   *encoding ) ;
extern int __attribute__((__visibility__("default")))  zend_multibyte_check_lexer_compatibility(zend_encoding const   *encoding ) ;
extern zend_encoding const __attribute__((__visibility__("default")))  *zend_multibyte_encoding_detector(unsigned char const   *string , size_t length , zend_encoding const   **list , size_t list_size ) ;
extern size_t __attribute__((__visibility__("default")))  zend_multibyte_encoding_converter(unsigned char **to , size_t *to_length , unsigned char const   *from , size_t from_length , zend_encoding const   *encoding_to , zend_encoding const   *encoding_from ) ;
extern int __attribute__((__visibility__("default")))  zend_multibyte_parse_encoding_list(char const   *encoding_list , size_t encoding_list_len , zend_encoding const   ***return_list , size_t *return_size , int persistent ) ;
extern zend_encoding const __attribute__((__visibility__("default")))  *zend_multibyte_get_internal_encoding(void) ;
extern zend_encoding const __attribute__((__visibility__("default")))  *zend_multibyte_get_script_encoding(void) ;
extern int __attribute__((__visibility__("default")))  zend_multibyte_set_script_encoding(zend_encoding const   **encoding_list , size_t encoding_list_size ) ;
extern int __attribute__((__visibility__("default")))  zend_multibyte_set_internal_encoding(zend_encoding const   *encoding ) ;
extern int __attribute__((__visibility__("default")))  zend_multibyte_set_script_encoding_by_string(char const   *new_value , size_t new_value_length ) ;
extern void init_compiler(void) ;
extern void shutdown_compiler(void) ;
extern void zend_init_compiler_data_structures(void) ;
extern void zend_init_compiler_context(void) ;
extern zend_op_array __attribute__((__visibility__("default")))  *(*zend_compile_file)(zend_file_handle *file_handle , int type ) ;
extern zend_op_array __attribute__((__visibility__("default")))  *(*zend_compile_string)(zval *source_string , char *filename ) ;
extern int __attribute__((__visibility__("default")))  lex_scan(zval *zendlval ) ;
extern void startup_scanner(void) ;
extern void shutdown_scanner(void) ;
extern char __attribute__((__visibility__("default")))  *zend_set_compiled_filename(char const   *new_compiled_filename ) ;
extern void __attribute__((__visibility__("default")))  zend_restore_compiled_filename(char *original_compiled_filename ) ;
extern char __attribute__((__visibility__("default")))  *zend_get_compiled_filename(void) ;
extern int __attribute__((__visibility__("default")))  zend_get_compiled_lineno(void) ;
extern size_t __attribute__((__visibility__("default")))  zend_get_scanned_file_offset(void) ;
extern void zend_resolve_non_class_name(znode *element_name , zend_bool check_namespace ) ;
extern void zend_resolve_class_name(znode *class_name , ulong fetch_type , int check_ns_name ) ;
extern char const __attribute__((__visibility__("default")))  *zend_get_compiled_variable_name(zend_op_array const   *op_array , zend_uint var , int *name_len ) ;
extern void zend_do_binary_op(zend_uchar op , znode *result , znode const   *op1 , znode const   *op2 ) ;
extern void zend_do_unary_op(zend_uchar op , znode *result , znode const   *op1 ) ;
extern void zend_do_binary_assign_op(zend_uchar op , znode *result , znode const   *op1 , znode const   *op2 ) ;
extern void zend_do_assign(znode *result , znode *variable , znode *value ) ;
extern void zend_do_assign_ref(znode *result , znode const   *lvar , znode const   *rvar ) ;
extern void fetch_simple_variable(znode *result , znode *varname , int bp ) ;
extern void fetch_simple_variable_ex(znode *result , znode *varname , int bp , zend_uchar op ) ;
extern void zend_do_indirect_references(znode *result , znode const   *num_references , znode *variable ) ;
extern void zend_do_fetch_static_variable(znode *varname , znode const   *static_assignment , int fetch_type ) ;
extern void zend_do_fetch_global_variable(znode *varname , znode const   *static_assignment , int fetch_type ) ;
extern void fetch_array_begin(znode *result , znode *varname , znode *first_dim ) ;
extern void fetch_array_dim(znode *result , znode const   *parent , znode const   *dim ) ;
extern void fetch_string_offset(znode *result , znode const   *parent , znode const   *offset ) ;
extern void zend_do_fetch_static_member(znode *result , znode *class_znode ) ;
extern void zend_do_print(znode *result , znode const   *arg ) ;
extern void zend_do_echo(znode const   *arg ) ;
extern unary_op_type __attribute__((__visibility__("default")))  get_unary_op(int opcode ) ;
extern binary_op_type __attribute__((__visibility__("default")))  get_binary_op(int opcode ) ;
extern void zend_do_while_cond(znode const   *expr , znode *close_bracket_token ) ;
extern void zend_do_while_end(znode const   *while_token , znode const   *close_bracket_token ) ;
extern void zend_do_do_while_begin(void) ;
extern void zend_do_do_while_end(znode const   *do_token , znode const   *expr_open_bracket , znode const   *expr ) ;
extern void zend_do_if_cond(znode const   *cond , znode *closing_bracket_token ) ;
extern void zend_do_if_after_statement(znode const   *closing_bracket_token , unsigned char initialize ) ;
extern void zend_do_if_end(void) ;
extern void zend_do_for_cond(znode const   *expr , znode *second_semicolon_token ) ;
extern void zend_do_for_before_statement(znode const   *cond_start , znode const   *second_semicolon_token ) ;
extern void zend_do_for_end(znode const   *second_semicolon_token ) ;
extern void zend_do_pre_incdec(znode *result , znode const   *op1 , zend_uchar op ) ;
extern void zend_do_post_incdec(znode *result , znode const   *op1 , zend_uchar op ) ;
extern void zend_do_begin_variable_parse(void) ;
extern void zend_do_end_variable_parse(znode *variable , int type , int arg_offset ) ;
extern void zend_check_writable_variable(znode const   *variable ) ;
extern void zend_do_free(znode *op1 ) ;
extern void zend_do_add_string(znode *result , znode const   *op1 , znode *op2 ) ;
extern void zend_do_add_variable(znode *result , znode const   *op1 , znode const   *op2 ) ;
extern int zend_do_verify_access_types(znode const   *current_access_type , znode const   *new_modifier ) ;
extern void zend_do_begin_function_declaration(znode *function_token , znode *function_name , int is_method , int return_reference , znode *fn_flags_znode ) ;
extern void zend_do_end_function_declaration(znode const   *function_token ) ;
extern void zend_do_receive_arg(zend_uchar op , znode *varname , znode const   *offset , znode const   *initialization , znode *class_type , zend_bool pass_by_reference ) ;
extern int zend_do_begin_function_call(znode *function_name , zend_bool check_namespace ) ;
extern void zend_do_begin_method_call(znode *left_bracket ) ;
extern void zend_do_clone(znode *result , znode const   *expr ) ;
extern void zend_do_begin_dynamic_function_call(znode *function_name , int prefix_len ) ;
extern void zend_do_fetch_class(znode *result , znode *class_name ) ;
extern void zend_do_build_full_name(znode *result , znode *prefix , znode *name , int is_class_member ) ;
extern int zend_do_begin_class_member_function_call(znode *class_name , znode *method_name ) ;
extern void zend_do_end_function_call(znode *function_name , znode *result , znode const   *argument_list , int is_method , int is_dynamic_fcall ) ;
extern void zend_do_return(znode *expr , int do_end_vparse ) ;
extern void zend_do_handle_exception(void) ;
extern void zend_do_begin_lambda_function_declaration(znode *result , znode *function_token , int return_reference , int is_static ) ;
extern void zend_do_fetch_lexical_variable(znode *varname , zend_bool is_ref ) ;
extern void zend_do_try(znode *try_token ) ;
extern void zend_do_begin_catch(znode *try_token , znode *catch_class , znode *catch_var , znode *first_catch ) ;
extern void zend_do_end_catch(znode const   *try_token ) ;
extern void zend_do_throw(znode const   *expr ) ;
extern int __attribute__((__visibility__("default")))  do_bind_function(zend_op_array const   *op_array , zend_op *opline , HashTable *function_table , zend_bool compile_time ) ;
extern zend_class_entry __attribute__((__visibility__("default")))  *do_bind_class(zend_op_array const   *op_array , zend_op const   *opline , HashTable *class_table , zend_bool compile_time ) ;
extern zend_class_entry __attribute__((__visibility__("default")))  *do_bind_inherited_class(zend_op_array const   *op_array , zend_op const   *opline , HashTable *class_table , zend_class_entry *parent_ce , zend_bool compile_time ) ;
extern void __attribute__((__visibility__("default")))  zend_do_inherit_interfaces(zend_class_entry *ce , zend_class_entry const   *iface ) ;
extern void __attribute__((__visibility__("default")))  zend_do_implement_interface(zend_class_entry *ce , zend_class_entry *iface ) ;
extern void zend_do_implements_interface(znode *interface_znode ) ;
extern void zend_add_trait_precedence(znode *precedence_znode ) ;
extern void zend_add_trait_alias(znode *alias_znode ) ;
extern void zend_do_implements_trait(znode *interface_znode ) ;
extern void __attribute__((__visibility__("default")))  zend_do_implement_trait(zend_class_entry *ce , zend_class_entry *trait ) ;
extern void __attribute__((__visibility__("default")))  zend_do_bind_traits(zend_class_entry *ce ) ;
extern void zend_prepare_trait_precedence(znode *result , znode *method_reference , znode *trait_list ) ;
extern void zend_prepare_reference(znode *result , znode *class_name , znode *method_name ) ;
extern void zend_prepare_trait_alias(znode *result , znode *method_reference , znode *modifiers , znode *alias ) ;
extern void init_trait_alias_list(znode *result , znode const   *trait_alias ) ;
extern void add_trait_alias(znode *result , znode const   *trait_alias ) ;
extern void init_trait_alias(znode *result , znode const   *method_name , znode const   *alias , znode const   *modifiers ) ;
extern void __attribute__((__visibility__("default")))  zend_do_inheritance(zend_class_entry *ce , zend_class_entry *parent_ce ) ;
extern void zend_do_early_binding(void) ;
extern void __attribute__((__visibility__("default")))  zend_do_delayed_early_binding(zend_op_array const   *op_array ) ;
extern void zend_do_pass_param(znode *param , zend_uchar op , int offset ) ;
extern void zend_do_boolean_or_begin(znode *expr1 , znode *op_token ) ;
extern void zend_do_boolean_or_end(znode *result , znode const   *expr1 , znode const   *expr2 , znode *op_token ) ;
extern void zend_do_boolean_and_begin(znode *expr1 , znode *op_token ) ;
extern void zend_do_boolean_and_end(znode *result , znode const   *expr1 , znode const   *expr2 , znode const   *op_token ) ;
extern void zend_do_brk_cont(zend_uchar op , znode const   *expr ) ;
extern void zend_do_switch_cond(znode const   *cond ) ;
extern void zend_do_switch_end(znode const   *case_list ) ;
extern void zend_do_case_before_statement(znode const   *case_list , znode *case_token , znode const   *case_expr ) ;
extern void zend_do_case_after_statement(znode *result , znode const   *case_token ) ;
extern void zend_do_default_before_statement(znode const   *case_list , znode *default_token ) ;
extern void zend_do_begin_class_declaration(znode const   *class_token , znode *class_name , znode const   *parent_class_name ) ;
extern void zend_do_end_class_declaration(znode const   *class_token , znode const   *parent_token ) ;
extern void zend_do_declare_property(znode const   *var_name , znode const   *value , zend_uint access_type ) ;
extern void zend_do_declare_class_constant(znode *var_name , znode const   *value ) ;
extern void zend_do_fetch_property(znode *result , znode *object , znode const   *property ) ;
extern void zend_do_halt_compiler_register(void) ;
extern void zend_do_push_object(znode const   *object ) ;
extern void zend_do_pop_object(znode *object ) ;
extern void zend_do_begin_new_object(znode *new_token , znode *class_type ) ;
extern void zend_do_end_new_object(znode *result , znode const   *new_token , znode const   *argument_list ) ;
extern void zend_do_fetch_constant(znode *result , znode *constant_container , znode *constant_name , int mode , zend_bool check_namespace ) ;
extern void zend_do_shell_exec(znode *result , znode const   *cmd ) ;
extern void zend_do_init_array(znode *result , znode const   *expr , znode const   *offset , zend_bool is_ref ) ;
extern void zend_do_add_array_element(znode *result , znode const   *expr , znode const   *offset , zend_bool is_ref ) ;
extern void zend_do_add_static_array_element(znode *result , znode *offset , znode const   *expr ) ;
extern void zend_do_list_init(void) ;
extern void zend_do_list_end(znode *result , znode *expr ) ;
extern void zend_do_add_list_element(znode const   *element ) ;
extern void zend_do_new_list_begin(void) ;
extern void zend_do_new_list_end(void) ;
extern void zend_init_list(void *result , void *item ) ;
extern void zend_add_to_list(void *result , void *item ) ;
extern void zend_do_cast(znode *result , znode const   *expr , int type ) ;
extern void zend_do_include_or_eval(int type , znode *result , znode const   *op1 ) ;
extern void zend_do_unset(znode const   *variable ) ;
extern void zend_do_isset_or_isempty(int type , znode *result , znode *variable ) ;
extern void zend_do_instanceof(znode *result , znode const   *expr , znode const   *class_znode , int type ) ;
extern void zend_do_foreach_begin(znode *foreach_token , znode *open_brackets_token , znode *array , znode *as_token , int variable ) ;
extern void zend_do_foreach_cont(znode *foreach_token , znode const   *open_brackets_token , znode const   *as_token , znode *value , znode *key ) ;
extern void zend_do_foreach_end(znode const   *foreach_token , znode const   *as_token ) ;
extern void zend_do_declare_begin(void) ;
extern void zend_do_declare_stmt(znode *var , znode *val ) ;
extern void zend_do_declare_end(znode const   *declare_token ) ;
extern void zend_do_exit(znode *result , znode const   *message ) ;
extern void zend_do_begin_silence(znode *strudel_token ) ;
extern void zend_do_end_silence(znode const   *strudel_token ) ;
extern void zend_do_jmp_set(znode const   *value , znode *jmp_token , znode *colon_token ) ;
extern void zend_do_jmp_set_else(znode *result , znode const   *false_value , znode const   *jmp_token , znode const   *colon_token ) ;
extern void zend_do_begin_qm_op(znode const   *cond , znode *qm_token ) ;
extern void zend_do_qm_true(znode const   *true_value , znode *qm_token , znode *colon_token ) ;
extern void zend_do_qm_false(znode *result , znode const   *false_value , znode const   *qm_token , znode const   *colon_token ) ;
extern void zend_do_extended_info(void) ;
extern void zend_do_extended_fcall_begin(void) ;
extern void zend_do_extended_fcall_end(void) ;
extern void zend_do_ticks(void) ;
extern void zend_do_abstract_method(znode const   *function_name , znode *modifiers , znode const   *body ) ;
extern void zend_do_declare_constant(znode *name , znode *value ) ;
extern void zend_do_build_namespace_name(znode *result , znode *prefix , znode *name ) ;
extern void zend_do_begin_namespace(znode const   *name , zend_bool with_brackets ) ;
extern void zend_do_end_namespace(void) ;
extern void zend_verify_namespace(void) ;
extern void zend_do_use(znode *name , znode *new_name , int is_global ) ;
extern void zend_do_end_compilation(void) ;
extern void zend_do_label(znode *label ) ;
extern void zend_do_goto(znode const   *label ) ;
extern void zend_resolve_goto_label(zend_op_array *op_array , zend_op *opline , int pass2 ) ;
extern void zend_release_labels(void) ;
extern void __attribute__((__visibility__("default")))  function_add_ref(zend_function *function ) ;
extern zend_op_array __attribute__((__visibility__("default")))  *compile_file(zend_file_handle *file_handle , int type ) ;
extern zend_op_array __attribute__((__visibility__("default")))  *compile_string(zval *source_string , char *filename ) ;
extern zend_op_array __attribute__((__visibility__("default")))  *compile_filename(int type , zval *filename ) ;
extern int __attribute__((__visibility__("default")))  zend_execute_scripts(int type , zval **retval , int file_count  , ...) ;
extern int __attribute__((__visibility__("default")))  open_file_for_scanning(zend_file_handle *file_handle ) ;
extern void __attribute__((__visibility__("default")))  init_op_array(zend_op_array *op_array , zend_uchar type , int initial_ops_size ) ;
extern void __attribute__((__visibility__("default")))  destroy_op_array(zend_op_array *op_array ) ;
extern void __attribute__((__visibility__("default")))  zend_destroy_file_handle(zend_file_handle *file_handle ) ;
extern int __attribute__((__visibility__("default")))  zend_cleanup_class_data(zend_class_entry **pce ) ;
extern int __attribute__((__visibility__("default")))  zend_cleanup_user_class_data(zend_class_entry **pce ) ;
extern void __attribute__((__visibility__("default")))  zend_cleanup_internal_class_data(zend_class_entry *ce ) ;
extern void __attribute__((__visibility__("default")))  zend_cleanup_internal_classes(void) ;
extern int __attribute__((__visibility__("default")))  zend_cleanup_function_data(zend_function *function ) ;
extern int __attribute__((__visibility__("default")))  zend_cleanup_function_data_full(zend_function *function ) ;
extern void __attribute__((__visibility__("default")))  destroy_zend_function(zend_function *function ) ;
extern void __attribute__((__visibility__("default")))  zend_function_dtor(zend_function *function ) ;
extern void __attribute__((__visibility__("default")))  destroy_zend_class(zend_class_entry **pce ) ;
extern void zend_class_add_ref(zend_class_entry **ce ) ;
extern void __attribute__((__visibility__("default")))  zend_mangle_property_name(char **dest , int *dest_length , char const   *src1 , int src1_length , char const   *src2 , int src2_length , int internal ) ;
extern int __attribute__((__visibility__("default")))  zend_unmangle_property_name(char const   *mangled_property , int mangled_property_len , char const   **class_name , char const   **prop_name ) ;
extern zend_op *get_next_op(zend_op_array *op_array ) ;
extern void init_op(zend_op *op ) ;
extern int get_next_op_number(zend_op_array *op_array ) ;
extern int print_class(zend_class_entry *class_entry ) ;
extern void print_op_array(zend_op_array *op_array , int optimizations ) ;
extern int __attribute__((__visibility__("default")))  pass_two(zend_op_array *op_array ) ;
extern zend_brk_cont_element *get_next_brk_cont_element(zend_op_array *op_array ) ;
extern void zend_do_first_catch(znode *open_parentheses ) ;
extern void zend_initialize_try_catch_element(znode const   *try_token ) ;
extern void zend_do_mark_last_catch(znode const   *first_catch , znode const   *last_additional_catch ) ;
extern zend_bool __attribute__((__visibility__("default")))  zend_is_compiling(void) ;
extern char __attribute__((__visibility__("default")))  *zend_make_compiled_string_description(char const   *name ) ;
extern void __attribute__((__visibility__("default")))  zend_initialize_class_data(zend_class_entry *ce , zend_bool nullify_handlers ) ;
extern int zend_get_class_fetch_type(char const   *class_name , uint class_name_len ) ;
extern int __attribute__((__visibility__("default")))  zend_register_auto_global(char const   *name , uint name_len , zend_bool jit , zend_bool (*auto_global_callback)(char const   *name , uint name_len ) ) ;
extern void __attribute__((__visibility__("default")))  zend_activate_auto_globals(void) ;
extern zend_bool __attribute__((__visibility__("default")))  zend_is_auto_global(char const   *name , uint name_len ) ;
extern zend_bool __attribute__((__visibility__("default")))  zend_is_auto_global_quick(char const   *name , uint name_len , ulong hashval ) ;
extern size_t __attribute__((__visibility__("default")))  zend_dirname(char *path , size_t len ) ;
extern int zendlex(znode *zendlval ) ;
extern int zend_add_literal(zend_op_array *op_array , zval const   *zv ) ;
extern void __attribute__((__visibility__("default")))  (*zend_execute)(zend_op_array *op_array ) ;
extern void __attribute__((__visibility__("default")))  (*zend_execute_internal)(zend_execute_data *execute_data_ptr , int return_value_used ) ;
extern void init_executor(void) ;
extern void shutdown_executor(void) ;
extern void shutdown_destructors(void) ;
void __attribute__((__visibility__("default")))  execute(zend_op_array *op_array ) ;
void __attribute__((__visibility__("default")))  execute_internal(zend_execute_data *execute_data_ptr , int return_value_used ) ;
extern int __attribute__((__visibility__("default")))  zend_is_true(zval *op ) ;
__inline static void ( __attribute__((__always_inline__)) safe_free_zval_ptr_rel)(zval *p ) 
{ 

  {
  if ((unsigned int )p != (unsigned int )executor_globals.uninitialized_zval_ptr) {
    while (1) {
      if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)p)->u.buffered & 4294967292UL)) {
        gc_remove_zval_from_buffer(p);
      } else {

      }
      _efree((void *)p);
      break;
    }
  } else {

  }
  return;
}
}
extern int __attribute__((__visibility__("default")))  zend_lookup_class(char const   *name , int name_length , zend_class_entry ***ce ) ;
extern int __attribute__((__visibility__("default")))  zend_lookup_class_ex(char const   *name , int name_length , zend_literal const   *key , int use_autoload , zend_class_entry ***ce ) ;
extern int __attribute__((__visibility__("default")))  zend_eval_string(char *str , zval *retval_ptr , char *string_name ) ;
extern int __attribute__((__visibility__("default")))  zend_eval_stringl(char *str , int str_len , zval *retval_ptr , char *string_name ) ;
extern int __attribute__((__visibility__("default")))  zend_eval_string_ex(char *str , zval *retval_ptr , char *string_name , int handle_exceptions ) ;
extern int __attribute__((__visibility__("default")))  zend_eval_stringl_ex(char *str , int str_len , zval *retval_ptr , char *string_name , int handle_exceptions ) ;
char __attribute__((__visibility__("default")))  *zend_verify_arg_class_kind(zend_arg_info const   *cur_arg_info , ulong fetch_type , char const   **class_name , zend_class_entry **pce ) ;
int __attribute__((__visibility__("default")))  zend_verify_arg_error(int error_type , zend_function const   *zf , zend_uint arg_num , char const   *need_msg , char const   *need_kind , char const   *given_msg , char const   *given_kind ) ;
__inline static void ( __attribute__((__always_inline__)) i_zval_ptr_dtor)(zval *zval_ptr ) 
{ zend_uint tmp ;
  zend_uint tmp___0 ;

  {
  tmp___0 = zval_delref_p(zval_ptr);
  if (tmp___0) {
    tmp = zval_refcount_p(zval_ptr);
    if (tmp == 1U) {
      zval_unset_isref_p(zval_ptr);
    } else {

    }
    gc_zval_check_possible_root(zval_ptr);
  } else {
    if ((unsigned int )zval_ptr != (unsigned int )(& executor_globals.uninitialized_zval)) {
      if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)zval_ptr)->u.buffered & 4294967292UL)) {
        gc_remove_zval_from_buffer(zval_ptr);
      } else {

      }
      _zval_dtor(zval_ptr);
      _efree((void *)zval_ptr);
    } else {

    }
  }
  return;
}
}
__inline static int ( __attribute__((__always_inline__)) i_zend_is_true)(zval *op ) 
{ int result ;
  int __attribute__((__visibility__("default")))  tmp ;
  int __attribute__((__visibility__("default")))  tmp___0 ;
  zval tmp___1 ;
  int tmp___2 ;
  zval *tmp___3 ;
  zval *tmp___4 ;

  {
  switch ((int )op->type) {
  case 0: 
  result = 0;
  break;
  case 1: 
  case 3: 
  case 7: 
  if (op->value.lval) {
    result = 1;
  } else {
    result = 0;
  }
  break;
  case 2: 
  if (op->value.dval) {
    result = 1;
  } else {
    result = 0;
  }
  break;
  case 6: 
  if (op->value.str.len == 0) {
    result = 0;
  } else {
    if (op->value.str.len == 1) {
      if ((int )*(op->value.str.val + 0) == 48) {
        result = 0;
      } else {
        result = 1;
      }
    } else {
      result = 1;
    }
  }
  break;
  case 4: 
  tmp___0 = zend_hash_num_elements((HashTable const   *)op->value.ht);
  if (tmp___0) {
    result = 1;
  } else {
    result = 0;
  }
  break;
  case 5: 
  if ((int )op->type == 5) {
    if ((unsigned int )(op->value.obj.handlers)->get_class_entry != (unsigned int )((void *)0)) {
      if ((op->value.obj.handlers)->cast_object) {
        tmp___2 = (*((op->value.obj.handlers)->cast_object))(op, & tmp___1, 3);
        if (tmp___2 == 0) {
          result = (int )tmp___1.value.lval;
          break;
        } else {

        }
      } else {
        if ((op->value.obj.handlers)->get) {
          tmp___4 = (*((op->value.obj.handlers)->get))(op);
          tmp___3 = tmp___4;
          if ((int )tmp___3->type != 5) {
            convert_to_boolean(tmp___3);
            result = (int )tmp___3->value.lval;
            _zval_ptr_dtor(& tmp___3);
            break;
          } else {

          }
        } else {

        }
      }
    } else {

    }
  } else {

  }
  result = 1;
  break;
  default: 
  result = 0;
  break;
  }
  return (result);
}
}
extern int __attribute__((__visibility__("default")))  zval_update_constant(zval **pp , void *arg ) ;
extern int __attribute__((__visibility__("default")))  zval_update_constant_inline_change(zval **pp , void *arg ) ;
extern int __attribute__((__visibility__("default")))  zval_update_constant_no_inline_change(zval **pp , void *arg ) ;
extern int __attribute__((__visibility__("default")))  zval_update_constant_ex(zval **pp , void *arg , zend_class_entry *scope ) ;
__inline static zend_vm_stack ( __attribute__((__always_inline__)) zend_vm_stack_new_page)(int count ) 
{ zend_vm_stack page ;
  void __attribute__((__visibility__("default")))  *tmp ;

  {
  tmp = _emalloc((((sizeof(*page) + 4U) - 1U) & 4294967292U) + sizeof(void *) * (unsigned int )count);
  page = (struct _zend_vm_stack *)tmp;
  page->top = (void **)((char *)page + (((sizeof(struct _zend_vm_stack ) + 4U) - 1U) & 4294967292U));
  page->end = page->top + count;
  page->prev = (struct _zend_vm_stack *)((void *)0);
  return (page);
}
}
__inline static void ( __attribute__((__always_inline__)) zend_vm_stack_init)(void) 
{ 

  {
  executor_globals.argument_stack = zend_vm_stack_new_page(16368);
  return;
}
}
__inline static void ( __attribute__((__always_inline__)) zend_vm_stack_destroy)(void) 
{ zend_vm_stack stack ;
  zend_vm_stack p ;

  {
  stack = executor_globals.argument_stack;
  while ((unsigned int )stack != (unsigned int )((void *)0)) {
    p = stack->prev;
    _efree((void *)stack);
    stack = p;
  }
  return;
}
}
__inline static void ( __attribute__((__always_inline__)) zend_vm_stack_extend)(int count ) 
{ zend_vm_stack p ;
  int tmp ;
  zend_vm_stack tmp___0 ;

  {
  if (count >= 16368) {
    tmp = count;
  } else {
    tmp = 16368;
  }
  tmp___0 = zend_vm_stack_new_page(tmp);
  p = tmp___0;
  p->prev = executor_globals.argument_stack;
  executor_globals.argument_stack = p;
  return;
}
}
__inline static void **( __attribute__((__always_inline__)) zend_vm_stack_top)(void) 
{ 

  {
  return ((executor_globals.argument_stack)->top);
}
}
__inline static void ( __attribute__((__always_inline__)) zend_vm_stack_push)(void *ptr ) 
{ long tmp ;
  void **tmp___0 ;

  {
  while (1) {
    tmp = __builtin_expect((long )(1 > (executor_globals.argument_stack)->end - (executor_globals.argument_stack)->top), 0L);
    if (tmp) {
      zend_vm_stack_extend(1);
    } else {

    }
    break;
  }
  tmp___0 = (executor_globals.argument_stack)->top;
  ((executor_globals.argument_stack)->top) ++;
  *tmp___0 = ptr;
  return;
}
}
__inline static void ( __attribute__((__always_inline__)) zend_vm_stack_push_nocheck)(void *ptr ) 
{ void **tmp ;

  {
  tmp = (executor_globals.argument_stack)->top;
  ((executor_globals.argument_stack)->top) ++;
  *tmp = ptr;
  return;
}
}
__inline static void *( __attribute__((__always_inline__)) zend_vm_stack_pop)(void) 
{ void *el ;
  zend_vm_stack p ;
  long tmp ;

  {
  ((executor_globals.argument_stack)->top) --;
  el = *((executor_globals.argument_stack)->top);
  tmp = __builtin_expect((long )((unsigned int )(executor_globals.argument_stack)->top == (unsigned int )((void **)((char *)executor_globals.argument_stack + (((sizeof(struct _zend_vm_stack ) + 4U) - 1U) & 4294967292U)))), 0L);
  if (tmp) {
    p = executor_globals.argument_stack;
    executor_globals.argument_stack = p->prev;
    _efree((void *)p);
  } else {

  }
  return (el);
}
}
__inline static void *( __attribute__((__always_inline__)) zend_vm_stack_alloc)(size_t size ) 
{ void *ret ;
  int extra ;
  void **old_top ;
  long tmp ;
  long tmp___0 ;

  {
  size = (size + (sizeof(void *) - 1U)) / sizeof(void *);
  if (4U > sizeof(void *)) {
    extra = (int )((4UL - ((unsigned long )(executor_globals.argument_stack)->top & 3UL)) / (unsigned long )sizeof(void *));
    tmp = __builtin_expect((long )((unsigned long )((size + (size_t )extra) + (((sizeof(void *) + 4U) - 1U) & 4294967292U) / sizeof(void *)) > (unsigned long )((executor_globals.argument_stack)->end - (executor_globals.argument_stack)->top)), 0L);
    if (tmp) {
      zend_vm_stack_extend((int )size);
    } else {
      old_top = (executor_globals.argument_stack)->top;
      (executor_globals.argument_stack)->top += extra;
      *((executor_globals.argument_stack)->top) = (void *)old_top;
      (executor_globals.argument_stack)->top += (((sizeof(void *) + 4U) - 1U) & 4294967292U) / sizeof(void *);
    }
  } else {
    while (1) {
      tmp___0 = __builtin_expect((long )((int )size > (executor_globals.argument_stack)->end - (executor_globals.argument_stack)->top), 0L);
      if (tmp___0) {
        zend_vm_stack_extend((int )size);
      } else {

      }
      break;
    }
  }
  ret = (void *)(executor_globals.argument_stack)->top;
  (executor_globals.argument_stack)->top += size;
  return (ret);
}
}
__inline static void ( __attribute__((__always_inline__)) zend_vm_stack_free_int)(void *ptr ) 
{ zend_vm_stack p ;
  long tmp ;

  {
  tmp = __builtin_expect((long )((unsigned int )((void **)((char *)executor_globals.argument_stack + (((sizeof(struct _zend_vm_stack ) + 4U) - 1U) & 4294967292U))) == (unsigned int )((void **)ptr)), 0L);
  if (tmp) {
    p = executor_globals.argument_stack;
    executor_globals.argument_stack = p->prev;
    _efree((void *)p);
  } else {
    (executor_globals.argument_stack)->top = (void **)ptr;
  }
  return;
}
}
__inline static void ( __attribute__((__always_inline__)) zend_vm_stack_free)(void *ptr ) 
{ zend_vm_stack p ;
  long tmp ;

  {
  tmp = __builtin_expect((long )((unsigned int )((void **)((char *)executor_globals.argument_stack + (((sizeof(struct _zend_vm_stack ) + 4U) - 1U) & 4294967292U))) == (unsigned int )((void **)ptr)), 0L);
  if (tmp) {
    p = executor_globals.argument_stack;
    executor_globals.argument_stack = p->prev;
    _efree((void *)p);
  } else {
    if (4U > sizeof(void *)) {
      ptr = (void *)((char *)ptr - (((sizeof(void *) + 4U) - 1U) & 4294967292U));
      (executor_globals.argument_stack)->top = *((void ***)ptr);
    } else {
      (executor_globals.argument_stack)->top = (void **)ptr;
    }
  }
  return;
}
}
__inline static void **( __attribute__((__always_inline__)) zend_vm_stack_push_args)(int count ) 
{ zend_vm_stack p ;
  void *data ;
  zend_vm_stack r ;
  long tmp ;
  int tmp___0 ;
  void **tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  void **tmp___4 ;

  {
  tmp___2 = __builtin_expect((long )((executor_globals.argument_stack)->top - (void **)((char *)executor_globals.argument_stack + (((sizeof(struct _zend_vm_stack ) + 4U) - 1U) & 4294967292U)) < count), 0L);
  if (tmp___2) {
    goto _L;
  } else {
    tmp___3 = __builtin_expect((long )((unsigned int )(executor_globals.argument_stack)->top == (unsigned int )(executor_globals.argument_stack)->end), 0L);
    if (tmp___3) {
      _L: /* CIL Label */ 
      p = executor_globals.argument_stack;
      zend_vm_stack_extend(count + 1);
      (executor_globals.argument_stack)->top += count;
      *((executor_globals.argument_stack)->top) = (void *)((unsigned long )count);
      while (1) {
        tmp___0 = count;
        count --;
        if (tmp___0 > 0) {

        } else {
          break;
        }
        (p->top) --;
        data = *(p->top);
        tmp = __builtin_expect((long )((unsigned int )p->top == (unsigned int )((void **)((char *)p + (((sizeof(struct _zend_vm_stack ) + 4U) - 1U) & 4294967292U)))), 0L);
        if (tmp) {
          r = p;
          (executor_globals.argument_stack)->prev = p->prev;
          p = p->prev;
          _efree((void *)r);
        } else {

        }
        *((void **)((char *)executor_globals.argument_stack + (((sizeof(struct _zend_vm_stack ) + 4U) - 1U) & 4294967292U)) + count) = data;
      }
      tmp___1 = (executor_globals.argument_stack)->top;
      ((executor_globals.argument_stack)->top) ++;
      return (tmp___1);
    } else {

    }
  }
  *((executor_globals.argument_stack)->top) = (void *)((unsigned long )count);
  tmp___4 = (executor_globals.argument_stack)->top;
  ((executor_globals.argument_stack)->top) ++;
  return (tmp___4);
}
}
__inline static void ( __attribute__((__always_inline__)) zend_vm_stack_clear_multiple)(void) 
{ void **p ;
  int delete_count ;
  zval *q ;

  {
  p = (executor_globals.argument_stack)->top - 1;
  delete_count = (int )((unsigned long )*p);
  while (1) {
    delete_count --;
    if (delete_count >= 0) {

    } else {
      break;
    }
    p --;
    q = *((zval **)p);
    *p = (void *)0;
    i_zval_ptr_dtor(q);
  }
  zend_vm_stack_free_int((void *)p);
  return;
}
}
__inline static zval **( __attribute__((__always_inline__)) zend_vm_stack_get_arg)(int requested_arg ) 
{ void **p ;
  int arg_count ;
  long tmp ;

  {
  p = ((executor_globals.current_execute_data)->prev_execute_data)->function_state.arguments;
  arg_count = (int )((unsigned long )*p);
  tmp = __builtin_expect((long )(requested_arg > arg_count), 0L);
  if (tmp) {
    return ((zval **)((void *)0));
  } else {

  }
  return ((((zval **)p - arg_count) + requested_arg) - 1);
}
}
__inline static void ( __attribute__((__always_inline__)) zend_arg_types_stack_2_pop)(zend_ptr_stack *stack , zval **object , zend_function **fbc ) 
{ void *a ;
  void *b ;

  {
  zend_ptr_stack_2_pop(stack, & a, & b);
  *object = (zval *)a;
  *fbc = (zend_function *)b;
  return;
}
}
__inline static void ( __attribute__((__always_inline__)) zend_arg_types_stack_3_pop)(zend_ptr_stack *stack , zend_class_entry **called_scope , zval **object , zend_function **fbc ) 
{ void *a ;
  void *b ;
  void *c ;

  {
  zend_ptr_stack_3_pop(stack, & a, & b, & c);
  *called_scope = (zend_class_entry *)a;
  *object = (zval *)b;
  *fbc = (zend_function *)c;
  return;
}
}
extern void execute_new_code(void) ;
extern char const __attribute__((__visibility__("default")))  *get_active_class_name(char const   **space ) ;
extern char const __attribute__((__visibility__("default")))  *get_active_function_name(void) ;
extern char const __attribute__((__visibility__("default")))  *zend_get_executed_filename(void) ;
extern uint __attribute__((__visibility__("default")))  zend_get_executed_lineno(void) ;
extern zend_bool __attribute__((__visibility__("default")))  zend_is_executing(void) ;
extern void __attribute__((__visibility__("default")))  zend_set_timeout(long seconds , int reset_signals ) ;
extern void __attribute__((__visibility__("default")))  zend_unset_timeout(void) ;
extern void __attribute__((__visibility__("default")))  zend_timeout(int dummy ) ;
extern zend_class_entry __attribute__((__visibility__("default")))  *zend_fetch_class(char const   *class_name , uint class_name_len , int fetch_type ) ;
extern zend_class_entry __attribute__((__visibility__("default")))  *zend_fetch_class_by_name(char const   *class_name , uint class_name_len , zend_literal const   *key , int fetch_type ) ;
extern void zend_verify_abstract_class(zend_class_entry *ce ) ;
zval __attribute__((__visibility__("default")))  **zend_get_compiled_variable_value(zend_execute_data const   *execute_data_ptr , zend_uint var ) ;
int __attribute__((__visibility__("default")))  zend_set_user_opcode_handler(zend_uchar opcode , int (*handler)(zend_execute_data *execute_data ) ) ;
user_opcode_handler_t __attribute__((__visibility__("default")))  zend_get_user_opcode_handler(zend_uchar opcode ) ;
zval __attribute__((__visibility__("default")))  *zend_get_zval_ptr(int op_type , znode_op const   *node , temp_variable const   *Ts , zend_free_op *should_free , int type ) ;
zval __attribute__((__visibility__("default")))  **zend_get_zval_ptr_ptr(int op_type , znode_op const   *node , temp_variable const   *Ts , zend_free_op *should_free , int type ) ;
int __attribute__((__visibility__("default")))  zend_do_fcall(zend_execute_data *execute_data ) ;
extern int __attribute__((__visibility__("default")))  zend_register_list_destructors(void (*ld)(void * ) , void (*pld)(void * ) , int module_number ) ;
extern int __attribute__((__visibility__("default")))  zend_register_list_destructors_ex(void (*ld)(zend_rsrc_list_entry *rsrc ) , void (*pld)(zend_rsrc_list_entry *rsrc ) , char const   *type_name , int module_number ) ;
extern void list_entry_destructor(void *ptr ) ;
extern void plist_entry_destructor(void *ptr ) ;
extern void zend_clean_module_rsrc_dtors(int module_number ) ;
extern int zend_init_rsrc_list(void) ;
extern int zend_init_rsrc_plist(void) ;
extern void zend_destroy_rsrc_list(HashTable *ht ) ;
extern int zend_init_rsrc_list_dtors(void) ;
extern void zend_destroy_rsrc_list_dtors(void) ;
extern int __attribute__((__visibility__("default")))  zend_list_insert(void *ptr , int type ) ;
extern int __attribute__((__visibility__("default")))  _zend_list_addref(int id ) ;
extern int __attribute__((__visibility__("default")))  _zend_list_delete(int id ) ;
extern void __attribute__((__visibility__("default")))  *_zend_list_find(int id , int *type ) ;
extern int __attribute__((__visibility__("default")))  zend_register_resource(zval *rsrc_result , void *rsrc_pointer , int rsrc_type ) ;
extern void __attribute__((__visibility__("default")))  *zend_fetch_resource(zval **passed_id , int default_id , char const   *resource_type_name , int *found_resource_type , int num_resource_types  , ...) ;
extern char const __attribute__((__visibility__("default")))  *zend_rsrc_list_get_rsrc_type(int resource ) ;
extern int __attribute__((__visibility__("default")))  zend_fetch_list_dtor_id(char *type_name ) ;
extern int __attribute__((__visibility__("default")))  le_index_ptr ;
extern int zend_next_free_module(void) ;
extern int __attribute__((__visibility__("default")))  zend_get_parameters(int ht , int param_count  , ...) ;
extern int __attribute__((__visibility__("default")))  _zend_get_parameters_array(int ht , int param_count , zval **argument_array ) ;
extern int __attribute__((__visibility__("default"), __deprecated__))  zend_get_parameters_ex(int param_count  , ...) ;
extern int __attribute__((__visibility__("default")))  _zend_get_parameters_array_ex(int param_count , zval ***argument_array ) ;
extern int __attribute__((__visibility__("default")))  zend_copy_parameters_array(int param_count , zval *argument_array ) ;
extern int __attribute__((__visibility__("default")))  zend_parse_parameters(int num_args , char const   *type_spec  , ...) ;
extern int __attribute__((__visibility__("default")))  zend_parse_parameters_ex(int flags , int num_args , char const   *type_spec  , ...) ;
extern char __attribute__((__visibility__("default")))  *zend_zval_type_name(zval const   *arg ) ;
extern int __attribute__((__visibility__("default")))  zend_parse_method_parameters(int num_args , zval *this_ptr , char const   *type_spec  , ...) ;
extern int __attribute__((__visibility__("default")))  zend_parse_method_parameters_ex(int flags , int num_args , zval *this_ptr , char const   *type_spec  , ...) ;
extern int __attribute__((__visibility__("default")))  zend_register_functions(zend_class_entry *scope , zend_function_entry const   *functions , HashTable *function_table , int type ) ;
extern void __attribute__((__visibility__("default")))  zend_unregister_functions(zend_function_entry const   *functions , int count , HashTable *function_table ) ;
extern int __attribute__((__visibility__("default")))  zend_startup_module(zend_module_entry *module_entry ) ;
extern zend_module_entry __attribute__((__visibility__("default")))  *zend_register_internal_module(zend_module_entry *module_entry ) ;
extern zend_module_entry __attribute__((__visibility__("default")))  *zend_register_module_ex(zend_module_entry *module ) ;
extern int __attribute__((__visibility__("default")))  zend_startup_module_ex(zend_module_entry *module ) ;
extern int __attribute__((__visibility__("default")))  zend_startup_modules(void) ;
extern void __attribute__((__visibility__("default")))  zend_collect_module_handlers(void) ;
extern void __attribute__((__visibility__("default")))  zend_destroy_modules(void) ;
extern void __attribute__((__visibility__("default")))  zend_check_magic_method_implementation(zend_class_entry const   *ce , zend_function const   *fptr , int error_type ) ;
extern zend_class_entry __attribute__((__visibility__("default")))  *zend_register_internal_class(zend_class_entry *class_entry ) ;
extern zend_class_entry __attribute__((__visibility__("default")))  *zend_register_internal_class_ex(zend_class_entry *class_entry , zend_class_entry *parent_ce , char *parent_name ) ;
extern zend_class_entry __attribute__((__visibility__("default")))  *zend_register_internal_interface(zend_class_entry *orig_class_entry ) ;
extern void __attribute__((__visibility__("default")))  zend_class_implements(zend_class_entry *class_entry , int num_interfaces  , ...) ;
extern int __attribute__((__visibility__("default")))  zend_register_class_alias_ex(char const   *name , int name_len , zend_class_entry *ce ) ;
extern int __attribute__((__visibility__("default")))  zend_disable_function(char *function_name , uint function_name_length ) ;
extern int __attribute__((__visibility__("default")))  zend_disable_class(char *class_name , uint class_name_length ) ;
extern void __attribute__((__visibility__("default")))  zend_wrong_param_count(void) ;
extern zend_bool __attribute__((__visibility__("default")))  zend_is_callable_ex(zval *callable , zval *object_ptr , uint check_flags , char **callable_name , int *callable_name_len , zend_fcall_info_cache *fcc , char **error ) ;
extern zend_bool __attribute__((__visibility__("default")))  zend_is_callable(zval *callable , uint check_flags , char **callable_name ) ;
extern zend_bool __attribute__((__visibility__("default")))  zend_make_callable(zval *callable , char **callable_name ) ;
extern char const __attribute__((__visibility__("default")))  *zend_get_module_version(char const   *module_name ) ;
extern int __attribute__((__visibility__("default")))  zend_get_module_started(char const   *module_name ) ;
extern int __attribute__((__visibility__("default")))  zend_declare_property(zend_class_entry *ce , char const   *name , int name_length , zval *property , int access_type ) ;
extern int __attribute__((__visibility__("default")))  zend_declare_property_ex(zend_class_entry *ce , char const   *name , int name_length , zval *property , int access_type , char const   *doc_comment , int doc_comment_len ) ;
extern int __attribute__((__visibility__("default")))  zend_declare_property_null(zend_class_entry *ce , char const   *name , int name_length , int access_type ) ;
extern int __attribute__((__visibility__("default")))  zend_declare_property_bool(zend_class_entry *ce , char const   *name , int name_length , long value , int access_type ) ;
extern int __attribute__((__visibility__("default")))  zend_declare_property_long(zend_class_entry *ce , char const   *name , int name_length , long value , int access_type ) ;
extern int __attribute__((__visibility__("default")))  zend_declare_property_double(zend_class_entry *ce , char const   *name , int name_length , double value , int access_type ) ;
extern int __attribute__((__visibility__("default")))  zend_declare_property_string(zend_class_entry *ce , char const   *name , int name_length , char const   *value , int access_type ) ;
extern int __attribute__((__visibility__("default")))  zend_declare_property_stringl(zend_class_entry *ce , char const   *name , int name_length , char const   *value , int value_len , int access_type ) ;
extern int __attribute__((__visibility__("default")))  zend_declare_class_constant(zend_class_entry *ce , char const   *name , size_t name_length , zval *value ) ;
extern int __attribute__((__visibility__("default")))  zend_declare_class_constant_null(zend_class_entry *ce , char const   *name , size_t name_length ) ;
extern int __attribute__((__visibility__("default")))  zend_declare_class_constant_long(zend_class_entry *ce , char const   *name , size_t name_length , long value ) ;
extern int __attribute__((__visibility__("default")))  zend_declare_class_constant_bool(zend_class_entry *ce , char const   *name , size_t name_length , zend_bool value ) ;
extern int __attribute__((__visibility__("default")))  zend_declare_class_constant_double(zend_class_entry *ce , char const   *name , size_t name_length , double value ) ;
extern int __attribute__((__visibility__("default")))  zend_declare_class_constant_stringl(zend_class_entry *ce , char const   *name , size_t name_length , char const   *value , size_t value_length ) ;
extern int __attribute__((__visibility__("default")))  zend_declare_class_constant_string(zend_class_entry *ce , char const   *name , size_t name_length , char const   *value ) ;
extern void __attribute__((__visibility__("default")))  zend_update_class_constants(zend_class_entry *class_type ) ;
extern void __attribute__((__visibility__("default")))  zend_update_property(zend_class_entry *scope , zval *object , char const   *name , int name_length , zval *value ) ;
extern void __attribute__((__visibility__("default")))  zend_update_property_null(zend_class_entry *scope , zval *object , char const   *name , int name_length ) ;
extern void __attribute__((__visibility__("default")))  zend_update_property_bool(zend_class_entry *scope , zval *object , char const   *name , int name_length , long value ) ;
extern void __attribute__((__visibility__("default")))  zend_update_property_long(zend_class_entry *scope , zval *object , char const   *name , int name_length , long value ) ;
extern void __attribute__((__visibility__("default")))  zend_update_property_double(zend_class_entry *scope , zval *object , char const   *name , int name_length , double value ) ;
extern void __attribute__((__visibility__("default")))  zend_update_property_string(zend_class_entry *scope , zval *object , char const   *name , int name_length , char const   *value ) ;
extern void __attribute__((__visibility__("default")))  zend_update_property_stringl(zend_class_entry *scope , zval *object , char const   *name , int name_length , char const   *value , int value_length ) ;
extern int __attribute__((__visibility__("default")))  zend_update_static_property(zend_class_entry *scope , char const   *name , int name_length , zval *value ) ;
extern int __attribute__((__visibility__("default")))  zend_update_static_property_null(zend_class_entry *scope , char const   *name , int name_length ) ;
extern int __attribute__((__visibility__("default")))  zend_update_static_property_bool(zend_class_entry *scope , char const   *name , int name_length , long value ) ;
extern int __attribute__((__visibility__("default")))  zend_update_static_property_long(zend_class_entry *scope , char const   *name , int name_length , long value ) ;
extern int __attribute__((__visibility__("default")))  zend_update_static_property_double(zend_class_entry *scope , char const   *name , int name_length , double value ) ;
extern int __attribute__((__visibility__("default")))  zend_update_static_property_string(zend_class_entry *scope , char const   *name , int name_length , char const   *value ) ;
extern int __attribute__((__visibility__("default")))  zend_update_static_property_stringl(zend_class_entry *scope , char const   *name , int name_length , char const   *value , int value_length ) ;
extern zval __attribute__((__visibility__("default")))  *zend_read_property(zend_class_entry *scope , zval *object , char const   *name , int name_length , zend_bool silent ) ;
extern zval __attribute__((__visibility__("default")))  *zend_read_static_property(zend_class_entry *scope , char const   *name , int name_length , zend_bool silent ) ;
extern zend_class_entry __attribute__((__visibility__("default")))  *zend_get_class_entry(zval const   *zobject ) ;
extern int __attribute__((__visibility__("default")))  zend_get_object_classname(zval const   *object , char const   **class_name , zend_uint *class_name_len ) ;
extern char __attribute__((__visibility__("default")))  *zend_get_type_by_const(int type ) ;
extern int __attribute__((__visibility__("default")))  _array_init(zval *arg , uint size ) ;
extern int __attribute__((__visibility__("default")))  _object_init(zval *arg ) ;
extern int __attribute__((__visibility__("default")))  _object_init_ex(zval *arg , zend_class_entry *ce ) ;
extern int __attribute__((__visibility__("default")))  _object_and_properties_init(zval *arg , zend_class_entry *ce , HashTable *properties ) ;
extern void __attribute__((__visibility__("default")))  object_properties_init(zend_object *object , zend_class_entry *class_type ) ;
extern void __attribute__((__visibility__("default")))  zend_merge_properties(zval *obj , HashTable *properties , int destroy_ht ) ;
extern int __attribute__((__visibility__("default")))  add_assoc_function(zval *arg , char const   *key , void (*function_ptr)(int ht , zval *return_value , zval **return_value_ptr , zval *this_ptr , int return_value_used ) ) ;
extern int __attribute__((__visibility__("default")))  add_assoc_long_ex(zval *arg , char const   *key , uint key_len , long n ) ;
extern int __attribute__((__visibility__("default")))  add_assoc_null_ex(zval *arg , char const   *key , uint key_len ) ;
extern int __attribute__((__visibility__("default")))  add_assoc_bool_ex(zval *arg , char const   *key , uint key_len , int b ) ;
extern int __attribute__((__visibility__("default")))  add_assoc_resource_ex(zval *arg , char const   *key , uint key_len , int r ) ;
extern int __attribute__((__visibility__("default")))  add_assoc_double_ex(zval *arg , char const   *key , uint key_len , double d ) ;
extern int __attribute__((__visibility__("default")))  add_assoc_string_ex(zval *arg , char const   *key , uint key_len , char *str , int duplicate ) ;
extern int __attribute__((__visibility__("default")))  add_assoc_stringl_ex(zval *arg , char const   *key , uint key_len , char *str , uint length , int duplicate ) ;
extern int __attribute__((__visibility__("default")))  add_assoc_zval_ex(zval *arg , char const   *key , uint key_len , zval *value ) ;
extern int __attribute__((__visibility__("default")))  add_index_long(zval *arg , ulong idx , long n ) ;
extern int __attribute__((__visibility__("default")))  add_index_null(zval *arg , ulong idx ) ;
extern int __attribute__((__visibility__("default")))  add_index_bool(zval *arg , ulong idx , int b ) ;
extern int __attribute__((__visibility__("default")))  add_index_resource(zval *arg , ulong idx , int r ) ;
extern int __attribute__((__visibility__("default")))  add_index_double(zval *arg , ulong idx , double d ) ;
extern int __attribute__((__visibility__("default")))  add_index_string(zval *arg , ulong idx , char const   *str , int duplicate ) ;
extern int __attribute__((__visibility__("default")))  add_index_stringl(zval *arg , ulong idx , char const   *str , uint length , int duplicate ) ;
extern int __attribute__((__visibility__("default")))  add_index_zval(zval *arg , ulong index , zval *value ) ;
extern int __attribute__((__visibility__("default")))  add_next_index_long(zval *arg , long n ) ;
extern int __attribute__((__visibility__("default")))  add_next_index_null(zval *arg ) ;
extern int __attribute__((__visibility__("default")))  add_next_index_bool(zval *arg , int b ) ;
extern int __attribute__((__visibility__("default")))  add_next_index_resource(zval *arg , int r ) ;
extern int __attribute__((__visibility__("default")))  add_next_index_double(zval *arg , double d ) ;
extern int __attribute__((__visibility__("default")))  add_next_index_string(zval *arg , char const   *str , int duplicate ) ;
extern int __attribute__((__visibility__("default")))  add_next_index_stringl(zval *arg , char const   *str , uint length , int duplicate ) ;
extern int __attribute__((__visibility__("default")))  add_next_index_zval(zval *arg , zval *value ) ;
extern int __attribute__((__visibility__("default")))  add_get_assoc_string_ex(zval *arg , char const   *key , uint key_len , char const   *str , void **dest , int duplicate ) ;
extern int __attribute__((__visibility__("default")))  add_get_assoc_stringl_ex(zval *arg , char const   *key , uint key_len , char const   *str , uint length , void **dest , int duplicate ) ;
extern int __attribute__((__visibility__("default")))  add_get_index_long(zval *arg , ulong idx , long l , void **dest ) ;
extern int __attribute__((__visibility__("default")))  add_get_index_double(zval *arg , ulong idx , double d , void **dest ) ;
extern int __attribute__((__visibility__("default")))  add_get_index_string(zval *arg , ulong idx , char const   *str , void **dest , int duplicate ) ;
extern int __attribute__((__visibility__("default")))  add_get_index_stringl(zval *arg , ulong idx , char const   *str , uint length , void **dest , int duplicate ) ;
extern int __attribute__((__visibility__("default")))  add_property_long_ex(zval *arg , char const   *key , uint key_len , long l ) ;
extern int __attribute__((__visibility__("default")))  add_property_null_ex(zval *arg , char const   *key , uint key_len ) ;
extern int __attribute__((__visibility__("default")))  add_property_bool_ex(zval *arg , char const   *key , uint key_len , int b ) ;
extern int __attribute__((__visibility__("default")))  add_property_resource_ex(zval *arg , char const   *key , uint key_len , long r ) ;
extern int __attribute__((__visibility__("default")))  add_property_double_ex(zval *arg , char const   *key , uint key_len , double d ) ;
extern int __attribute__((__visibility__("default")))  add_property_string_ex(zval *arg , char const   *key , uint key_len , char const   *str , int duplicate ) ;
extern int __attribute__((__visibility__("default")))  add_property_stringl_ex(zval *arg , char const   *key , uint key_len , char const   *str , uint length , int duplicate ) ;
extern int __attribute__((__visibility__("default")))  add_property_zval_ex(zval *arg , char const   *key , uint key_len , zval *value ) ;
extern int __attribute__((__visibility__("default")))  call_user_function(HashTable *function_table , zval **object_pp , zval *function_name , zval *retval_ptr , zend_uint param_count , zval **params ) ;
extern int __attribute__((__visibility__("default")))  call_user_function_ex(HashTable *function_table , zval **object_pp , zval *function_name , zval **retval_ptr_ptr , zend_uint param_count , zval ***params , int no_separation , HashTable *symbol_table ) ;
extern zend_fcall_info const __attribute__((__visibility__("default")))  empty_fcall_info ;
extern zend_fcall_info_cache const __attribute__((__visibility__("default")))  empty_fcall_info_cache ;
extern int __attribute__((__visibility__("default")))  zend_fcall_info_init(zval *callable , uint check_flags , zend_fcall_info *fci , zend_fcall_info_cache *fcc , char **callable_name , char **error ) ;
extern void __attribute__((__visibility__("default")))  zend_fcall_info_args_clear(zend_fcall_info *fci , int free_mem ) ;
extern void __attribute__((__visibility__("default")))  zend_fcall_info_args_save(zend_fcall_info *fci , int *param_count , zval ****params ) ;
extern void __attribute__((__visibility__("default")))  zend_fcall_info_args_restore(zend_fcall_info *fci , int param_count , zval ***params ) ;
extern int __attribute__((__visibility__("default")))  zend_fcall_info_args(zend_fcall_info *fci , zval *args ) ;
extern int __attribute__((__visibility__("default")))  zend_fcall_info_argp(zend_fcall_info *fci , int argc , zval ***argv ) ;
extern int __attribute__((__visibility__("default")))  zend_fcall_info_argv(zend_fcall_info *fci , int argc , va_list *argv ) ;
extern int __attribute__((__visibility__("default")))  zend_fcall_info_argn(zend_fcall_info *fci , int argc  , ...) ;
extern int __attribute__((__visibility__("default")))  zend_fcall_info_call(zend_fcall_info *fci , zend_fcall_info_cache *fcc , zval **retval , zval *args ) ;
extern int __attribute__((__visibility__("default")))  zend_call_function(zend_fcall_info *fci , zend_fcall_info_cache *fci_cache ) ;
extern int __attribute__((__visibility__("default")))  zend_set_hash_symbol(zval *symbol , char const   *name , int name_length , zend_bool is_ref , int num_symbol_tables  , ...) ;
extern void __attribute__((__visibility__("default")))  zend_delete_variable(zend_execute_data *ex , HashTable *ht , char const   *name , int name_len , ulong hash_value ) ;
extern int __attribute__((__visibility__("default")))  zend_delete_global_variable(char const   *name , int name_len ) ;
extern int __attribute__((__visibility__("default")))  zend_delete_global_variable_ex(char const   *name , int name_len , ulong hash_value ) ;
extern void __attribute__((__visibility__("default")))  zend_reset_all_cv(HashTable *symbol_table ) ;
extern void __attribute__((__visibility__("default")))  zend_rebuild_symbol_table(void) ;
extern void __attribute__((__visibility__("default")))  zif_display_disabled_function(int ht , zval *return_value , zval **return_value_ptr , zval *this_ptr , int return_value_used ) ;
extern void __attribute__((__visibility__("default")))  zif_display_disabled_class(int ht , zval *return_value , zval **return_value_ptr , zval *this_ptr , int return_value_used ) ;
extern void clean_module_constants(int module_number ) ;
extern void free_zend_constant(zend_constant *c ) ;
extern int zend_startup_constants(void) ;
extern int zend_shutdown_constants(void) ;
extern void zend_register_standard_constants(void) ;
extern void clean_non_persistent_constants(void) ;
extern int __attribute__((__visibility__("default")))  zend_get_constant(char const   *name , uint name_len , zval *result ) ;
extern int __attribute__((__visibility__("default")))  zend_get_constant_ex(char const   *name , uint name_len , zval *result , zend_class_entry *scope , ulong flags ) ;
extern void __attribute__((__visibility__("default")))  zend_register_long_constant(char const   *name , uint name_len , long lval , int flags , int module_number ) ;
extern void __attribute__((__visibility__("default")))  zend_register_double_constant(char const   *name , uint name_len , double dval , int flags , int module_number ) ;
extern void __attribute__((__visibility__("default")))  zend_register_string_constant(char const   *name , uint name_len , char *strval , int flags , int module_number ) ;
extern void __attribute__((__visibility__("default")))  zend_register_stringl_constant(char const   *name , uint name_len , char *strval , uint strlen , int flags , int module_number ) ;
extern int __attribute__((__visibility__("default")))  zend_register_constant(zend_constant *c ) ;
extern void zend_copy_constants(HashTable *target , HashTable *sourc ) ;
extern void copy_zend_constant(zend_constant *c ) ;
extern zend_constant *zend_quick_get_constant(zend_literal const   *key , ulong flags ) ;
extern int __attribute__((__visibility__("default")))  zend_get_resource_handle(zend_extension *extension ) ;
extern void __attribute__((__visibility__("default")))  zend_extension_dispatch_message(int message , void *arg ) ;
extern zend_llist __attribute__((__visibility__("default")))  zend_extensions ;
extern void zend_extension_dtor(zend_extension *extension ) ;
extern void zend_append_version_info(zend_extension const   *extension ) ;
extern int zend_startup_extensions_mechanism(void) ;
extern int zend_startup_extensions(void) ;
extern void zend_shutdown_extensions(void) ;
extern int __attribute__((__visibility__("default")))  zend_load_extension(char const   *path ) ;
extern int __attribute__((__visibility__("default")))  zend_register_extension(zend_extension *new_extension , void *handle ) ;
extern zend_extension __attribute__((__visibility__("default")))  *zend_get_extension(char const   *extension_name ) ;
extern int __attribute__((__visibility__("default")))  zend_ini_startup(void) ;
extern int __attribute__((__visibility__("default")))  zend_ini_shutdown(void) ;
extern int __attribute__((__visibility__("default")))  zend_ini_global_shutdown(void) ;
extern int __attribute__((__visibility__("default")))  zend_ini_deactivate(void) ;
extern int __attribute__((__visibility__("default")))  zend_copy_ini_directives(void) ;
extern void __attribute__((__visibility__("default")))  zend_ini_sort_entries(void) ;
extern int __attribute__((__visibility__("default")))  zend_register_ini_entries(zend_ini_entry const   *ini_entry , int module_number ) ;
extern void __attribute__((__visibility__("default")))  zend_unregister_ini_entries(int module_number ) ;
extern void __attribute__((__visibility__("default")))  zend_ini_refresh_caches(int stage ) ;
extern int __attribute__((__visibility__("default")))  zend_alter_ini_entry(char *name , uint name_length , char *new_value , uint new_value_length , int modify_type , int stage ) ;
extern int __attribute__((__visibility__("default")))  zend_alter_ini_entry_ex(char *name , uint name_length , char *new_value , uint new_value_length , int modify_type , int stage , int force_change ) ;
extern int __attribute__((__visibility__("default")))  zend_restore_ini_entry(char *name , uint name_length , int stage ) ;
extern void __attribute__((__visibility__("default")))  display_ini_entries(zend_module_entry *module ) ;
extern long __attribute__((__visibility__("default")))  zend_ini_long(char *name , uint name_length , int orig ) ;
extern double __attribute__((__visibility__("default")))  zend_ini_double(char *name , uint name_length , int orig ) ;
extern char __attribute__((__visibility__("default")))  *zend_ini_string(char *name , uint name_length , int orig ) ;
extern char __attribute__((__visibility__("default")))  *zend_ini_string_ex(char *name , uint name_length , int orig , zend_bool *exists ) ;
extern int __attribute__((__visibility__("default")))  zend_ini_register_displayer(char *name , uint name_length , void (*displayer)(zend_ini_entry *ini_entry , int type ) ) ;
extern void __attribute__((__visibility__("default")))  zend_ini_boolean_displayer_cb(zend_ini_entry *ini_entry , int type ) ;
extern void __attribute__((__visibility__("default")))  zend_ini_color_displayer_cb(zend_ini_entry *ini_entry , int type ) ;
extern void __attribute__((__visibility__("default")))  display_link_numbers(zend_ini_entry *ini_entry , int type ) ;
extern int __attribute__((__visibility__("default")))  OnUpdateBool(zend_ini_entry *entry , char *new_value , uint new_value_length , void *mh_arg1 , void *mh_arg2 , void *mh_arg3 , int stage ) ;
extern int __attribute__((__visibility__("default")))  OnUpdateLong(zend_ini_entry *entry , char *new_value , uint new_value_length , void *mh_arg1 , void *mh_arg2 , void *mh_arg3 , int stage ) ;
extern int __attribute__((__visibility__("default")))  OnUpdateLongGEZero(zend_ini_entry *entry , char *new_value , uint new_value_length , void *mh_arg1 , void *mh_arg2 , void *mh_arg3 , int stage ) ;
extern int __attribute__((__visibility__("default")))  OnUpdateReal(zend_ini_entry *entry , char *new_value , uint new_value_length , void *mh_arg1 , void *mh_arg2 , void *mh_arg3 , int stage ) ;
extern int __attribute__((__visibility__("default")))  OnUpdateString(zend_ini_entry *entry , char *new_value , uint new_value_length , void *mh_arg1 , void *mh_arg2 , void *mh_arg3 , int stage ) ;
extern int __attribute__((__visibility__("default")))  OnUpdateStringUnempty(zend_ini_entry *entry , char *new_value , uint new_value_length , void *mh_arg1 , void *mh_arg2 , void *mh_arg3 , int stage ) ;
extern int __attribute__((__visibility__("default")))  zend_parse_ini_file(zend_file_handle *fh , zend_bool unbuffered_errors , int scanner_mode , void (*ini_parser_cb)(zval *arg1 , zval *arg2 , zval *arg3 , int callback_type , void *arg ) , void *arg ) ;
extern int __attribute__((__visibility__("default")))  zend_parse_ini_string(char *str , zend_bool unbuffered_errors , int scanner_mode , void (*ini_parser_cb)(zval *arg1 , zval *arg2 , zval *arg3 , int callback_type , void *arg ) , void *arg ) ;
extern void __attribute__((__visibility__("default")))  zend_exception_set_previous(zval *exception , zval *add_previous ) ;
extern void __attribute__((__visibility__("default")))  zend_exception_save(void) ;
extern void __attribute__((__visibility__("default")))  zend_exception_restore(void) ;
extern void zend_throw_exception_internal(zval *exception ) ;
extern void zend_register_default_exception(void) ;
extern zend_class_entry __attribute__((__visibility__("default")))  *zend_exception_get_default(void) ;
extern zend_class_entry __attribute__((__visibility__("default")))  *zend_get_error_exception(void) ;
extern void __attribute__((__visibility__("default")))  zend_register_default_classes(void) ;
extern zval __attribute__((__visibility__("default")))  *zend_throw_exception(zend_class_entry *exception_ce , char *message , long code ) ;
extern zval __attribute__((__visibility__("default")))  *zend_throw_exception_ex(zend_class_entry *exception_ce , long code , char *format  , ...) ;
extern void __attribute__((__visibility__("default")))  zend_throw_exception_object(zval *exception ) ;
extern void __attribute__((__visibility__("default")))  zend_clear_exception(void) ;
extern zval __attribute__((__visibility__("default")))  *zend_throw_error_exception(zend_class_entry *exception_ce , char *message , long code , int severity ) ;
extern void __attribute__((__visibility__("default")))  (*zend_throw_exception_hook)(zval *ex ) ;
extern void __attribute__((__visibility__("default")))  zend_exception_error(zval *exception , int severity ) ;
extern int zend_spprintf(char **message , int max_len , char *format  , ...) ;
extern zend_class_entry __attribute__((__visibility__("default")))  *zend_ce_traversable ;
extern zend_class_entry __attribute__((__visibility__("default")))  *zend_ce_aggregate ;
extern zend_class_entry __attribute__((__visibility__("default")))  *zend_ce_iterator ;
extern zend_class_entry __attribute__((__visibility__("default")))  *zend_ce_arrayaccess ;
extern zend_class_entry __attribute__((__visibility__("default")))  *zend_ce_serializable ;
extern zval __attribute__((__visibility__("default")))  *zend_call_method(zval **object_pp , zend_class_entry *obj_ce , zend_function **fn_proxy , char const   *function_name , int function_name_len , zval **retval_ptr_ptr , int param_count , zval *arg1 , zval *arg2 ) ;
extern void __attribute__((__visibility__("default")))  zend_user_it_rewind(zend_object_iterator *_iter ) ;
extern int __attribute__((__visibility__("default")))  zend_user_it_valid(zend_object_iterator *_iter ) ;
extern int __attribute__((__visibility__("default")))  zend_user_it_get_current_key(zend_object_iterator *_iter , char **str_key , uint *str_key_len , ulong *int_key ) ;
extern void __attribute__((__visibility__("default")))  zend_user_it_get_current_data(zend_object_iterator *_iter , zval ***data ) ;
extern void __attribute__((__visibility__("default")))  zend_user_it_move_forward(zend_object_iterator *_iter ) ;
extern void __attribute__((__visibility__("default")))  zend_user_it_invalidate_current(zend_object_iterator *_iter ) ;
extern zval __attribute__((__visibility__("default")))  *zend_user_it_new_iterator(zend_class_entry *ce , zval *object ) ;
extern zend_object_iterator __attribute__((__visibility__("default")))  *zend_user_it_get_new_iterator(zend_class_entry *ce , zval *object , int by_ref ) ;
extern void __attribute__((__visibility__("default")))  zend_register_interfaces(void) ;
extern int __attribute__((__visibility__("default")))  zend_user_serialize(zval *object , unsigned char **buffer , zend_uint *buf_len , zend_serialize_data *data ) ;
extern int __attribute__((__visibility__("default")))  zend_user_unserialize(zval **object , zend_class_entry *ce , unsigned char const   *buf , zend_uint buf_len , zend_unserialize_data *data ) ;
extern int __attribute__((__visibility__("default")))  zend_class_serialize_deny(zval *object , unsigned char **buffer , zend_uint *buf_len , zend_serialize_data *data ) ;
extern int __attribute__((__visibility__("default")))  zend_class_unserialize_deny(zval **object , zend_class_entry *ce , unsigned char const   *buf , zend_uint buf_len , zend_unserialize_data *data ) ;
extern void zend_register_closure_ce(void) ;
extern zend_class_entry __attribute__((__visibility__("default")))  *zend_ce_closure ;
extern void __attribute__((__visibility__("default")))  zend_create_closure(zval *res , zend_function *op_array , zend_class_entry *scope , zval *this_ptr ) ;
extern zend_function __attribute__((__visibility__("default")))  *zend_get_closure_invoke_method(zval *obj ) ;
extern zend_function const __attribute__((__visibility__("default")))  *zend_get_closure_method_def(zval *obj ) ;
extern zval __attribute__((__visibility__("default")))  *zend_get_closure_this_ptr(zval *obj ) ;
extern void __attribute__((__visibility__("default")))  zend_vm_use_old_executor(void) ;
void __attribute__((__visibility__("default")))  zend_vm_set_opcode_handler(zend_op *op ) ;
extern  __attribute__((__nothrow__)) int access(char const   *__name , int __type )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int faccessat(int __fd , char const   *__file , int __type , int __flag )  __attribute__((__nonnull__(2))) ;
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
extern int close(int __fd ) ;
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off_t __offset ) ;
extern ssize_t pwrite(int __fd , void const   *__buf , size_t __n , __off_t __offset ) ;
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
extern unsigned int sleep(unsigned int __seconds ) ;
extern  __attribute__((__nothrow__)) __useconds_t ualarm(__useconds_t __value , __useconds_t __interval ) ;
extern int usleep(__useconds_t __useconds ) ;
extern int pause(void) ;
extern  __attribute__((__nothrow__)) int chown(char const   *__file , __uid_t __owner , __gid_t __group )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int fchown(int __fd , __uid_t __owner , __gid_t __group ) ;
extern  __attribute__((__nothrow__)) int lchown(char const   *__file , __uid_t __owner , __gid_t __group )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int fchownat(int __fd , char const   *__file , __uid_t __owner , __gid_t __group , int __flag )  __attribute__((__nonnull__(2))) ;
extern  __attribute__((__nothrow__)) int chdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int fchdir(int __fd ) ;
extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size ) ;
extern  __attribute__((__nothrow__)) char *getwd(char *__buf )  __attribute__((__nonnull__(1), __deprecated__)) ;
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
extern char **__environ ;
extern  __attribute__((__nothrow__)) int execve(char const   *__path , char * const  *__argv , char * const  *__envp )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) int fexecve(int __fd , char * const  *__argv , char * const  *__envp )  __attribute__((__nonnull__(2))) ;
extern  __attribute__((__nothrow__)) int execv(char const   *__path , char * const  *__argv )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) int execle(char const   *__path , char const   *__arg  , ...)  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) int execl(char const   *__path , char const   *__arg  , ...)  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) int execvp(char const   *__file , char * const  *__argv )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) int execlp(char const   *__file , char const   *__arg  , ...)  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) int nice(int __inc ) ;
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
extern  __attribute__((__nothrow__)) long pathconf(char const   *__path , int __name )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) long fpathconf(int __fd , int __name ) ;
extern  __attribute__((__nothrow__)) long sysconf(int __name ) ;
extern  __attribute__((__nothrow__)) size_t confstr(int __name , char *__buf , size_t __len ) ;
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
extern  __attribute__((__nothrow__)) __pid_t getppid(void) ;
extern  __attribute__((__nothrow__)) __pid_t getpgrp(void) ;
extern  __attribute__((__nothrow__)) __pid_t __getpgid(__pid_t __pid ) ;
extern  __attribute__((__nothrow__)) __pid_t getpgid(__pid_t __pid ) ;
extern  __attribute__((__nothrow__)) int setpgid(__pid_t __pid , __pid_t __pgid ) ;
extern  __attribute__((__nothrow__)) int setpgrp(void) ;
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
extern  __attribute__((__nothrow__)) __pid_t getsid(__pid_t __pid ) ;
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
extern  __attribute__((__nothrow__)) __gid_t getgid(void) ;
extern  __attribute__((__nothrow__)) __gid_t getegid(void) ;
extern  __attribute__((__nothrow__)) int getgroups(int __size , __gid_t *__list ) ;
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
extern  __attribute__((__nothrow__)) int setreuid(__uid_t __ruid , __uid_t __euid ) ;
extern  __attribute__((__nothrow__)) int seteuid(__uid_t __uid ) ;
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
extern  __attribute__((__nothrow__)) int setregid(__gid_t __rgid , __gid_t __egid ) ;
extern  __attribute__((__nothrow__)) int setegid(__gid_t __gid ) ;
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
extern  __attribute__((__nothrow__)) __pid_t vfork(void) ;
extern  __attribute__((__nothrow__)) char *ttyname(int __fd ) ;
extern  __attribute__((__nothrow__)) int ttyname_r(int __fd , char *__buf , size_t __buflen )  __attribute__((__nonnull__(2))) ;
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
extern  __attribute__((__nothrow__)) int ttyslot(void) ;
extern  __attribute__((__nothrow__)) int link(char const   *__from , char const   *__to )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) int linkat(int __fromfd , char const   *__from , int __tofd , char const   *__to , int __flags )  __attribute__((__nonnull__(2,4))) ;
extern  __attribute__((__nothrow__)) int symlink(char const   *__from , char const   *__to )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) ssize_t readlink(char const   * __restrict  __path , char * __restrict  __buf , size_t __len )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) int symlinkat(char const   *__from , int __tofd , char const   *__to )  __attribute__((__nonnull__(1,3))) ;
extern  __attribute__((__nothrow__)) ssize_t readlinkat(int __fd , char const   * __restrict  __path , char * __restrict  __buf , size_t __len )  __attribute__((__nonnull__(2,3))) ;
extern  __attribute__((__nothrow__)) int unlink(char const   *__name )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int unlinkat(int __fd , char const   *__name , int __flag )  __attribute__((__nonnull__(2))) ;
extern  __attribute__((__nothrow__)) int rmdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) __pid_t tcgetpgrp(int __fd ) ;
extern  __attribute__((__nothrow__)) int tcsetpgrp(int __fd , __pid_t __pgrp_id ) ;
extern char *getlogin(void) ;
extern int getlogin_r(char *__name , size_t __name_len )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int setlogin(char const   *__name )  __attribute__((__nonnull__(1))) ;
extern char *optarg ;
extern int optind ;
extern int opterr ;
extern int optopt ;
extern  __attribute__((__nothrow__)) int getopt(int ___argc , char * const  *___argv , char const   *__shortopts ) ;
extern  __attribute__((__nothrow__)) int gethostname(char *__name , size_t __len )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int sethostname(char const   *__name , size_t __len )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int sethostid(long __id ) ;
extern  __attribute__((__nothrow__)) int getdomainname(char *__name , size_t __len )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int setdomainname(char const   *__name , size_t __len )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int vhangup(void) ;
extern  __attribute__((__nothrow__)) int revoke(char const   *__file )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int profil(unsigned short *__sample_buffer , size_t __size , size_t __offset , unsigned int __scale )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int acct(char const   *__name ) ;
extern  __attribute__((__nothrow__)) char *getusershell(void) ;
extern  __attribute__((__nothrow__)) void endusershell(void) ;
extern  __attribute__((__nothrow__)) void setusershell(void) ;
extern  __attribute__((__nothrow__)) int daemon(int __nochdir , int __noclose ) ;
extern  __attribute__((__nothrow__)) int chroot(char const   *__path )  __attribute__((__nonnull__(1))) ;
extern char *getpass(char const   *__prompt )  __attribute__((__nonnull__(1))) ;
extern int fsync(int __fd ) ;
extern long gethostid(void) ;
extern  __attribute__((__nothrow__)) void sync(void) ;
extern  __attribute__((__nothrow__)) int getpagesize(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int getdtablesize(void) ;
extern  __attribute__((__nothrow__)) int truncate(char const   *__file , __off_t __length )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int ftruncate(int __fd , __off_t __length ) ;
extern  __attribute__((__nothrow__)) int brk(void *__addr ) ;
extern  __attribute__((__nothrow__)) void *sbrk(intptr_t __delta ) ;
extern  __attribute__((__nothrow__)) long syscall(long __sysno  , ...) ;
extern int lockf(int __fd , int __cmd , __off_t __len ) ;
extern int fdatasync(int __fildes ) ;
__inline extern  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
__inline extern  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
__inline extern  __attribute__((__nothrow__)) int fstatat(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf , int __flag )  __attribute__((__nonnull__(2,3))) ;
__inline extern  __attribute__((__nothrow__)) int lstat(char const   * __restrict  __path , struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) int chmod(char const   *__file , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int lchmod(char const   *__file , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int fchmod(int __fd , __mode_t __mode ) ;
extern  __attribute__((__nothrow__)) int fchmodat(int __fd , char const   *__file , __mode_t __mode , int __flag )  __attribute__((__nonnull__(2))) ;
extern  __attribute__((__nothrow__)) __mode_t umask(__mode_t __mask ) ;
extern  __attribute__((__nothrow__)) int mkdir(char const   *__path , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int mkdirat(int __fd , char const   *__path , __mode_t __mode )  __attribute__((__nonnull__(2))) ;
__inline extern  __attribute__((__nothrow__)) int mknod(char const   *__path , __mode_t __mode , __dev_t __dev )  __attribute__((__nonnull__(1))) ;
__inline extern  __attribute__((__nothrow__)) int mknodat(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev )  __attribute__((__nonnull__(2))) ;
extern  __attribute__((__nothrow__)) int mkfifo(char const   *__path , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int mkfifoat(int __fd , char const   *__path , __mode_t __mode )  __attribute__((__nonnull__(2))) ;
extern  __attribute__((__nothrow__)) int utimensat(int __fd , char const   *__path , struct timespec  const  *__times , int __flags )  __attribute__((__nonnull__(2))) ;
extern  __attribute__((__nothrow__)) int futimens(int __fd , struct timespec  const  *__times ) ;
extern  __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf )  __attribute__((__nonnull__(3))) ;
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename , struct stat *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
extern  __attribute__((__nothrow__)) int __lxstat(int __ver , char const   *__filename , struct stat *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
extern  __attribute__((__nothrow__)) int __fxstatat(int __ver , int __fildes , char const   *__filename , struct stat *__stat_buf , int __flag )  __attribute__((__nonnull__(3,4))) ;
extern  __attribute__((__nothrow__)) int __xmknod(int __ver , char const   *__path , __mode_t __mode , __dev_t *__dev )  __attribute__((__nonnull__(2,4))) ;
extern  __attribute__((__nothrow__)) int __xmknodat(int __ver , int __fd , char const   *__path , __mode_t __mode , __dev_t *__dev )  __attribute__((__nonnull__(3,5))) ;
__inline extern  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
__inline extern int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ int tmp ;

  {
  tmp = __xstat(3, (char const   *)__path, (struct stat *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int lstat(char const   * __restrict  __path , struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
__inline extern int lstat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ int tmp ;

  {
  tmp = __lxstat(3, (char const   *)__path, (struct stat *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
__inline extern int fstat(int __fd , struct stat *__statbuf ) 
{ int tmp ;

  {
  tmp = __fxstat(3, __fd, __statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int fstatat(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf , int __flag )  __attribute__((__nonnull__(2,3))) ;
__inline extern int fstatat(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf , int __flag ) 
{ int tmp ;

  {
  tmp = __fxstatat(3, __fd, (char const   *)__filename, (struct stat *)__statbuf, __flag);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int mknod(char const   *__path , __mode_t __mode , __dev_t __dev )  __attribute__((__nonnull__(1))) ;
__inline extern int mknod(char const   *__path , __mode_t __mode , __dev_t __dev ) 
{ int tmp ;

  {
  tmp = __xmknod(1, __path, __mode, & __dev);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int mknodat(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev )  __attribute__((__nonnull__(2))) ;
__inline extern int mknodat(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) 
{ int tmp ;

  {
  tmp = __xmknodat(1, __fd, __path, __mode, & __dev);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_toupper_loc(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int isalnum(int  ) ;
extern  __attribute__((__nothrow__)) int isalpha(int  ) ;
extern  __attribute__((__nothrow__)) int iscntrl(int  ) ;
extern  __attribute__((__nothrow__)) int isdigit(int  ) ;
extern  __attribute__((__nothrow__)) int islower(int  ) ;
extern  __attribute__((__nothrow__)) int isgraph(int  ) ;
extern  __attribute__((__nothrow__)) int isprint(int  ) ;
extern  __attribute__((__nothrow__)) int ispunct(int  ) ;
extern  __attribute__((__nothrow__)) int isspace(int  ) ;
extern  __attribute__((__nothrow__)) int isupper(int  ) ;
extern  __attribute__((__nothrow__)) int isxdigit(int  ) ;
__inline extern  __attribute__((__nothrow__)) int tolower(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int toupper(int __c ) ;
extern  __attribute__((__nothrow__)) int isblank(int  ) ;
extern  __attribute__((__nothrow__)) int isascii(int __c ) ;
extern  __attribute__((__nothrow__)) int toascii(int __c ) ;
extern  __attribute__((__nothrow__)) int _toupper(int  ) ;
extern  __attribute__((__nothrow__)) int _tolower(int  ) ;
__inline extern  __attribute__((__nothrow__)) int tolower(int __c ) ;
__inline extern int tolower(int __c ) 
{ __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
  if (__c >= -128) {
    if (__c < 256) {
      tmp = __ctype_tolower_loc();
      tmp___0 = *(*tmp + __c);
    } else {
      tmp___0 = (int const   )__c;
    }
  } else {
    tmp___0 = (int const   )__c;
  }
  return ((int )tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) int toupper(int __c ) ;
__inline extern int toupper(int __c ) 
{ __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
  if (__c >= -128) {
    if (__c < 256) {
      tmp = __ctype_toupper_loc();
      tmp___0 = *(*tmp + __c);
    } else {
      tmp___0 = (int const   )__c;
    }
  } else {
    tmp___0 = (int const   )__c;
  }
  return ((int )tmp___0);
}
}
extern  __attribute__((__nothrow__)) int isalnum_l(int  , __locale_t  ) ;
extern  __attribute__((__nothrow__)) int isalpha_l(int  , __locale_t  ) ;
extern  __attribute__((__nothrow__)) int iscntrl_l(int  , __locale_t  ) ;
extern  __attribute__((__nothrow__)) int isdigit_l(int  , __locale_t  ) ;
extern  __attribute__((__nothrow__)) int islower_l(int  , __locale_t  ) ;
extern  __attribute__((__nothrow__)) int isgraph_l(int  , __locale_t  ) ;
extern  __attribute__((__nothrow__)) int isprint_l(int  , __locale_t  ) ;
extern  __attribute__((__nothrow__)) int ispunct_l(int  , __locale_t  ) ;
extern  __attribute__((__nothrow__)) int isspace_l(int  , __locale_t  ) ;
extern  __attribute__((__nothrow__)) int isupper_l(int  , __locale_t  ) ;
extern  __attribute__((__nothrow__)) int isxdigit_l(int  , __locale_t  ) ;
extern  __attribute__((__nothrow__)) int isblank_l(int  , __locale_t  ) ;
extern  __attribute__((__nothrow__)) int __tolower_l(int __c , __locale_t __l ) ;
extern  __attribute__((__nothrow__)) int tolower_l(int __c , __locale_t __l ) ;
extern  __attribute__((__nothrow__)) int __toupper_l(int __c , __locale_t __l ) ;
extern  __attribute__((__nothrow__)) int toupper_l(int __c , __locale_t __l ) ;
extern  __attribute__((__nothrow__)) int utime(char const   *__file , struct utimbuf  const  *__file_times )  __attribute__((__nonnull__(1))) ;
extern DIR *opendir(char const   *__name )  __attribute__((__nonnull__(1))) ;
extern DIR *fdopendir(int __fd ) ;
extern int closedir(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
extern struct dirent *readdir(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
extern int readdir_r(DIR * __restrict  __dirp , struct dirent * __restrict  __entry , struct dirent ** __restrict  __result )  __attribute__((__nonnull__(1,2,3))) ;
extern  __attribute__((__nothrow__)) void rewinddir(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) void seekdir(DIR *__dirp , long __pos )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) long telldir(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int dirfd(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
extern int scandir(char const   * __restrict  __dir , struct dirent *** __restrict  __namelist , int (*__selector)(struct dirent  const  * ) , int (*__cmp)(struct dirent  const  ** , struct dirent  const  ** ) )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) int alphasort(struct dirent  const  **__e1 , struct dirent  const  **__e2 )  __attribute__((__pure__, __nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) __ssize_t getdirentries(int __fd , char * __restrict  __buf , size_t __nbytes , __off_t * __restrict  __basep )  __attribute__((__nonnull__(2,4))) ;
extern void __attribute__((__visibility__("default")))  virtual_cwd_startup(void) ;
extern void __attribute__((__visibility__("default")))  virtual_cwd_shutdown(void) ;
extern char __attribute__((__visibility__("default")))  *virtual_getcwd_ex(size_t *length ) ;
extern char __attribute__((__visibility__("default")))  *virtual_getcwd(char *buf , size_t size ) ;
extern int __attribute__((__visibility__("default")))  virtual_chdir(char const   *path ) ;
extern int __attribute__((__visibility__("default")))  virtual_chdir_file(char const   *path , int (*p_chdir)(char const   *path ) ) ;
extern int __attribute__((__visibility__("default")))  virtual_filepath(char const   *path , char **filepath ) ;
extern int __attribute__((__visibility__("default")))  virtual_filepath_ex(char const   *path , char **filepath , int (*verify_path)(cwd_state const   * ) ) ;
extern char __attribute__((__visibility__("default")))  *virtual_realpath(char const   *path , char *real_path ) ;
extern FILE __attribute__((__visibility__("default")))  *virtual_fopen(char const   *path , char const   *mode ) ;
extern int __attribute__((__visibility__("default")))  virtual_open(char const   *path , int flags  , ...) ;
extern int __attribute__((__visibility__("default")))  virtual_creat(char const   *path , mode_t mode ) ;
extern int __attribute__((__visibility__("default")))  virtual_rename(char *oldname , char *newname ) ;
extern int __attribute__((__visibility__("default")))  virtual_stat(char const   *path , struct stat *buf ) ;
extern int __attribute__((__visibility__("default")))  virtual_lstat(char const   *path , struct stat *buf ) ;
extern int __attribute__((__visibility__("default")))  virtual_unlink(char const   *path ) ;
extern int __attribute__((__visibility__("default")))  virtual_mkdir(char const   *pathname , mode_t mode ) ;
extern int __attribute__((__visibility__("default")))  virtual_rmdir(char const   *pathname ) ;
extern DIR __attribute__((__visibility__("default")))  *virtual_opendir(char const   *pathname ) ;
extern FILE __attribute__((__visibility__("default")))  *virtual_popen(char const   *command , char const   *type ) ;
extern int __attribute__((__visibility__("default")))  virtual_access(char const   *pathname , int mode ) ;
extern int __attribute__((__visibility__("default")))  virtual_utime(char const   *filename , struct utimbuf *buf ) ;
extern int __attribute__((__visibility__("default")))  virtual_chmod(char const   *filename , mode_t mode ) ;
extern int __attribute__((__visibility__("default")))  virtual_chown(char const   *filename , uid_t owner , gid_t group , int link ) ;
extern int __attribute__((__visibility__("default")))  virtual_file_ex(cwd_state *state , char const   *path , int (*verify_path)(cwd_state const   * ) , int use_realpath ) ;
extern char __attribute__((__visibility__("default")))  *tsrm_realpath(char const   *path , char *real_path ) ;
extern virtual_cwd_globals cwd_globals ;
extern void __attribute__((__visibility__("default")))  realpath_cache_clean(void) ;
extern void __attribute__((__visibility__("default")))  realpath_cache_del(char const   *path , int path_len ) ;
extern realpath_cache_bucket __attribute__((__visibility__("default")))  *realpath_cache_lookup(char const   *path , int path_len , time_t t ) ;
extern int __attribute__((__visibility__("default")))  realpath_cache_size(void) ;
extern int __attribute__((__visibility__("default")))  realpath_cache_max_buckets(void) ;
extern realpath_cache_bucket __attribute__((__visibility__("default")))  **realpath_cache_get_buckets(void) ;
static void zend_extension_statement_handler(zend_extension const   *extension , zend_op_array *op_array ) ;
static void zend_extension_fcall_begin_handler(zend_extension const   *extension , zend_op_array *op_array ) ;
static void zend_extension_fcall_end_handler(zend_extension const   *extension , zend_op_array *op_array ) ;
__inline static void ( __attribute__((__always_inline__)) zend_pzval_unlock_func)(zval *z , zend_free_op *should_free , int unref ) 
{ zend_bool tmp ;
  zend_uint tmp___0 ;
  zend_uint tmp___1 ;

  {
  tmp___1 = zval_delref_p(z);
  if (tmp___1) {
    should_free->var = (zval *)0;
    if (unref) {
      tmp = zval_isref_p(z);
      if (tmp) {
        tmp___0 = zval_refcount_p(z);
        if (tmp___0 == 1U) {
          zval_unset_isref_p(z);
        } else {

        }
      } else {

      }
    } else {

    }
    gc_zval_check_possible_root(z);
  } else {
    zval_set_refcount_p(z, 1U);
    zval_unset_isref_p(z);
    should_free->var = z;
  }
  return;
}
}
__inline static void ( __attribute__((__always_inline__)) zend_pzval_unlock_free_func)(zval *z ) 
{ zend_uint tmp ;

  {
  tmp = zval_delref_p(z);
  if (tmp) {

  } else {
    if ((unsigned int )z != (unsigned int )(& executor_globals.uninitialized_zval)) {
      if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
        gc_remove_zval_from_buffer(z);
      } else {

      }
      _zval_dtor(z);
      _efree((void *)z);
    } else {

    }
  }
  return;
}
}
zval __attribute__((__visibility__("default")))  **zend_get_compiled_variable_value(zend_execute_data const   *execute_data_ptr , zend_uint var ) 
{ 

  {
  return ((zval __attribute__((__visibility__("default")))  **)*(execute_data_ptr->CVs + var));
}
}
__inline static zval *( __attribute__((__always_inline__)) _get_zval_ptr_tmp)(zend_uint var , temp_variable const   *Ts , zend_free_op *should_free ) 
{ zval *tmp ;

  {
  tmp = & ((temp_variable *)((char *)Ts + var))->tmp_var;
  should_free->var = tmp;
  return (tmp);
}
}
__inline static zval *( __attribute__((__always_inline__)) _get_zval_ptr_var)(zend_uint var , temp_variable const   *Ts , zend_free_op *should_free ) 
{ zval *ptr ;

  {
  ptr = ((temp_variable *)((char *)Ts + var))->var.ptr;
  zend_pzval_unlock_func(ptr, should_free, 1);
  return (ptr);
}
}
static zval **( __attribute__((__noinline__)) _get_zval_cv_lookup)(zval ***ptr , zend_uint var , int type ) 
{ zend_compiled_variable *cv ;
  int __attribute__((__visibility__("default")))  tmp ;

  {
  cv = (executor_globals.active_op_array)->vars + var;
  if (! executor_globals.active_symbol_table) {
    goto _L;
  } else {
    tmp = zend_hash_quick_find((HashTable const   *)executor_globals.active_symbol_table, cv->name, (unsigned int )(cv->name_len + 1), cv->hash_value, (void **)ptr);
    if (tmp == (int __attribute__((__visibility__("default")))  )-1) {
      _L: /* CIL Label */ 
      switch (type) {
      case 0: 
      case 6: 
      zend_error(1 << 3L, "Undefined variable: %s", cv->name);
      case 3: 
      return (& executor_globals.uninitialized_zval_ptr);
      break;
      case 2: 
      zend_error(1 << 3L, "Undefined variable: %s", cv->name);
      case 1: 
      zval_addref_p(& executor_globals.uninitialized_zval);
      if (! executor_globals.active_symbol_table) {
        *ptr = (zval **)(executor_globals.current_execute_data)->CVs + ((zend_uint )(executor_globals.active_op_array)->last_var + var);
        *(*ptr) = & executor_globals.uninitialized_zval;
      } else {
        _zend_hash_quick_add_or_update(executor_globals.active_symbol_table, cv->name, (unsigned int )(cv->name_len + 1), cv->hash_value, (void *)(& executor_globals.uninitialized_zval_ptr), sizeof(zval *), (void **)ptr, 1);
      }
      break;
      }
    } else {

    }
  }
  return (*ptr);
}
}
static zval **( __attribute__((__noinline__)) _get_zval_cv_lookup_BP_VAR_R)(zval ***ptr , zend_uint var ) 
{ zend_compiled_variable *cv ;
  int __attribute__((__visibility__("default")))  tmp ;

  {
  cv = (executor_globals.active_op_array)->vars + var;
  if (! executor_globals.active_symbol_table) {
    zend_error(1 << 3L, "Undefined variable: %s", cv->name);
    return (& executor_globals.uninitialized_zval_ptr);
  } else {
    tmp = zend_hash_quick_find((HashTable const   *)executor_globals.active_symbol_table, cv->name, (unsigned int )(cv->name_len + 1), cv->hash_value, (void **)ptr);
    if (tmp == (int __attribute__((__visibility__("default")))  )-1) {
      zend_error(1 << 3L, "Undefined variable: %s", cv->name);
      return (& executor_globals.uninitialized_zval_ptr);
    } else {

    }
  }
  return (*ptr);
}
}
static zval **( __attribute__((__noinline__)) _get_zval_cv_lookup_BP_VAR_UNSET)(zval ***ptr , zend_uint var ) 
{ zend_compiled_variable *cv ;
  int __attribute__((__visibility__("default")))  tmp ;

  {
  cv = (executor_globals.active_op_array)->vars + var;
  if (! executor_globals.active_symbol_table) {
    zend_error(1 << 3L, "Undefined variable: %s", cv->name);
    return (& executor_globals.uninitialized_zval_ptr);
  } else {
    tmp = zend_hash_quick_find((HashTable const   *)executor_globals.active_symbol_table, cv->name, (unsigned int )(cv->name_len + 1), cv->hash_value, (void **)ptr);
    if (tmp == (int __attribute__((__visibility__("default")))  )-1) {
      zend_error(1 << 3L, "Undefined variable: %s", cv->name);
      return (& executor_globals.uninitialized_zval_ptr);
    } else {

    }
  }
  return (*ptr);
}
}
static zval **( __attribute__((__noinline__)) _get_zval_cv_lookup_BP_VAR_IS)(zval ***ptr , zend_uint var ) 
{ zend_compiled_variable *cv ;
  int __attribute__((__visibility__("default")))  tmp ;

  {
  cv = (executor_globals.active_op_array)->vars + var;
  if (! executor_globals.active_symbol_table) {
    return (& executor_globals.uninitialized_zval_ptr);
  } else {
    tmp = zend_hash_quick_find((HashTable const   *)executor_globals.active_symbol_table, cv->name, (unsigned int )(cv->name_len + 1), cv->hash_value, (void **)ptr);
    if (tmp == (int __attribute__((__visibility__("default")))  )-1) {
      return (& executor_globals.uninitialized_zval_ptr);
    } else {

    }
  }
  return (*ptr);
}
}
static zval **( __attribute__((__noinline__)) _get_zval_cv_lookup_BP_VAR_RW)(zval ***ptr , zend_uint var ) 
{ zend_compiled_variable *cv ;
  int __attribute__((__visibility__("default")))  tmp ;

  {
  cv = (executor_globals.active_op_array)->vars + var;
  if (! executor_globals.active_symbol_table) {
    zval_addref_p(& executor_globals.uninitialized_zval);
    *ptr = (zval **)(executor_globals.current_execute_data)->CVs + ((zend_uint )(executor_globals.active_op_array)->last_var + var);
    *(*ptr) = & executor_globals.uninitialized_zval;
    zend_error(1 << 3L, "Undefined variable: %s", cv->name);
  } else {
    tmp = zend_hash_quick_find((HashTable const   *)executor_globals.active_symbol_table, cv->name, (unsigned int )(cv->name_len + 1), cv->hash_value, (void **)ptr);
    if (tmp == (int __attribute__((__visibility__("default")))  )-1) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      _zend_hash_quick_add_or_update(executor_globals.active_symbol_table, cv->name, (unsigned int )(cv->name_len + 1), cv->hash_value, (void *)(& executor_globals.uninitialized_zval_ptr), sizeof(zval *), (void **)ptr, 1);
      zend_error(1 << 3L, "Undefined variable: %s", cv->name);
    } else {

    }
  }
  return (*ptr);
}
}
static zval **( __attribute__((__noinline__)) _get_zval_cv_lookup_BP_VAR_W)(zval ***ptr , zend_uint var ) 
{ zend_compiled_variable *cv ;
  int __attribute__((__visibility__("default")))  tmp ;

  {
  cv = (executor_globals.active_op_array)->vars + var;
  if (! executor_globals.active_symbol_table) {
    zval_addref_p(& executor_globals.uninitialized_zval);
    *ptr = (zval **)(executor_globals.current_execute_data)->CVs + ((zend_uint )(executor_globals.active_op_array)->last_var + var);
    *(*ptr) = & executor_globals.uninitialized_zval;
  } else {
    tmp = zend_hash_quick_find((HashTable const   *)executor_globals.active_symbol_table, cv->name, (unsigned int )(cv->name_len + 1), cv->hash_value, (void **)ptr);
    if (tmp == (int __attribute__((__visibility__("default")))  )-1) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      _zend_hash_quick_add_or_update(executor_globals.active_symbol_table, cv->name, (unsigned int )(cv->name_len + 1), cv->hash_value, (void *)(& executor_globals.uninitialized_zval_ptr), sizeof(zval *), (void **)ptr, 1);
    } else {

    }
  }
  return (*ptr);
}
}
__inline static zval *( __attribute__((__always_inline__)) _get_zval_ptr_cv)(zend_uint var , int type ) 
{ zval ***ptr ;
  zval **tmp ;
  long tmp___0 ;

  {
  ptr = (executor_globals.current_execute_data)->CVs + var;
  tmp___0 = __builtin_expect((long )((unsigned int )*ptr == (unsigned int )((void *)0)), 0L);
  if (tmp___0) {
    tmp = _get_zval_cv_lookup(ptr, var, type);
    return (*tmp);
  } else {

  }
  return (*(*ptr));
}
}
__inline static zval *( __attribute__((__always_inline__)) _get_zval_ptr_cv_BP_VAR_R)(zval ***CVs , zend_uint var ) 
{ zval ***ptr ;
  zval **tmp ;
  long tmp___0 ;

  {
  ptr = CVs + var;
  tmp___0 = __builtin_expect((long )((unsigned int )*ptr == (unsigned int )((void *)0)), 0L);
  if (tmp___0) {
    tmp = _get_zval_cv_lookup_BP_VAR_R(ptr, var);
    return (*tmp);
  } else {

  }
  return (*(*ptr));
}
}
__inline static zval *( __attribute__((__always_inline__)) _get_zval_ptr_cv_BP_VAR_UNSET)(zval ***CVs , zend_uint var ) 
{ zval ***ptr ;
  zval **tmp ;
  long tmp___0 ;

  {
  ptr = CVs + var;
  tmp___0 = __builtin_expect((long )((unsigned int )*ptr == (unsigned int )((void *)0)), 0L);
  if (tmp___0) {
    tmp = _get_zval_cv_lookup_BP_VAR_UNSET(ptr, var);
    return (*tmp);
  } else {

  }
  return (*(*ptr));
}
}
__inline static zval *( __attribute__((__always_inline__)) _get_zval_ptr_cv_BP_VAR_IS)(zval ***CVs , zend_uint var ) 
{ zval ***ptr ;
  zval **tmp ;
  long tmp___0 ;

  {
  ptr = CVs + var;
  tmp___0 = __builtin_expect((long )((unsigned int )*ptr == (unsigned int )((void *)0)), 0L);
  if (tmp___0) {
    tmp = _get_zval_cv_lookup_BP_VAR_IS(ptr, var);
    return (*tmp);
  } else {

  }
  return (*(*ptr));
}
}
__inline static zval *( __attribute__((__always_inline__)) _get_zval_ptr_cv_BP_VAR_RW)(zval ***CVs , zend_uint var ) 
{ zval ***ptr ;
  zval **tmp ;
  long tmp___0 ;

  {
  ptr = CVs + var;
  tmp___0 = __builtin_expect((long )((unsigned int )*ptr == (unsigned int )((void *)0)), 0L);
  if (tmp___0) {
    tmp = _get_zval_cv_lookup_BP_VAR_RW(ptr, var);
    return (*tmp);
  } else {

  }
  return (*(*ptr));
}
}
__inline static zval *( __attribute__((__always_inline__)) _get_zval_ptr_cv_BP_VAR_W)(zval ***CVs , zend_uint var ) 
{ zval ***ptr ;
  zval **tmp ;
  long tmp___0 ;

  {
  ptr = CVs + var;
  tmp___0 = __builtin_expect((long )((unsigned int )*ptr == (unsigned int )((void *)0)), 0L);
  if (tmp___0) {
    tmp = _get_zval_cv_lookup_BP_VAR_W(ptr, var);
    return (*tmp);
  } else {

  }
  return (*(*ptr));
}
}
__inline static zval *_get_zval_ptr(int op_type , znode_op const   *node , temp_variable const   *Ts , zend_free_op *should_free , int type ) 
{ zval *tmp ;
  zval *tmp___0 ;

  {
  switch (op_type) {
  case 1: 
  should_free->var = (zval *)0;
  return ((zval *)node->zv);
  break;
  case 1 << 1: 
  should_free->var = (zval *)((unsigned long )(& ((temp_variable *)((char *)Ts + node->var))->tmp_var) | 1UL);
  return (& ((temp_variable *)((char *)Ts + node->var))->tmp_var);
  break;
  case 1 << 2: 
  tmp = _get_zval_ptr_var((unsigned int )node->var, Ts, should_free);
  return (tmp);
  break;
  case 1 << 3: 
  should_free->var = (zval *)0;
  return ((zval *)((void *)0));
  break;
  case 1 << 4: 
  should_free->var = (zval *)0;
  tmp___0 = _get_zval_ptr_cv((unsigned int )node->var, type);
  return (tmp___0);
  break;
  }
  return ((zval *)((void *)0));
}
}
__inline static zval **( __attribute__((__always_inline__)) _get_zval_ptr_ptr_var)(zend_uint var , temp_variable const   *Ts , zend_free_op *should_free ) 
{ zval **ptr_ptr ;
  long tmp ;

  {
  ptr_ptr = ((temp_variable *)((char *)Ts + var))->var.ptr_ptr;
  tmp = __builtin_expect((long )((unsigned int )ptr_ptr != (unsigned int )((void *)0)), 1L);
  if (tmp) {
    zend_pzval_unlock_func(*ptr_ptr, should_free, 1);
  } else {
    zend_pzval_unlock_func(((temp_variable *)((char *)Ts + var))->str_offset.str, should_free, 1);
  }
  return (ptr_ptr);
}
}
__inline static zval **( __attribute__((__always_inline__)) _get_zval_ptr_ptr_cv)(zend_uint var , int type ) 
{ zval ***ptr ;
  zval **tmp ;
  long tmp___0 ;

  {
  ptr = (executor_globals.current_execute_data)->CVs + var;
  tmp___0 = __builtin_expect((long )((unsigned int )*ptr == (unsigned int )((void *)0)), 0L);
  if (tmp___0) {
    tmp = _get_zval_cv_lookup(ptr, var, type);
    return (tmp);
  } else {

  }
  return (*ptr);
}
}
__inline static zval **( __attribute__((__always_inline__)) _get_zval_ptr_ptr_cv_BP_VAR_R)(zval ***CVs , zend_uint var ) 
{ zval ***ptr ;
  zval **tmp ;
  long tmp___0 ;

  {
  ptr = CVs + var;
  tmp___0 = __builtin_expect((long )((unsigned int )*ptr == (unsigned int )((void *)0)), 0L);
  if (tmp___0) {
    tmp = _get_zval_cv_lookup_BP_VAR_R(ptr, var);
    return (tmp);
  } else {

  }
  return (*ptr);
}
}
__inline static zval **( __attribute__((__always_inline__)) _get_zval_ptr_ptr_cv_BP_VAR_UNSET)(zval ***CVs , zend_uint var ) 
{ zval ***ptr ;
  zval **tmp ;
  long tmp___0 ;

  {
  ptr = CVs + var;
  tmp___0 = __builtin_expect((long )((unsigned int )*ptr == (unsigned int )((void *)0)), 0L);
  if (tmp___0) {
    tmp = _get_zval_cv_lookup_BP_VAR_UNSET(ptr, var);
    return (tmp);
  } else {

  }
  return (*ptr);
}
}
__inline static zval **( __attribute__((__always_inline__)) _get_zval_ptr_ptr_cv_BP_VAR_IS)(zval ***CVs , zend_uint var ) 
{ zval ***ptr ;
  zval **tmp ;
  long tmp___0 ;

  {
  ptr = CVs + var;
  tmp___0 = __builtin_expect((long )((unsigned int )*ptr == (unsigned int )((void *)0)), 0L);
  if (tmp___0) {
    tmp = _get_zval_cv_lookup_BP_VAR_IS(ptr, var);
    return (tmp);
  } else {

  }
  return (*ptr);
}
}
__inline static zval **( __attribute__((__always_inline__)) _get_zval_ptr_ptr_cv_BP_VAR_RW)(zval ***CVs , zend_uint var ) 
{ zval ***ptr ;
  zval **tmp ;
  long tmp___0 ;

  {
  ptr = CVs + var;
  tmp___0 = __builtin_expect((long )((unsigned int )*ptr == (unsigned int )((void *)0)), 0L);
  if (tmp___0) {
    tmp = _get_zval_cv_lookup_BP_VAR_RW(ptr, var);
    return (tmp);
  } else {

  }
  return (*ptr);
}
}
__inline static zval **( __attribute__((__always_inline__)) _get_zval_ptr_ptr_cv_BP_VAR_W)(zval ***CVs , zend_uint var ) 
{ zval ***ptr ;
  zval **tmp ;
  long tmp___0 ;

  {
  ptr = CVs + var;
  tmp___0 = __builtin_expect((long )((unsigned int )*ptr == (unsigned int )((void *)0)), 0L);
  if (tmp___0) {
    tmp = _get_zval_cv_lookup_BP_VAR_W(ptr, var);
    return (tmp);
  } else {

  }
  return (*ptr);
}
}
__inline static zval **_get_zval_ptr_ptr(int op_type , znode_op const   *node , temp_variable const   *Ts , zend_free_op *should_free , int type ) 
{ zval **tmp ;
  zval **tmp___0 ;

  {
  if (op_type == 1 << 4) {
    should_free->var = (zval *)0;
    tmp = _get_zval_ptr_ptr_cv((unsigned int )node->var, type);
    return (tmp);
  } else {
    if (op_type == 1 << 2) {
      tmp___0 = _get_zval_ptr_ptr_var((unsigned int )node->var, Ts, should_free);
      return (tmp___0);
    } else {
      should_free->var = (zval *)0;
      return ((zval **)((void *)0));
    }
  }
}
}
__inline static zval *( __attribute__((__always_inline__)) _get_obj_zval_ptr_unused)(void) 
{ long tmp ;

  {
  tmp = __builtin_expect((long )((unsigned int )executor_globals.This != (unsigned int )((void *)0)), 1L);
  if (tmp) {
    return (executor_globals.This);
  } else {
    zend_error_noreturn(1, "Using $this when not in object context");
    return ((zval *)((void *)0));
  }
}
}
__inline static zval **_get_obj_zval_ptr_ptr(int op_type , znode_op const   *op , temp_variable const   *Ts , zend_free_op *should_free , int type ) 
{ long tmp ;
  zval **tmp___0 ;

  {
  if (op_type == 1 << 3) {
    tmp = __builtin_expect((long )((unsigned int )executor_globals.This != (unsigned int )((void *)0)), 1L);
    if (tmp) {
      should_free->var = (zval *)0;
      return (& executor_globals.This);
    } else {
      zend_error_noreturn(1, "Using $this when not in object context");
    }
  } else {

  }
  tmp___0 = _get_zval_ptr_ptr(op_type, op, Ts, should_free, type);
  return (tmp___0);
}
}
__inline static zval **( __attribute__((__always_inline__)) _get_obj_zval_ptr_ptr_unused)(void) 
{ long tmp ;

  {
  tmp = __builtin_expect((long )((unsigned int )executor_globals.This != (unsigned int )((void *)0)), 1L);
  if (tmp) {
    return (& executor_globals.This);
  } else {
    zend_error_noreturn(1, "Using $this when not in object context");
    return ((zval **)((void *)0));
  }
}
}
__inline static zval *_get_obj_zval_ptr(int op_type , znode_op *op , temp_variable const   *Ts , zend_free_op *should_free , int type ) 
{ long tmp ;
  zval *tmp___0 ;

  {
  if (op_type == 1 << 3) {
    tmp = __builtin_expect((long )((unsigned int )executor_globals.This != (unsigned int )((void *)0)), 1L);
    if (tmp) {
      should_free->var = (zval *)0;
      return (executor_globals.This);
    } else {
      zend_error_noreturn(1, "Using $this when not in object context");
    }
  } else {

  }
  tmp___0 = _get_zval_ptr(op_type, (znode_op const   *)op, Ts, should_free, type);
  return (tmp___0);
}
}
static void zend_assign_to_variable_reference(zval **variable_ptr_ptr , zval **value_ptr_ptr ) 
{ zval *variable_ptr ;
  zval *value_ptr ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_uint tmp___3 ;
  zend_uint tmp___4 ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  zend_uint tmp___6 ;
  zend_bool tmp___7 ;

  {
  variable_ptr = *variable_ptr_ptr;
  value_ptr = *value_ptr_ptr;
  if ((unsigned int )variable_ptr == (unsigned int )(& executor_globals.error_zval)) {
    variable_ptr_ptr = & executor_globals.uninitialized_zval_ptr;
  } else {
    if ((unsigned int )value_ptr == (unsigned int )(& executor_globals.error_zval)) {
      variable_ptr_ptr = & executor_globals.uninitialized_zval_ptr;
    } else {
      if ((unsigned int )variable_ptr != (unsigned int )value_ptr) {
        tmp___1 = zval_isref_p(value_ptr);
        if (tmp___1) {

        } else {
          zval_delref_p(value_ptr);
          tmp___0 = zval_refcount_p(value_ptr);
          if (tmp___0 > 0U) {
            while (1) {
              tmp = _emalloc(sizeof(zval_gc_info ));
              *value_ptr_ptr = (zval *)tmp;
              ((zval_gc_info *)*value_ptr_ptr)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              (*value_ptr_ptr)->value = value_ptr->value;
              (*value_ptr_ptr)->type = value_ptr->type;
              break;
            }
            value_ptr = *value_ptr_ptr;
            _zval_copy_ctor(value_ptr);
          } else {

          }
          zval_set_refcount_p(value_ptr, 1U);
          zval_set_isref_p(value_ptr);
        }
        *variable_ptr_ptr = value_ptr;
        zval_addref_p(value_ptr);
        i_zval_ptr_dtor(variable_ptr);
      } else {
        tmp___7 = zval_isref_p(variable_ptr);
        if (tmp___7) {

        } else {
          if ((unsigned int )variable_ptr_ptr == (unsigned int )value_ptr_ptr) {
            while (1) {
              tmp___3 = zval_refcount_p(*variable_ptr_ptr);
              if (tmp___3 > 1U) {
                zval_delref_p(*variable_ptr_ptr);
                while (1) {
                  tmp___2 = _emalloc(sizeof(zval_gc_info ));
                  new_zv = (zval *)tmp___2;
                  ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                  break;
                }
                while (1) {
                  while (1) {
                    new_zv->value = (*variable_ptr_ptr)->value;
                    new_zv->type = (*variable_ptr_ptr)->type;
                    break;
                  }
                  zval_set_refcount_p(new_zv, 1U);
                  zval_unset_isref_p(new_zv);
                  break;
                }
                *variable_ptr_ptr = new_zv;
                _zval_copy_ctor(new_zv);
              } else {

              }
              break;
            }
          } else {
            if ((unsigned int )variable_ptr == (unsigned int )(& executor_globals.uninitialized_zval)) {
              goto _L;
            } else {
              tmp___6 = zval_refcount_p(variable_ptr);
              if (tmp___6 > 2U) {
                _L: /* CIL Label */ 
                tmp___4 = zval_refcount_p(variable_ptr);
                zval_set_refcount_p(variable_ptr, tmp___4 - 2U);
                while (1) {
                  tmp___5 = _emalloc(sizeof(zval_gc_info ));
                  *variable_ptr_ptr = (zval *)tmp___5;
                  ((zval_gc_info *)*variable_ptr_ptr)->u.buffered = (gc_root_buffer *)((void *)0);
                  break;
                }
                while (1) {
                  (*variable_ptr_ptr)->value = variable_ptr->value;
                  (*variable_ptr_ptr)->type = variable_ptr->type;
                  break;
                }
                _zval_copy_ctor(*variable_ptr_ptr);
                *value_ptr_ptr = *variable_ptr_ptr;
                zval_set_refcount_p(*variable_ptr_ptr, 2U);
              } else {

              }
            }
          }
          zval_set_isref_p(*variable_ptr_ptr);
        }
      }
    }
  }
  return;
}
}
__inline static void make_real_object(zval **object_ptr ) 
{ zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;

  {
  if ((int )(*object_ptr)->type == 0) {
    goto _L;
  } else {
    if ((int )(*object_ptr)->type == 3) {
      if ((*object_ptr)->value.lval == 0L) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      if ((int )(*object_ptr)->type == 6) {
        if ((*object_ptr)->value.str.len == 0) {
          _L: /* CIL Label */ 
          zend_error(1 << 1L, "Creating default object from empty value");
          tmp___1 = zval_isref_p(*object_ptr);
          if (tmp___1) {

          } else {
            while (1) {
              tmp___0 = zval_refcount_p(*object_ptr);
              if (tmp___0 > 1U) {
                zval_delref_p(*object_ptr);
                while (1) {
                  tmp = _emalloc(sizeof(zval_gc_info ));
                  new_zv = (zval *)tmp;
                  ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                  break;
                }
                while (1) {
                  while (1) {
                    new_zv->value = (*object_ptr)->value;
                    new_zv->type = (*object_ptr)->type;
                    break;
                  }
                  zval_set_refcount_p(new_zv, 1U);
                  zval_unset_isref_p(new_zv);
                  break;
                }
                *object_ptr = new_zv;
                _zval_copy_ctor(new_zv);
              } else {

              }
              break;
            }
          }
          _zval_dtor(*object_ptr);
          _object_init(*object_ptr);
        } else {

        }
      } else {

      }
    }
  }
  return;
}
}
char __attribute__((__visibility__("default")))  *zend_verify_arg_class_kind(zend_arg_info const   *cur_arg_info , ulong fetch_type , char const   **class_name , zend_class_entry **pce ) 
{ zend_class_entry __attribute__((__visibility__("default")))  *tmp ;

  {
  tmp = zend_fetch_class((char const   *)cur_arg_info->class_name, (unsigned int )cur_arg_info->class_name_len, (int )((fetch_type | 5UL) | 128UL));
  *pce = (zend_class_entry *)tmp;
  if (*pce) {
    *class_name = (*pce)->name;
  } else {
    *class_name = (char const   *)cur_arg_info->class_name;
  }
  if (*pce) {
    if ((*pce)->ce_flags & 128U) {
      return ((char __attribute__((__visibility__("default")))  *)"implement interface ");
    } else {
      return ((char __attribute__((__visibility__("default")))  *)"be an instance of ");
    }
  } else {
    return ((char __attribute__((__visibility__("default")))  *)"be an instance of ");
  }
}
}
int __attribute__((__visibility__("default")))  zend_verify_arg_error(int error_type , zend_function const   *zf , zend_uint arg_num , char const   *need_msg , char const   *need_kind , char const   *given_msg , char const   *given_kind ) 
{ zend_execute_data *ptr ;
  char const   *fname ;
  char *fsep ;
  char const   *fclass ;

  {
  ptr = (executor_globals.current_execute_data)->prev_execute_data;
  fname = (char const   *)zf->common.function_name;
  if (zf->common.scope) {
    fsep = (char *)"::";
    fclass = (zf->common.scope)->name;
  } else {
    fsep = (char *)"";
    fclass = "";
  }
  if (ptr) {
    if (ptr->op_array) {
      zend_error(error_type, "Argument %d passed to %s%s%s() must %s%s, %s%s given, called in %s on line %d and defined", arg_num, fclass, fsep, fname, need_msg, need_kind, given_msg, given_kind, (ptr->op_array)->filename, (ptr->opline)->lineno);
    } else {
      zend_error(error_type, "Argument %d passed to %s%s%s() must %s%s, %s%s given", arg_num, fclass, fsep, fname, need_msg, need_kind, given_msg, given_kind);
    }
  } else {
    zend_error(error_type, "Argument %d passed to %s%s%s() must %s%s, %s%s given", arg_num, fclass, fsep, fname, need_msg, need_kind, given_msg, given_kind);
  }
  return ((int __attribute__((__visibility__("default")))  )0);
}
}
__inline static int zend_verify_arg_type(zend_function *zf , zend_uint arg_num , zval *arg , ulong fetch_type ) 
{ zend_arg_info *cur_arg_info ;
  char *need_msg ;
  zend_class_entry *ce ;
  char const   *class_name ;
  char __attribute__((__visibility__("default")))  *tmp ;
  int __attribute__((__visibility__("default")))  tmp___0 ;
  char __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___2 ;
  int __attribute__((__visibility__("default")))  tmp___3 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_bool __attribute__((__visibility__("default")))  tmp___5 ;
  char __attribute__((__visibility__("default")))  *tmp___6 ;
  char __attribute__((__visibility__("default")))  *tmp___7 ;
  int __attribute__((__visibility__("default")))  tmp___8 ;
  int __attribute__((__visibility__("default")))  tmp___9 ;
  char __attribute__((__visibility__("default")))  *tmp___10 ;
  int __attribute__((__visibility__("default")))  tmp___11 ;
  int __attribute__((__visibility__("default")))  tmp___12 ;
  char __attribute__((__visibility__("default")))  *tmp___13 ;
  int __attribute__((__visibility__("default")))  tmp___14 ;
  zend_bool __attribute__((__visibility__("default")))  tmp___15 ;

  {
  if (! zf->common.arg_info) {
    return (1);
  } else {
    if (arg_num > zf->common.num_args) {
      return (1);
    } else {

    }
  }
  cur_arg_info = zf->common.arg_info + (arg_num - 1U);
  if (cur_arg_info->class_name) {
    if (! arg) {
      tmp = zend_verify_arg_class_kind((zend_arg_info const   *)cur_arg_info, fetch_type, & class_name, & ce);
      need_msg = (char *)tmp;
      tmp___0 = zend_verify_arg_error(1 << 12L, (zend_function const   *)zf, arg_num, (char const   *)need_msg, class_name, "none", "");
      return ((int )tmp___0);
    } else {

    }
    if ((int )arg->type == 5) {
      tmp___1 = zend_verify_arg_class_kind((zend_arg_info const   *)cur_arg_info, fetch_type, & class_name, & ce);
      need_msg = (char *)tmp___1;
      if (! ce) {
        tmp___2 = zend_get_class_entry((zval const   *)arg);
        tmp___3 = zend_verify_arg_error(1 << 12L, (zend_function const   *)zf, arg_num, (char const   *)need_msg, class_name, "instance of ", tmp___2->name);
        return ((int )tmp___3);
      } else {
        tmp___4 = zend_get_class_entry((zval const   *)arg);
        tmp___5 = instanceof_function((zend_class_entry const   *)tmp___4, (zend_class_entry const   *)ce);
        if (tmp___5) {

        } else {
          tmp___2 = zend_get_class_entry((zval const   *)arg);
          tmp___3 = zend_verify_arg_error(1 << 12L, (zend_function const   *)zf, arg_num, (char const   *)need_msg, class_name, "instance of ", tmp___2->name);
          return ((int )tmp___3);
        }
      }
    } else {
      if ((int )arg->type != 0) {
        tmp___6 = zend_verify_arg_class_kind((zend_arg_info const   *)cur_arg_info, fetch_type, & class_name, & ce);
        need_msg = (char *)tmp___6;
        tmp___7 = zend_zval_type_name((zval const   *)arg);
        tmp___8 = zend_verify_arg_error(1 << 12L, (zend_function const   *)zf, arg_num, (char const   *)need_msg, class_name, (char const   *)tmp___7, "");
        return ((int )tmp___8);
      } else {
        if (! cur_arg_info->allow_null) {
          tmp___6 = zend_verify_arg_class_kind((zend_arg_info const   *)cur_arg_info, fetch_type, & class_name, & ce);
          need_msg = (char *)tmp___6;
          tmp___7 = zend_zval_type_name((zval const   *)arg);
          tmp___8 = zend_verify_arg_error(1 << 12L, (zend_function const   *)zf, arg_num, (char const   *)need_msg, class_name, (char const   *)tmp___7, "");
          return ((int )tmp___8);
        } else {

        }
      }
    }
  } else {
    if (cur_arg_info->type_hint) {
      switch ((int )cur_arg_info->type_hint) {
      case 4: 
      if (! arg) {
        tmp___9 = zend_verify_arg_error(1 << 12L, (zend_function const   *)zf, arg_num, "be of the type array", "", "none", "");
        return ((int )tmp___9);
      } else {

      }
      if ((int )arg->type != 4) {
        if ((int )arg->type != 0) {
          tmp___10 = zend_zval_type_name((zval const   *)arg);
          tmp___11 = zend_verify_arg_error(1 << 12L, (zend_function const   *)zf, arg_num, "be of the type array", "", (char const   *)tmp___10, "");
          return ((int )tmp___11);
        } else {
          if (! cur_arg_info->allow_null) {
            tmp___10 = zend_zval_type_name((zval const   *)arg);
            tmp___11 = zend_verify_arg_error(1 << 12L, (zend_function const   *)zf, arg_num, "be of the type array", "", (char const   *)tmp___10, "");
            return ((int )tmp___11);
          } else {

          }
        }
      } else {

      }
      break;
      case 10: 
      if (! arg) {
        tmp___12 = zend_verify_arg_error(1 << 12L, (zend_function const   *)zf, arg_num, "be callable", "", "none", "");
        return ((int )tmp___12);
      } else {

      }
      tmp___15 = zend_is_callable(arg, (unsigned int )(1 << 3), (char **)((void *)0));
      if (tmp___15) {

      } else {
        if ((int )arg->type != 0) {
          tmp___13 = zend_zval_type_name((zval const   *)arg);
          tmp___14 = zend_verify_arg_error(1 << 12L, (zend_function const   *)zf, arg_num, "be callable", "", (char const   *)tmp___13, "");
          return ((int )tmp___14);
        } else {
          if (! cur_arg_info->allow_null) {
            tmp___13 = zend_zval_type_name((zval const   *)arg);
            tmp___14 = zend_verify_arg_error(1 << 12L, (zend_function const   *)zf, arg_num, "be callable", "", (char const   *)tmp___13, "");
            return ((int )tmp___14);
          } else {

          }
        }
      }
      break;
      default: 
      zend_error(1, "Unknown typehint");
      }
    } else {

    }
  }
  return (1);
}
}
__inline static void zend_assign_to_object(zval **retval , zval **object_ptr , zval *property_name , int value_type , znode_op *value_op , temp_variable const   *Ts , int opcode , zend_literal const   *key ) 
{ zval *object ;
  zend_free_op free_value ;
  zval *value ;
  zval *tmp ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_uint tmp___1 ;
  zend_bool tmp___2 ;
  zend_uint tmp___3 ;
  zval *orig_value ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zval *orig_value___0 ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;

  {
  object = *object_ptr;
  tmp = _get_zval_ptr(value_type, (znode_op const   *)value_op, Ts, & free_value, 0);
  value = tmp;
  if ((int )object->type != 5) {
    if ((unsigned int )object == (unsigned int )(& executor_globals.error_zval)) {
      if (retval) {
        *retval = & executor_globals.uninitialized_zval;
        zval_addref_p(*retval);
      } else {

      }
      if (free_value.var) {
        if ((unsigned long )free_value.var & 1UL) {
          _zval_dtor((zval *)((unsigned long )free_value.var & 4294967294UL));
        } else {
          i_zval_ptr_dtor(free_value.var);
        }
      } else {

      }
      return;
    } else {

    }
    if ((int )object->type == 0) {
      goto _L;
    } else {
      if ((int )object->type == 3) {
        if (object->value.lval == 0L) {
          goto _L;
        } else {
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
        if ((int )object->type == 6) {
          if (object->value.str.len == 0) {
            _L: /* CIL Label */ 
            tmp___2 = zval_isref_p(*object_ptr);
            if (tmp___2) {

            } else {
              while (1) {
                tmp___1 = zval_refcount_p(*object_ptr);
                if (tmp___1 > 1U) {
                  zval_delref_p(*object_ptr);
                  while (1) {
                    tmp___0 = _emalloc(sizeof(zval_gc_info ));
                    new_zv = (zval *)tmp___0;
                    ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                    break;
                  }
                  while (1) {
                    while (1) {
                      new_zv->value = (*object_ptr)->value;
                      new_zv->type = (*object_ptr)->type;
                      break;
                    }
                    zval_set_refcount_p(new_zv, 1U);
                    zval_unset_isref_p(new_zv);
                    break;
                  }
                  *object_ptr = new_zv;
                  _zval_copy_ctor(new_zv);
                } else {

                }
                break;
              }
            }
            object = *object_ptr;
            zval_addref_p(object);
            zend_error(1 << 1L, "Creating default object from empty value");
            tmp___3 = zval_refcount_p(object);
            if (tmp___3 == 1U) {
              i_zval_ptr_dtor(object);
              if (retval) {
                *retval = & executor_globals.uninitialized_zval;
                zval_addref_p(*retval);
              } else {

              }
              if (free_value.var) {
                if ((unsigned long )free_value.var & 1UL) {
                  _zval_dtor((zval *)((unsigned long )free_value.var & 4294967294UL));
                } else {
                  i_zval_ptr_dtor(free_value.var);
                }
              } else {

              }
              return;
            } else {

            }
            zval_delref_p(object);
            _zval_dtor(object);
            _object_init(object);
          } else {
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
          zend_error(1 << 1L, "Attempt to assign property of non-object");
          if (retval) {
            *retval = & executor_globals.uninitialized_zval;
            zval_addref_p(*retval);
          } else {

          }
          if (free_value.var) {
            if ((unsigned long )free_value.var & 1UL) {
              _zval_dtor((zval *)((unsigned long )free_value.var & 4294967294UL));
            } else {
              i_zval_ptr_dtor(free_value.var);
            }
          } else {

          }
          return;
        }
      }
    }
  } else {

  }
  if (value_type == 1 << 1) {
    orig_value = value;
    while (1) {
      tmp___4 = _emalloc(sizeof(zval_gc_info ));
      value = (zval *)tmp___4;
      ((zval_gc_info *)value)->u.buffered = (gc_root_buffer *)((void *)0);
      break;
    }
    while (1) {
      value->value = orig_value->value;
      value->type = orig_value->type;
      break;
    }
    zval_unset_isref_p(value);
    zval_set_refcount_p(value, 0U);
  } else {
    if (value_type == 1) {
      orig_value___0 = value;
      while (1) {
        tmp___5 = _emalloc(sizeof(zval_gc_info ));
        value = (zval *)tmp___5;
        ((zval_gc_info *)value)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      while (1) {
        value->value = orig_value___0->value;
        value->type = orig_value___0->type;
        break;
      }
      zval_unset_isref_p(value);
      zval_set_refcount_p(value, 0U);
      _zval_copy_ctor(value);
    } else {

    }
  }
  zval_addref_p(value);
  if (opcode == 136) {
    if (! (object->value.obj.handlers)->write_property) {
      zend_error(1 << 1L, "Attempt to assign property of non-object");
      if (retval) {
        *retval = & executor_globals.uninitialized_zval;
        zval_addref_p(& executor_globals.uninitialized_zval);
      } else {

      }
      if (value_type == 1 << 1) {
        while (1) {
          if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)value)->u.buffered & 4294967292UL)) {
            gc_remove_zval_from_buffer(value);
          } else {

          }
          _efree((void *)value);
          break;
        }
      } else {
        if (value_type == 1) {
          i_zval_ptr_dtor(value);
        } else {

        }
      }
      if (free_value.var) {
        if ((unsigned long )free_value.var & 1UL) {
          _zval_dtor((zval *)((unsigned long )free_value.var & 4294967294UL));
        } else {
          i_zval_ptr_dtor(free_value.var);
        }
      } else {

      }
      return;
    } else {

    }
    (*((object->value.obj.handlers)->write_property))(object, property_name, value, key);
  } else {
    if (! (object->value.obj.handlers)->write_dimension) {
      zend_error_noreturn(1, "Cannot use object as array");
    } else {

    }
    (*((object->value.obj.handlers)->write_dimension))(object, property_name, value);
  }
  if (retval) {
    if (! executor_globals.exception) {
      *retval = value;
      zval_addref_p(value);
    } else {

    }
  } else {

  }
  i_zval_ptr_dtor(value);
  if ((unsigned int )free_value.var != (unsigned int )((void *)0)) {
    if (((unsigned long )free_value.var & 1UL) == 0UL) {
      i_zval_ptr_dtor(free_value.var);
    } else {

    }
  } else {

  }
  return;
}
}
__inline static int zend_assign_to_string_offset(temp_variable const   *T , zval const   *value , int value_type ) 
{ char *tmp ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  char *tmp___2 ;
  void __attribute__((__visibility__("default")))  *tmp___3 ;
  zval tmp___4 ;

  {
  if ((int )(T->str_offset.str)->type == 6) {
    if ((int )T->str_offset.offset < 0) {
      zend_error(1 << 1L, "Illegal string offset:  %d", T->str_offset.offset);
      return (0);
    } else {

    }
    if (T->str_offset.offset >= (zend_uint const   )(T->str_offset.str)->value.str.len) {
      if ((unsigned int )(T->str_offset.str)->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
        if ((unsigned int )(T->str_offset.str)->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
          tmp___0 = _emalloc((unsigned int )((T->str_offset.offset + 1U) + 1U));
          tmp = (char *)tmp___0;
          memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)(T->str_offset.str)->value.str.val, (unsigned int )((T->str_offset.str)->value.str.len + 1));
          (T->str_offset.str)->value.str.val = tmp;
        } else {
          tmp___1 = _erealloc((void *)(T->str_offset.str)->value.str.val, (unsigned int )((T->str_offset.offset + 1U) + 1U), 0);
          (T->str_offset.str)->value.str.val = (char *)tmp___1;
        }
      } else {
        tmp___1 = _erealloc((void *)(T->str_offset.str)->value.str.val, (unsigned int )((T->str_offset.offset + 1U) + 1U), 0);
        (T->str_offset.str)->value.str.val = (char *)tmp___1;
      }
      memset((void *)((T->str_offset.str)->value.str.val + (T->str_offset.str)->value.str.len), ' ', (unsigned int )(T->str_offset.offset - (zend_uint const   )(T->str_offset.str)->value.str.len));
      *((T->str_offset.str)->value.str.val + (T->str_offset.offset + 1U)) = (char)0;
      (T->str_offset.str)->value.str.len = (int )(T->str_offset.offset + 1U);
    } else {
      if ((unsigned int )(T->str_offset.str)->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
        if ((unsigned int )(T->str_offset.str)->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
          tmp___3 = _emalloc((unsigned int )((T->str_offset.str)->value.str.len + 1));
          tmp___2 = (char *)tmp___3;
          memcpy((void */* __restrict  */)tmp___2, (void const   */* __restrict  */)(T->str_offset.str)->value.str.val, (unsigned int )((T->str_offset.str)->value.str.len + 1));
          (T->str_offset.str)->value.str.val = tmp___2;
        } else {

        }
      } else {

      }
    }
    if ((int const   )value->type != 6) {
      while (1) {
        tmp___4.value = (union _zvalue_value )value->value;
        tmp___4.type = (unsigned char )value->type;
        break;
      }
      if (value_type != 1 << 1) {
        _zval_copy_ctor(& tmp___4);
      } else {

      }
      if ((int )tmp___4.type != 6) {
        _convert_to_string(& tmp___4);
      } else {

      }
      *((T->str_offset.str)->value.str.val + T->str_offset.offset) = *(tmp___4.value.str.val + 0);
      if (tmp___4.value.str.val) {
        if ((unsigned int )tmp___4.value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
          if ((unsigned int )tmp___4.value.str.val < (unsigned int )compiler_globals.interned_strings_end) {

          } else {
            _efree((void *)tmp___4.value.str.val);
          }
        } else {
          _efree((void *)tmp___4.value.str.val);
        }
      } else {

      }
    } else {
      *((T->str_offset.str)->value.str.val + T->str_offset.offset) = *(value->value.str.val + 0);
      if (value_type == 1 << 1) {
        if (value->value.str.val) {
          if ((unsigned int )value->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
            if ((unsigned int )value->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {

            } else {
              _efree((void *)value->value.str.val);
            }
          } else {
            _efree((void *)value->value.str.val);
          }
        } else {

        }
      } else {

      }
    }
  } else {

  }
  return (1);
}
}
__inline static zval *zend_assign_tmp_to_variable(zval **variable_ptr_ptr , zval *value ) 
{ zval *variable_ptr ;
  zval garbage ;
  long tmp ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  long tmp___1 ;
  zend_uint tmp___2 ;
  long tmp___3 ;
  zend_bool tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;

  {
  variable_ptr = *variable_ptr_ptr;
  if ((int )variable_ptr->type == 5) {
    tmp = __builtin_expect((long )((unsigned int )(variable_ptr->value.obj.handlers)->set != (unsigned int )((void *)0)), 0L);
    if (tmp) {
      (*((variable_ptr->value.obj.handlers)->set))(variable_ptr_ptr, value);
      return (variable_ptr);
    } else {

    }
  } else {

  }
  tmp___2 = zval_refcount_p(variable_ptr);
  tmp___3 = __builtin_expect((long )(tmp___2 > 1U), 0L);
  if (tmp___3) {
    tmp___4 = zval_isref_p(variable_ptr);
    if (tmp___4) {
      tmp___5 = 0;
    } else {
      tmp___5 = 1;
    }
    tmp___6 = __builtin_expect((long )tmp___5, 1L);
    if (tmp___6) {
      zval_delref_p(variable_ptr);
      gc_zval_check_possible_root(variable_ptr);
      while (1) {
        tmp___0 = _emalloc(sizeof(zval_gc_info ));
        variable_ptr = (zval *)tmp___0;
        ((zval_gc_info *)variable_ptr)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      while (1) {
        while (1) {
          variable_ptr->value = value->value;
          variable_ptr->type = value->type;
          break;
        }
        zval_set_refcount_p(variable_ptr, 1U);
        zval_unset_isref_p(variable_ptr);
        break;
      }
      *variable_ptr_ptr = variable_ptr;
      return (variable_ptr);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    tmp___1 = __builtin_expect((long )((int )variable_ptr->type <= 3), 1L);
    if (tmp___1) {
      while (1) {
        variable_ptr->value = value->value;
        variable_ptr->type = value->type;
        break;
      }
    } else {
      while (1) {
        garbage.value = variable_ptr->value;
        garbage.type = variable_ptr->type;
        break;
      }
      while (1) {
        variable_ptr->value = value->value;
        variable_ptr->type = value->type;
        break;
      }
      _zval_dtor_func(& garbage);
    }
    return (variable_ptr);
  }
}
}
__inline static zval *zend_assign_const_to_variable(zval **variable_ptr_ptr , zval *value ) 
{ zval *variable_ptr ;
  zval garbage ;
  long tmp ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  long tmp___1 ;
  zend_uint tmp___2 ;
  long tmp___3 ;
  zend_bool tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;

  {
  variable_ptr = *variable_ptr_ptr;
  if ((int )variable_ptr->type == 5) {
    tmp = __builtin_expect((long )((unsigned int )(variable_ptr->value.obj.handlers)->set != (unsigned int )((void *)0)), 0L);
    if (tmp) {
      (*((variable_ptr->value.obj.handlers)->set))(variable_ptr_ptr, value);
      return (variable_ptr);
    } else {

    }
  } else {

  }
  tmp___2 = zval_refcount_p(variable_ptr);
  tmp___3 = __builtin_expect((long )(tmp___2 > 1U), 0L);
  if (tmp___3) {
    tmp___4 = zval_isref_p(variable_ptr);
    if (tmp___4) {
      tmp___5 = 0;
    } else {
      tmp___5 = 1;
    }
    tmp___6 = __builtin_expect((long )tmp___5, 1L);
    if (tmp___6) {
      zval_delref_p(variable_ptr);
      gc_zval_check_possible_root(variable_ptr);
      while (1) {
        tmp___0 = _emalloc(sizeof(zval_gc_info ));
        variable_ptr = (zval *)tmp___0;
        ((zval_gc_info *)variable_ptr)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      while (1) {
        while (1) {
          variable_ptr->value = value->value;
          variable_ptr->type = value->type;
          break;
        }
        zval_set_refcount_p(variable_ptr, 1U);
        zval_unset_isref_p(variable_ptr);
        break;
      }
      _zval_copy_ctor(variable_ptr);
      *variable_ptr_ptr = variable_ptr;
      return (variable_ptr);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    tmp___1 = __builtin_expect((long )((int )variable_ptr->type <= 3), 1L);
    if (tmp___1) {
      while (1) {
        variable_ptr->value = value->value;
        variable_ptr->type = value->type;
        break;
      }
      _zval_copy_ctor(variable_ptr);
    } else {
      while (1) {
        garbage.value = variable_ptr->value;
        garbage.type = variable_ptr->type;
        break;
      }
      while (1) {
        variable_ptr->value = value->value;
        variable_ptr->type = value->type;
        break;
      }
      _zval_copy_ctor(variable_ptr);
      _zval_dtor_func(& garbage);
    }
    return (variable_ptr);
  }
}
}
__inline static zval *zend_assign_to_variable(zval **variable_ptr_ptr , zval *value ) 
{ zval *variable_ptr ;
  zval garbage ;
  long tmp ;
  long tmp___0 ;
  zend_bool tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  zend_bool tmp___6 ;
  zend_uint tmp___7 ;
  zend_uint tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  zend_bool tmp___11 ;
  int tmp___12 ;
  long tmp___13 ;

  {
  variable_ptr = *variable_ptr_ptr;
  if ((int )variable_ptr->type == 5) {
    tmp = __builtin_expect((long )((unsigned int )(variable_ptr->value.obj.handlers)->set != (unsigned int )((void *)0)), 0L);
    if (tmp) {
      (*((variable_ptr->value.obj.handlers)->set))(variable_ptr_ptr, value);
      return (variable_ptr);
    } else {

    }
  } else {

  }
  tmp___11 = zval_isref_p(variable_ptr);
  if (tmp___11) {
    tmp___12 = 0;
  } else {
    tmp___12 = 1;
  }
  tmp___13 = __builtin_expect((long )tmp___12, 1L);
  if (tmp___13) {
    tmp___8 = zval_refcount_p(variable_ptr);
    if (tmp___8 == 1U) {
      tmp___4 = __builtin_expect((long )((unsigned int )variable_ptr == (unsigned int )value), 0L);
      if (tmp___4) {
        return (variable_ptr);
      } else {
        tmp___1 = zval_isref_p(value);
        if (tmp___1) {
          tmp___2 = 0;
        } else {
          tmp___2 = 1;
        }
        tmp___3 = __builtin_expect((long )tmp___2, 1L);
        if (tmp___3) {
          zval_addref_p(value);
          *variable_ptr_ptr = value;
          tmp___0 = __builtin_expect((long )((unsigned int )variable_ptr != (unsigned int )(& executor_globals.uninitialized_zval)), 1L);
          if (tmp___0) {
            if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)variable_ptr)->u.buffered & 4294967292UL)) {
              gc_remove_zval_from_buffer(variable_ptr);
            } else {

            }
            _zval_dtor(variable_ptr);
            _efree((void *)variable_ptr);
          } else {
            zval_delref_p(variable_ptr);
          }
          return (value);
        } else {
          goto copy_value;
        }
      }
    } else {
      zval_delref_p(variable_ptr);
      gc_zval_check_possible_root(variable_ptr);
      tmp___6 = zval_isref_p(value);
      if (tmp___6) {
        tmp___7 = zval_refcount_p(value);
        if (tmp___7 > 0U) {
          while (1) {
            tmp___5 = _emalloc(sizeof(zval_gc_info ));
            variable_ptr = (zval *)tmp___5;
            ((zval_gc_info *)variable_ptr)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          *variable_ptr_ptr = variable_ptr;
          while (1) {
            while (1) {
              variable_ptr->value = value->value;
              variable_ptr->type = value->type;
              break;
            }
            zval_set_refcount_p(variable_ptr, 1U);
            zval_unset_isref_p(variable_ptr);
            break;
          }
          _zval_copy_ctor(variable_ptr);
          return (variable_ptr);
        } else {
          *variable_ptr_ptr = value;
          zval_addref_p(value);
          zval_unset_isref_p(value);
          return (value);
        }
      } else {
        *variable_ptr_ptr = value;
        zval_addref_p(value);
        zval_unset_isref_p(value);
        return (value);
      }
    }
  } else {
    tmp___10 = __builtin_expect((long )((unsigned int )variable_ptr != (unsigned int )value), 1L);
    if (tmp___10) {
      copy_value: 
      tmp___9 = __builtin_expect((long )((int )variable_ptr->type <= 3), 1L);
      if (tmp___9) {
        while (1) {
          variable_ptr->value = value->value;
          variable_ptr->type = value->type;
          break;
        }
        _zval_copy_ctor(variable_ptr);
      } else {
        while (1) {
          garbage.value = variable_ptr->value;
          garbage.type = variable_ptr->type;
          break;
        }
        while (1) {
          variable_ptr->value = value->value;
          variable_ptr->type = value->type;
          break;
        }
        _zval_copy_ctor(variable_ptr);
        _zval_dtor_func(& garbage);
      }
    } else {

    }
    return (variable_ptr);
  }
}
}
static void zend_extension_statement_handler(zend_extension const   *extension , zend_op_array *op_array ) 
{ 

  {
  if (extension->statement_handler) {
    (*(extension->statement_handler))(op_array);
  } else {

  }
  return;
}
}
static void zend_extension_fcall_begin_handler(zend_extension const   *extension , zend_op_array *op_array ) 
{ 

  {
  if (extension->fcall_begin_handler) {
    (*(extension->fcall_begin_handler))(op_array);
  } else {

  }
  return;
}
}
static void zend_extension_fcall_end_handler(zend_extension const   *extension , zend_op_array *op_array ) 
{ 

  {
  if (extension->fcall_end_handler) {
    (*(extension->fcall_end_handler))(op_array);
  } else {

  }
  return;
}
}
__inline static HashTable *zend_get_target_symbol_table(int fetch_type ) 
{ void __attribute__((__visibility__("default")))  *tmp ;

  {
  switch (fetch_type) {
  case 0x10000000: 
  if (! executor_globals.active_symbol_table) {
    zend_rebuild_symbol_table();
  } else {

  }
  return (executor_globals.active_symbol_table);
  break;
  case 0x00000000: 
  case 0x40000000: 
  return (& executor_globals.symbol_table);
  break;
  case 0x20000000: 
  if (! (executor_globals.active_op_array)->static_variables) {
    tmp = _emalloc(sizeof(HashTable ));
    (executor_globals.active_op_array)->static_variables = (HashTable *)tmp;
    _zend_hash_init((executor_globals.active_op_array)->static_variables, 2U, (ulong (*)(char const   *arKey , uint nKeyLength ))((void *)0), (void (*)(void * ))(& _zval_ptr_dtor), (unsigned char)0);
  } else {

  }
  return ((executor_globals.active_op_array)->static_variables);
  break;
  }
  return ((HashTable *)((void *)0));
}
}
__inline static zval **zend_fetch_dimension_address_inner(HashTable *ht , zval const   *dim , int dim_type , int type ) 
{ zval **retval ;
  char *offset_key ;
  int offset_key_length ;
  ulong hval ;
  register char const   *tmp ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___0 ;
  zval *new_zval ;
  int __attribute__((__visibility__("default")))  tmp___1 ;
  long tmp___2 ;
  zval *new_zval___0 ;
  int __attribute__((__visibility__("default")))  tmp___3 ;
  zval **tmp___4 ;

  {
  switch ((int )dim->type) {
  case 0: 
  offset_key = (char *)"";
  offset_key_length = 0;
  hval = zend_inline_hash_func("", 1U);
  goto fetch_string_dim;
  case 6: 
  offset_key = (char *)dim->value.str.val;
  offset_key_length = (int )dim->value.str.len;
  if (dim_type == 1) {
    hval = ((zend_literal *)dim)->hash_value;
  } else {
    while (1) {
      tmp = (char const   *)offset_key;
      if ((int const   )*tmp == 45) {
        tmp ++;
      } else {

      }
      if ((int const   )*tmp >= 48) {
        if ((int const   )*tmp <= 57) {
          end = (char const   *)(((offset_key + offset_key_length) + 1) - 1);
          if ((int const   )*end != 0) {
            break;
          } else {
            if ((int const   )*tmp == 48) {
              if (offset_key_length + 1 > 2) {
                break;
              } else {
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
              if (end - tmp > 10) {
                break;
              } else {
                if (end - tmp == 10) {
                  if ((int const   )*tmp > 50) {
                    break;
                  } else {

                  }
                } else {

                }
              }
            }
          }
          hval = (unsigned long )((int const   )*tmp - 48);
          while (1) {
            tmp ++;
            if ((unsigned int )tmp != (unsigned int )end) {
              if ((int const   )*tmp >= 48) {
                if ((int const   )*tmp <= 57) {

                } else {
                  break;
                }
              } else {
                break;
              }
            } else {
              break;
            }
            hval = hval * 10UL + (ulong )((int const   )*tmp - 48);
          }
          if ((unsigned int )tmp == (unsigned int )end) {
            if ((int )*offset_key == 45) {
              if (hval - 1UL > 2147483647UL) {
                break;
              } else {

              }
              hval = (unsigned long )(- ((long )hval));
            } else {
              if (hval > 2147483647UL) {
                break;
              } else {

              }
            }
            goto num_index;
          } else {

          }
        } else {

        }
      } else {

      }
      break;
    }
    if ((unsigned int )offset_key >= (unsigned int )compiler_globals.interned_strings_start) {
      if ((unsigned int )offset_key < (unsigned int )compiler_globals.interned_strings_end) {
        hval = ((Bucket *)(offset_key - sizeof(Bucket )))->h;
      } else {
        tmp___0 = zend_hash_func((char const   *)offset_key, (unsigned int )(offset_key_length + 1));
        hval = (unsigned long )tmp___0;
      }
    } else {
      tmp___0 = zend_hash_func((char const   *)offset_key, (unsigned int )(offset_key_length + 1));
      hval = (unsigned long )tmp___0;
    }
  }
  fetch_string_dim: 
  tmp___1 = zend_hash_quick_find((HashTable const   *)ht, (char const   *)offset_key, (unsigned int )(offset_key_length + 1), hval, (void **)(& retval));
  if (tmp___1 == (int __attribute__((__visibility__("default")))  )-1) {
    switch (type) {
    case 0: 
    zend_error(1 << 3L, "Undefined index: %s", offset_key);
    case 6: 
    case 3: 
    retval = & executor_globals.uninitialized_zval_ptr;
    break;
    case 2: 
    zend_error(1 << 3L, "Undefined index: %s", offset_key);
    case 1: 
    new_zval = & executor_globals.uninitialized_zval;
    zval_addref_p(new_zval);
    _zend_hash_quick_add_or_update(ht, (char const   *)offset_key, (unsigned int )(offset_key_length + 1), hval, (void *)(& new_zval), sizeof(zval *), (void **)(& retval), 1);
    break;
    }
  } else {

  }
  break;
  case 2: 
  tmp___2 = zend_dval_to_lval((double )dim->value.dval);
  hval = (unsigned long )tmp___2;
  goto num_index;
  case 7: 
  zend_error(1 << 11L, "Resource ID#%ld used as offset, casting to integer (%ld)", dim->value.lval, dim->value.lval);
  case 3: 
  case 1: 
  hval = (unsigned long )dim->value.lval;
  num_index: 
  tmp___3 = zend_hash_index_find((HashTable const   *)ht, hval, (void **)(& retval));
  if (tmp___3 == (int __attribute__((__visibility__("default")))  )-1) {
    switch (type) {
    case 0: 
    zend_error(1 << 3L, "Undefined offset: %ld", hval);
    case 6: 
    case 3: 
    retval = & executor_globals.uninitialized_zval_ptr;
    break;
    case 2: 
    zend_error(1 << 3L, "Undefined offset: %ld", hval);
    case 1: 
    new_zval___0 = & executor_globals.uninitialized_zval;
    zval_addref_p(new_zval___0);
    _zend_hash_index_update_or_next_insert(ht, hval, (void *)(& new_zval___0), sizeof(zval *), (void **)(& retval), 1);
    break;
    }
  } else {

  }
  break;
  default: 
  zend_error(1 << 1L, "Illegal offset type");
  if (type == 1) {
    tmp___4 = & executor_globals.error_zval_ptr;
  } else {
    if (type == 2) {
      tmp___4 = & executor_globals.error_zval_ptr;
    } else {
      tmp___4 = & executor_globals.uninitialized_zval_ptr;
    }
  }
  return (tmp___4);
  }
  return (retval);
}
}
static void zend_fetch_dimension_address(temp_variable *result , zval **container_ptr , zval *dim , int dim_type , int type ) 
{ zval *container ;
  zval **retval ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_uint tmp___1 ;
  zend_bool tmp___2 ;
  zval *new_zval ;
  int __attribute__((__visibility__("default")))  tmp___3 ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_uint tmp___5 ;
  zend_bool tmp___6 ;
  zval tmp___7 ;
  zval *new_zv___1 ;
  void __attribute__((__visibility__("default")))  *tmp___8 ;
  zend_uint tmp___9 ;
  zend_bool tmp___10 ;
  zval *overloaded_result ;
  zval *orig ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___11 ;
  zval *tmp___12 ;
  void __attribute__((__visibility__("default")))  *tmp___13 ;
  zend_uint tmp___14 ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___15 ;
  zend_bool tmp___16 ;
  temp_variable *__t ;
  temp_variable *__t___0 ;

  {
  container = *container_ptr;
  switch ((int )container->type) {
  case 4: 
  if (type != 6) {
    tmp___1 = zval_refcount_p(container);
    if (tmp___1 > 1U) {
      tmp___2 = zval_isref_p(container);
      if (tmp___2) {

      } else {
        while (1) {
          tmp___0 = zval_refcount_p(*container_ptr);
          if (tmp___0 > 1U) {
            zval_delref_p(*container_ptr);
            while (1) {
              tmp = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*container_ptr)->value;
                new_zv->type = (*container_ptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *container_ptr = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
        container = *container_ptr;
      }
    } else {

    }
  } else {

  }
  fetch_from_array: 
  if ((unsigned int )dim == (unsigned int )((void *)0)) {
    new_zval = & executor_globals.uninitialized_zval;
    zval_addref_p(new_zval);
    tmp___3 = _zend_hash_index_update_or_next_insert(container->value.ht, 0UL, (void *)(& new_zval), sizeof(zval *), (void **)(& retval), 1 << 2);
    if (tmp___3 == (int __attribute__((__visibility__("default")))  )-1) {
      zend_error(1 << 1L, "Cannot add element to the array as the next element is already occupied");
      retval = & executor_globals.error_zval_ptr;
      zval_delref_p(new_zval);
    } else {

    }
  } else {
    retval = zend_fetch_dimension_address_inner(container->value.ht, (zval const   *)dim, dim_type, type);
  }
  result->var.ptr_ptr = retval;
  zval_addref_p(*retval);
  return;
  break;
  case 0: 
  if ((unsigned int )container == (unsigned int )(& executor_globals.error_zval)) {
    result->var.ptr_ptr = & executor_globals.error_zval_ptr;
    zval_addref_p(executor_globals.error_zval_ptr);
  } else {
    if (type != 6) {
      convert_to_array: 
      tmp___6 = zval_isref_p(container);
      if (tmp___6) {

      } else {
        while (1) {
          tmp___5 = zval_refcount_p(*container_ptr);
          if (tmp___5 > 1U) {
            zval_delref_p(*container_ptr);
            while (1) {
              tmp___4 = _emalloc(sizeof(zval_gc_info ));
              new_zv___0 = (zval *)tmp___4;
              ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv___0->value = (*container_ptr)->value;
                new_zv___0->type = (*container_ptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv___0, 1U);
              zval_unset_isref_p(new_zv___0);
              break;
            }
            *container_ptr = new_zv___0;
            _zval_copy_ctor(new_zv___0);
          } else {

          }
          break;
        }
        container = *container_ptr;
      }
      _zval_dtor(container);
      _array_init(container, 0U);
      goto fetch_from_array;
    } else {
      result->var.ptr_ptr = & executor_globals.uninitialized_zval_ptr;
      zval_addref_p(executor_globals.uninitialized_zval_ptr);
    }
  }
  return;
  break;
  case 6: 
  if (type != 6) {
    if (container->value.str.len == 0) {
      goto convert_to_array;
    } else {

    }
  } else {

  }
  if ((unsigned int )dim == (unsigned int )((void *)0)) {
    zend_error_noreturn(1, "[] operator not supported for strings");
  } else {

  }
  if ((int )dim->type != 1) {
    switch ((int )dim->type) {
    case 6: 
    case 2: 
    case 0: 
    case 3: 
    break;
    default: 
    zend_error(1 << 1L, "Illegal offset type");
    break;
    }
    tmp___7 = *dim;
    _zval_copy_ctor(& tmp___7);
    convert_to_long(& tmp___7);
    dim = & tmp___7;
  } else {

  }
  if (type != 6) {
    tmp___10 = zval_isref_p(*container_ptr);
    if (tmp___10) {

    } else {
      while (1) {
        tmp___9 = zval_refcount_p(*container_ptr);
        if (tmp___9 > 1U) {
          zval_delref_p(*container_ptr);
          while (1) {
            tmp___8 = _emalloc(sizeof(zval_gc_info ));
            new_zv___1 = (zval *)tmp___8;
            ((zval_gc_info *)new_zv___1)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv___1->value = (*container_ptr)->value;
              new_zv___1->type = (*container_ptr)->type;
              break;
            }
            zval_set_refcount_p(new_zv___1, 1U);
            zval_unset_isref_p(new_zv___1);
            break;
          }
          *container_ptr = new_zv___1;
          _zval_copy_ctor(new_zv___1);
        } else {

        }
        break;
      }
    }
  } else {

  }
  container = *container_ptr;
  result->str_offset.str = container;
  zval_addref_p(container);
  result->str_offset.offset = (unsigned int )dim->value.lval;
  result->str_offset.ptr_ptr = (zval **)((void *)0);
  return;
  break;
  case 5: 
  if (! (container->value.obj.handlers)->read_dimension) {
    zend_error_noreturn(1, "Cannot use object as array");
  } else {
    if (dim_type == 1 << 1) {
      orig = dim;
      while (1) {
        while (1) {
          tmp___11 = _emalloc(sizeof(zval_gc_info ));
          _tmp = (zval *)tmp___11;
          ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            _tmp->value = dim->value;
            _tmp->type = dim->type;
            break;
          }
          zval_set_refcount_p(_tmp, 1U);
          zval_unset_isref_p(_tmp);
          break;
        }
        dim = _tmp;
        break;
      }
      orig->type = (unsigned char)0;
    } else {

    }
    overloaded_result = (*((container->value.obj.handlers)->read_dimension))(container, dim, type);
    if (overloaded_result) {
      tmp___16 = zval_isref_p(overloaded_result);
      if (tmp___16) {

      } else {
        tmp___14 = zval_refcount_p(overloaded_result);
        if (tmp___14 > 0U) {
          tmp___12 = overloaded_result;
          while (1) {
            tmp___13 = _emalloc(sizeof(zval_gc_info ));
            overloaded_result = (zval *)tmp___13;
            ((zval_gc_info *)overloaded_result)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            overloaded_result->value = tmp___12->value;
            overloaded_result->type = tmp___12->type;
            break;
          }
          _zval_copy_ctor(overloaded_result);
          zval_unset_isref_p(overloaded_result);
          zval_set_refcount_p(overloaded_result, 0U);
        } else {

        }
        if ((int )overloaded_result->type != 5) {
          tmp___15 = zend_get_class_entry((zval const   *)container);
          ce = (zend_class_entry *)tmp___15;
          zend_error(1 << 3L, "Indirect modification of overloaded element of %s has no effect", ce->name);
        } else {

        }
      }
      retval = & overloaded_result;
    } else {
      retval = & executor_globals.error_zval_ptr;
    }
    while (1) {
      __t = result;
      __t->var.ptr = *retval;
      __t->var.ptr_ptr = & __t->var.ptr;
      break;
    }
    zval_addref_p(*retval);
    if (dim_type == 1 << 1) {
      i_zval_ptr_dtor(dim);
    } else {

    }
  }
  return;
  break;
  case 3: 
  if (type != 6) {
    if (container->value.lval == 0L) {
      goto convert_to_array;
    } else {

    }
  } else {

  }
  default: ;
  if (type == 6) {
    zend_error(1 << 1L, "Cannot unset offset in a non-array variable");
    while (1) {
      __t___0 = result;
      __t___0->var.ptr = & executor_globals.uninitialized_zval;
      __t___0->var.ptr_ptr = & __t___0->var.ptr;
      break;
    }
    zval_addref_p(& executor_globals.uninitialized_zval);
  } else {
    zend_error(1 << 1L, "Cannot use a scalar value as an array");
    result->var.ptr_ptr = & executor_globals.error_zval_ptr;
    zval_addref_p(executor_globals.error_zval_ptr);
  }
  break;
  }
  return;
}
}
static void zend_fetch_dimension_address_read(temp_variable *result , zval **container_ptr , zval *dim , int dim_type , int type ) 
{ zval *container ;
  zval **retval ;
  temp_variable *__t ;
  temp_variable *__t___0 ;
  zval tmp ;
  zval *ptr ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  char __attribute__((__visibility__("default")))  *tmp___1 ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  temp_variable *__t___1 ;
  zval *overloaded_result ;
  zval *orig ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___3 ;
  temp_variable *__t___2 ;
  temp_variable *__t___3 ;
  temp_variable *__t___4 ;

  {
  container = *container_ptr;
  switch ((int )container->type) {
  case 4: 
  retval = zend_fetch_dimension_address_inner(container->value.ht, (zval const   *)dim, dim_type, type);
  while (1) {
    __t = result;
    __t->var.ptr = *retval;
    __t->var.ptr_ptr = & __t->var.ptr;
    break;
  }
  zval_addref_p(*retval);
  return;
  case 0: 
  while (1) {
    __t___0 = result;
    __t___0->var.ptr = & executor_globals.uninitialized_zval;
    __t___0->var.ptr_ptr = & __t___0->var.ptr;
    break;
  }
  zval_addref_p(& executor_globals.uninitialized_zval);
  return;
  case 6: 
  if ((int )dim->type != 1) {
    switch ((int )dim->type) {
    case 6: 
    case 2: 
    case 0: 
    case 3: 
    break;
    default: 
    zend_error(1 << 1L, "Illegal offset type");
    break;
    }
    while (1) {
      tmp.value = dim->value;
      tmp.type = dim->type;
      break;
    }
    _zval_copy_ctor(& tmp);
    convert_to_long(& tmp);
    dim = & tmp;
  } else {

  }
  while (1) {
    tmp___0 = _emalloc(sizeof(zval_gc_info ));
    ptr = (zval *)tmp___0;
    ((zval_gc_info *)ptr)->u.buffered = (gc_root_buffer *)((void *)0);
    break;
  }
  ptr->refcount__gc = 1U;
  ptr->is_ref__gc = (unsigned char)0;
  ptr->type = (unsigned char)6;
  if (dim->value.lval < 0L) {
    goto _L;
  } else {
    if ((long )container->value.str.len <= dim->value.lval) {
      _L: /* CIL Label */ 
      if (type != 3) {
        zend_error(1 << 3L, "Uninitialized string offset: %ld", dim->value.lval);
      } else {

      }
      tmp___1 = _estrndup("", sizeof("") - 1U);
      ptr->value.str.val = (char *)tmp___1;
      ptr->value.str.len = 0;
    } else {
      tmp___2 = _emalloc(2U);
      ptr->value.str.val = (char *)tmp___2;
      *(ptr->value.str.val + 0) = *(container->value.str.val + dim->value.lval);
      *(ptr->value.str.val + 1) = (char)0;
      ptr->value.str.len = 1;
    }
  }
  while (1) {
    __t___1 = result;
    __t___1->var.ptr = ptr;
    __t___1->var.ptr_ptr = & __t___1->var.ptr;
    break;
  }
  return;
  break;
  case 5: 
  if (! (container->value.obj.handlers)->read_dimension) {
    zend_error_noreturn(1, "Cannot use object as array");
  } else {
    if (dim_type == 1 << 1) {
      orig = dim;
      while (1) {
        while (1) {
          tmp___3 = _emalloc(sizeof(zval_gc_info ));
          _tmp = (zval *)tmp___3;
          ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            _tmp->value = dim->value;
            _tmp->type = dim->type;
            break;
          }
          zval_set_refcount_p(_tmp, 1U);
          zval_unset_isref_p(_tmp);
          break;
        }
        dim = _tmp;
        break;
      }
      orig->type = (unsigned char)0;
    } else {

    }
    overloaded_result = (*((container->value.obj.handlers)->read_dimension))(container, dim, type);
    if (overloaded_result) {
      while (1) {
        __t___2 = result;
        __t___2->var.ptr = overloaded_result;
        __t___2->var.ptr_ptr = & __t___2->var.ptr;
        break;
      }
      zval_addref_p(overloaded_result);
    } else {
      if (result) {
        while (1) {
          __t___3 = result;
          __t___3->var.ptr = & executor_globals.uninitialized_zval;
          __t___3->var.ptr_ptr = & __t___3->var.ptr;
          break;
        }
        zval_addref_p(& executor_globals.uninitialized_zval);
      } else {

      }
    }
    if (dim_type == 1 << 1) {
      i_zval_ptr_dtor(dim);
    } else {

    }
  }
  return;
  default: ;
  while (1) {
    __t___4 = result;
    __t___4->var.ptr = & executor_globals.uninitialized_zval;
    __t___4->var.ptr_ptr = & __t___4->var.ptr;
    break;
  }
  zval_addref_p(& executor_globals.uninitialized_zval);
  return;
  }
  return;
}
}
static void zend_fetch_property_address(temp_variable *result , zval **container_ptr , zval *prop_ptr , zend_literal const   *key , int type ) 
{ zval *container ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  zval **ptr_ptr ;
  zval **tmp___2 ;
  zval *ptr ;
  temp_variable *__t ;
  zval *ptr___0 ;
  zval *tmp___3 ;
  temp_variable *__t___0 ;

  {
  container = *container_ptr;
  if ((int )container->type != 5) {
    if ((unsigned int )container == (unsigned int )(& executor_globals.error_zval)) {
      result->var.ptr_ptr = & executor_globals.error_zval_ptr;
      zval_addref_p(executor_globals.error_zval_ptr);
      return;
    } else {

    }
    if (type != 6) {
      if ((int )container->type == 0) {
        goto _L;
      } else {
        if ((int )container->type == 3) {
          if (container->value.lval == 0L) {
            goto _L;
          } else {
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
          if ((int )container->type == 6) {
            if (container->value.str.len == 0) {
              _L: /* CIL Label */ 
              tmp___1 = zval_isref_p(container);
              if (tmp___1) {

              } else {
                while (1) {
                  tmp___0 = zval_refcount_p(*container_ptr);
                  if (tmp___0 > 1U) {
                    zval_delref_p(*container_ptr);
                    while (1) {
                      tmp = _emalloc(sizeof(zval_gc_info ));
                      new_zv = (zval *)tmp;
                      ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                      break;
                    }
                    while (1) {
                      while (1) {
                        new_zv->value = (*container_ptr)->value;
                        new_zv->type = (*container_ptr)->type;
                        break;
                      }
                      zval_set_refcount_p(new_zv, 1U);
                      zval_unset_isref_p(new_zv);
                      break;
                    }
                    *container_ptr = new_zv;
                    _zval_copy_ctor(new_zv);
                  } else {

                  }
                  break;
                }
                container = *container_ptr;
              }
              _object_init(container);
            } else {
              zend_error(1 << 1L, "Attempt to modify property of non-object");
              result->var.ptr_ptr = & executor_globals.error_zval_ptr;
              zval_addref_p(executor_globals.error_zval_ptr);
              return;
            }
          } else {
            zend_error(1 << 1L, "Attempt to modify property of non-object");
            result->var.ptr_ptr = & executor_globals.error_zval_ptr;
            zval_addref_p(executor_globals.error_zval_ptr);
            return;
          }
        }
      }
    } else {
      zend_error(1 << 1L, "Attempt to modify property of non-object");
      result->var.ptr_ptr = & executor_globals.error_zval_ptr;
      zval_addref_p(executor_globals.error_zval_ptr);
      return;
    }
  } else {

  }
  if ((container->value.obj.handlers)->get_property_ptr_ptr) {
    tmp___2 = (*((container->value.obj.handlers)->get_property_ptr_ptr))(container, prop_ptr, key);
    ptr_ptr = tmp___2;
    if ((unsigned int )((void *)0) == (unsigned int )ptr_ptr) {
      if ((container->value.obj.handlers)->read_property) {
        ptr = (*((container->value.obj.handlers)->read_property))(container, prop_ptr, type, key);
        if ((unsigned int )ptr != (unsigned int )((void *)0)) {
          while (1) {
            __t = result;
            __t->var.ptr = ptr;
            __t->var.ptr_ptr = & __t->var.ptr;
            break;
          }
          zval_addref_p(ptr);
        } else {
          zend_error_noreturn(1, "Cannot access undefined property for object with overloaded property access");
        }
      } else {
        zend_error_noreturn(1, "Cannot access undefined property for object with overloaded property access");
      }
    } else {
      result->var.ptr_ptr = ptr_ptr;
      zval_addref_p(*ptr_ptr);
    }
  } else {
    if ((container->value.obj.handlers)->read_property) {
      tmp___3 = (*((container->value.obj.handlers)->read_property))(container, prop_ptr, type, key);
      ptr___0 = tmp___3;
      while (1) {
        __t___0 = result;
        __t___0->var.ptr = ptr___0;
        __t___0->var.ptr_ptr = & __t___0->var.ptr;
        break;
      }
      zval_addref_p(ptr___0);
    } else {
      zend_error(1 << 1L, "This object doesn\'t support property references");
      result->var.ptr_ptr = & executor_globals.error_zval_ptr;
      zval_addref_p(executor_globals.error_zval_ptr);
    }
  }
  return;
}
}
__inline static zend_brk_cont_element *zend_brk_cont(int nest_levels , int array_offset , zend_op_array const   *op_array , temp_variable const   *Ts ) 
{ int original_nest_levels ;
  zend_brk_cont_element *jmp_to ;
  char const   *tmp ;
  zend_op *brk_opline ;

  {
  original_nest_levels = nest_levels;
  while (1) {
    if (array_offset == -1) {
      if (original_nest_levels == 1) {
        tmp = "";
      } else {
        tmp = "s";
      }
      zend_error_noreturn(1, "Cannot break/continue %d level%s", original_nest_levels, tmp);
    } else {

    }
    jmp_to = op_array->brk_cont_array + array_offset;
    if (nest_levels > 1) {
      brk_opline = op_array->opcodes + jmp_to->brk;
      switch ((int )brk_opline->opcode) {
      case 49: 
      if (! (brk_opline->extended_value & (unsigned long )(1 << 2))) {
        i_zval_ptr_dtor(((temp_variable *)((char *)Ts + brk_opline->op1.var))->var.ptr);
      } else {

      }
      break;
      case 70: 
      if (! (brk_opline->extended_value & (unsigned long )(1 << 2))) {
        _zval_dtor(& ((temp_variable *)((char *)Ts + brk_opline->op1.var))->tmp_var);
      } else {

      }
      break;
      }
    } else {

    }
    array_offset = jmp_to->parent;
    nest_levels --;
    if (nest_levels > 0) {

    } else {
      break;
    }
  }
  return (jmp_to);
}
}
void __attribute__((__visibility__("default")))  execute_internal(zend_execute_data *execute_data_ptr , int return_value_used ) 
{ zval **return_value_ptr ;
  zval **tmp ;

  {
  return_value_ptr = & ((temp_variable *)((char *)execute_data_ptr->Ts + (execute_data_ptr->opline)->result.var))->var.ptr;
  if ((execute_data_ptr->function_state.function)->common.fn_flags & 67108864U) {
    tmp = return_value_ptr;
  } else {
    tmp = (zval **)((void *)0);
  }
  (*(((zend_internal_function *)execute_data_ptr->function_state.function)->handler))((int )(execute_data_ptr->opline)->extended_value, *return_value_ptr, tmp, execute_data_ptr->object, return_value_used);
  return;
}
}
static user_opcode_handler_t zend_user_opcode_handlers[256]  = 
  {      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0), 
        (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0),      (int (*)(zend_execute_data *execute_data ))((void *)0)};
static zend_uchar zend_user_opcodes[256]  = 
  {      (zend_uchar )0,      (zend_uchar )1,      (zend_uchar )2,      (zend_uchar )3, 
        (zend_uchar )4,      (zend_uchar )5,      (zend_uchar )6,      (zend_uchar )7, 
        (zend_uchar )8,      (zend_uchar )9,      (zend_uchar )10,      (zend_uchar )11, 
        (zend_uchar )12,      (zend_uchar )13,      (zend_uchar )14,      (zend_uchar )15, 
        (zend_uchar )16,      (zend_uchar )17,      (zend_uchar )18,      (zend_uchar )19, 
        (zend_uchar )20,      (zend_uchar )21,      (zend_uchar )22,      (zend_uchar )23, 
        (zend_uchar )24,      (zend_uchar )25,      (zend_uchar )26,      (zend_uchar )27, 
        (zend_uchar )28,      (zend_uchar )29,      (zend_uchar )30,      (zend_uchar )31, 
        (zend_uchar )32,      (zend_uchar )33,      (zend_uchar )34,      (zend_uchar )35, 
        (zend_uchar )36,      (zend_uchar )37,      (zend_uchar )38,      (zend_uchar )39, 
        (zend_uchar )40,      (zend_uchar )41,      (zend_uchar )42,      (zend_uchar )43, 
        (zend_uchar )44,      (zend_uchar )45,      (zend_uchar )46,      (zend_uchar )47, 
        (zend_uchar )48,      (zend_uchar )49,      (zend_uchar )50,      (zend_uchar )51, 
        (zend_uchar )52,      (zend_uchar )53,      (zend_uchar )54,      (zend_uchar )55, 
        (zend_uchar )56,      (zend_uchar )57,      (zend_uchar )58,      (zend_uchar )59, 
        (zend_uchar )60,      (zend_uchar )61,      (zend_uchar )62,      (zend_uchar )63, 
        (zend_uchar )64,      (zend_uchar )65,      (zend_uchar )66,      (zend_uchar )67, 
        (zend_uchar )68,      (zend_uchar )69,      (zend_uchar )70,      (zend_uchar )71, 
        (zend_uchar )72,      (zend_uchar )73,      (zend_uchar )74,      (zend_uchar )75, 
        (zend_uchar )76,      (zend_uchar )77,      (zend_uchar )78,      (zend_uchar )79, 
        (zend_uchar )80,      (zend_uchar )81,      (zend_uchar )82,      (zend_uchar )83, 
        (zend_uchar )84,      (zend_uchar )85,      (zend_uchar )86,      (zend_uchar )87, 
        (zend_uchar )88,      (zend_uchar )89,      (zend_uchar )90,      (zend_uchar )91, 
        (zend_uchar )92,      (zend_uchar )93,      (zend_uchar )94,      (zend_uchar )95, 
        (zend_uchar )96,      (zend_uchar )97,      (zend_uchar )98,      (zend_uchar )99, 
        (zend_uchar )100,      (zend_uchar )101,      (zend_uchar )102,      (zend_uchar )103, 
        (zend_uchar )104,      (zend_uchar )105,      (zend_uchar )106,      (zend_uchar )107, 
        (zend_uchar )108,      (zend_uchar )109,      (zend_uchar )110,      (zend_uchar )111, 
        (zend_uchar )112,      (zend_uchar )113,      (zend_uchar )114,      (zend_uchar )115, 
        (zend_uchar )116,      (zend_uchar )117,      (zend_uchar )118,      (zend_uchar )119, 
        (zend_uchar )120,      (zend_uchar )121,      (zend_uchar )122,      (zend_uchar )123, 
        (zend_uchar )124,      (zend_uchar )125,      (zend_uchar )126,      (zend_uchar )127, 
        (zend_uchar )128,      (zend_uchar )129,      (zend_uchar )130,      (zend_uchar )131, 
        (zend_uchar )132,      (zend_uchar )133,      (zend_uchar )134,      (zend_uchar )135, 
        (zend_uchar )136,      (zend_uchar )137,      (zend_uchar )138,      (zend_uchar )139, 
        (zend_uchar )140,      (zend_uchar )141,      (zend_uchar )142,      (zend_uchar )143, 
        (zend_uchar )144,      (zend_uchar )145,      (zend_uchar )146,      (zend_uchar )147, 
        (zend_uchar )148,      (zend_uchar )149,      (zend_uchar )150,      (zend_uchar )151, 
        (zend_uchar )152,      (zend_uchar )153,      (zend_uchar )154,      (zend_uchar )155, 
        (zend_uchar )156,      (zend_uchar )157,      (zend_uchar )158,      (zend_uchar )159, 
        (zend_uchar )160,      (zend_uchar )161,      (zend_uchar )162,      (zend_uchar )163, 
        (zend_uchar )164,      (zend_uchar )165,      (zend_uchar )166,      (zend_uchar )167, 
        (zend_uchar )168,      (zend_uchar )169,      (zend_uchar )170,      (zend_uchar )171, 
        (zend_uchar )172,      (zend_uchar )173,      (zend_uchar )174,      (zend_uchar )175, 
        (zend_uchar )176,      (zend_uchar )177,      (zend_uchar )178,      (zend_uchar )179, 
        (zend_uchar )180,      (zend_uchar )181,      (zend_uchar )182,      (zend_uchar )183, 
        (zend_uchar )184,      (zend_uchar )185,      (zend_uchar )186,      (zend_uchar )187, 
        (zend_uchar )188,      (zend_uchar )189,      (zend_uchar )190,      (zend_uchar )191, 
        (zend_uchar )192,      (zend_uchar )193,      (zend_uchar )194,      (zend_uchar )195, 
        (zend_uchar )196,      (zend_uchar )197,      (zend_uchar )198,      (zend_uchar )199, 
        (zend_uchar )200,      (zend_uchar )201,      (zend_uchar )202,      (zend_uchar )203, 
        (zend_uchar )204,      (zend_uchar )205,      (zend_uchar )206,      (zend_uchar )207, 
        (zend_uchar )208,      (zend_uchar )209,      (zend_uchar )210,      (zend_uchar )211, 
        (zend_uchar )212,      (zend_uchar )213,      (zend_uchar )214,      (zend_uchar )215, 
        (zend_uchar )216,      (zend_uchar )217,      (zend_uchar )218,      (zend_uchar )219, 
        (zend_uchar )220,      (zend_uchar )221,      (zend_uchar )222,      (zend_uchar )223, 
        (zend_uchar )224,      (zend_uchar )225,      (zend_uchar )226,      (zend_uchar )227, 
        (zend_uchar )228,      (zend_uchar )229,      (zend_uchar )230,      (zend_uchar )231, 
        (zend_uchar )232,      (zend_uchar )233,      (zend_uchar )234,      (zend_uchar )235, 
        (zend_uchar )236,      (zend_uchar )237,      (zend_uchar )238,      (zend_uchar )239, 
        (zend_uchar )240,      (zend_uchar )241,      (zend_uchar )242,      (zend_uchar )243, 
        (zend_uchar )244,      (zend_uchar )245,      (zend_uchar )246,      (zend_uchar )247, 
        (zend_uchar )248,      (zend_uchar )249,      (zend_uchar )250,      (zend_uchar )251, 
        (zend_uchar )252,      (zend_uchar )253,      (zend_uchar )254,      (zend_uchar )255};
static opcode_handler_t zend_vm_get_opcode_handler(zend_uchar opcode , zend_op *op ) ;
void __attribute__((__visibility__("default")))  execute(zend_op_array *op_array ) 
{ zend_execute_data *execute_data ;
  zend_bool nested ;
  zend_bool original_in_execution ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  int __attribute__((__visibility__("default")))  tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  int ret ;

  {
  nested = (zend_bool )0;
  original_in_execution = executor_globals.in_execution;
  if (executor_globals.exception) {
    return;
  } else {

  }
  executor_globals.in_execution = (unsigned char)1;
  zend_vm_enter: 
  if (executor_globals.active_symbol_table) {
    tmp = 1;
  } else {
    tmp = 2;
  }
  tmp___0 = zend_vm_stack_alloc(((((sizeof(zend_execute_data ) + 4U) - 1U) & 4294967292U) + ((((sizeof(zval **) * (unsigned int )op_array->last_var) * (unsigned int )tmp + 4U) - 1U) & 4294967292U)) + (((sizeof(temp_variable ) + 4U) - 1U) & 4294967292U) * op_array->T);
  execute_data = (zend_execute_data *)tmp___0;
  execute_data->CVs = (zval ***)((char *)execute_data + (((sizeof(zend_execute_data ) + 4U) - 1U) & 4294967292U));
  memset((void *)execute_data->CVs, 0, sizeof(zval **) * (unsigned int )op_array->last_var);
  if (executor_globals.active_symbol_table) {
    tmp___1 = 1;
  } else {
    tmp___1 = 2;
  }
  execute_data->Ts = (temp_variable *)((char *)execute_data->CVs + ((((sizeof(zval **) * (unsigned int )op_array->last_var) * (unsigned int )tmp___1 + 4U) - 1U) & 4294967292U));
  execute_data->fbc = (zend_function *)((void *)0);
  execute_data->called_scope = (zend_class_entry *)((void *)0);
  execute_data->object = (zval *)((void *)0);
  execute_data->old_error_reporting = (zval *)((void *)0);
  execute_data->op_array = op_array;
  execute_data->symbol_table = executor_globals.active_symbol_table;
  execute_data->prev_execute_data = executor_globals.current_execute_data;
  executor_globals.current_execute_data = execute_data;
  execute_data->nested = nested;
  nested = (unsigned char)1;
  if (! op_array->run_time_cache) {
    if (op_array->last_cache_slot) {
      tmp___2 = _ecalloc((unsigned int )op_array->last_cache_slot, sizeof(void *));
      op_array->run_time_cache = (void **)tmp___2;
    } else {

    }
  } else {

  }
  if (op_array->this_var != 4294967295U) {
    if (executor_globals.This) {
      zval_addref_p(executor_globals.This);
      if (! executor_globals.active_symbol_table) {
        *(execute_data->CVs + op_array->this_var) = (zval **)execute_data->CVs + ((zend_uint )op_array->last_var + op_array->this_var);
        *(*(execute_data->CVs + op_array->this_var)) = executor_globals.This;
      } else {
        tmp___3 = _zend_hash_add_or_update(executor_globals.active_symbol_table, "this", sizeof("this"), (void *)(& executor_globals.This), sizeof(zval *), (void **)(execute_data->CVs + op_array->this_var), 1 << 1);
        if (tmp___3 == (int __attribute__((__visibility__("default")))  )-1) {
          zval_delref_p(executor_globals.This);
        } else {

        }
      }
    } else {

    }
  } else {

  }
  tmp___5 = __builtin_expect((long )((op_array->fn_flags & 16U) != 0U), 0L);
  if (tmp___5) {
    if (executor_globals.start_op) {
      execute_data->opline = executor_globals.start_op;
    } else {
      execute_data->opline = op_array->opcodes;
    }
  } else {
    execute_data->opline = op_array->opcodes;
  }
  executor_globals.opline_ptr = & execute_data->opline;
  execute_data->function_state.function = (zend_function *)op_array;
  execute_data->function_state.arguments = (void **)((void *)0);
  while (1) {
    ret = (*((execute_data->opline)->handler))(execute_data);
    if (ret > 0) {
      switch (ret) {
      case 1: 
      executor_globals.in_execution = original_in_execution;
      return;
      case 2: 
      op_array = executor_globals.active_op_array;
      goto zend_vm_enter;
      case 3: 
      execute_data = executor_globals.current_execute_data;
      default: ;
      break;
      }
    } else {

    }
  }
  zend_error_noreturn(1, "Arrived at end of main loop which shouldn\'t happen");
}
}
static int ( __attribute__((__fastcall__)) ZEND_JMP_SPEC_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;

  {
  opline = execute_data->opline;
  execute_data->opline = opline->op1.jmp_addr;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_STRING_SPEC_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  tmp___0 = _emalloc(1U);
  tmp->value.str.val = (char *)tmp___0;
  *(tmp->value.str.val + 0) = (char)0;
  tmp->value.str.len = 0;
  zval_set_refcount_p(tmp, 1U);
  tmp->type = (unsigned char)6;
  zval_unset_isref_p(tmp);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_leave_helper_SPEC)(zend_execute_data *execute_data ) 
{ zend_bool nested ;
  zend_op_array *op_array ;
  zval ***cv ;
  zval ***end ;
  zend_op *opline ;
  zval *retval ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zval *__z ;
  long tmp___0 ;
  zend_uint tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
  op_array = execute_data->op_array;
  executor_globals.current_execute_data = execute_data->prev_execute_data;
  executor_globals.opline_ptr = (zend_op **)((void *)0);
  if (! executor_globals.active_symbol_table) {
    cv = execute_data->CVs;
    end = cv + op_array->last_var;
    while ((unsigned int )cv != (unsigned int )end) {
      if (*cv) {
        i_zval_ptr_dtor(*(*cv));
      } else {

      }
      cv ++;
    }
  } else {

  }
  if (op_array->fn_flags & 1048576U) {
    if (op_array->prototype) {
      i_zval_ptr_dtor(*((zval **)(& op_array->prototype)));
    } else {

    }
  } else {

  }
  nested = execute_data->nested;
  zend_vm_stack_free((void *)execute_data);
  if (nested) {
    execute_data = executor_globals.current_execute_data;
  } else {

  }
  if (nested) {
    opline = execute_data->opline;
    tmp___4 = __builtin_expect((long )((int )opline->opcode == 73), 0L);
    if (tmp___4) {
      execute_data->function_state.function = (zend_function *)execute_data->op_array;
      execute_data->function_state.arguments = (void **)((void *)0);
      execute_data->object = execute_data->current_object;
      executor_globals.opline_ptr = & execute_data->opline;
      executor_globals.active_op_array = execute_data->op_array;
      executor_globals.return_value_ptr_ptr = execute_data->original_return_value;
      destroy_op_array(op_array);
      _efree((void *)op_array);
      tmp___0 = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
      if (tmp___0) {
        zend_throw_exception_internal((zval *)((void *)0));
        return (3);
      } else {
        if (! ((int )opline->result_type & (1 << 5))) {
          if (! ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr) {
            while (1) {
              tmp = _emalloc(sizeof(zval_gc_info ));
              retval = (zval *)tmp;
              ((zval_gc_info *)retval)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              __z = retval;
              __z->value.lval = 1L;
              __z->type = (unsigned char)3;
              break;
            }
            retval->refcount__gc = 1U;
            retval->is_ref__gc = (unsigned char)0;
            ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = retval;
          } else {

          }
        } else {

        }
      }
      (execute_data->opline) ++;
      return (3);
    } else {
      executor_globals.opline_ptr = & execute_data->opline;
      executor_globals.active_op_array = execute_data->op_array;
      executor_globals.return_value_ptr_ptr = execute_data->original_return_value;
      if (executor_globals.active_symbol_table) {
        if ((unsigned int )executor_globals.symtable_cache_ptr >= (unsigned int )executor_globals.symtable_cache_limit) {
          zend_hash_destroy(executor_globals.active_symbol_table);
          _efree((void *)executor_globals.active_symbol_table);
        } else {
          zend_hash_clean(executor_globals.active_symbol_table);
          (executor_globals.symtable_cache_ptr) ++;
          *(executor_globals.symtable_cache_ptr) = executor_globals.active_symbol_table;
        }
      } else {

      }
      executor_globals.active_symbol_table = execute_data->symbol_table;
      execute_data->function_state.function = (zend_function *)execute_data->op_array;
      execute_data->function_state.arguments = (void **)((void *)0);
      if (executor_globals.This) {
        tmp___2 = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
        if (tmp___2) {
          if ((unsigned long )execute_data->called_scope & 1UL) {
            if ((unsigned long )execute_data->called_scope & 2UL) {
              zval_delref_p(executor_globals.This);
            } else {

            }
            tmp___1 = zval_refcount_p(executor_globals.This);
            if (tmp___1 == 1U) {
              zend_object_store_ctor_failed(executor_globals.This);
            } else {

            }
          } else {

          }
        } else {

        }
        i_zval_ptr_dtor(executor_globals.This);
      } else {

      }
      executor_globals.This = execute_data->current_this;
      executor_globals.scope = execute_data->current_scope;
      executor_globals.called_scope = execute_data->current_called_scope;
      execute_data->object = execute_data->current_object;
      execute_data->called_scope = (zend_class_entry *)((unsigned long )execute_data->called_scope & 4294967292UL);
      zend_vm_stack_clear_multiple();
      tmp___3 = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
      if (tmp___3) {
        zend_throw_exception_internal((zval *)((void *)0));
        if (! ((int )opline->result_type & (1 << 5))) {
          if (((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr) {
            i_zval_ptr_dtor(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr);
          } else {

          }
        } else {

        }
        return (3);
      } else {

      }
      (execute_data->opline) ++;
      return (3);
    }
  } else {

  }
  return (1);
}
}
static int ( __attribute__((__fastcall__)) zend_do_fcall_common_helper_SPEC)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_bool should_change_scope ;
  zend_function *fbc ;
  long tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  temp_variable *ret ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_uint i ;
  zval **p ;
  ulong arg_count ;
  zval **tmp___5 ;
  temp_variable *ret___0 ;
  long tmp___6 ;
  long tmp___7 ;
  void __attribute__((__visibility__("default")))  *tmp___8 ;
  long tmp___9 ;
  zend_uint tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;

  {
  opline = execute_data->opline;
  should_change_scope = (zend_bool )0;
  fbc = execute_data->function_state.function;
  tmp___3 = __builtin_expect((long )((fbc->common.fn_flags & 262146U) != 0U), 0L);
  if (tmp___3) {
    tmp = __builtin_expect((long )((fbc->common.fn_flags & 2U) != 0U), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot call abstract method %s::%s()", (fbc->common.scope)->name, fbc->common.function_name);
      (execute_data->opline) ++;
      return (0);
    } else {

    }
    tmp___2 = __builtin_expect((long )((fbc->common.fn_flags & 262144U) != 0U), 0L);
    if (tmp___2) {
      if (fbc->common.scope) {
        tmp___0 = "::";
      } else {
        tmp___0 = "";
      }
      if (fbc->common.scope) {
        tmp___1 = (fbc->common.scope)->name;
      } else {
        tmp___1 = "";
      }
      zend_error(1 << 13L, "Function %s%s%s() is deprecated", tmp___1, tmp___0, fbc->common.function_name);
    } else {

    }
  } else {

  }
  if (fbc->common.scope) {
    if (! (fbc->common.fn_flags & 1U)) {
      if (! execute_data->object) {
        if (fbc->common.fn_flags & 65536U) {
          zend_error(1 << 11L, "Non-static method %s::%s() should not be called statically", (fbc->common.scope)->name, fbc->common.function_name);
        } else {
          zend_error_noreturn(1, "Non-static method %s::%s() cannot be called statically", (fbc->common.scope)->name, fbc->common.function_name);
        }
      } else {

      }
    } else {

    }
  } else {

  }
  if ((int )fbc->type == 2) {
    goto _L;
  } else {
    if (fbc->common.scope) {
      _L: /* CIL Label */ 
      should_change_scope = (unsigned char)1;
      execute_data->current_this = executor_globals.This;
      execute_data->current_scope = executor_globals.scope;
      execute_data->current_called_scope = executor_globals.called_scope;
      executor_globals.This = execute_data->object;
      if ((int )fbc->type == 2) {
        executor_globals.scope = fbc->common.scope;
      } else {
        if (! execute_data->object) {
          executor_globals.scope = fbc->common.scope;
        } else {
          executor_globals.scope = (zend_class_entry *)((void *)0);
        }
      }
      executor_globals.called_scope = execute_data->called_scope;
    } else {

    }
  }
  zend_arg_types_stack_3_pop(& executor_globals.arg_types_stack, & execute_data->called_scope, & execute_data->current_object, & execute_data->fbc);
  execute_data->function_state.arguments = zend_vm_stack_push_args((int )opline->extended_value);
  if ((int )fbc->type == 1) {
    ret = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
    while (1) {
      tmp___4 = _emalloc(sizeof(zval_gc_info ));
      ret->var.ptr = (zval *)tmp___4;
      ((zval_gc_info *)ret->var.ptr)->u.buffered = (gc_root_buffer *)((void *)0);
      break;
    }
    {

    }
    (ret->var.ptr)->is_ref__gc = (unsigned char)0;
    (ret->var.ptr)->type = (unsigned char)0;
    ret->var.ptr_ptr = & ret->var.ptr;
    ret->var.fcall_returned_reference = (unsigned char )((fbc->common.fn_flags & 67108864U) != 0U);
    if (fbc->common.arg_info) {
      i = (zend_uint )0;
      p = (zval **)execute_data->function_state.arguments;
      arg_count = opline->extended_value;
      while (arg_count > 0UL) {
        i ++;
        zend_verify_arg_type(fbc, i, *(p - arg_count), 0UL);
        arg_count --;
      }
    } else {

    }
    if (! zend_execute_internal) {
      if (fbc->common.fn_flags & 67108864U) {
        tmp___5 = & ret->var.ptr;
      } else {
        tmp___5 = (zval **)((void *)0);
      }
      (*(fbc->internal_function.handler))((int )opline->extended_value, ret->var.ptr, tmp___5, execute_data->object, ! ((int )opline->result_type & (1 << 5)));
    } else {
      (*zend_execute_internal)(execute_data, ! ((int )opline->result_type & (1 << 5)));
    }
    if (! (! ((int )opline->result_type & (1 << 5)))) {
      i_zval_ptr_dtor(ret->var.ptr);
    } else {

    }
  } else {
    if ((int )fbc->type == 2) {
      execute_data->original_return_value = executor_globals.return_value_ptr_ptr;
      executor_globals.active_symbol_table = (HashTable *)((void *)0);
      executor_globals.active_op_array = & fbc->op_array;
      executor_globals.return_value_ptr_ptr = (zval **)((void *)0);
      if (! ((int )opline->result_type & (1 << 5))) {
        ret___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        ret___0->var.ptr = (zval *)((void *)0);
        executor_globals.return_value_ptr_ptr = & ret___0->var.ptr;
        ret___0->var.ptr_ptr = & ret___0->var.ptr;
        ret___0->var.fcall_returned_reference = (unsigned char )((fbc->common.fn_flags & 67108864U) != 0U);
      } else {

      }
      tmp___7 = __builtin_expect((long )((unsigned int )zend_execute == (unsigned int )(& execute)), 1L);
      if (tmp___7) {
        tmp___6 = __builtin_expect((long )((unsigned int )executor_globals.exception == (unsigned int )((void *)0)), 1L);
        if (tmp___6) {
          return (2);
        } else {

        }
      } else {
        (*zend_execute)(executor_globals.active_op_array);
      }
      executor_globals.opline_ptr = & execute_data->opline;
      executor_globals.active_op_array = execute_data->op_array;
      executor_globals.return_value_ptr_ptr = execute_data->original_return_value;
      if (executor_globals.active_symbol_table) {
        if ((unsigned int )executor_globals.symtable_cache_ptr >= (unsigned int )executor_globals.symtable_cache_limit) {
          zend_hash_destroy(executor_globals.active_symbol_table);
          _efree((void *)executor_globals.active_symbol_table);
        } else {
          zend_hash_clean(executor_globals.active_symbol_table);
          (executor_globals.symtable_cache_ptr) ++;
          *(executor_globals.symtable_cache_ptr) = executor_globals.active_symbol_table;
        }
      } else {

      }
      executor_globals.active_symbol_table = execute_data->symbol_table;
    } else {
      while (1) {
        tmp___8 = _emalloc(sizeof(zval_gc_info ));
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = (zval *)tmp___8;
        ((zval_gc_info *)((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      (((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr)->refcount__gc = 1U;
      (((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr)->is_ref__gc = (unsigned char)0;
      (((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr)->type = (unsigned char)0;
      tmp___9 = __builtin_expect((long )((unsigned int )execute_data->object != (unsigned int )((void *)0)), 1L);
      if (tmp___9) {
        (*(((execute_data->object)->value.obj.handlers)->call_method))(fbc->common.function_name, (int )opline->extended_value, ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr, & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr, execute_data->object, ! ((int )opline->result_type & (1 << 5)));
      } else {
        zend_error_noreturn(1, "Cannot call overloaded function for non-object");
      }
      if ((int )fbc->type == 5) {
        _efree((void *)((char *)fbc->common.function_name));
      } else {

      }
      _efree((void *)fbc);
      if (! (! ((int )opline->result_type & (1 << 5)))) {
        i_zval_ptr_dtor(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr);
      } else {
        zval_unset_isref_p(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr);
        zval_set_refcount_p(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr, 1U);
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.fcall_returned_reference = (unsigned char)0;
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
      }
    }
  }
  execute_data->function_state.function = (zend_function *)execute_data->op_array;
  execute_data->function_state.arguments = (void **)((void *)0);
  if (should_change_scope) {
    if (executor_globals.This) {
      tmp___11 = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
      if (tmp___11) {
        if ((unsigned long )execute_data->called_scope & 1UL) {
          if ((unsigned long )execute_data->called_scope & 2UL) {
            zval_delref_p(executor_globals.This);
          } else {

          }
          tmp___10 = zval_refcount_p(executor_globals.This);
          if (tmp___10 == 1U) {
            zend_object_store_ctor_failed(executor_globals.This);
          } else {

          }
        } else {

        }
      } else {

      }
      i_zval_ptr_dtor(executor_globals.This);
    } else {

    }
    executor_globals.This = execute_data->current_this;
    executor_globals.scope = execute_data->current_scope;
    executor_globals.called_scope = execute_data->current_called_scope;
  } else {

  }
  execute_data->object = execute_data->current_object;
  execute_data->called_scope = (zend_class_entry *)((unsigned long )execute_data->called_scope & 4294967292UL);
  zend_vm_stack_clear_multiple();
  tmp___12 = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
  if (tmp___12) {
    zend_throw_exception_internal((zval *)((void *)0));
    if (! ((int )opline->result_type & (1 << 5))) {
      if (((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr) {
        i_zval_ptr_dtor(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr);
      } else {

      }
    } else {

    }
    return (0);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  execute_data->function_state.function = execute_data->fbc;
  tmp = zend_do_fcall_common_helper_SPEC(execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_RECV_SPEC_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_uint arg_num ;
  zval **param ;
  zval **tmp ;
  char const   *space ;
  char const   *class_name ;
  zend_execute_data *ptr ;
  char const __attribute__((__visibility__("default")))  *tmp___0 ;
  char const __attribute__((__visibility__("default")))  *tmp___1 ;
  int tmp___2 ;
  zval **var_ptr ;
  long tmp___3 ;

  {
  opline = execute_data->opline;
  arg_num = opline->op1.num;
  tmp = zend_vm_stack_get_arg((int )arg_num);
  param = tmp;
  tmp___3 = __builtin_expect((long )((unsigned int )param == (unsigned int )((void *)0)), 0L);
  if (tmp___3) {
    tmp___2 = zend_verify_arg_type((zend_function *)executor_globals.active_op_array, arg_num, (zval *)((void *)0), opline->extended_value);
    if (tmp___2) {
      if ((executor_globals.active_op_array)->scope) {
        class_name = ((executor_globals.active_op_array)->scope)->name;
        space = "::";
      } else {
        space = "";
        class_name = space;
      }
      ptr = execute_data->prev_execute_data;
      if (ptr) {
        if (ptr->op_array) {
          tmp___0 = get_active_function_name();
          zend_error(1 << 1L, "Missing argument %u for %s%s%s(), called in %s on line %d and defined", opline->op1.num, class_name, space, tmp___0, (ptr->op_array)->filename, (ptr->opline)->lineno);
        } else {
          tmp___1 = get_active_function_name();
          zend_error(1 << 1L, "Missing argument %u for %s%s%s()", opline->op1.num, class_name, space, tmp___1);
        }
      } else {
        tmp___1 = get_active_function_name();
        zend_error(1 << 1L, "Missing argument %u for %s%s%s()", opline->op1.num, class_name, space, tmp___1);
      }
    } else {

    }
  } else {
    zend_verify_arg_type((zend_function *)executor_globals.active_op_array, arg_num, *param, opline->extended_value);
    var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->result.var);
    zval_delref_p(*var_ptr);
    *var_ptr = *param;
    zval_addref_p(*var_ptr);
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_NEW_SPEC_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *object_zval ;
  zend_function *constructor ;
  long tmp ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  temp_variable *__t ;
  long tmp___1 ;
  temp_variable *__t___0 ;
  int tmp___2 ;

  {
  opline = execute_data->opline;
  tmp = __builtin_expect((long )(((((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->class_entry)->ce_flags & 176U) != 0U), 0L);
  if (tmp) {
    if ((((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->class_entry)->ce_flags & 128U) {
      zend_error_noreturn(1, "Cannot instantiate interface %s", (((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->class_entry)->name);
    } else {
      if (((((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->class_entry)->ce_flags & 288U) == 288U) {
        zend_error_noreturn(1, "Cannot instantiate trait %s", (((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->class_entry)->name);
      } else {
        zend_error_noreturn(1, "Cannot instantiate abstract class %s", (((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->class_entry)->name);
      }
    }
  } else {

  }
  while (1) {
    tmp___0 = _emalloc(sizeof(zval_gc_info ));
    object_zval = (zval *)tmp___0;
    ((zval_gc_info *)object_zval)->u.buffered = (gc_root_buffer *)((void *)0);
    break;
  }
  _object_init_ex(object_zval, ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->class_entry);
  object_zval->refcount__gc = 1U;
  object_zval->is_ref__gc = (unsigned char)0;
  constructor = (*((object_zval->value.obj.handlers)->get_constructor))(object_zval);
  if ((unsigned int )constructor == (unsigned int )((void *)0)) {
    if (! ((int )opline->result_type & (1 << 5))) {
      while (1) {
        __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t->var.ptr = object_zval;
        __t->var.ptr_ptr = & __t->var.ptr;
        break;
      }
    } else {
      i_zval_ptr_dtor(object_zval);
    }
    tmp___1 = __builtin_expect((long )(! executor_globals.exception), 1L);
    if (tmp___1) {
      execute_data->opline = (execute_data->op_array)->opcodes + opline->op2.opline_num;
    } else {

    }
    return (0);
  } else {
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(object_zval);
      while (1) {
        __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t___0->var.ptr = object_zval;
        __t___0->var.ptr_ptr = & __t___0->var.ptr;
        break;
      }
    } else {

    }
    if (! ((int )opline->result_type & (1 << 5))) {
      tmp___2 = 0x2;
    } else {
      tmp___2 = 0;
    }
    zend_ptr_stack_3_push(& executor_globals.arg_types_stack, (void *)execute_data->fbc, (void *)execute_data->object, (void *)((zend_class_entry *)(((unsigned long )execute_data->called_scope | 1UL) | (unsigned long )tmp___2)));
    execute_data->object = object_zval;
    execute_data->fbc = constructor;
    execute_data->called_scope = ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->class_entry;
    (execute_data->opline) ++;
    return (0);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_BEGIN_SILENCE_SPEC_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  int __attribute__((__visibility__("default")))  tmp ;
  long tmp___0 ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  int __attribute__((__visibility__("default")))  tmp___2 ;
  long tmp___3 ;
  char __attribute__((__visibility__("default")))  *tmp___4 ;

  {
  opline = execute_data->opline;
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.lval = (long )executor_globals.error_reporting;
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.type = (unsigned char)1;
  if ((unsigned int )execute_data->old_error_reporting == (unsigned int )((void *)0)) {
    execute_data->old_error_reporting = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  } else {

  }
  if (executor_globals.error_reporting) {
    while (1) {
      executor_globals.error_reporting = 0;
      if (! executor_globals.error_reporting_ini_entry) {
        tmp = zend_hash_find((HashTable const   *)executor_globals.ini_directives, "error_reporting", sizeof("error_reporting"), (void **)(& executor_globals.error_reporting_ini_entry));
        tmp___0 = __builtin_expect((long )(tmp == (int __attribute__((__visibility__("default")))  )-1), 0L);
        if (tmp___0) {
          break;
        } else {

        }
      } else {

      }
      if (! (executor_globals.error_reporting_ini_entry)->modified) {
        if (! executor_globals.modified_ini_directives) {
          tmp___1 = _emalloc(sizeof(HashTable ));
          executor_globals.modified_ini_directives = (HashTable *)tmp___1;
          _zend_hash_init(executor_globals.modified_ini_directives, 8U, (ulong (*)(char const   *arKey , uint nKeyLength ))((void *)0), (void (*)(void *pDest ))((void *)0), (unsigned char)0);
        } else {

        }
        tmp___2 = _zend_hash_add_or_update(executor_globals.modified_ini_directives, "error_reporting", sizeof("error_reporting"), (void *)(& executor_globals.error_reporting_ini_entry), sizeof(zend_ini_entry *), (void **)((void *)0), 1 << 1);
        tmp___3 = __builtin_expect((long )(tmp___2 == (int __attribute__((__visibility__("default")))  )0), 1L);
        if (tmp___3) {
          (executor_globals.error_reporting_ini_entry)->orig_value = (executor_globals.error_reporting_ini_entry)->value;
          (executor_globals.error_reporting_ini_entry)->orig_value_length = (executor_globals.error_reporting_ini_entry)->value_length;
          (executor_globals.error_reporting_ini_entry)->orig_modifiable = (executor_globals.error_reporting_ini_entry)->modifiable;
          (executor_globals.error_reporting_ini_entry)->modified = 1;
        } else {

        }
      } else {
        if ((unsigned int )(executor_globals.error_reporting_ini_entry)->value != (unsigned int )(executor_globals.error_reporting_ini_entry)->orig_value) {
          _efree((void *)(executor_globals.error_reporting_ini_entry)->value);
        } else {

        }
      }
      tmp___4 = _estrndup("0", sizeof("0") - 1U);
      (executor_globals.error_reporting_ini_entry)->value = (char *)tmp___4;
      (executor_globals.error_reporting_ini_entry)->value_length = sizeof("0") - 1U;
      break;
    }
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER)(zend_execute_data *execute_data ) 
{ 

  {
  zend_error_noreturn(1, "Cannot call abstract method %s::%s()", (executor_globals.scope)->name, (execute_data->op_array)->function_name);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_EXT_STMT_SPEC_HANDLER)(zend_execute_data *execute_data ) 
{ 

  {
  if (! executor_globals.no_extensions) {
    zend_llist_apply_with_argument((zend_llist *)(& zend_extensions), (void (*)(void *data , void *arg ))(& zend_extension_statement_handler), (void *)execute_data->op_array);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER)(zend_execute_data *execute_data ) 
{ 

  {
  if (! executor_globals.no_extensions) {
    zend_llist_apply_with_argument((zend_llist *)(& zend_extensions), (void (*)(void *data , void *arg ))(& zend_extension_fcall_begin_handler), (void *)execute_data->op_array);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_EXT_FCALL_END_SPEC_HANDLER)(zend_execute_data *execute_data ) 
{ 

  {
  if (! executor_globals.no_extensions) {
    zend_llist_apply_with_argument((zend_llist *)(& zend_extensions), (void (*)(void *data , void *arg ))(& zend_extension_fcall_end_handler), (void *)execute_data->op_array);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_DECLARE_CLASS_SPEC_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp ;

  {
  opline = execute_data->opline;
  tmp = do_bind_class((zend_op_array const   *)execute_data->op_array, (zend_op const   *)opline, executor_globals.class_table, (unsigned char)0);
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->class_entry = (zend_class_entry *)tmp;
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp ;

  {
  opline = execute_data->opline;
  tmp = do_bind_inherited_class((zend_op_array const   *)execute_data->op_array, (zend_op const   *)opline, executor_globals.class_table, ((temp_variable *)((char *)execute_data->Ts + opline->extended_value))->class_entry, (unsigned char)0);
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->class_entry = (zend_class_entry *)tmp;
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_class_entry **pce ;
  zend_class_entry **pce_orig ;
  int __attribute__((__visibility__("default")))  tmp ;
  int __attribute__((__visibility__("default")))  tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = zend_hash_quick_find((HashTable const   *)executor_globals.class_table, (char const   *)(opline->op2.zv)->value.str.val, (unsigned int )((opline->op2.zv)->value.str.len + 1), ((zend_literal *)opline->op2.zv)->hash_value, (void **)(& pce));
  if (tmp == (int __attribute__((__visibility__("default")))  )-1) {
    do_bind_inherited_class((zend_op_array const   *)execute_data->op_array, (zend_op const   *)opline, executor_globals.class_table, ((temp_variable *)((char *)execute_data->Ts + opline->extended_value))->class_entry, (unsigned char)0);
  } else {
    tmp___0 = zend_hash_quick_find((HashTable const   *)executor_globals.class_table, (char const   *)(opline->op1.zv)->value.str.val, (unsigned int )(opline->op1.zv)->value.str.len, ((zend_literal *)opline->op1.zv)->hash_value, (void **)(& pce_orig));
    if (tmp___0 == (int __attribute__((__visibility__("default")))  )0) {
      if ((unsigned int )*pce != (unsigned int )*pce_orig) {
        do_bind_inherited_class((zend_op_array const   *)execute_data->op_array, (zend_op const   *)opline, executor_globals.class_table, ((temp_variable *)((char *)execute_data->Ts + opline->extended_value))->class_entry, (unsigned char)0);
      } else {

      }
    } else {

    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_DECLARE_FUNCTION_SPEC_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;

  {
  opline = execute_data->opline;
  do_bind_function((zend_op_array const   *)execute_data->op_array, opline, executor_globals.function_table, (unsigned char)0);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_TICKS_SPEC_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;

  {
  opline = execute_data->opline;
  (executor_globals.ticks_count) ++;
  if ((ulong )executor_globals.ticks_count >= opline->extended_value) {
    executor_globals.ticks_count = 0;
    if (zend_ticks_function) {
      (*zend_ticks_function)((int )opline->extended_value);
    } else {

    }
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_EXT_NOP_SPEC_HANDLER)(zend_execute_data *execute_data ) 
{ 

  {
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_NOP_SPEC_HANDLER)(zend_execute_data *execute_data ) 
{ 

  {
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_TRAIT_SPEC_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_class_entry *ce ;
  zend_class_entry *trait ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;

  {
  opline = execute_data->opline;
  ce = ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->class_entry;
  if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
    trait = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
  } else {
    tmp = zend_fetch_class_by_name((char const   *)(opline->op2.zv)->value.str.val, (unsigned int )(opline->op2.zv)->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), (int )opline->extended_value);
    trait = (zend_class_entry *)tmp;
    tmp___0 = __builtin_expect((long )((unsigned int )trait == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      (execute_data->opline) ++;
      return (0);
    } else {

    }
    if (! ((trait->ce_flags & 288U) == 288U)) {
      zend_error_noreturn(1, "%s cannot use %s - it is not a trait", ce->name, trait->name);
    } else {

    }
    while (1) {
      *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)trait;
      break;
    }
  }
  zend_do_implement_trait(ce, trait);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BIND_TRAITS_SPEC_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_class_entry *ce ;

  {
  opline = execute_data->opline;
  ce = ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->class_entry;
  zend_do_bind_traits(ce);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_HANDLE_EXCEPTION_SPEC_HANDLER)(zend_execute_data *execute_data ) 
{ zend_uint op_num ;
  int i ;
  zend_uint catch_op_num ;
  int catched ;
  zval restored_error_reporting ;
  void **stack_frame ;
  zval *stack_zval_p ;
  void *tmp ;
  void **tmp___0 ;
  void *tmp___1 ;
  zend_uint tmp___2 ;
  zend_op *brk_opline ;
  int tmp___3 ;

  {
  op_num = (zend_uint )(executor_globals.opline_before_exception - (executor_globals.active_op_array)->opcodes);
  catch_op_num = (zend_uint )0;
  catched = 0;
  stack_frame = (void **)((char *)execute_data->Ts + (((sizeof(temp_variable ) + 4U) - 1U) & 4294967292U) * (execute_data->op_array)->T);
  while (1) {
    tmp___0 = zend_vm_stack_top();
    if ((unsigned int )tmp___0 != (unsigned int )stack_frame) {

    } else {
      break;
    }
    tmp = zend_vm_stack_pop();
    stack_zval_p = (zval *)tmp;
    i_zval_ptr_dtor(stack_zval_p);
  }
  i = 0;
  while (i < (executor_globals.active_op_array)->last_try_catch) {
    if (((executor_globals.active_op_array)->try_catch_array + i)->try_op > op_num) {
      break;
    } else {
      if (op_num < ((executor_globals.active_op_array)->try_catch_array + i)->catch_op) {
        catch_op_num = ((execute_data->op_array)->try_catch_array + i)->catch_op;
        catched = 1;
      } else {

      }
    }
    i ++;
  }
  while (execute_data->fbc) {
    tmp___1 = zend_ptr_stack_pop(& executor_globals.arg_types_stack);
    execute_data->called_scope = (zend_class_entry *)tmp___1;
    if (execute_data->object) {
      if ((unsigned long )execute_data->called_scope & 1UL) {
        if ((unsigned long )execute_data->called_scope & 2UL) {
          zval_delref_p(execute_data->object);
        } else {

        }
        tmp___2 = zval_refcount_p(execute_data->object);
        if (tmp___2 == 1U) {
          zend_object_store_ctor_failed(execute_data->object);
        } else {

        }
      } else {

      }
      i_zval_ptr_dtor(execute_data->object);
    } else {

    }
    execute_data->called_scope = (zend_class_entry *)((unsigned long )execute_data->called_scope & 4294967292UL);
    zend_arg_types_stack_2_pop(& executor_globals.arg_types_stack, & execute_data->object, & execute_data->fbc);
  }
  i = 0;
  while (i < (execute_data->op_array)->last_brk_cont) {
    if (((execute_data->op_array)->brk_cont_array + i)->start < 0) {
      goto __Cont;
    } else {
      if ((zend_uint )((execute_data->op_array)->brk_cont_array + i)->start > op_num) {
        break;
      } else {
        if (op_num < (zend_uint )((execute_data->op_array)->brk_cont_array + i)->brk) {
          if (! catched) {
            goto _L;
          } else {
            if (catch_op_num >= (zend_uint )((execute_data->op_array)->brk_cont_array + i)->brk) {
              _L: /* CIL Label */ 
              brk_opline = (execute_data->op_array)->opcodes + ((execute_data->op_array)->brk_cont_array + i)->brk;
              switch ((int )brk_opline->opcode) {
              case 49: 
              if (! (brk_opline->extended_value & (unsigned long )(1 << 2))) {
                i_zval_ptr_dtor(((temp_variable *)((char *)execute_data->Ts + brk_opline->op1.var))->var.ptr);
              } else {

              }
              break;
              case 70: 
              if (! (brk_opline->extended_value & (unsigned long )(1 << 2))) {
                _zval_dtor(& ((temp_variable *)((char *)execute_data->Ts + brk_opline->op1.var))->tmp_var);
              } else {

              }
              break;
              }
            } else {

            }
          }
        } else {

        }
      }
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  if (! executor_globals.error_reporting) {
    if ((unsigned int )execute_data->old_error_reporting != (unsigned int )((void *)0)) {
      if ((execute_data->old_error_reporting)->value.lval != 0L) {
        restored_error_reporting.type = (unsigned char)1;
        restored_error_reporting.value.lval = (execute_data->old_error_reporting)->value.lval;
        if ((int )restored_error_reporting.type != 6) {
          _convert_to_string(& restored_error_reporting);
        } else {

        }
        zend_alter_ini_entry_ex((char *)"error_reporting", sizeof("error_reporting"), restored_error_reporting.value.str.val, (unsigned int )restored_error_reporting.value.str.len, 1, 1 << 4, 1);
        _zval_dtor(& restored_error_reporting);
      } else {

      }
    } else {

    }
  } else {

  }
  execute_data->old_error_reporting = (zval *)((void *)0);
  if (! catched) {
    tmp___3 = zend_leave_helper_SPEC(execute_data);
    return (tmp___3);
  } else {
    execute_data->opline = (execute_data->op_array)->opcodes + catch_op_num;
    return (0);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;

  {
  opline = execute_data->opline;
  zend_verify_abstract_class(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->class_entry);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_USER_OPCODE_SPEC_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  int ret ;
  int tmp ;
  opcode_handler_t tmp___0 ;
  int tmp___1 ;
  opcode_handler_t tmp___2 ;
  int tmp___3 ;

  {
  opline = execute_data->opline;
  ret = (*(zend_user_opcode_handlers[opline->opcode]))(execute_data);
  switch (ret) {
  case 0: 
  return (0);
  case 1: 
  tmp = zend_leave_helper_SPEC(execute_data);
  return (tmp);
  case 3: 
  return (2);
  case 4: 
  return (3);
  case 2: 
  tmp___0 = zend_vm_get_opcode_handler(opline->opcode, opline);
  tmp___1 = (*tmp___0)(execute_data);
  return (tmp___1);
  default: 
  tmp___2 = zend_vm_get_opcode_handler((unsigned char )(ret & 0xff), opline);
  tmp___3 = (*tmp___2)(execute_data);
  return (tmp___3);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_CLASS_SPEC_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp ;
  zval *class_name ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___2 ;

  {
  opline = execute_data->opline;
  executor_globals.exception = (zval *)((void *)0);
  if (1 == 1 << 3) {
    tmp = zend_fetch_class((char const   *)((void *)0), 0U, (int )opline->extended_value);
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->class_entry = (zend_class_entry *)tmp;
    (execute_data->opline) ++;
    return (0);
  } else {
    class_name = opline->op2.zv;
    if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->class_entry = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
    } else {
      tmp___0 = zend_fetch_class_by_name((char const   *)class_name->value.str.val, (unsigned int )class_name->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), (int )opline->extended_value);
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->class_entry = (zend_class_entry *)tmp___0;
      while (1) {
        *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)((temp_variable *)((char *)execute_data->Ts + opline->result.var))->class_entry;
        break;
      }
    }
    (execute_data->opline) ++;
    return (0);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_FCALL_BY_NAME_SPEC_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *function_name ;
  int __attribute__((__visibility__("default")))  tmp ;
  long tmp___0 ;
  char *function_name_strval ;
  char *lcname ;
  int function_name_strlen ;
  char __attribute__((__visibility__("default")))  *tmp___1 ;
  char __attribute__((__visibility__("default")))  *tmp___2 ;
  int __attribute__((__visibility__("default")))  tmp___3 ;
  long tmp___4 ;
  zend_class_entry *ce ;
  zval **method ;
  zval **obj ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___5 ;
  long tmp___6 ;
  union _zend_function  __attribute__((__visibility__("default"))) *tmp___7 ;
  zend_class_entry *tmp___8 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___9 ;
  zend_class_entry *tmp___10 ;
  zend_class_entry *tmp___11 ;
  char const   *tmp___12 ;
  zend_class_entry *tmp___13 ;
  long tmp___14 ;
  zval *this_ptr ;
  void __attribute__((__visibility__("default")))  *tmp___15 ;
  zend_bool tmp___16 ;
  long tmp___17 ;
  long tmp___18 ;
  int __attribute__((__visibility__("default")))  tmp___19 ;
  long tmp___20 ;
  int tmp___21 ;
  long tmp___22 ;

  {
  opline = execute_data->opline;
  zend_ptr_stack_3_push(& executor_globals.arg_types_stack, (void *)execute_data->fbc, (void *)execute_data->object, (void *)execute_data->called_scope);
  function_name = (zval *)(opline->op2.literal + 1);
  if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
    execute_data->fbc = (zend_function *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
  } else {
    tmp = zend_hash_quick_find((HashTable const   *)executor_globals.function_table, (char const   *)function_name->value.str.val, (unsigned int )(function_name->value.str.len + 1), ((zend_literal *)function_name)->hash_value, (void **)(& execute_data->fbc));
    tmp___0 = __builtin_expect((long )(tmp == (int __attribute__((__visibility__("default")))  )-1), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Call to undefined function %s()", (opline->op2.zv)->value.str.val);
    } else {
      while (1) {
        *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)execute_data->fbc;
        break;
      }
    }
  }
  execute_data->object = (zval *)((void *)0);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_NS_FCALL_BY_NAME_SPEC_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_literal *func_name ;
  int __attribute__((__visibility__("default")))  tmp ;
  long tmp___0 ;
  int __attribute__((__visibility__("default")))  tmp___1 ;

  {
  opline = execute_data->opline;
  zend_ptr_stack_3_push(& executor_globals.arg_types_stack, (void *)execute_data->fbc, (void *)execute_data->object, (void *)execute_data->called_scope);
  func_name = opline->op2.literal + 1;
  if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
    execute_data->fbc = (zend_function *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
  } else {
    tmp___1 = zend_hash_quick_find((HashTable const   *)executor_globals.function_table, (char const   *)func_name->constant.value.str.val, (unsigned int )(func_name->constant.value.str.len + 1), func_name->hash_value, (void **)(& execute_data->fbc));
    if (tmp___1 == (int __attribute__((__visibility__("default")))  )-1) {
      func_name ++;
      tmp = zend_hash_quick_find((HashTable const   *)executor_globals.function_table, (char const   *)func_name->constant.value.str.val, (unsigned int )(func_name->constant.value.str.len + 1), func_name->hash_value, (void **)(& execute_data->fbc));
      tmp___0 = __builtin_expect((long )(tmp == (int __attribute__((__visibility__("default")))  )-1), 0L);
      if (tmp___0) {
        zend_error_noreturn(1, "Call to undefined function %s()", (opline->op2.zv)->value.str.val);
      } else {
        while (1) {
          *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)execute_data->fbc;
          break;
        }
      }
    } else {
      while (1) {
        *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)execute_data->fbc;
        break;
      }
    }
  }
  execute_data->object = (zval *)((void *)0);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_RECV_INIT_SPEC_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *assignment_value ;
  zend_uint arg_num ;
  zval **param ;
  zval **tmp ;
  zval **var_ptr ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;

  {
  opline = execute_data->opline;
  arg_num = opline->op1.num;
  tmp = zend_vm_stack_get_arg((int )arg_num);
  param = tmp;
  if ((unsigned int )param == (unsigned int )((void *)0)) {
    while (1) {
      tmp___0 = _emalloc(sizeof(zval_gc_info ));
      assignment_value = (zval *)tmp___0;
      ((zval_gc_info *)assignment_value)->u.buffered = (gc_root_buffer *)((void *)0);
      break;
    }
    *assignment_value = *(opline->op2.zv);
    if (((int )assignment_value->type & 0x00f) == 8) {
      zval_set_refcount_p(assignment_value, 1U);
      zval_update_constant(& assignment_value, (void *)0);
    } else {
      if ((int )assignment_value->type == 9) {
        zval_set_refcount_p(assignment_value, 1U);
        zval_update_constant(& assignment_value, (void *)0);
      } else {
        _zval_copy_ctor(assignment_value);
      }
    }
    assignment_value->refcount__gc = 1U;
    assignment_value->is_ref__gc = (unsigned char)0;
  } else {
    assignment_value = *param;
    zval_addref_p(assignment_value);
  }
  zend_verify_arg_type((zend_function *)executor_globals.active_op_array, arg_num, assignment_value, opline->extended_value);
  var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->result.var);
  zval_delref_p(*var_ptr);
  *var_ptr = assignment_value;
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BRK_SPEC_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_brk_cont_element *el ;
  long tmp ;

  {
  opline = execute_data->opline;
  el = zend_brk_cont((int )(opline->op2.zv)->value.lval, (int )opline->op1.opline_num, (zend_op_array const   *)execute_data->op_array, (temp_variable const   *)execute_data->Ts);
  tmp = __builtin_expect((long )(! executor_globals.exception), 1L);
  if (tmp) {
    execute_data->opline = (execute_data->op_array)->opcodes + el->brk;
  } else {

  }
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_CONT_SPEC_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_brk_cont_element *el ;
  long tmp ;

  {
  opline = execute_data->opline;
  el = zend_brk_cont((int )(opline->op2.zv)->value.lval, (int )opline->op1.opline_num, (zend_op_array const   *)execute_data->op_array, (temp_variable const   *)execute_data->Ts);
  tmp = __builtin_expect((long )(! executor_globals.exception), 1L);
  if (tmp) {
    execute_data->opline = (execute_data->op_array)->opcodes + el->cont;
  } else {

  }
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_GOTO_SPEC_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *brk_opline ;
  zend_op *opline ;
  zend_brk_cont_element *el ;
  long tmp ;

  {
  opline = execute_data->opline;
  el = zend_brk_cont((int )(opline->op2.zv)->value.lval, (int )opline->extended_value, (zend_op_array const   *)execute_data->op_array, (temp_variable const   *)execute_data->Ts);
  brk_opline = (execute_data->op_array)->opcodes + el->brk;
  switch ((int )brk_opline->opcode) {
  case 49: 
  if (! (brk_opline->extended_value & (unsigned long )(1 << 2))) {
    i_zval_ptr_dtor(((temp_variable *)((char *)execute_data->Ts + brk_opline->op1.var))->var.ptr);
  } else {

  }
  break;
  case 70: 
  if (! (brk_opline->extended_value & (unsigned long )(1 << 2))) {
    _zval_dtor(& ((temp_variable *)((char *)execute_data->Ts + brk_opline->op1.var))->tmp_var);
  } else {

  }
  break;
  }
  tmp = __builtin_expect((long )(! executor_globals.exception), 1L);
  if (tmp) {
    execute_data->opline = opline->op1.jmp_addr;
  } else {

  }
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_INTERFACE_SPEC_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_class_entry *ce ;
  zend_class_entry *iface ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  opline = execute_data->opline;
  ce = ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->class_entry;
  if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
    iface = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
  } else {
    tmp = zend_fetch_class_by_name((char const   *)(opline->op2.zv)->value.str.val, (unsigned int )(opline->op2.zv)->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), (int )opline->extended_value);
    iface = (zend_class_entry *)tmp;
    tmp___0 = __builtin_expect((long )((unsigned int )iface == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      (execute_data->opline) ++;
      return (0);
    } else {

    }
    while (1) {
      *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
      break;
    }
  }
  tmp___1 = __builtin_expect((long )((iface->ce_flags & 128U) == 0U), 0L);
  if (tmp___1) {
    zend_error_noreturn(1, "%s cannot implement %s - it is not an interface", ce->name, iface->name);
  } else {

  }
  zend_do_implement_interface(ce, iface);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_CLASS_SPEC_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp ;
  zend_free_op free_op2 ;
  zval *class_name ;
  zval *tmp___0 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___3 ;

  {
  opline = execute_data->opline;
  executor_globals.exception = (zval *)((void *)0);
  if (1 << 1 == 1 << 3) {
    tmp = zend_fetch_class((char const   *)((void *)0), 0U, (int )opline->extended_value);
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->class_entry = (zend_class_entry *)tmp;
    (execute_data->opline) ++;
    return (0);
  } else {
    tmp___0 = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    class_name = tmp___0;
    if (1 << 1 == 1) {
      if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->class_entry = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
      } else {
        tmp___1 = zend_fetch_class_by_name((char const   *)class_name->value.str.val, (unsigned int )class_name->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), (int )opline->extended_value);
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->class_entry = (zend_class_entry *)tmp___1;
        while (1) {
          *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)((temp_variable *)((char *)execute_data->Ts + opline->result.var))->class_entry;
          break;
        }
      }
    } else {
      if ((int )class_name->type == 5) {
        tmp___2 = zend_get_class_entry((zval const   *)class_name);
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->class_entry = (zend_class_entry *)tmp___2;
      } else {
        if ((int )class_name->type == 6) {
          tmp___3 = zend_fetch_class((char const   *)class_name->value.str.val, (unsigned int )class_name->value.str.len, (int )opline->extended_value);
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->class_entry = (zend_class_entry *)tmp___3;
        } else {
          zend_error_noreturn(1, "Class name must be a valid object or a string");
        }
      }
    }
    _zval_dtor(free_op2.var);
    (execute_data->opline) ++;
    return (0);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_FCALL_BY_NAME_SPEC_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *function_name ;
  int __attribute__((__visibility__("default")))  tmp ;
  long tmp___0 ;
  char *function_name_strval ;
  char *lcname ;
  int function_name_strlen ;
  zend_free_op free_op2 ;
  char __attribute__((__visibility__("default")))  *tmp___1 ;
  char __attribute__((__visibility__("default")))  *tmp___2 ;
  int __attribute__((__visibility__("default")))  tmp___3 ;
  long tmp___4 ;
  zend_class_entry *ce ;
  zval **method ;
  zval **obj ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___5 ;
  long tmp___6 ;
  union _zend_function  __attribute__((__visibility__("default"))) *tmp___7 ;
  zend_class_entry *tmp___8 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___9 ;
  zend_class_entry *tmp___10 ;
  zend_class_entry *tmp___11 ;
  char const   *tmp___12 ;
  zend_class_entry *tmp___13 ;
  long tmp___14 ;
  zval *this_ptr ;
  void __attribute__((__visibility__("default")))  *tmp___15 ;
  zend_bool tmp___16 ;
  long tmp___17 ;
  long tmp___18 ;
  int __attribute__((__visibility__("default")))  tmp___19 ;
  long tmp___20 ;
  int tmp___21 ;
  long tmp___22 ;

  {
  opline = execute_data->opline;
  zend_ptr_stack_3_push(& executor_globals.arg_types_stack, (void *)execute_data->fbc, (void *)execute_data->object, (void *)execute_data->called_scope);
  if (1 << 1 == 1) {
    function_name = (zval *)(opline->op2.literal + 1);
    if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
      execute_data->fbc = (zend_function *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
    } else {
      tmp = zend_hash_quick_find((HashTable const   *)executor_globals.function_table, (char const   *)function_name->value.str.val, (unsigned int )(function_name->value.str.len + 1), ((zend_literal *)function_name)->hash_value, (void **)(& execute_data->fbc));
      tmp___0 = __builtin_expect((long )(tmp == (int __attribute__((__visibility__("default")))  )-1), 0L);
      if (tmp___0) {
        zend_error_noreturn(1, "Call to undefined function %s()", (opline->op2.zv)->value.str.val);
      } else {
        while (1) {
          *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)execute_data->fbc;
          break;
        }
      }
    }
    execute_data->object = (zval *)((void *)0);
    (execute_data->opline) ++;
    return (0);
  } else {
    function_name = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    tmp___22 = __builtin_expect((long )((int )function_name->type == 6), 1L);
    if (tmp___22) {
      function_name_strval = function_name->value.str.val;
      function_name_strlen = function_name->value.str.len;
      if ((int )*(function_name_strval + 0) == 92) {
        function_name_strlen --;
        tmp___1 = zend_str_tolower_dup((char const   *)(function_name_strval + 1), (unsigned int )function_name_strlen);
        lcname = (char *)tmp___1;
      } else {
        tmp___2 = zend_str_tolower_dup((char const   *)function_name_strval, (unsigned int )function_name_strlen);
        lcname = (char *)tmp___2;
      }
      tmp___3 = zend_hash_find((HashTable const   *)executor_globals.function_table, (char const   *)lcname, (unsigned int )(function_name_strlen + 1), (void **)(& execute_data->fbc));
      tmp___4 = __builtin_expect((long )(tmp___3 == (int __attribute__((__visibility__("default")))  )-1), 0L);
      if (tmp___4) {
        zend_error_noreturn(1, "Call to undefined function %s()", function_name_strval);
      } else {

      }
      _efree((void *)lcname);
      _zval_dtor(free_op2.var);
      execute_data->object = (zval *)((void *)0);
      (execute_data->opline) ++;
      return (0);
    } else {
      if (1 << 1 != 1) {
        if (1 << 1 != 1 << 1) {
          tmp___20 = __builtin_expect((long )((int )function_name->type == 5), 1L);
          if (tmp___20) {
            if ((function_name->value.obj.handlers)->get_closure) {
              tmp___21 = (*((function_name->value.obj.handlers)->get_closure))(function_name, & execute_data->called_scope, & execute_data->fbc, & execute_data->object);
              if (tmp___21 == 0) {
                if (execute_data->object) {
                  zval_addref_p(execute_data->object);
                } else {

                }
                if (1 << 1 == 1 << 2) {
                  if ((execute_data->fbc)->common.fn_flags & 1048576U) {
                    (execute_data->fbc)->common.prototype = (zend_function *)function_name;
                  } else {
                    _zval_dtor(free_op2.var);
                  }
                } else {
                  _zval_dtor(free_op2.var);
                }
                (execute_data->opline) ++;
                return (0);
              } else {
                goto _L___2;
              }
            } else {
              goto _L___2;
            }
          } else {
            goto _L___2;
          }
        } else {
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
        _L___1: /* CIL Label */ 
        _L___0: /* CIL Label */ 
        _L: /* CIL Label */ 
        if (1 << 1 != 1) {
          tmp___18 = __builtin_expect((long )((int )function_name->type == 4), 1L);
          if (tmp___18) {
            tmp___19 = zend_hash_num_elements((HashTable const   *)function_name->value.ht);
            if (tmp___19 == (int __attribute__((__visibility__("default")))  )2) {
              method = (zval **)((void *)0);
              obj = (zval **)((void *)0);
              zend_hash_index_find((HashTable const   *)function_name->value.ht, 0UL, (void **)(& obj));
              zend_hash_index_find((HashTable const   *)function_name->value.ht, 1UL, (void **)(& method));
              if ((int )(*obj)->type != 6) {
                if ((int )(*obj)->type != 5) {
                  zend_error_noreturn(1, "First array member is not a valid class name or object");
                } else {

                }
              } else {

              }
              if ((int )(*method)->type != 6) {
                zend_error_noreturn(1, "Second array member is not a valid method");
              } else {

              }
              if ((int )(*obj)->type == 6) {
                tmp___5 = zend_fetch_class_by_name((char const   *)(*obj)->value.str.val, (unsigned int )(*obj)->value.str.len, (zend_literal const   *)((void *)0), 0);
                ce = (zend_class_entry *)tmp___5;
                tmp___6 = __builtin_expect((long )((unsigned int )ce == (unsigned int )((void *)0)), 0L);
                if (tmp___6) {
                  zend_error_noreturn(1, "Class \'%s\' not found", (*obj)->value.str.val);
                } else {

                }
                execute_data->called_scope = ce;
                execute_data->object = (zval *)((void *)0);
                if (ce->get_static_method) {
                  execute_data->fbc = (*(ce->get_static_method))(ce, (*method)->value.str.val, (*method)->value.str.len);
                } else {
                  tmp___7 = zend_std_get_static_method(ce, (char const   *)(*method)->value.str.val, (*method)->value.str.len, (struct _zend_literal  const  *)((void *)0));
                  execute_data->fbc = (zend_function *)tmp___7;
                }
              } else {
                execute_data->object = *obj;
                tmp___9 = zend_get_class_entry((zval const   *)*obj);
                tmp___8 = (zend_class_entry *)tmp___9;
                execute_data->called_scope = tmp___8;
                ce = tmp___8;
                execute_data->fbc = (*(((execute_data->object)->value.obj.handlers)->get_method))(& execute_data->object, (*method)->value.str.val, (*method)->value.str.len, (struct _zend_literal  const  *)((void *)0));
                tmp___14 = __builtin_expect((long )((unsigned int )execute_data->fbc == (unsigned int )((void *)0)), 0L);
                if (tmp___14) {
                  if (execute_data->object) {
                    if ((int )(execute_data->object)->type == 5) {
                      if ((unsigned int )((execute_data->object)->value.obj.handlers)->get_class_entry != (unsigned int )((void *)0)) {
                        tmp___13 = (*(((execute_data->object)->value.obj.handlers)->get_class_entry))((zval const   *)execute_data->object);
                        if (tmp___13) {
                          tmp___11 = (*(((execute_data->object)->value.obj.handlers)->get_class_entry))((zval const   *)execute_data->object);
                          tmp___12 = tmp___11->name;
                        } else {
                          tmp___12 = "";
                        }
                      } else {
                        tmp___12 = "";
                      }
                    } else {
                      tmp___12 = "";
                    }
                  } else {
                    tmp___12 = "";
                  }
                  zend_error_noreturn(1, "Call to undefined method %s::%s()", tmp___12, (*method)->value.str.val);
                } else {

                }
                if (((execute_data->fbc)->common.fn_flags & 1U) != 0U) {
                  execute_data->object = (zval *)((void *)0);
                } else {
                  tmp___16 = zval_isref_p(execute_data->object);
                  if (tmp___16) {
                    while (1) {
                      tmp___15 = _emalloc(sizeof(zval_gc_info ));
                      this_ptr = (zval *)tmp___15;
                      ((zval_gc_info *)this_ptr)->u.buffered = (gc_root_buffer *)((void *)0);
                      break;
                    }
                    while (1) {
                      while (1) {
                        this_ptr->value = (execute_data->object)->value;
                        this_ptr->type = (execute_data->object)->type;
                        break;
                      }
                      zval_set_refcount_p(this_ptr, 1U);
                      zval_unset_isref_p(this_ptr);
                      break;
                    }
                    _zval_copy_ctor(this_ptr);
                    execute_data->object = this_ptr;
                  } else {
                    zval_addref_p(execute_data->object);
                  }
                }
              }
              tmp___17 = __builtin_expect((long )((unsigned int )execute_data->fbc == (unsigned int )((void *)0)), 0L);
              if (tmp___17) {
                zend_error_noreturn(1, "Call to undefined method %s::%s()", ce->name, (*method)->value.str.val);
              } else {

              }
              _zval_dtor(free_op2.var);
              (execute_data->opline) ++;
              return (0);
            } else {
              zend_error_noreturn(1, "Function name must be a string");
            }
          } else {
            zend_error_noreturn(1, "Function name must be a string");
          }
        } else {
          zend_error_noreturn(1, "Function name must be a string");
        }
      }
    }
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_CLASS_SPEC_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp ;
  zend_free_op free_op2 ;
  zval *class_name ;
  zval *tmp___0 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___3 ;

  {
  opline = execute_data->opline;
  executor_globals.exception = (zval *)((void *)0);
  if (1 << 2 == 1 << 3) {
    tmp = zend_fetch_class((char const   *)((void *)0), 0U, (int )opline->extended_value);
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->class_entry = (zend_class_entry *)tmp;
    (execute_data->opline) ++;
    return (0);
  } else {
    tmp___0 = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    class_name = tmp___0;
    if (1 << 2 == 1) {
      if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->class_entry = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
      } else {
        tmp___1 = zend_fetch_class_by_name((char const   *)class_name->value.str.val, (unsigned int )class_name->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), (int )opline->extended_value);
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->class_entry = (zend_class_entry *)tmp___1;
        while (1) {
          *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)((temp_variable *)((char *)execute_data->Ts + opline->result.var))->class_entry;
          break;
        }
      }
    } else {
      if ((int )class_name->type == 5) {
        tmp___2 = zend_get_class_entry((zval const   *)class_name);
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->class_entry = (zend_class_entry *)tmp___2;
      } else {
        if ((int )class_name->type == 6) {
          tmp___3 = zend_fetch_class((char const   *)class_name->value.str.val, (unsigned int )class_name->value.str.len, (int )opline->extended_value);
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->class_entry = (zend_class_entry *)tmp___3;
        } else {
          zend_error_noreturn(1, "Class name must be a valid object or a string");
        }
      }
    }
    if (free_op2.var) {
      i_zval_ptr_dtor(free_op2.var);
    } else {

    }
    (execute_data->opline) ++;
    return (0);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_FCALL_BY_NAME_SPEC_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *function_name ;
  int __attribute__((__visibility__("default")))  tmp ;
  long tmp___0 ;
  char *function_name_strval ;
  char *lcname ;
  int function_name_strlen ;
  zend_free_op free_op2 ;
  char __attribute__((__visibility__("default")))  *tmp___1 ;
  char __attribute__((__visibility__("default")))  *tmp___2 ;
  int __attribute__((__visibility__("default")))  tmp___3 ;
  long tmp___4 ;
  zend_class_entry *ce ;
  zval **method ;
  zval **obj ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___5 ;
  long tmp___6 ;
  union _zend_function  __attribute__((__visibility__("default"))) *tmp___7 ;
  zend_class_entry *tmp___8 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___9 ;
  zend_class_entry *tmp___10 ;
  zend_class_entry *tmp___11 ;
  char const   *tmp___12 ;
  zend_class_entry *tmp___13 ;
  long tmp___14 ;
  zval *this_ptr ;
  void __attribute__((__visibility__("default")))  *tmp___15 ;
  zend_bool tmp___16 ;
  long tmp___17 ;
  long tmp___18 ;
  int __attribute__((__visibility__("default")))  tmp___19 ;
  long tmp___20 ;
  int tmp___21 ;
  long tmp___22 ;

  {
  opline = execute_data->opline;
  zend_ptr_stack_3_push(& executor_globals.arg_types_stack, (void *)execute_data->fbc, (void *)execute_data->object, (void *)execute_data->called_scope);
  if (1 << 2 == 1) {
    function_name = (zval *)(opline->op2.literal + 1);
    if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
      execute_data->fbc = (zend_function *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
    } else {
      tmp = zend_hash_quick_find((HashTable const   *)executor_globals.function_table, (char const   *)function_name->value.str.val, (unsigned int )(function_name->value.str.len + 1), ((zend_literal *)function_name)->hash_value, (void **)(& execute_data->fbc));
      tmp___0 = __builtin_expect((long )(tmp == (int __attribute__((__visibility__("default")))  )-1), 0L);
      if (tmp___0) {
        zend_error_noreturn(1, "Call to undefined function %s()", (opline->op2.zv)->value.str.val);
      } else {
        while (1) {
          *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)execute_data->fbc;
          break;
        }
      }
    }
    execute_data->object = (zval *)((void *)0);
    (execute_data->opline) ++;
    return (0);
  } else {
    function_name = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    tmp___22 = __builtin_expect((long )((int )function_name->type == 6), 1L);
    if (tmp___22) {
      function_name_strval = function_name->value.str.val;
      function_name_strlen = function_name->value.str.len;
      if ((int )*(function_name_strval + 0) == 92) {
        function_name_strlen --;
        tmp___1 = zend_str_tolower_dup((char const   *)(function_name_strval + 1), (unsigned int )function_name_strlen);
        lcname = (char *)tmp___1;
      } else {
        tmp___2 = zend_str_tolower_dup((char const   *)function_name_strval, (unsigned int )function_name_strlen);
        lcname = (char *)tmp___2;
      }
      tmp___3 = zend_hash_find((HashTable const   *)executor_globals.function_table, (char const   *)lcname, (unsigned int )(function_name_strlen + 1), (void **)(& execute_data->fbc));
      tmp___4 = __builtin_expect((long )(tmp___3 == (int __attribute__((__visibility__("default")))  )-1), 0L);
      if (tmp___4) {
        zend_error_noreturn(1, "Call to undefined function %s()", function_name_strval);
      } else {

      }
      _efree((void *)lcname);
      if (free_op2.var) {
        i_zval_ptr_dtor(free_op2.var);
      } else {

      }
      execute_data->object = (zval *)((void *)0);
      (execute_data->opline) ++;
      return (0);
    } else {
      if (1 << 2 != 1) {
        if (1 << 2 != 1 << 1) {
          tmp___20 = __builtin_expect((long )((int )function_name->type == 5), 1L);
          if (tmp___20) {
            if ((function_name->value.obj.handlers)->get_closure) {
              tmp___21 = (*((function_name->value.obj.handlers)->get_closure))(function_name, & execute_data->called_scope, & execute_data->fbc, & execute_data->object);
              if (tmp___21 == 0) {
                if (execute_data->object) {
                  zval_addref_p(execute_data->object);
                } else {

                }
                if (1 << 2 == 1 << 2) {
                  if ((unsigned int )free_op2.var != (unsigned int )((void *)0)) {
                    if ((execute_data->fbc)->common.fn_flags & 1048576U) {
                      (execute_data->fbc)->common.prototype = (zend_function *)function_name;
                    } else {
                      goto _L___0;
                    }
                  } else {
                    goto _L___0;
                  }
                } else {
                  _L___0: /* CIL Label */ 
                  _L: /* CIL Label */ 
                  if (free_op2.var) {
                    i_zval_ptr_dtor(free_op2.var);
                  } else {

                  }
                }
                (execute_data->opline) ++;
                return (0);
              } else {
                goto _L___4;
              }
            } else {
              goto _L___4;
            }
          } else {
            goto _L___4;
          }
        } else {
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ 
        _L___3: /* CIL Label */ 
        _L___2: /* CIL Label */ 
        _L___1: /* CIL Label */ 
        if (1 << 2 != 1) {
          tmp___18 = __builtin_expect((long )((int )function_name->type == 4), 1L);
          if (tmp___18) {
            tmp___19 = zend_hash_num_elements((HashTable const   *)function_name->value.ht);
            if (tmp___19 == (int __attribute__((__visibility__("default")))  )2) {
              method = (zval **)((void *)0);
              obj = (zval **)((void *)0);
              zend_hash_index_find((HashTable const   *)function_name->value.ht, 0UL, (void **)(& obj));
              zend_hash_index_find((HashTable const   *)function_name->value.ht, 1UL, (void **)(& method));
              if ((int )(*obj)->type != 6) {
                if ((int )(*obj)->type != 5) {
                  zend_error_noreturn(1, "First array member is not a valid class name or object");
                } else {

                }
              } else {

              }
              if ((int )(*method)->type != 6) {
                zend_error_noreturn(1, "Second array member is not a valid method");
              } else {

              }
              if ((int )(*obj)->type == 6) {
                tmp___5 = zend_fetch_class_by_name((char const   *)(*obj)->value.str.val, (unsigned int )(*obj)->value.str.len, (zend_literal const   *)((void *)0), 0);
                ce = (zend_class_entry *)tmp___5;
                tmp___6 = __builtin_expect((long )((unsigned int )ce == (unsigned int )((void *)0)), 0L);
                if (tmp___6) {
                  zend_error_noreturn(1, "Class \'%s\' not found", (*obj)->value.str.val);
                } else {

                }
                execute_data->called_scope = ce;
                execute_data->object = (zval *)((void *)0);
                if (ce->get_static_method) {
                  execute_data->fbc = (*(ce->get_static_method))(ce, (*method)->value.str.val, (*method)->value.str.len);
                } else {
                  tmp___7 = zend_std_get_static_method(ce, (char const   *)(*method)->value.str.val, (*method)->value.str.len, (struct _zend_literal  const  *)((void *)0));
                  execute_data->fbc = (zend_function *)tmp___7;
                }
              } else {
                execute_data->object = *obj;
                tmp___9 = zend_get_class_entry((zval const   *)*obj);
                tmp___8 = (zend_class_entry *)tmp___9;
                execute_data->called_scope = tmp___8;
                ce = tmp___8;
                execute_data->fbc = (*(((execute_data->object)->value.obj.handlers)->get_method))(& execute_data->object, (*method)->value.str.val, (*method)->value.str.len, (struct _zend_literal  const  *)((void *)0));
                tmp___14 = __builtin_expect((long )((unsigned int )execute_data->fbc == (unsigned int )((void *)0)), 0L);
                if (tmp___14) {
                  if (execute_data->object) {
                    if ((int )(execute_data->object)->type == 5) {
                      if ((unsigned int )((execute_data->object)->value.obj.handlers)->get_class_entry != (unsigned int )((void *)0)) {
                        tmp___13 = (*(((execute_data->object)->value.obj.handlers)->get_class_entry))((zval const   *)execute_data->object);
                        if (tmp___13) {
                          tmp___11 = (*(((execute_data->object)->value.obj.handlers)->get_class_entry))((zval const   *)execute_data->object);
                          tmp___12 = tmp___11->name;
                        } else {
                          tmp___12 = "";
                        }
                      } else {
                        tmp___12 = "";
                      }
                    } else {
                      tmp___12 = "";
                    }
                  } else {
                    tmp___12 = "";
                  }
                  zend_error_noreturn(1, "Call to undefined method %s::%s()", tmp___12, (*method)->value.str.val);
                } else {

                }
                if (((execute_data->fbc)->common.fn_flags & 1U) != 0U) {
                  execute_data->object = (zval *)((void *)0);
                } else {
                  tmp___16 = zval_isref_p(execute_data->object);
                  if (tmp___16) {
                    while (1) {
                      tmp___15 = _emalloc(sizeof(zval_gc_info ));
                      this_ptr = (zval *)tmp___15;
                      ((zval_gc_info *)this_ptr)->u.buffered = (gc_root_buffer *)((void *)0);
                      break;
                    }
                    while (1) {
                      while (1) {
                        this_ptr->value = (execute_data->object)->value;
                        this_ptr->type = (execute_data->object)->type;
                        break;
                      }
                      zval_set_refcount_p(this_ptr, 1U);
                      zval_unset_isref_p(this_ptr);
                      break;
                    }
                    _zval_copy_ctor(this_ptr);
                    execute_data->object = this_ptr;
                  } else {
                    zval_addref_p(execute_data->object);
                  }
                }
              }
              tmp___17 = __builtin_expect((long )((unsigned int )execute_data->fbc == (unsigned int )((void *)0)), 0L);
              if (tmp___17) {
                zend_error_noreturn(1, "Call to undefined method %s::%s()", ce->name, (*method)->value.str.val);
              } else {

              }
              if (free_op2.var) {
                i_zval_ptr_dtor(free_op2.var);
              } else {

              }
              (execute_data->opline) ++;
              return (0);
            } else {
              zend_error_noreturn(1, "Function name must be a string");
            }
          } else {
            zend_error_noreturn(1, "Function name must be a string");
          }
        } else {
          zend_error_noreturn(1, "Function name must be a string");
        }
      }
    }
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_CLASS_SPEC_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp ;
  zval *class_name ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___2 ;

  {
  opline = execute_data->opline;
  executor_globals.exception = (zval *)((void *)0);
  if (1 << 3 == 1 << 3) {
    tmp = zend_fetch_class((char const   *)((void *)0), 0U, (int )opline->extended_value);
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->class_entry = (zend_class_entry *)tmp;
    (execute_data->opline) ++;
    return (0);
  } else {
    class_name = (zval *)((void *)0);
    if (1 << 3 == 1) {
      if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->class_entry = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
      } else {
        tmp___0 = zend_fetch_class_by_name((char const   *)class_name->value.str.val, (unsigned int )class_name->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), (int )opline->extended_value);
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->class_entry = (zend_class_entry *)tmp___0;
        while (1) {
          *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)((temp_variable *)((char *)execute_data->Ts + opline->result.var))->class_entry;
          break;
        }
      }
    } else {
      if ((int )class_name->type == 5) {
        tmp___1 = zend_get_class_entry((zval const   *)class_name);
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->class_entry = (zend_class_entry *)tmp___1;
      } else {
        if ((int )class_name->type == 6) {
          tmp___2 = zend_fetch_class((char const   *)class_name->value.str.val, (unsigned int )class_name->value.str.len, (int )opline->extended_value);
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->class_entry = (zend_class_entry *)tmp___2;
        } else {
          zend_error_noreturn(1, "Class name must be a valid object or a string");
        }
      }
    }
    (execute_data->opline) ++;
    return (0);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_CLASS_SPEC_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp ;
  zval *class_name ;
  zval *tmp___0 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___3 ;

  {
  opline = execute_data->opline;
  executor_globals.exception = (zval *)((void *)0);
  if (1 << 4 == 1 << 3) {
    tmp = zend_fetch_class((char const   *)((void *)0), 0U, (int )opline->extended_value);
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->class_entry = (zend_class_entry *)tmp;
    (execute_data->opline) ++;
    return (0);
  } else {
    tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
    class_name = tmp___0;
    if (1 << 4 == 1) {
      if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->class_entry = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
      } else {
        tmp___1 = zend_fetch_class_by_name((char const   *)class_name->value.str.val, (unsigned int )class_name->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), (int )opline->extended_value);
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->class_entry = (zend_class_entry *)tmp___1;
        while (1) {
          *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)((temp_variable *)((char *)execute_data->Ts + opline->result.var))->class_entry;
          break;
        }
      }
    } else {
      if ((int )class_name->type == 5) {
        tmp___2 = zend_get_class_entry((zval const   *)class_name);
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->class_entry = (zend_class_entry *)tmp___2;
      } else {
        if ((int )class_name->type == 6) {
          tmp___3 = zend_fetch_class((char const   *)class_name->value.str.val, (unsigned int )class_name->value.str.len, (int )opline->extended_value);
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->class_entry = (zend_class_entry *)tmp___3;
        } else {
          zend_error_noreturn(1, "Class name must be a valid object or a string");
        }
      }
    }
    (execute_data->opline) ++;
    return (0);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_FCALL_BY_NAME_SPEC_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *function_name ;
  int __attribute__((__visibility__("default")))  tmp ;
  long tmp___0 ;
  char *function_name_strval ;
  char *lcname ;
  int function_name_strlen ;
  char __attribute__((__visibility__("default")))  *tmp___1 ;
  char __attribute__((__visibility__("default")))  *tmp___2 ;
  int __attribute__((__visibility__("default")))  tmp___3 ;
  long tmp___4 ;
  zend_class_entry *ce ;
  zval **method ;
  zval **obj ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___5 ;
  long tmp___6 ;
  union _zend_function  __attribute__((__visibility__("default"))) *tmp___7 ;
  zend_class_entry *tmp___8 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___9 ;
  zend_class_entry *tmp___10 ;
  zend_class_entry *tmp___11 ;
  char const   *tmp___12 ;
  zend_class_entry *tmp___13 ;
  long tmp___14 ;
  zval *this_ptr ;
  void __attribute__((__visibility__("default")))  *tmp___15 ;
  zend_bool tmp___16 ;
  long tmp___17 ;
  long tmp___18 ;
  int __attribute__((__visibility__("default")))  tmp___19 ;
  long tmp___20 ;
  int tmp___21 ;
  long tmp___22 ;

  {
  opline = execute_data->opline;
  zend_ptr_stack_3_push(& executor_globals.arg_types_stack, (void *)execute_data->fbc, (void *)execute_data->object, (void *)execute_data->called_scope);
  if (1 << 4 == 1) {
    function_name = (zval *)(opline->op2.literal + 1);
    if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
      execute_data->fbc = (zend_function *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
    } else {
      tmp = zend_hash_quick_find((HashTable const   *)executor_globals.function_table, (char const   *)function_name->value.str.val, (unsigned int )(function_name->value.str.len + 1), ((zend_literal *)function_name)->hash_value, (void **)(& execute_data->fbc));
      tmp___0 = __builtin_expect((long )(tmp == (int __attribute__((__visibility__("default")))  )-1), 0L);
      if (tmp___0) {
        zend_error_noreturn(1, "Call to undefined function %s()", (opline->op2.zv)->value.str.val);
      } else {
        while (1) {
          *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)execute_data->fbc;
          break;
        }
      }
    }
    execute_data->object = (zval *)((void *)0);
    (execute_data->opline) ++;
    return (0);
  } else {
    function_name = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
    tmp___22 = __builtin_expect((long )((int )function_name->type == 6), 1L);
    if (tmp___22) {
      function_name_strval = function_name->value.str.val;
      function_name_strlen = function_name->value.str.len;
      if ((int )*(function_name_strval + 0) == 92) {
        function_name_strlen --;
        tmp___1 = zend_str_tolower_dup((char const   *)(function_name_strval + 1), (unsigned int )function_name_strlen);
        lcname = (char *)tmp___1;
      } else {
        tmp___2 = zend_str_tolower_dup((char const   *)function_name_strval, (unsigned int )function_name_strlen);
        lcname = (char *)tmp___2;
      }
      tmp___3 = zend_hash_find((HashTable const   *)executor_globals.function_table, (char const   *)lcname, (unsigned int )(function_name_strlen + 1), (void **)(& execute_data->fbc));
      tmp___4 = __builtin_expect((long )(tmp___3 == (int __attribute__((__visibility__("default")))  )-1), 0L);
      if (tmp___4) {
        zend_error_noreturn(1, "Call to undefined function %s()", function_name_strval);
      } else {

      }
      _efree((void *)lcname);
      execute_data->object = (zval *)((void *)0);
      (execute_data->opline) ++;
      return (0);
    } else {
      if (1 << 4 != 1) {
        if (1 << 4 != 1 << 1) {
          tmp___20 = __builtin_expect((long )((int )function_name->type == 5), 1L);
          if (tmp___20) {
            if ((function_name->value.obj.handlers)->get_closure) {
              tmp___21 = (*((function_name->value.obj.handlers)->get_closure))(function_name, & execute_data->called_scope, & execute_data->fbc, & execute_data->object);
              if (tmp___21 == 0) {
                if (execute_data->object) {
                  zval_addref_p(execute_data->object);
                } else {

                }
                if (1 << 4 == 1 << 2) {

                } else {

                }
                (execute_data->opline) ++;
                return (0);
              } else {
                goto _L___2;
              }
            } else {
              goto _L___2;
            }
          } else {
            goto _L___2;
          }
        } else {
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
        _L___1: /* CIL Label */ 
        _L___0: /* CIL Label */ 
        _L: /* CIL Label */ 
        if (1 << 4 != 1) {
          tmp___18 = __builtin_expect((long )((int )function_name->type == 4), 1L);
          if (tmp___18) {
            tmp___19 = zend_hash_num_elements((HashTable const   *)function_name->value.ht);
            if (tmp___19 == (int __attribute__((__visibility__("default")))  )2) {
              method = (zval **)((void *)0);
              obj = (zval **)((void *)0);
              zend_hash_index_find((HashTable const   *)function_name->value.ht, 0UL, (void **)(& obj));
              zend_hash_index_find((HashTable const   *)function_name->value.ht, 1UL, (void **)(& method));
              if ((int )(*obj)->type != 6) {
                if ((int )(*obj)->type != 5) {
                  zend_error_noreturn(1, "First array member is not a valid class name or object");
                } else {

                }
              } else {

              }
              if ((int )(*method)->type != 6) {
                zend_error_noreturn(1, "Second array member is not a valid method");
              } else {

              }
              if ((int )(*obj)->type == 6) {
                tmp___5 = zend_fetch_class_by_name((char const   *)(*obj)->value.str.val, (unsigned int )(*obj)->value.str.len, (zend_literal const   *)((void *)0), 0);
                ce = (zend_class_entry *)tmp___5;
                tmp___6 = __builtin_expect((long )((unsigned int )ce == (unsigned int )((void *)0)), 0L);
                if (tmp___6) {
                  zend_error_noreturn(1, "Class \'%s\' not found", (*obj)->value.str.val);
                } else {

                }
                execute_data->called_scope = ce;
                execute_data->object = (zval *)((void *)0);
                if (ce->get_static_method) {
                  execute_data->fbc = (*(ce->get_static_method))(ce, (*method)->value.str.val, (*method)->value.str.len);
                } else {
                  tmp___7 = zend_std_get_static_method(ce, (char const   *)(*method)->value.str.val, (*method)->value.str.len, (struct _zend_literal  const  *)((void *)0));
                  execute_data->fbc = (zend_function *)tmp___7;
                }
              } else {
                execute_data->object = *obj;
                tmp___9 = zend_get_class_entry((zval const   *)*obj);
                tmp___8 = (zend_class_entry *)tmp___9;
                execute_data->called_scope = tmp___8;
                ce = tmp___8;
                execute_data->fbc = (*(((execute_data->object)->value.obj.handlers)->get_method))(& execute_data->object, (*method)->value.str.val, (*method)->value.str.len, (struct _zend_literal  const  *)((void *)0));
                tmp___14 = __builtin_expect((long )((unsigned int )execute_data->fbc == (unsigned int )((void *)0)), 0L);
                if (tmp___14) {
                  if (execute_data->object) {
                    if ((int )(execute_data->object)->type == 5) {
                      if ((unsigned int )((execute_data->object)->value.obj.handlers)->get_class_entry != (unsigned int )((void *)0)) {
                        tmp___13 = (*(((execute_data->object)->value.obj.handlers)->get_class_entry))((zval const   *)execute_data->object);
                        if (tmp___13) {
                          tmp___11 = (*(((execute_data->object)->value.obj.handlers)->get_class_entry))((zval const   *)execute_data->object);
                          tmp___12 = tmp___11->name;
                        } else {
                          tmp___12 = "";
                        }
                      } else {
                        tmp___12 = "";
                      }
                    } else {
                      tmp___12 = "";
                    }
                  } else {
                    tmp___12 = "";
                  }
                  zend_error_noreturn(1, "Call to undefined method %s::%s()", tmp___12, (*method)->value.str.val);
                } else {

                }
                if (((execute_data->fbc)->common.fn_flags & 1U) != 0U) {
                  execute_data->object = (zval *)((void *)0);
                } else {
                  tmp___16 = zval_isref_p(execute_data->object);
                  if (tmp___16) {
                    while (1) {
                      tmp___15 = _emalloc(sizeof(zval_gc_info ));
                      this_ptr = (zval *)tmp___15;
                      ((zval_gc_info *)this_ptr)->u.buffered = (gc_root_buffer *)((void *)0);
                      break;
                    }
                    while (1) {
                      while (1) {
                        this_ptr->value = (execute_data->object)->value;
                        this_ptr->type = (execute_data->object)->type;
                        break;
                      }
                      zval_set_refcount_p(this_ptr, 1U);
                      zval_unset_isref_p(this_ptr);
                      break;
                    }
                    _zval_copy_ctor(this_ptr);
                    execute_data->object = this_ptr;
                  } else {
                    zval_addref_p(execute_data->object);
                  }
                }
              }
              tmp___17 = __builtin_expect((long )((unsigned int )execute_data->fbc == (unsigned int )((void *)0)), 0L);
              if (tmp___17) {
                zend_error_noreturn(1, "Call to undefined method %s::%s()", ce->name, (*method)->value.str.val);
              } else {

              }
              (execute_data->opline) ++;
              return (0);
            } else {
              zend_error_noreturn(1, "Function name must be a string");
            }
          } else {
            zend_error_noreturn(1, "Function name must be a string");
          }
        } else {
          zend_error_noreturn(1, "Function name must be a string");
        }
      }
    }
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_NOT_SPEC_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;

  {
  opline = execute_data->opline;
  bitwise_not_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BOOL_NOT_SPEC_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;

  {
  opline = execute_data->opline;
  boolean_not_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ECHO_SPEC_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval z_copy ;
  zval *z ;
  int __attribute__((__visibility__("default")))  tmp ;
  long tmp___0 ;

  {
  opline = execute_data->opline;
  z = opline->op1.zv;
  zend_print_variable(z);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_PRINT_SPEC_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *__z ;
  int tmp ;

  {
  opline = execute_data->opline;
  __z = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  __z->value.lval = 1L;
  __z->type = (unsigned char)1;
  tmp = ZEND_ECHO_SPEC_CONST_HANDLER(execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_JMPZ_SPEC_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *val ;
  int ret ;
  long tmp ;
  long tmp___0 ;

  {
  opline = execute_data->opline;
  val = opline->op1.zv;
  if (1 == 1 << 1) {
    tmp___0 = __builtin_expect((long )((int )val->type == 3), 1L);
    if (tmp___0) {
      ret = (int )val->value.lval;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    ret = i_zend_is_true(val);
    tmp = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
    if (tmp) {
      return (0);
    } else {

    }
  }
  if (! ret) {
    execute_data->opline = opline->op2.jmp_addr;
    return (0);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_JMPNZ_SPEC_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *val ;
  int ret ;
  long tmp ;
  long tmp___0 ;

  {
  opline = execute_data->opline;
  val = opline->op1.zv;
  if (1 == 1 << 1) {
    tmp___0 = __builtin_expect((long )((int )val->type == 3), 1L);
    if (tmp___0) {
      ret = (int )val->value.lval;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    ret = i_zend_is_true(val);
    tmp = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
    if (tmp) {
      return (0);
    } else {

    }
  }
  if (ret) {
    execute_data->opline = opline->op2.jmp_addr;
    return (0);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_JMPZNZ_SPEC_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *val ;
  int retval ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  opline = execute_data->opline;
  val = opline->op1.zv;
  if (1 == 1 << 1) {
    tmp___0 = __builtin_expect((long )((int )val->type == 3), 1L);
    if (tmp___0) {
      retval = (int )val->value.lval;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    retval = i_zend_is_true(val);
    tmp = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
    if (tmp) {
      return (0);
    } else {

    }
  }
  tmp___1 = __builtin_expect((long )(retval != 0), 1L);
  if (tmp___1) {
    execute_data->opline = (execute_data->op_array)->opcodes + opline->extended_value;
    return (0);
  } else {
    execute_data->opline = (execute_data->op_array)->opcodes + opline->op2.opline_num;
    return (0);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_JMPZ_EX_SPEC_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *val ;
  int retval ;
  long tmp ;
  long tmp___0 ;

  {
  opline = execute_data->opline;
  val = opline->op1.zv;
  if (1 == 1 << 1) {
    tmp___0 = __builtin_expect((long )((int )val->type == 3), 1L);
    if (tmp___0) {
      retval = (int )val->value.lval;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    retval = i_zend_is_true(val);
    tmp = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
    if (tmp) {
      return (0);
    } else {

    }
  }
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.lval = (long )retval;
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.type = (unsigned char)3;
  if (! retval) {
    execute_data->opline = opline->op2.jmp_addr;
    return (0);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_JMPNZ_EX_SPEC_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *val ;
  int retval ;
  long tmp ;
  long tmp___0 ;

  {
  opline = execute_data->opline;
  val = opline->op1.zv;
  if (1 == 1 << 1) {
    tmp___0 = __builtin_expect((long )((int )val->type == 3), 1L);
    if (tmp___0) {
      retval = (int )val->value.lval;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    retval = i_zend_is_true(val);
    tmp = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
    if (tmp) {
      return (0);
    } else {

    }
  }
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.lval = (long )retval;
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.type = (unsigned char)3;
  if (retval) {
    execute_data->opline = opline->op2.jmp_addr;
    return (0);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_DO_FCALL_SPEC_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *fname ;
  int __attribute__((__visibility__("default")))  tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  fname = opline->op1.zv;
  zend_ptr_stack_3_push(& executor_globals.arg_types_stack, (void *)execute_data->fbc, (void *)execute_data->object, (void *)execute_data->called_scope);
  if (*((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot)) {
    execute_data->function_state.function = (zend_function *)*((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot);
  } else {
    tmp = zend_hash_quick_find((HashTable const   *)executor_globals.function_table, (char const   *)fname->value.str.val, (unsigned int )(fname->value.str.len + 1), ((zend_literal *)fname)->hash_value, (void **)(& execute_data->function_state.function));
    tmp___0 = __builtin_expect((long )(tmp == (int __attribute__((__visibility__("default")))  )-1), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Call to undefined function %s()", fname->value.str.val);
    } else {
      while (1) {
        *((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot) = (void *)execute_data->function_state.function;
        break;
      }
    }
  }
  execute_data->object = (zval *)((void *)0);
  tmp___1 = zend_do_fcall_common_helper_SPEC(execute_data);
  return (tmp___1);
}
}
static int ( __attribute__((__fastcall__)) ZEND_RETURN_SPEC_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *retval_ptr ;
  zval *ret ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zval *ret___0 ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_bool tmp___1 ;
  zend_uint tmp___2 ;
  zval *ret___1 ;
  void __attribute__((__visibility__("default")))  *tmp___3 ;
  int tmp___4 ;

  {
  opline = execute_data->opline;
  retval_ptr = opline->op1.zv;
  if (! executor_globals.return_value_ptr_ptr) {
    if (1 == 1 << 1) {

    } else {

    }
  } else {
    if (1) {
      while (1) {
        tmp = _emalloc(sizeof(zval_gc_info ));
        ret = (zval *)tmp;
        ((zval_gc_info *)ret)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      while (1) {
        while (1) {
          ret->value = retval_ptr->value;
          ret->type = retval_ptr->type;
          break;
        }
        zval_set_refcount_p(ret, 1U);
        zval_unset_isref_p(ret);
        break;
      }
      _zval_copy_ctor(ret);
      *(executor_globals.return_value_ptr_ptr) = ret;
    } else {
      if (1 == 1 << 4) {
        goto _L;
      } else {
        if (1 == 1 << 2) {
          _L: /* CIL Label */ 
          if ((unsigned int )retval_ptr == (unsigned int )(& executor_globals.uninitialized_zval)) {
            while (1) {
              tmp___0 = _emalloc(sizeof(zval_gc_info ));
              ret___0 = (zval *)tmp___0;
              ((zval_gc_info *)ret___0)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            *ret___0 = (struct _zval_struct )zval_used_for_init;
            *(executor_globals.return_value_ptr_ptr) = ret___0;
          } else {
            *(executor_globals.return_value_ptr_ptr) = retval_ptr;
            zval_addref_p(retval_ptr);
          }
        } else {
          *(executor_globals.return_value_ptr_ptr) = retval_ptr;
          zval_addref_p(retval_ptr);
        }
      }
    }
  }
  tmp___4 = zend_leave_helper_SPEC(execute_data);
  return (tmp___4);
}
}
static int ( __attribute__((__fastcall__)) ZEND_RETURN_BY_REF_SPEC_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *retval_ptr ;
  zval **retval_ptr_ptr ;
  zval *ret ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zval *ret___0 ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  long tmp___1 ;
  zend_bool tmp___2 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___3 ;
  zend_uint tmp___4 ;
  zend_bool tmp___5 ;
  int tmp___6 ;

  {
  opline = execute_data->opline;
  while (1) {
    zend_error(1 << 3L, "Only variable references should be returned by reference");
    retval_ptr = opline->op1.zv;
    if (! executor_globals.return_value_ptr_ptr) {
      if (1 == 1 << 1) {

      } else {

      }
    } else {
      while (1) {
        tmp = _emalloc(sizeof(zval_gc_info ));
        ret = (zval *)tmp;
        ((zval_gc_info *)ret)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      while (1) {
        while (1) {
          ret->value = retval_ptr->value;
          ret->type = retval_ptr->type;
          break;
        }
        zval_set_refcount_p(ret, 1U);
        zval_unset_isref_p(ret);
        break;
      }
      _zval_copy_ctor(ret);
      *(executor_globals.return_value_ptr_ptr) = ret;
    }
    break;
    retval_ptr_ptr = (zval **)((void *)0);
    if (1 == 1 << 2) {
      tmp___1 = __builtin_expect((long )((unsigned int )retval_ptr_ptr == (unsigned int )((void *)0)), 0L);
      if (tmp___1) {
        zend_error_noreturn(1, "Cannot return string offsets by reference");
      } else {

      }
    } else {

    }
    if (1 == 1 << 2) {
      tmp___2 = zval_isref_p(*retval_ptr_ptr);
      if (tmp___2) {

      } else {
        if (opline->extended_value == 1UL) {
          if (((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.fcall_returned_reference) {

          } else {
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          if ((unsigned int )((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr == (unsigned int )(& ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr)) {
            zend_error(1 << 3L, "Only variable references should be returned by reference");
            if (executor_globals.return_value_ptr_ptr) {
              retval_ptr = *retval_ptr_ptr;
              *(executor_globals.return_value_ptr_ptr) = retval_ptr;
              zval_addref_p(retval_ptr);
            } else {

            }
            break;
          } else {

          }
        }
      }
    } else {

    }
    if (executor_globals.return_value_ptr_ptr) {
      tmp___5 = zval_isref_p(*retval_ptr_ptr);
      if (tmp___5) {

      } else {
        while (1) {
          tmp___4 = zval_refcount_p(*retval_ptr_ptr);
          if (tmp___4 > 1U) {
            zval_delref_p(*retval_ptr_ptr);
            while (1) {
              tmp___3 = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp___3;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*retval_ptr_ptr)->value;
                new_zv->type = (*retval_ptr_ptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *retval_ptr_ptr = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
        zval_set_isref_p(*retval_ptr_ptr);
      }
      zval_addref_p(*retval_ptr_ptr);
      *(executor_globals.return_value_ptr_ptr) = *retval_ptr_ptr;
    } else {

    }
    break;
  }
  tmp___6 = zend_leave_helper_SPEC(execute_data);
  return (tmp___6);
}
}
static int ( __attribute__((__fastcall__)) ZEND_THROW_SPEC_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *value ;
  zval *exception ;
  long tmp ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;

  {
  opline = execute_data->opline;
  value = opline->op1.zv;
  zend_error_noreturn(1, "Can only throw objects");
  zend_exception_save();
  while (1) {
    tmp___0 = _emalloc(sizeof(zval_gc_info ));
    exception = (zval *)tmp___0;
    ((zval_gc_info *)exception)->u.buffered = (gc_root_buffer *)((void *)0);
    break;
  }
  while (1) {
    while (1) {
      exception->value = value->value;
      exception->type = value->type;
      break;
    }
    zval_set_refcount_p(exception, 1U);
    zval_unset_isref_p(exception);
    break;
  }
  _zval_copy_ctor(exception);
  zend_throw_exception_object(exception);
  zend_exception_restore();
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SEND_VAL_SPEC_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  unsigned int tmp ;
  zval *valptr ;
  zval *value ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;

  {
  opline = execute_data->opline;
  if (opline->extended_value == 61UL) {
    if (execute_data->fbc) {
      if ((execute_data->fbc)->common.arg_info) {
        if (opline->op2.opline_num <= (execute_data->fbc)->common.num_args) {
          tmp = (unsigned int )((int )((execute_data->fbc)->common.arg_info + (opline->op2.opline_num - 1U))->pass_by_reference & 1);
        } else {
          tmp = (execute_data->fbc)->common.fn_flags & 16777216U;
        }
      } else {
        tmp = (execute_data->fbc)->common.fn_flags & 16777216U;
      }
      if (tmp) {
        zend_error_noreturn(1, "Cannot pass parameter %d by reference", opline->op2.opline_num);
      } else {

      }
    } else {

    }
  } else {

  }
  value = opline->op1.zv;
  while (1) {
    tmp___0 = _emalloc(sizeof(zval_gc_info ));
    valptr = (zval *)tmp___0;
    ((zval_gc_info *)valptr)->u.buffered = (gc_root_buffer *)((void *)0);
    break;
  }
  while (1) {
    while (1) {
      valptr->value = value->value;
      valptr->type = value->type;
      break;
    }
    zval_set_refcount_p(valptr, 1U);
    zval_unset_isref_p(valptr);
    break;
  }
  _zval_copy_ctor(valptr);
  zend_vm_stack_push((void *)valptr);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BOOL_SPEC_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *retval ;
  zval *__z ;
  int tmp ;

  {
  opline = execute_data->opline;
  retval = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = retval;
    tmp = i_zend_is_true(opline->op1.zv);
    __z->value.lval = (long )(tmp != 0);
    __z->type = (unsigned char)3;
    break;
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_CLONE_SPEC_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *obj ;
  zend_class_entry *ce ;
  zend_function *clone ;
  zend_object_value (*clone_call)(zval *object ) ;
  long tmp ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  long tmp___1 ;
  char const   *tmp___2 ;
  long tmp___3 ;
  char const   *tmp___4 ;
  int __attribute__((__visibility__("default")))  tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  zval *retval ;
  void __attribute__((__visibility__("default")))  *tmp___8 ;
  temp_variable *__t ;
  long tmp___9 ;
  long tmp___10 ;

  {
  opline = execute_data->opline;
  obj = opline->op1.zv;
  zend_error_noreturn(1, "__clone method called on non-object");
  tmp___0 = zend_get_class_entry((zval const   *)obj);
  ce = (zend_class_entry *)tmp___0;
  if (ce) {
    clone = ce->clone;
  } else {
    clone = (zend_function *)((void *)0);
  }
  clone_call = (zend_object_value (*)(zval *object ))(obj->value.obj.handlers)->clone_obj;
  tmp___1 = __builtin_expect((long )((unsigned int )clone_call == (unsigned int )((void *)0)), 0L);
  if (tmp___1) {
    if (ce) {
      zend_error_noreturn(1, "Trying to clone an uncloneable object of class %s", ce->name);
    } else {
      zend_error_noreturn(1, "Trying to clone an uncloneable object");
    }
  } else {

  }
  if (ce) {
    if (clone) {
      if (clone->op_array.fn_flags & 1024U) {
        tmp___3 = __builtin_expect((long )((unsigned int )ce != (unsigned int )executor_globals.scope), 0L);
        if (tmp___3) {
          if (executor_globals.scope) {
            tmp___2 = (executor_globals.scope)->name;
          } else {
            tmp___2 = "";
          }
          zend_error_noreturn(1, "Call to private %s::__clone() from context \'%s\'", ce->name, tmp___2);
        } else {

        }
      } else {
        if (clone->common.fn_flags & 512U) {
          tmp___5 = zend_check_protected(clone->common.scope, executor_globals.scope);
          if (tmp___5) {
            tmp___6 = 0;
          } else {
            tmp___6 = 1;
          }
          tmp___7 = __builtin_expect((long )tmp___6, 0L);
          if (tmp___7) {
            if (executor_globals.scope) {
              tmp___4 = (executor_globals.scope)->name;
            } else {
              tmp___4 = "";
            }
            zend_error_noreturn(1, "Call to protected %s::__clone() from context \'%s\'", ce->name, tmp___4);
          } else {

          }
        } else {

        }
      }
    } else {

    }
  } else {

  }
  tmp___10 = __builtin_expect((long )((unsigned int )executor_globals.exception == (unsigned int )((void *)0)), 1L);
  if (tmp___10) {
    while (1) {
      tmp___8 = _emalloc(sizeof(zval_gc_info ));
      retval = (zval *)tmp___8;
      ((zval_gc_info *)retval)->u.buffered = (gc_root_buffer *)((void *)0);
      break;
    }
    retval->value.obj = (*clone_call)(obj);
    retval->type = (unsigned char)5;
    zval_set_refcount_p(retval, 1U);
    zval_set_isref_p(retval);
    if (! (! ((int )opline->result_type & (1 << 5)))) {
      i_zval_ptr_dtor(retval);
    } else {
      tmp___9 = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
      if (tmp___9) {
        i_zval_ptr_dtor(retval);
      } else {
        while (1) {
          __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
          __t->var.ptr = retval;
          __t->var.ptr_ptr = & __t->var.ptr;
          break;
        }
      }
    }
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_CAST_SPEC_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *expr ;
  zval *result ;
  zval var_copy ;
  int use_copy ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  expr = opline->op1.zv;
  if (opline->extended_value != 6UL) {
    while (1) {
      result->value = expr->value;
      result->type = expr->type;
      break;
    }
    _zval_copy_ctor(result);
  } else {

  }
  switch ((int )opline->extended_value) {
  case 0: 
  convert_to_null(result);
  break;
  case 3: 
  convert_to_boolean(result);
  break;
  case 1: 
  convert_to_long(result);
  break;
  case 2: 
  convert_to_double(result);
  break;
  case 6: 
  zend_make_printable_zval(expr, & var_copy, & use_copy);
  if (use_copy) {
    while (1) {
      result->value = var_copy.value;
      result->type = var_copy.type;
      break;
    }
  } else {
    while (1) {
      result->value = expr->value;
      result->type = expr->type;
      break;
    }
    _zval_copy_ctor(result);
  }
  break;
  case 4: 
  convert_to_array(result);
  break;
  case 5: 
  convert_to_object(result);
  break;
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INCLUDE_OR_EVAL_SPEC_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_op_array *new_op_array ;
  zval *inc_filename ;
  zval tmp_inc_filename ;
  zend_bool failure_retval ;
  zend_file_handle file_handle ;
  char *resolved_path ;
  char __attribute__((__visibility__("default")))  *tmp ;
  size_t tmp___0 ;
  int __attribute__((__visibility__("default")))  tmp___1 ;
  char __attribute__((__visibility__("default")))  *tmp___2 ;
  int tmp___3 ;
  zend_op_array __attribute__((__visibility__("default")))  *tmp___4 ;
  size_t tmp___5 ;
  int __attribute__((__visibility__("default")))  tmp___6 ;
  int __attribute__((__visibility__("default")))  tmp___7 ;
  zend_op_array __attribute__((__visibility__("default")))  *tmp___8 ;
  char *eval_desc ;
  char __attribute__((__visibility__("default")))  *tmp___9 ;
  zend_op_array __attribute__((__visibility__("default")))  *tmp___10 ;
  size_t tmp___11 ;
  long tmp___12 ;
  zval *retval ;
  void __attribute__((__visibility__("default")))  *tmp___13 ;
  zval *__z ;
  long tmp___14 ;
  zval *retval___0 ;
  void __attribute__((__visibility__("default")))  *tmp___15 ;
  zval *__z___0 ;
  temp_variable *__t ;
  long tmp___16 ;
  long tmp___17 ;

  {
  opline = execute_data->opline;
  new_op_array = (zend_op_array *)((void *)0);
  failure_retval = (zend_bool )0;
  inc_filename = opline->op1.zv;
  if ((int )inc_filename->type != 6) {
    while (1) {
      tmp_inc_filename.value = inc_filename->value;
      tmp_inc_filename.type = inc_filename->type;
      break;
    }
    _zval_copy_ctor(& tmp_inc_filename);
    if ((int )tmp_inc_filename.type != 6) {
      _convert_to_string(& tmp_inc_filename);
    } else {

    }
    inc_filename = & tmp_inc_filename;
  } else {

  }
  if (opline->extended_value != 1UL) {
    tmp___11 = strlen((char const   *)inc_filename->value.str.val);
    if (tmp___11 != (size_t )inc_filename->value.str.len) {
      if (opline->extended_value == (ulong )(1 << 2)) {
        zend_message_dispatcher(1L, (void const   *)inc_filename->value.str.val);
      } else {
        if (opline->extended_value == (ulong )(1 << 1)) {
          zend_message_dispatcher(1L, (void const   *)inc_filename->value.str.val);
        } else {
          zend_message_dispatcher(2L, (void const   *)inc_filename->value.str.val);
        }
      }
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    switch ((int )opline->extended_value) {
    case 1 << 2: 
    case 1 << 4: 
    tmp = (*zend_resolve_path)((char const   *)inc_filename->value.str.val, inc_filename->value.str.len);
    resolved_path = (char *)tmp;
    if (resolved_path) {
      tmp___0 = strlen((char const   *)resolved_path);
      tmp___1 = zend_hash_exists((HashTable const   *)(& executor_globals.included_files), (char const   *)resolved_path, tmp___0 + 1U);
      failure_retval = (unsigned char )tmp___1;
    } else {
      resolved_path = inc_filename->value.str.val;
    }
    if (failure_retval) {

    } else {
      tmp___7 = zend_stream_open((char const   *)resolved_path, & file_handle);
      if (0 == (int )tmp___7) {
        if (! file_handle.opened_path) {
          tmp___2 = _estrdup((char const   *)resolved_path);
          file_handle.opened_path = (char *)tmp___2;
        } else {

        }
        tmp___5 = strlen((char const   *)file_handle.opened_path);
        tmp___6 = zend_hash_add_empty_element(& executor_globals.included_files, (char const   *)file_handle.opened_path, tmp___5 + 1U);
        if (tmp___6 == (int __attribute__((__visibility__("default")))  )0) {
          if (opline->extended_value == (ulong )(1 << 2)) {
            tmp___3 = 1 << 1;
          } else {
            tmp___3 = 1 << 3;
          }
          tmp___4 = (*zend_compile_file)(& file_handle, tmp___3);
          new_op_array = (zend_op_array *)tmp___4;
          zend_destroy_file_handle(& file_handle);
        } else {
          zend_file_handle_dtor(& file_handle);
          failure_retval = (unsigned char)1;
        }
      } else {
        if (opline->extended_value == (ulong )(1 << 2)) {
          zend_message_dispatcher(1L, (void const   *)inc_filename->value.str.val);
        } else {
          zend_message_dispatcher(2L, (void const   *)inc_filename->value.str.val);
        }
      }
    }
    if ((unsigned int )resolved_path != (unsigned int )inc_filename->value.str.val) {
      _efree((void *)resolved_path);
    } else {

    }
    break;
    case 1 << 1: 
    case 1 << 3: 
    tmp___8 = compile_filename((int )opline->extended_value, inc_filename);
    new_op_array = (zend_op_array *)tmp___8;
    break;
    case 1: 
    tmp___9 = zend_make_compiled_string_description("eval()\'d code");
    eval_desc = (char *)tmp___9;
    tmp___10 = (*zend_compile_string)(inc_filename, eval_desc);
    new_op_array = (zend_op_array *)tmp___10;
    _efree((void *)eval_desc);
    break;
    }
  }
  if ((unsigned int )inc_filename == (unsigned int )(& tmp_inc_filename)) {
    _zval_dtor(& tmp_inc_filename);
  } else {

  }
  tmp___17 = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
  if (tmp___17) {
    return (0);
  } else {
    tmp___16 = __builtin_expect((long )((unsigned int )new_op_array != (unsigned int )((void *)0)), 1L);
    if (tmp___16) {
      execute_data->original_return_value = executor_globals.return_value_ptr_ptr;
      executor_globals.active_op_array = new_op_array;
      if (! ((int )opline->result_type & (1 << 5))) {
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = (zval *)((void *)0);
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
        executor_globals.return_value_ptr_ptr = ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr;
      } else {
        executor_globals.return_value_ptr_ptr = (zval **)((void *)0);
      }
      execute_data->current_object = execute_data->object;
      execute_data->function_state.function = (zend_function *)new_op_array;
      execute_data->object = (zval *)((void *)0);
      if (! executor_globals.active_symbol_table) {
        zend_rebuild_symbol_table();
      } else {

      }
      tmp___12 = __builtin_expect((long )((unsigned int )zend_execute == (unsigned int )(& execute)), 1L);
      if (tmp___12) {
        return (2);
      } else {
        (*zend_execute)(new_op_array);
      }
      execute_data->function_state.function = (zend_function *)execute_data->op_array;
      execute_data->object = execute_data->current_object;
      executor_globals.opline_ptr = & execute_data->opline;
      executor_globals.active_op_array = execute_data->op_array;
      executor_globals.return_value_ptr_ptr = execute_data->original_return_value;
      destroy_op_array(new_op_array);
      _efree((void *)new_op_array);
      tmp___14 = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
      if (tmp___14) {
        zend_throw_exception_internal((zval *)((void *)0));
        return (0);
      } else {
        if (! ((int )opline->result_type & (1 << 5))) {
          if (! ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr) {
            while (1) {
              tmp___13 = _emalloc(sizeof(zval_gc_info ));
              retval = (zval *)tmp___13;
              ((zval_gc_info *)retval)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              __z = retval;
              __z->value.lval = 1L;
              __z->type = (unsigned char)3;
              break;
            }
            retval->refcount__gc = 1U;
            retval->is_ref__gc = (unsigned char)0;
            ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = retval;
          } else {

          }
        } else {

        }
      }
    } else {
      if (! ((int )opline->result_type & (1 << 5))) {
        while (1) {
          tmp___15 = _emalloc(sizeof(zval_gc_info ));
          retval___0 = (zval *)tmp___15;
          ((zval_gc_info *)retval___0)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          __z___0 = retval___0;
          __z___0->value.lval = (long )((int )failure_retval != 0);
          __z___0->type = (unsigned char)3;
          break;
        }
        retval___0->refcount__gc = 1U;
        retval___0->is_ref__gc = (unsigned char)0;
        while (1) {
          __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
          __t->var.ptr = retval___0;
          __t->var.ptr_ptr = & __t->var.ptr;
          break;
        }
      } else {

      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FE_RESET_SPEC_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *array_ptr ;
  zval **array_ptr_ptr ;
  HashTable *fe_ht ;
  zend_object_iterator *iter ;
  zend_class_entry *ce ;
  zend_bool is_empty ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___1 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_uint tmp___3 ;
  zend_bool tmp___4 ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  zend_uint tmp___6 ;
  zend_bool tmp___7 ;
  zval *tmp___8 ;
  void __attribute__((__visibility__("default")))  *tmp___9 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___10 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___11 ;
  zval *tmp___12 ;
  void __attribute__((__visibility__("default")))  *tmp___13 ;
  zend_bool tmp___14 ;
  zend_uint tmp___15 ;
  zval __attribute__((__visibility__("default")))  *tmp___16 ;
  long tmp___17 ;
  long tmp___18 ;
  int tmp___19 ;
  long tmp___20 ;
  zend_object *zobj ;
  zend_object __attribute__((__visibility__("default")))  *tmp___21 ;
  char *str_key ;
  uint str_key_len ;
  ulong int_key ;
  zend_uchar key_type ;
  int __attribute__((__visibility__("default")))  tmp___22 ;
  int __attribute__((__visibility__("default")))  tmp___23 ;
  int __attribute__((__visibility__("default")))  tmp___24 ;
  int tmp___25 ;
  int __attribute__((__visibility__("default")))  tmp___26 ;
  int __attribute__((__visibility__("default")))  tmp___27 ;
  int tmp___28 ;
  int __attribute__((__visibility__("default")))  tmp___29 ;
  HashTable *tmp___30 ;
  HashTable *tmp___31 ;
  long tmp___32 ;

  {
  opline = execute_data->opline;
  iter = (zend_object_iterator *)((void *)0);
  ce = (zend_class_entry *)((void *)0);
  is_empty = (zend_bool )0;
  if (1 == 1 << 4) {
    goto _L___2;
  } else {
    if (1 == 1 << 2) {
      _L___2: /* CIL Label */ 
      if (opline->extended_value & 1UL) {
        array_ptr_ptr = (zval **)((void *)0);
        if ((unsigned int )array_ptr_ptr == (unsigned int )((void *)0)) {
          goto _L___0;
        } else {
          if ((unsigned int )array_ptr_ptr == (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
            _L___0: /* CIL Label */ 
            while (1) {
              tmp = _emalloc(sizeof(zval_gc_info ));
              array_ptr = (zval *)tmp;
              ((zval_gc_info *)array_ptr)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            array_ptr->refcount__gc = 1U;
            array_ptr->is_ref__gc = (unsigned char)0;
            array_ptr->type = (unsigned char)0;
          } else {
            if ((int )(*array_ptr_ptr)->type == 5) {
              if ((unsigned int )((*array_ptr_ptr)->value.obj.handlers)->get_class_entry == (unsigned int )((void *)0)) {
                zend_error(1 << 1L, "foreach() cannot iterate over objects without PHP class");
                tmp___0 = __builtin_expect((long )(! executor_globals.exception), 1L);
                if (tmp___0) {
                  execute_data->opline = (execute_data->op_array)->opcodes + opline->op2.opline_num;
                } else {

                }
                return (0);
              } else {

              }
              tmp___1 = zend_get_class_entry((zval const   *)*array_ptr_ptr);
              ce = (zend_class_entry *)tmp___1;
              if (! ce) {
                goto _L;
              } else {
                if ((unsigned int )ce->get_iterator == (unsigned int )((void *)0)) {
                  _L: /* CIL Label */ 
                  tmp___4 = zval_isref_p(*array_ptr_ptr);
                  if (tmp___4) {

                  } else {
                    while (1) {
                      tmp___3 = zval_refcount_p(*array_ptr_ptr);
                      if (tmp___3 > 1U) {
                        zval_delref_p(*array_ptr_ptr);
                        while (1) {
                          tmp___2 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___2;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*array_ptr_ptr)->value;
                            new_zv->type = (*array_ptr_ptr)->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *array_ptr_ptr = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  }
                  zval_addref_p(*array_ptr_ptr);
                } else {

                }
              }
              array_ptr = *array_ptr_ptr;
            } else {
              if ((int )(*array_ptr_ptr)->type == 4) {
                tmp___7 = zval_isref_p(*array_ptr_ptr);
                if (tmp___7) {

                } else {
                  while (1) {
                    tmp___6 = zval_refcount_p(*array_ptr_ptr);
                    if (tmp___6 > 1U) {
                      zval_delref_p(*array_ptr_ptr);
                      while (1) {
                        tmp___5 = _emalloc(sizeof(zval_gc_info ));
                        new_zv___0 = (zval *)tmp___5;
                        ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                        break;
                      }
                      while (1) {
                        while (1) {
                          new_zv___0->value = (*array_ptr_ptr)->value;
                          new_zv___0->type = (*array_ptr_ptr)->type;
                          break;
                        }
                        zval_set_refcount_p(new_zv___0, 1U);
                        zval_unset_isref_p(new_zv___0);
                        break;
                      }
                      *array_ptr_ptr = new_zv___0;
                      _zval_copy_ctor(new_zv___0);
                    } else {

                    }
                    break;
                  }
                }
                if (opline->extended_value & 1UL) {
                  zval_set_isref_p(*array_ptr_ptr);
                } else {

                }
              } else {

              }
              array_ptr = *array_ptr_ptr;
              zval_addref_p(array_ptr);
            }
          }
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      array_ptr = opline->op1.zv;
      if ((int )array_ptr->type == 5) {
        tmp___11 = zend_get_class_entry((zval const   *)array_ptr);
        ce = (zend_class_entry *)tmp___11;
        if (! ce) {
          zval_addref_p(array_ptr);
        } else {
          if (! ce->get_iterator) {
            zval_addref_p(array_ptr);
          } else {

          }
        }
      } else {
        while (1) {
          tmp___13 = _emalloc(sizeof(zval_gc_info ));
          tmp___12 = (zval *)tmp___13;
          ((zval_gc_info *)tmp___12)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            tmp___12->value = array_ptr->value;
            tmp___12->type = array_ptr->type;
            break;
          }
          zval_set_refcount_p(tmp___12, 1U);
          zval_unset_isref_p(tmp___12);
          break;
        }
        _zval_copy_ctor(tmp___12);
        array_ptr = tmp___12;
      }
    }
  }
  if (ce) {
    if (ce->get_iterator) {
      iter = (*(ce->get_iterator))(ce, array_ptr, (int )(opline->extended_value & (unsigned long )(1 << 1)));
      if (iter) {
        tmp___17 = __builtin_expect((long )((unsigned int )executor_globals.exception == (unsigned int )((void *)0)), 1L);
        if (tmp___17) {
          tmp___16 = zend_iterator_wrap(iter);
          array_ptr = (zval *)tmp___16;
        } else {
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ 
        if (! executor_globals.exception) {
          zend_throw_exception_ex((zend_class_entry *)((void *)0), 0L, (char *)"Object of type %s did not create an Iterator", ce->name);
        } else {

        }
        zend_throw_exception_internal((zval *)((void *)0));
        return (0);
      }
    } else {

    }
  } else {

  }
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->fe.ptr = array_ptr;
  if (iter) {
    iter->index = 0UL;
    if ((iter->funcs)->rewind) {
      (*((iter->funcs)->rewind))(iter);
      tmp___18 = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
      if (tmp___18) {
        i_zval_ptr_dtor(array_ptr);
        return (0);
      } else {

      }
    } else {

    }
    tmp___19 = (*((iter->funcs)->valid))(iter);
    is_empty = (unsigned char )(tmp___19 != 0);
    tmp___20 = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
    if (tmp___20) {
      i_zval_ptr_dtor(array_ptr);
      return (0);
    } else {

    }
    iter->index = 4294967295UL;
  } else {
    if ((int )array_ptr->type == 4) {
      fe_ht = array_ptr->value.ht;
    } else {
      if ((int )array_ptr->type == 5) {
        tmp___30 = (*((array_ptr->value.obj.handlers)->get_properties))(array_ptr);
        tmp___31 = tmp___30;
      } else {
        tmp___31 = (HashTable *)((void *)0);
      }
      fe_ht = tmp___31;
    }
    if ((unsigned int )fe_ht != (unsigned int )((void *)0)) {
      zend_hash_internal_pointer_reset_ex(fe_ht, (HashPosition *)((void *)0));
      if (ce) {
        tmp___21 = zend_objects_get_address((zval const   *)array_ptr);
        zobj = (zend_object *)tmp___21;
        while (1) {
          tmp___26 = zend_hash_get_current_key_type_ex(fe_ht, (HashPosition *)((void *)0));
          if (tmp___26 == (int __attribute__((__visibility__("default")))  )3) {
            tmp___25 = -1;
          } else {
            tmp___25 = 0;
          }
          if (tmp___25 == 0) {

          } else {
            break;
          }
          tmp___22 = zend_hash_get_current_key_ex((HashTable const   *)fe_ht, & str_key, & str_key_len, & int_key, (unsigned char)0, (HashPosition *)((void *)0));
          key_type = (unsigned char )tmp___22;
          if ((int )key_type != 3) {
            if ((int )key_type == 2) {
              break;
            } else {
              tmp___23 = zend_check_property_access(zobj, (char const   *)str_key, (int )(str_key_len - 1U));
              if (tmp___23 == (int __attribute__((__visibility__("default")))  )0) {
                break;
              } else {

              }
            }
          } else {

          }
          zend_hash_move_forward_ex(fe_ht, (HashPosition *)((void *)0));
        }
      } else {

      }
      tmp___29 = zend_hash_get_current_key_type_ex(fe_ht, (HashPosition *)((void *)0));
      if (tmp___29 == (int __attribute__((__visibility__("default")))  )3) {
        tmp___28 = -1;
      } else {
        tmp___28 = 0;
      }
      is_empty = (unsigned char )(tmp___28 != 0);
      zend_hash_get_pointer((HashTable const   *)fe_ht, & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->fe.fe_pos);
    } else {
      zend_error(1 << 1L, "Invalid argument supplied for foreach()");
      is_empty = (unsigned char)1;
    }
  }
  if (is_empty) {
    tmp___32 = __builtin_expect((long )(! executor_globals.exception), 1L);
    if (tmp___32) {
      execute_data->opline = (execute_data->op_array)->opcodes + opline->op2.opline_num;
    } else {

    }
    return (0);
  } else {
    (execute_data->opline) ++;
    return (0);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_EXIT_SPEC_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *ptr ;

  {
  opline = execute_data->opline;
  if (1 != 1 << 3) {
    ptr = opline->op1.zv;
    if ((int )ptr->type == 1) {
      executor_globals.exit_status = (int )ptr->value.lval;
    } else {
      zend_print_variable(ptr);
    }
  } else {

  }
  _zend_bailout((char *)"/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-12-18-beda5efd41-622412d8e6/php/Zend/zend_vm_execute.h", 2824U);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_JMP_SET_SPEC_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *value ;
  long tmp ;
  int tmp___0 ;

  {
  opline = execute_data->opline;
  value = opline->op1.zv;
  tmp___0 = i_zend_is_true(value);
  if (tmp___0) {
    while (1) {
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value = value->value;
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.type = value->type;
      break;
    }
    _zval_copy_ctor(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var);
    tmp = __builtin_expect((long )(! executor_globals.exception), 1L);
    if (tmp) {
      execute_data->opline = opline->op2.jmp_addr;
    } else {

    }
    return (0);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_JMP_SET_VAR_SPEC_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *value ;
  zval *ret ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  value = opline->op1.zv;
  tmp___1 = i_zend_is_true(value);
  if (tmp___1) {
    if (1 == 1 << 2) {
      zval_addref_p(value);
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = value;
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
    } else {
      if (1 == 1 << 4) {
        zval_addref_p(value);
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = value;
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
      } else {
        while (1) {
          tmp = _emalloc(sizeof(zval_gc_info ));
          ret = (zval *)tmp;
          ((zval_gc_info *)ret)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            ret->value = value->value;
            ret->type = value->type;
            break;
          }
          zval_set_refcount_p(ret, 1U);
          zval_unset_isref_p(ret);
          break;
        }
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = ret;
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
        _zval_copy_ctor(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr);
      }
    }
    tmp___0 = __builtin_expect((long )(! executor_globals.exception), 1L);
    if (tmp___0) {
      execute_data->opline = opline->op2.jmp_addr;
    } else {

    }
    return (0);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_QM_ASSIGN_SPEC_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *value ;

  {
  opline = execute_data->opline;
  value = opline->op1.zv;
  while (1) {
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value = value->value;
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.type = value->type;
    break;
  }
  _zval_copy_ctor(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_QM_ASSIGN_VAR_SPEC_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *value ;
  zval *ret ;
  void __attribute__((__visibility__("default")))  *tmp ;

  {
  opline = execute_data->opline;
  value = opline->op1.zv;
  if (1 == 1 << 2) {
    zval_addref_p(value);
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = value;
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
  } else {
    if (1 == 1 << 4) {
      zval_addref_p(value);
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = value;
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
    } else {
      while (1) {
        tmp = _emalloc(sizeof(zval_gc_info ));
        ret = (zval *)tmp;
        ((zval_gc_info *)ret)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      while (1) {
        while (1) {
          ret->value = value->value;
          ret->type = value->type;
          break;
        }
        zval_set_refcount_p(ret, 1U);
        zval_unset_isref_p(ret);
        break;
      }
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = ret;
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
      _zval_copy_ctor(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr);
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_SPEC_CONST_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;

  {
  opline = execute_data->opline;
  fast_add_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, opline->op2.zv);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SUB_SPEC_CONST_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;

  {
  opline = execute_data->opline;
  fast_sub_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, opline->op2.zv);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_MUL_SPEC_CONST_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;

  {
  opline = execute_data->opline;
  fast_mul_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, opline->op2.zv);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_DIV_SPEC_CONST_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;

  {
  opline = execute_data->opline;
  fast_div_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, opline->op2.zv);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_MOD_SPEC_CONST_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;

  {
  opline = execute_data->opline;
  fast_mod_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, opline->op2.zv);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SL_SPEC_CONST_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;

  {
  opline = execute_data->opline;
  shift_left_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, opline->op2.zv);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SR_SPEC_CONST_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;

  {
  opline = execute_data->opline;
  shift_right_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, opline->op2.zv);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_CONCAT_SPEC_CONST_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;

  {
  opline = execute_data->opline;
  concat_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, opline->op2.zv);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_IDENTICAL_SPEC_CONST_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;

  {
  opline = execute_data->opline;
  is_identical_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, opline->op2.zv);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_NOT_IDENTICAL_SPEC_CONST_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *result ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  is_identical_function(result, opline->op1.zv, opline->op2.zv);
  result->value.lval = (long )(! result->value.lval);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_EQUAL_SPEC_CONST_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *result ;
  zval *__z ;
  int tmp ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = fast_equal_function(result, opline->op1.zv, opline->op2.zv);
    __z->value.lval = (long )(tmp != 0);
    __z->type = (unsigned char)3;
    break;
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_NOT_EQUAL_SPEC_CONST_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *result ;
  zval *__z ;
  int tmp ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = fast_not_equal_function(result, opline->op1.zv, opline->op2.zv);
    __z->value.lval = (long )(tmp != 0);
    __z->type = (unsigned char)3;
    break;
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_SMALLER_SPEC_CONST_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *result ;
  zval *__z ;
  int tmp ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = fast_is_smaller_function(result, opline->op1.zv, opline->op2.zv);
    __z->value.lval = (long )(tmp != 0);
    __z->type = (unsigned char)3;
    break;
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *result ;
  zval *__z ;
  int tmp ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = fast_is_smaller_or_equal_function(result, opline->op1.zv, opline->op2.zv);
    __z->value.lval = (long )(tmp != 0);
    __z->type = (unsigned char)3;
    break;
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_OR_SPEC_CONST_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;

  {
  opline = execute_data->opline;
  bitwise_or_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, opline->op2.zv);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_AND_SPEC_CONST_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;

  {
  opline = execute_data->opline;
  bitwise_and_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, opline->op2.zv);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_XOR_SPEC_CONST_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;

  {
  opline = execute_data->opline;
  bitwise_xor_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, opline->op2.zv);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BOOL_XOR_SPEC_CONST_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;

  {
  opline = execute_data->opline;
  boolean_xor_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, opline->op2.zv);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_fetch_var_address_helper_SPEC_CONST_CONST)(int type , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *varname ;
  zval **retval ;
  zval tmp_varname ;
  HashTable *target_symbol_table ;
  ulong hash_value ;
  long tmp ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  zval __attribute__((__visibility__("default")))  **tmp___1 ;
  ulong __attribute__((__visibility__("default")))  tmp___2 ;
  int __attribute__((__visibility__("default")))  tmp___3 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_uint tmp___5 ;
  zend_bool tmp___6 ;
  temp_variable *__t ;
  zend_free_op free_res ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___7 ;
  zend_uint tmp___8 ;
  zend_bool tmp___9 ;

  {
  opline = execute_data->opline;
  varname = opline->op1.zv;
  if (1 != 1 << 3) {
    if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
      ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
    } else {
      tmp___0 = zend_fetch_class_by_name((char const   *)(opline->op2.zv)->value.str.val, (unsigned int )(opline->op2.zv)->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), 0);
      ce = (zend_class_entry *)tmp___0;
      while (1) {
        *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
        break;
      }
    }
    tmp___1 = zend_std_get_static_property(ce, (char const   *)varname->value.str.val, varname->value.str.len, (unsigned char)0, (struct _zend_literal  const  *)opline->op1.literal);
    retval = (zval **)tmp___1;
  } else {
    target_symbol_table = zend_get_target_symbol_table((int )(opline->extended_value & 1879048192UL));
    hash_value = ((zend_literal *)varname)->hash_value;
    tmp___3 = zend_hash_quick_find((HashTable const   *)target_symbol_table, (char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1), hash_value, (void **)(& retval));
    if (tmp___3 == (int __attribute__((__visibility__("default")))  )-1) {
      switch (type) {
      case 0: 
      case 6: 
      zend_error(1 << 3L, "Undefined variable: %s", varname->value.str.val);
      case 3: 
      retval = & executor_globals.uninitialized_zval_ptr;
      break;
      case 2: 
      zend_error(1 << 3L, "Undefined variable: %s", varname->value.str.val);
      case 1: 
      zval_addref_p(& executor_globals.uninitialized_zval);
      _zend_hash_quick_add_or_update(target_symbol_table, (char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1), hash_value, (void *)(& executor_globals.uninitialized_zval_ptr), sizeof(zval *), (void **)(& retval), 1);
      break;
      }
    } else {

    }
    switch ((int )(opline->extended_value & 1879048192UL)) {
    case 0x00000000: 
    if (1 != 1 << 1) {

    } else {

    }
    break;
    case 0x10000000: 
    break;
    case 0x20000000: 
    zval_update_constant(retval, (void *)1);
    break;
    case 0x40000000: 
    if (1 == 1 << 2) {
      if (! free_op1.var) {
        zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr));
      } else {

      }
    } else {

    }
    break;
    }
  }
  if (opline->extended_value & 67108864UL) {
    tmp___6 = zval_isref_p(*retval);
    if (tmp___6) {

    } else {
      while (1) {
        tmp___5 = zval_refcount_p(*retval);
        if (tmp___5 > 1U) {
          zval_delref_p(*retval);
          while (1) {
            tmp___4 = _emalloc(sizeof(zval_gc_info ));
            new_zv = (zval *)tmp___4;
            ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv->value = (*retval)->value;
              new_zv->type = (*retval)->type;
              break;
            }
            zval_set_refcount_p(new_zv, 1U);
            zval_unset_isref_p(new_zv);
            break;
          }
          *retval = new_zv;
          _zval_copy_ctor(new_zv);
        } else {

        }
        break;
      }
      zval_set_isref_p(*retval);
    }
  } else {

  }
  zval_addref_p(*retval);
  switch (type) {
  case 0: 
  case 3: 
  while (1) {
    __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
    __t->var.ptr = *retval;
    __t->var.ptr_ptr = & __t->var.ptr;
    break;
  }
  break;
  case 6: 
  zend_pzval_unlock_func(*retval, & free_res, 1);
  if ((unsigned int )retval != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
    tmp___9 = zval_isref_p(*retval);
    if (tmp___9) {

    } else {
      while (1) {
        tmp___8 = zval_refcount_p(*retval);
        if (tmp___8 > 1U) {
          zval_delref_p(*retval);
          while (1) {
            tmp___7 = _emalloc(sizeof(zval_gc_info ));
            new_zv___0 = (zval *)tmp___7;
            ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv___0->value = (*retval)->value;
              new_zv___0->type = (*retval)->type;
              break;
            }
            zval_set_refcount_p(new_zv___0, 1U);
            zval_unset_isref_p(new_zv___0);
            break;
          }
          *retval = new_zv___0;
          _zval_copy_ctor(new_zv___0);
        } else {

        }
        break;
      }
    }
  } else {

  }
  zval_addref_p(*retval);
  if (free_res.var) {
    i_zval_ptr_dtor(free_res.var);
  } else {

  }
  default: 
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = retval;
  break;
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_R_SPEC_CONST_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_CONST_CONST(0, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_W_SPEC_CONST_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_CONST_CONST(1, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_RW_SPEC_CONST_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_CONST_CONST(2, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_FUNC_ARG_SPEC_CONST_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  unsigned int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
  opline = execute_data->opline;
  if (execute_data->fbc) {
    if ((execute_data->fbc)->common.arg_info) {
      if ((opline->extended_value & 1048575UL) <= (unsigned long )(execute_data->fbc)->common.num_args) {
        tmp___1 = (unsigned int )((int )((execute_data->fbc)->common.arg_info + ((opline->extended_value & 1048575UL) - 1UL))->pass_by_reference & 3);
      } else {
        tmp___1 = (execute_data->fbc)->common.fn_flags & 50331648U;
      }
    } else {
      tmp___1 = (execute_data->fbc)->common.fn_flags & 50331648U;
    }
    if (tmp___1) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___2 = zend_fetch_var_address_helper_SPEC_CONST_CONST(tmp___0, execute_data);
  return (tmp___2);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_UNSET_SPEC_CONST_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_CONST_CONST(6, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_IS_SPEC_CONST_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_CONST_CONST(3, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_TMP_VAR_SPEC_CONST_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *container ;
  temp_variable *__t ;
  zval *value ;
  zval **tmp ;
  temp_variable *__t___0 ;
  long tmp___0 ;

  {
  opline = execute_data->opline;
  container = opline->op1.zv;
  tmp___0 = __builtin_expect((long )((int )container->type != 4), 0L);
  if (tmp___0) {
    zval_addref_p(& executor_globals.uninitialized_zval);
    while (1) {
      __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
      __t->var.ptr = & executor_globals.uninitialized_zval;
      __t->var.ptr_ptr = & __t->var.ptr;
      break;
    }
  } else {
    tmp = zend_fetch_dimension_address_inner(container->value.ht, (zval const   *)opline->op2.zv, 1, 0);
    value = *tmp;
    zval_addref_p(value);
    while (1) {
      __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
      __t___0->var.ptr = value;
      __t___0->var.ptr_ptr = & __t___0->var.ptr;
      break;
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *function_name ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  char *function_name_strval ;
  int function_name_strlen ;
  long tmp___1 ;
  union _zend_function  __attribute__((__visibility__("default"))) *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___6 ;
  zend_function *tmp___7 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___8 ;
  zend_bool __attribute__((__visibility__("default")))  tmp___9 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___10 ;
  zval *tmp___11 ;

  {
  opline = execute_data->opline;
  zend_ptr_stack_3_push(& executor_globals.arg_types_stack, (void *)execute_data->fbc, (void *)execute_data->object, (void *)execute_data->called_scope);
  if (*((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot)) {
    ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot);
  } else {
    tmp = zend_fetch_class_by_name((char const   *)(opline->op1.zv)->value.str.val, (unsigned int )(opline->op1.zv)->value.str.len, (zend_literal const   *)(opline->op1.literal + 1), (int )opline->extended_value);
    ce = (zend_class_entry *)tmp;
    tmp___0 = __builtin_expect((long )((unsigned int )ce == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Class \'%s\' not found", (opline->op1.zv)->value.str.val);
    } else {

    }
    while (1) {
      *((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot) = (void *)ce;
      break;
    }
  }
  execute_data->called_scope = ce;
  if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
    execute_data->fbc = (zend_function *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
  } else {
    if (1 != 1 << 3) {
      function_name_strval = (char *)((void *)0);
      function_name_strlen = 0;
      function_name_strval = (opline->op2.zv)->value.str.val;
      function_name_strlen = (opline->op2.zv)->value.str.len;
      if (function_name_strval) {
        if (ce->get_static_method) {
          execute_data->fbc = (*(ce->get_static_method))(ce, function_name_strval, function_name_strlen);
        } else {
          tmp___2 = zend_std_get_static_method(ce, (char const   *)function_name_strval, function_name_strlen, (struct _zend_literal  const  *)(opline->op2.literal + 1));
          execute_data->fbc = (zend_function *)tmp___2;
        }
        tmp___3 = __builtin_expect((long )((unsigned int )execute_data->fbc == (unsigned int )((void *)0)), 0L);
        if (tmp___3) {
          zend_error_noreturn(1, "Call to undefined method %s::%s()", ce->name, function_name_strval);
        } else {

        }
        tmp___4 = __builtin_expect((long )(((execute_data->fbc)->common.fn_flags & 6291456U) == 0U), 1L);
        if (tmp___4) {
          while (1) {
            *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)execute_data->fbc;
            break;
          }
        } else {

        }
      } else {

      }
    } else {
      tmp___5 = __builtin_expect((long )((unsigned int )ce->constructor == (unsigned int )((void *)0)), 0L);
      if (tmp___5) {
        zend_error_noreturn(1, "Cannot call constructor");
      } else {

      }
      if (executor_globals.This) {
        tmp___6 = zend_get_class_entry((zval const   *)executor_globals.This);
        if ((unsigned int )tmp___6 != (unsigned int )(ce->constructor)->common.scope) {
          if ((ce->constructor)->common.fn_flags & 1024U) {
            zend_error_noreturn(1, "Cannot call private %s::__construct()", ce->name);
          } else {

          }
        } else {

        }
      } else {

      }
      execute_data->fbc = ce->constructor;
    }
  }
  if ((execute_data->fbc)->common.fn_flags & 1U) {
    execute_data->object = (zval *)((void *)0);
  } else {
    if (executor_globals.This) {
      if (((executor_globals.This)->value.obj.handlers)->get_class_entry) {
        tmp___8 = zend_get_class_entry((zval const   *)executor_globals.This);
        tmp___9 = instanceof_function((zend_class_entry const   *)tmp___8, (zend_class_entry const   *)ce);
        if (tmp___9) {

        } else {
          if ((execute_data->fbc)->common.fn_flags & 65536U) {
            zend_error(1 << 11L, "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", ((execute_data->fbc)->common.scope)->name, (execute_data->fbc)->common.function_name);
          } else {
            zend_error_noreturn(1, "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", ((execute_data->fbc)->common.scope)->name, (execute_data->fbc)->common.function_name);
          }
        }
      } else {

      }
    } else {

    }
    tmp___11 = executor_globals.This;
    execute_data->object = tmp___11;
    if (tmp___11) {
      zval_addref_p(execute_data->object);
      tmp___10 = zend_get_class_entry((zval const   *)execute_data->object);
      execute_data->called_scope = (zend_class_entry *)tmp___10;
    } else {

    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_CASE_SPEC_CONST_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;

  {
  opline = execute_data->opline;
  if (1 == 1 << 2) {
    zval_addref_p(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr);
  } else {

  }
  is_equal_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, opline->op2.zv);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_CONSTANT_SPEC_CONST_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_constant *c ;
  zval *retval ;
  char *actual ;
  void const   *tmp ;
  char const   *__s ;
  int __l ;
  zval *__z ;
  char __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_class_entry *ce ;
  zval **value ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___1 ;
  long tmp___2 ;
  zend_class_entry *old_scope ;
  int __attribute__((__visibility__("default")))  tmp___3 ;
  long tmp___4 ;

  {
  opline = execute_data->opline;
  if (1 == 1 << 3) {
    if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
      c = (zend_constant *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
    } else {
      c = zend_quick_get_constant((zend_literal const   *)(opline->op2.literal + 1), opline->extended_value);
      if ((unsigned int )c == (unsigned int )((void *)0)) {
        if ((opline->extended_value & 16UL) != 0UL) {
          tmp = zend_memrchr((void const   *)(opline->op2.zv)->value.str.val, '\\', (unsigned int )(opline->op2.zv)->value.str.len);
          actual = (char *)tmp;
          if (! actual) {
            actual = (opline->op2.zv)->value.str.val;
          } else {
            actual ++;
          }
          zend_error(1 << 3L, "Use of undefined constant %s - assumed \'%s\'", actual, actual);
          while (1) {
            __s = (char const   *)actual;
            __l = (opline->op2.zv)->value.str.len - (actual - (opline->op2.zv)->value.str.val);
            __z = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
            __z->value.str.len = __l;
            tmp___0 = _estrndup(__s, (unsigned int )__l);
            __z->value.str.val = (char *)tmp___0;
            __z->type = (unsigned char)6;
            break;
          }
          (execute_data->opline) ++;
          return (0);
        } else {
          zend_error_noreturn(1, "Undefined constant \'%s\'", (opline->op2.zv)->value.str.val);
        }
      } else {
        while (1) {
          *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)c;
          break;
        }
      }
    }
    retval = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
    while (1) {
      retval->value = c->value.value;
      retval->type = c->value.type;
      break;
    }
    _zval_copy_ctor(retval);
    (execute_data->opline) ++;
    return (0);
  } else {
    if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
      value = (zval **)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
      while (1) {
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value = (*value)->value;
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.type = (*value)->type;
        break;
      }
      _zval_copy_ctor(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var);
      (execute_data->opline) ++;
      return (0);
    } else {
      if (*((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot)) {
        ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot);
      } else {
        tmp___1 = zend_fetch_class_by_name((char const   *)(opline->op1.zv)->value.str.val, (unsigned int )(opline->op1.zv)->value.str.len, (zend_literal const   *)(opline->op1.literal + 1), (int )opline->extended_value);
        ce = (zend_class_entry *)tmp___1;
        tmp___2 = __builtin_expect((long )((unsigned int )ce == (unsigned int )((void *)0)), 0L);
        if (tmp___2) {
          zend_error_noreturn(1, "Undefined class constant \'%s\'", (opline->op2.zv)->value.str.val);
        } else {

        }
        while (1) {
          *((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot) = (void *)ce;
          break;
        }
      }
    }
    tmp___3 = zend_hash_quick_find((HashTable const   *)(& ce->constants_table), (char const   *)(opline->op2.zv)->value.str.val, (unsigned int )((opline->op2.zv)->value.str.len + 1), ((zend_literal *)opline->op2.zv)->hash_value, (void **)(& value));
    tmp___4 = __builtin_expect((long )(tmp___3 == (int __attribute__((__visibility__("default")))  )0), 1L);
    if (tmp___4) {
      if ((int )(*value)->type == 9) {
        old_scope = executor_globals.scope;
        executor_globals.scope = ce;
        zval_update_constant(value, (void *)1);
        executor_globals.scope = old_scope;
      } else {
        if (((int )(*value)->type & 0x00f) == 8) {
          old_scope = executor_globals.scope;
          executor_globals.scope = ce;
          zval_update_constant(value, (void *)1);
          executor_globals.scope = old_scope;
        } else {

        }
      }
      while (1) {
        *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)value;
        break;
      }
      while (1) {
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value = (*value)->value;
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.type = (*value)->type;
        break;
      }
      _zval_copy_ctor(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var);
    } else {
      zend_error_noreturn(1, "Undefined class constant \'%s\'", (opline->op2.zv)->value.str.val);
    }
    (execute_data->opline) ++;
    return (0);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *expr_ptr ;
  zval **expr_ptr_ptr ;
  long tmp ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_uint tmp___1 ;
  zend_bool tmp___2 ;
  zval *new_expr ;
  void __attribute__((__visibility__("default")))  *tmp___3 ;
  zval *new_expr___0 ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_bool tmp___5 ;
  zval *offset ;
  ulong hval ;
  long tmp___6 ;
  register char const   *tmp___7 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___8 ;

  {
  opline = execute_data->opline;
  if (1 == 1 << 2) {
    goto _L___0;
  } else {
    if (1 == 1 << 4) {
      _L___0: /* CIL Label */ 
      if (opline->extended_value) {
        expr_ptr_ptr = (zval **)((void *)0);
        if (1 == 1 << 2) {
          tmp = __builtin_expect((long )((unsigned int )expr_ptr_ptr == (unsigned int )((void *)0)), 0L);
          if (tmp) {
            zend_error_noreturn(1, "Cannot create references to/from string offsets");
          } else {

          }
        } else {

        }
        tmp___2 = zval_isref_p(*expr_ptr_ptr);
        if (tmp___2) {

        } else {
          while (1) {
            tmp___1 = zval_refcount_p(*expr_ptr_ptr);
            if (tmp___1 > 1U) {
              zval_delref_p(*expr_ptr_ptr);
              while (1) {
                tmp___0 = _emalloc(sizeof(zval_gc_info ));
                new_zv = (zval *)tmp___0;
                ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv->value = (*expr_ptr_ptr)->value;
                  new_zv->type = (*expr_ptr_ptr)->type;
                  break;
                }
                zval_set_refcount_p(new_zv, 1U);
                zval_unset_isref_p(new_zv);
                break;
              }
              *expr_ptr_ptr = new_zv;
              _zval_copy_ctor(new_zv);
            } else {

            }
            break;
          }
          zval_set_isref_p(*expr_ptr_ptr);
        }
        expr_ptr = *expr_ptr_ptr;
        zval_addref_p(expr_ptr);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      expr_ptr = opline->op1.zv;
      while (1) {
        tmp___4 = _emalloc(sizeof(zval_gc_info ));
        new_expr___0 = (zval *)tmp___4;
        ((zval_gc_info *)new_expr___0)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      while (1) {
        while (1) {
          new_expr___0->value = expr_ptr->value;
          new_expr___0->type = expr_ptr->type;
          break;
        }
        zval_set_refcount_p(new_expr___0, 1U);
        zval_unset_isref_p(new_expr___0);
        break;
      }
      expr_ptr = new_expr___0;
      _zval_copy_ctor(expr_ptr);
    }
  }
  if (1 != 1 << 3) {
    offset = opline->op2.zv;
    switch ((int )offset->type) {
    case 2: 
    tmp___6 = zend_dval_to_lval(offset->value.dval);
    hval = (unsigned long )tmp___6;
    goto num_index;
    case 1: 
    case 3: 
    hval = (unsigned long )offset->value.lval;
    num_index: 
    _zend_hash_index_update_or_next_insert(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, hval, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    case 6: 
    if (1) {
      hval = ((zend_literal *)offset)->hash_value;
    } else {
      while (1) {
        tmp___7 = (char const   *)offset->value.str.val;
        if ((int const   )*tmp___7 == 45) {
          tmp___7 ++;
        } else {

        }
        if ((int const   )*tmp___7 >= 48) {
          if ((int const   )*tmp___7 <= 57) {
            end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
            if ((int const   )*end != 0) {
              break;
            } else {
              if ((int const   )*tmp___7 == 48) {
                if (offset->value.str.len + 1 > 2) {
                  break;
                } else {
                  goto _L___1;
                }
              } else {
                _L___1: /* CIL Label */ 
                if (end - tmp___7 > 10) {
                  break;
                } else {
                  if (end - tmp___7 == 10) {
                    if ((int const   )*tmp___7 > 50) {
                      break;
                    } else {

                    }
                  } else {

                  }
                }
              }
            }
            hval = (unsigned long )((int const   )*tmp___7 - 48);
            while (1) {
              tmp___7 ++;
              if ((unsigned int )tmp___7 != (unsigned int )end) {
                if ((int const   )*tmp___7 >= 48) {
                  if ((int const   )*tmp___7 <= 57) {

                  } else {
                    break;
                  }
                } else {
                  break;
                }
              } else {
                break;
              }
              hval = hval * 10UL + (ulong )((int const   )*tmp___7 - 48);
            }
            if ((unsigned int )tmp___7 == (unsigned int )end) {
              if ((int )*(offset->value.str.val) == 45) {
                if (hval - 1UL > 2147483647UL) {
                  break;
                } else {

                }
                hval = (unsigned long )(- ((long )hval));
              } else {
                if (hval > 2147483647UL) {
                  break;
                } else {

                }
              }
              goto num_index;
            } else {

            }
          } else {

          }
        } else {

        }
        break;
      }
      if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
        if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
          hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
        } else {
          tmp___8 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___8;
        }
      } else {
        tmp___8 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
        hval = (unsigned long )tmp___8;
      }
    }
    _zend_hash_quick_add_or_update(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    case 0: 
    _zend_hash_add_or_update(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, "", sizeof(""), (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    default: 
    zend_error(1 << 1L, "Illegal offset type");
    i_zval_ptr_dtor(expr_ptr);
    break;
    }
  } else {
    _zend_hash_index_update_or_next_insert(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, 0UL, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1 << 2);
  }
  if (1 == 1 << 2) {
    goto _L___2;
  } else {
    if (1 == 1 << 4) {
      _L___2: /* CIL Label */ 
      if (opline->extended_value) {

      } else {

      }
    } else {

    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_ARRAY_SPEC_CONST_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  int tmp ;

  {
  opline = execute_data->opline;
  _array_init(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, 0U);
  if (1 == 1 << 3) {
    (execute_data->opline) ++;
    return (0);
  } else {
    tmp = ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CONST_HANDLER(execute_data);
    return (tmp);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_UNSET_VAR_SPEC_CONST_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval tmp ;
  zval *varname ;
  HashTable *target_symbol_table ;
  zend_compiled_variable *cv ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  ulong hash_value ;
  ulong tmp___1 ;

  {
  opline = execute_data->opline;
  if (1 == 1 << 4) {
    if (1 == 1 << 3) {
      if (opline->extended_value & 8388608UL) {
        if (executor_globals.active_symbol_table) {
          cv = (executor_globals.active_op_array)->vars + opline->op1.var;
          zend_delete_variable(execute_data->prev_execute_data, executor_globals.active_symbol_table, cv->name, cv->name_len + 1, cv->hash_value);
          *(execute_data->CVs + opline->op1.var) = (zval **)((void *)0);
        } else {
          if (*(execute_data->CVs + opline->op1.var)) {
            i_zval_ptr_dtor(*(*(execute_data->CVs + opline->op1.var)));
            *(execute_data->CVs + opline->op1.var) = (zval **)((void *)0);
          } else {

          }
        }
        (execute_data->opline) ++;
        return (0);
      } else {

      }
    } else {

    }
  } else {

  }
  varname = opline->op1.zv;
  if (1 == 1 << 2) {
    zval_addref_p(varname);
  } else {
    if (1 == 1 << 4) {
      zval_addref_p(varname);
    } else {

    }
  }
  if (1 != 1 << 3) {
    if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
      ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
    } else {
      tmp___0 = zend_fetch_class_by_name((char const   *)(opline->op2.zv)->value.str.val, (unsigned int )(opline->op2.zv)->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), 0);
      ce = (zend_class_entry *)tmp___0;
      while (1) {
        *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
        break;
      }
    }
    zend_std_unset_static_property(ce, (char const   *)varname->value.str.val, varname->value.str.len, (struct _zend_literal  const  *)opline->op1.literal);
  } else {
    tmp___1 = zend_inline_hash_func((char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1));
    hash_value = tmp___1;
    target_symbol_table = zend_get_target_symbol_table((int )(opline->extended_value & 1879048192UL));
    zend_delete_variable(execute_data, target_symbol_table, (char const   *)varname->value.str.val, varname->value.str.len + 1, hash_value);
  }
  if (1 == 1 << 2) {
    i_zval_ptr_dtor(varname);
  } else {
    if (1 == 1 << 4) {
      i_zval_ptr_dtor(varname);
    } else {

    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ISSET_ISEMPTY_VAR_SPEC_CONST_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **value ;
  zend_bool isset ;
  zend_compiled_variable *cv ;
  int __attribute__((__visibility__("default")))  tmp ;
  HashTable *target_symbol_table ;
  zval tmp___0 ;
  zval *varname ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___1 ;
  zval __attribute__((__visibility__("default")))  **tmp___2 ;
  int __attribute__((__visibility__("default")))  tmp___3 ;
  zval *__z ;
  zval *__z___0 ;
  zval *__z___1 ;
  zval *__z___2 ;
  int tmp___4 ;

  {
  opline = execute_data->opline;
  isset = (zend_bool )1;
  if (1 == 1 << 4) {
    if (1 == 1 << 3) {
      if (opline->extended_value & 8388608UL) {
        if (*(execute_data->CVs + opline->op1.var)) {
          value = *(execute_data->CVs + opline->op1.var);
        } else {
          if (executor_globals.active_symbol_table) {
            cv = (executor_globals.active_op_array)->vars + opline->op1.var;
            tmp = zend_hash_quick_find((HashTable const   *)executor_globals.active_symbol_table, cv->name, (unsigned int )(cv->name_len + 1), cv->hash_value, (void **)(& value));
            if (tmp == (int __attribute__((__visibility__("default")))  )-1) {
              isset = (unsigned char)0;
            } else {

            }
          } else {
            isset = (unsigned char)0;
          }
        }
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    _L: /* CIL Label */ 
    varname = opline->op1.zv;
    if (1 != 1 << 3) {
      if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
        ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
      } else {
        tmp___1 = zend_fetch_class_by_name((char const   *)(opline->op2.zv)->value.str.val, (unsigned int )(opline->op2.zv)->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), 0);
        ce = (zend_class_entry *)tmp___1;
        while (1) {
          *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
          break;
        }
      }
      tmp___2 = zend_std_get_static_property(ce, (char const   *)varname->value.str.val, varname->value.str.len, (unsigned char)1, (struct _zend_literal  const  *)opline->op1.literal);
      value = (zval **)tmp___2;
      if (! value) {
        isset = (unsigned char)0;
      } else {

      }
    } else {
      target_symbol_table = zend_get_target_symbol_table((int )(opline->extended_value & 1879048192UL));
      tmp___3 = zend_hash_find((HashTable const   *)target_symbol_table, (char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1), (void **)(& value));
      if (tmp___3 == (int __attribute__((__visibility__("default")))  )-1) {
        isset = (unsigned char)0;
      } else {

      }
    }
  }
  if (opline->extended_value & 33554432UL) {
    if (isset) {
      if ((int )(*value)->type != 0) {
        while (1) {
          __z = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
          __z->value.lval = 1L;
          __z->type = (unsigned char)3;
          break;
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      while (1) {
        __z___0 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
        __z___0->value.lval = 0L;
        __z___0->type = (unsigned char)3;
        break;
      }
    }
  } else {
    if (! isset) {
      goto _L___2;
    } else {
      tmp___4 = i_zend_is_true(*value);
      if (tmp___4) {
        while (1) {
          __z___2 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
          __z___2->value.lval = 0L;
          __z___2->type = (unsigned char)3;
          break;
        }
      } else {
        _L___2: /* CIL Label */ 
        while (1) {
          __z___1 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
          __z___1->value.lval = 1L;
          __z___1->type = (unsigned char)3;
          break;
        }
      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_DECLARE_CONST_SPEC_CONST_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *name ;
  zval *val ;
  zend_constant c ;
  zval tmp ;
  zval *tmp_ptr ;
  char __attribute__((__visibility__("default")))  *tmp___0 ;
  int __attribute__((__visibility__("default")))  tmp___1 ;

  {
  opline = execute_data->opline;
  name = opline->op1.zv;
  val = opline->op2.zv;
  if (((int )val->type & 0x00f) == 8) {
    goto _L;
  } else {
    if ((int )val->type == 9) {
      _L: /* CIL Label */ 
      tmp_ptr = & tmp;
      while (1) {
        tmp.value = val->value;
        tmp.type = val->type;
        break;
      }
      if ((int )val->type == 9) {
        _zval_copy_ctor(& tmp);
      } else {

      }
      tmp.refcount__gc = 1U;
      tmp.is_ref__gc = (unsigned char)0;
      zval_update_constant(& tmp_ptr, (void *)0);
      c.value = *tmp_ptr;
    } else {
      while (1) {
        while (1) {
          c.value.value = val->value;
          c.value.type = val->type;
          break;
        }
        zval_set_refcount_p(& c.value, 1U);
        zval_unset_isref_p(& c.value);
        break;
      }
      _zval_copy_ctor(& c.value);
    }
  }
  c.flags = 1;
  if ((unsigned int )name->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
    if ((unsigned int )name->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
      c.name = name->value.str.val;
    } else {
      tmp___0 = zend_strndup((char const   *)name->value.str.val, (unsigned int )name->value.str.len);
      c.name = (char *)tmp___0;
    }
  } else {
    tmp___0 = zend_strndup((char const   *)name->value.str.val, (unsigned int )name->value.str.len);
    c.name = (char *)tmp___0;
  }
  c.name_len = (unsigned int )(name->value.str.len + 1);
  c.module_number = 2147483647;
  tmp___1 = zend_register_constant(& c);
  if (tmp___1 == (int __attribute__((__visibility__("default")))  )-1) {

  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_SPEC_CONST_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  fast_add_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, tmp);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SUB_SPEC_CONST_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  fast_sub_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, tmp);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_MUL_SPEC_CONST_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  fast_mul_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, tmp);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_DIV_SPEC_CONST_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  fast_div_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, tmp);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_MOD_SPEC_CONST_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  fast_mod_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, tmp);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SL_SPEC_CONST_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  shift_left_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, tmp);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SR_SPEC_CONST_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  shift_right_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, tmp);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_CONCAT_SPEC_CONST_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  concat_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, tmp);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_IDENTICAL_SPEC_CONST_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  is_identical_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, tmp);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_NOT_IDENTICAL_SPEC_CONST_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *result ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  is_identical_function(result, opline->op1.zv, tmp);
  result->value.lval = (long )(! result->value.lval);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_EQUAL_SPEC_CONST_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  int tmp___0 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    tmp___0 = fast_equal_function(result, opline->op1.zv, tmp);
    __z->value.lval = (long )(tmp___0 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_NOT_EQUAL_SPEC_CONST_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  int tmp___0 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    tmp___0 = fast_not_equal_function(result, opline->op1.zv, tmp);
    __z->value.lval = (long )(tmp___0 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_SMALLER_SPEC_CONST_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  int tmp___0 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    tmp___0 = fast_is_smaller_function(result, opline->op1.zv, tmp);
    __z->value.lval = (long )(tmp___0 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  int tmp___0 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    tmp___0 = fast_is_smaller_or_equal_function(result, opline->op1.zv, tmp);
    __z->value.lval = (long )(tmp___0 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_OR_SPEC_CONST_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  bitwise_or_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, tmp);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_AND_SPEC_CONST_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  bitwise_and_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, tmp);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_XOR_SPEC_CONST_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  bitwise_xor_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, tmp);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BOOL_XOR_SPEC_CONST_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  boolean_xor_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, tmp);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *function_name ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  char *function_name_strval ;
  int function_name_strlen ;
  zend_free_op free_op2 ;
  long tmp___1 ;
  zend_literal *tmp___2 ;
  union _zend_function  __attribute__((__visibility__("default"))) *tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___7 ;
  zend_function *tmp___8 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___9 ;
  zend_bool __attribute__((__visibility__("default")))  tmp___10 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___11 ;
  zval *tmp___12 ;

  {
  opline = execute_data->opline;
  zend_ptr_stack_3_push(& executor_globals.arg_types_stack, (void *)execute_data->fbc, (void *)execute_data->object, (void *)execute_data->called_scope);
  if (*((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot)) {
    ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot);
  } else {
    tmp = zend_fetch_class_by_name((char const   *)(opline->op1.zv)->value.str.val, (unsigned int )(opline->op1.zv)->value.str.len, (zend_literal const   *)(opline->op1.literal + 1), (int )opline->extended_value);
    ce = (zend_class_entry *)tmp;
    tmp___0 = __builtin_expect((long )((unsigned int )ce == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Class \'%s\' not found", (opline->op1.zv)->value.str.val);
    } else {

    }
    while (1) {
      *((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot) = (void *)ce;
      break;
    }
  }
  execute_data->called_scope = ce;
  if (1 << 1 == 1) {
    if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
      execute_data->fbc = (zend_function *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if (1 << 1 != 1 << 3) {
      function_name_strval = (char *)((void *)0);
      function_name_strlen = 0;
      if (1 << 1 == 1) {
        function_name_strval = (opline->op2.zv)->value.str.val;
        function_name_strlen = (opline->op2.zv)->value.str.len;
      } else {
        function_name = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
        tmp___1 = __builtin_expect((long )((int )function_name->type != 6), 0L);
        if (tmp___1) {
          zend_error_noreturn(1, "Function name must be a string");
        } else {
          function_name_strval = function_name->value.str.val;
          function_name_strlen = function_name->value.str.len;
        }
      }
      if (function_name_strval) {
        if (ce->get_static_method) {
          execute_data->fbc = (*(ce->get_static_method))(ce, function_name_strval, function_name_strlen);
        } else {
          if (1 << 1 == 1) {
            tmp___2 = opline->op2.literal + 1;
          } else {
            tmp___2 = (zend_literal *)((void *)0);
          }
          tmp___3 = zend_std_get_static_method(ce, (char const   *)function_name_strval, function_name_strlen, (struct _zend_literal  const  *)tmp___2);
          execute_data->fbc = (zend_function *)tmp___3;
        }
        tmp___4 = __builtin_expect((long )((unsigned int )execute_data->fbc == (unsigned int )((void *)0)), 0L);
        if (tmp___4) {
          zend_error_noreturn(1, "Call to undefined method %s::%s()", ce->name, function_name_strval);
        } else {

        }
        if (1 << 1 == 1) {
          tmp___5 = __builtin_expect((long )(((execute_data->fbc)->common.fn_flags & 6291456U) == 0U), 1L);
          if (tmp___5) {
            while (1) {
              *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)execute_data->fbc;
              break;
            }
          } else {

          }
        } else {

        }
      } else {

      }
      if (1 << 1 != 1) {
        _zval_dtor(free_op2.var);
      } else {

      }
    } else {
      tmp___6 = __builtin_expect((long )((unsigned int )ce->constructor == (unsigned int )((void *)0)), 0L);
      if (tmp___6) {
        zend_error_noreturn(1, "Cannot call constructor");
      } else {

      }
      if (executor_globals.This) {
        tmp___7 = zend_get_class_entry((zval const   *)executor_globals.This);
        if ((unsigned int )tmp___7 != (unsigned int )(ce->constructor)->common.scope) {
          if ((ce->constructor)->common.fn_flags & 1024U) {
            zend_error_noreturn(1, "Cannot call private %s::__construct()", ce->name);
          } else {

          }
        } else {

        }
      } else {

      }
      execute_data->fbc = ce->constructor;
    }
  }
  if ((execute_data->fbc)->common.fn_flags & 1U) {
    execute_data->object = (zval *)((void *)0);
  } else {
    if (executor_globals.This) {
      if (((executor_globals.This)->value.obj.handlers)->get_class_entry) {
        tmp___9 = zend_get_class_entry((zval const   *)executor_globals.This);
        tmp___10 = instanceof_function((zend_class_entry const   *)tmp___9, (zend_class_entry const   *)ce);
        if (tmp___10) {

        } else {
          if ((execute_data->fbc)->common.fn_flags & 65536U) {
            zend_error(1 << 11L, "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", ((execute_data->fbc)->common.scope)->name, (execute_data->fbc)->common.function_name);
          } else {
            zend_error_noreturn(1, "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", ((execute_data->fbc)->common.scope)->name, (execute_data->fbc)->common.function_name);
          }
        }
      } else {

      }
    } else {

    }
    tmp___12 = executor_globals.This;
    execute_data->object = tmp___12;
    if (tmp___12) {
      zval_addref_p(execute_data->object);
      tmp___11 = zend_get_class_entry((zval const   *)execute_data->object);
      execute_data->called_scope = (zend_class_entry *)tmp___11;
    } else {

    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_CASE_SPEC_CONST_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  if (1 == 1 << 2) {
    zval_addref_p(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr);
  } else {

  }
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  is_equal_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, tmp);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *expr_ptr ;
  zval **expr_ptr_ptr ;
  long tmp ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_uint tmp___1 ;
  zend_bool tmp___2 ;
  zval *new_expr ;
  void __attribute__((__visibility__("default")))  *tmp___3 ;
  zval *new_expr___0 ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_bool tmp___5 ;
  zend_free_op free_op2 ;
  zval *offset ;
  zval *tmp___6 ;
  ulong hval ;
  long tmp___7 ;
  register char const   *tmp___8 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___9 ;

  {
  opline = execute_data->opline;
  if (1 == 1 << 2) {
    goto _L___0;
  } else {
    if (1 == 1 << 4) {
      _L___0: /* CIL Label */ 
      if (opline->extended_value) {
        expr_ptr_ptr = (zval **)((void *)0);
        if (1 == 1 << 2) {
          tmp = __builtin_expect((long )((unsigned int )expr_ptr_ptr == (unsigned int )((void *)0)), 0L);
          if (tmp) {
            zend_error_noreturn(1, "Cannot create references to/from string offsets");
          } else {

          }
        } else {

        }
        tmp___2 = zval_isref_p(*expr_ptr_ptr);
        if (tmp___2) {

        } else {
          while (1) {
            tmp___1 = zval_refcount_p(*expr_ptr_ptr);
            if (tmp___1 > 1U) {
              zval_delref_p(*expr_ptr_ptr);
              while (1) {
                tmp___0 = _emalloc(sizeof(zval_gc_info ));
                new_zv = (zval *)tmp___0;
                ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv->value = (*expr_ptr_ptr)->value;
                  new_zv->type = (*expr_ptr_ptr)->type;
                  break;
                }
                zval_set_refcount_p(new_zv, 1U);
                zval_unset_isref_p(new_zv);
                break;
              }
              *expr_ptr_ptr = new_zv;
              _zval_copy_ctor(new_zv);
            } else {

            }
            break;
          }
          zval_set_isref_p(*expr_ptr_ptr);
        }
        expr_ptr = *expr_ptr_ptr;
        zval_addref_p(expr_ptr);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      expr_ptr = opline->op1.zv;
      while (1) {
        tmp___4 = _emalloc(sizeof(zval_gc_info ));
        new_expr___0 = (zval *)tmp___4;
        ((zval_gc_info *)new_expr___0)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      while (1) {
        while (1) {
          new_expr___0->value = expr_ptr->value;
          new_expr___0->type = expr_ptr->type;
          break;
        }
        zval_set_refcount_p(new_expr___0, 1U);
        zval_unset_isref_p(new_expr___0);
        break;
      }
      expr_ptr = new_expr___0;
      _zval_copy_ctor(expr_ptr);
    }
  }
  if (1 << 1 != 1 << 3) {
    tmp___6 = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    offset = tmp___6;
    switch ((int )offset->type) {
    case 2: 
    tmp___7 = zend_dval_to_lval(offset->value.dval);
    hval = (unsigned long )tmp___7;
    goto num_index;
    case 1: 
    case 3: 
    hval = (unsigned long )offset->value.lval;
    num_index: 
    _zend_hash_index_update_or_next_insert(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, hval, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    case 6: 
    if (1 << 1 == 1) {
      hval = ((zend_literal *)offset)->hash_value;
    } else {
      while (1) {
        tmp___8 = (char const   *)offset->value.str.val;
        if ((int const   )*tmp___8 == 45) {
          tmp___8 ++;
        } else {

        }
        if ((int const   )*tmp___8 >= 48) {
          if ((int const   )*tmp___8 <= 57) {
            end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
            if ((int const   )*end != 0) {
              break;
            } else {
              if ((int const   )*tmp___8 == 48) {
                if (offset->value.str.len + 1 > 2) {
                  break;
                } else {
                  goto _L___1;
                }
              } else {
                _L___1: /* CIL Label */ 
                if (end - tmp___8 > 10) {
                  break;
                } else {
                  if (end - tmp___8 == 10) {
                    if ((int const   )*tmp___8 > 50) {
                      break;
                    } else {

                    }
                  } else {

                  }
                }
              }
            }
            hval = (unsigned long )((int const   )*tmp___8 - 48);
            while (1) {
              tmp___8 ++;
              if ((unsigned int )tmp___8 != (unsigned int )end) {
                if ((int const   )*tmp___8 >= 48) {
                  if ((int const   )*tmp___8 <= 57) {

                  } else {
                    break;
                  }
                } else {
                  break;
                }
              } else {
                break;
              }
              hval = hval * 10UL + (ulong )((int const   )*tmp___8 - 48);
            }
            if ((unsigned int )tmp___8 == (unsigned int )end) {
              if ((int )*(offset->value.str.val) == 45) {
                if (hval - 1UL > 2147483647UL) {
                  break;
                } else {

                }
                hval = (unsigned long )(- ((long )hval));
              } else {
                if (hval > 2147483647UL) {
                  break;
                } else {

                }
              }
              goto num_index;
            } else {

            }
          } else {

          }
        } else {

        }
        break;
      }
      if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
        if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
          hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
        } else {
          tmp___9 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___9;
        }
      } else {
        tmp___9 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
        hval = (unsigned long )tmp___9;
      }
    }
    _zend_hash_quick_add_or_update(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    case 0: 
    _zend_hash_add_or_update(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, "", sizeof(""), (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    default: 
    zend_error(1 << 1L, "Illegal offset type");
    i_zval_ptr_dtor(expr_ptr);
    break;
    }
    _zval_dtor(free_op2.var);
  } else {
    _zend_hash_index_update_or_next_insert(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, 0UL, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1 << 2);
  }
  if (1 == 1 << 2) {
    goto _L___2;
  } else {
    if (1 == 1 << 4) {
      _L___2: /* CIL Label */ 
      if (opline->extended_value) {

      } else {

      }
    } else {

    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_ARRAY_SPEC_CONST_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  int tmp ;

  {
  opline = execute_data->opline;
  _array_init(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, 0U);
  if (1 == 1 << 3) {
    (execute_data->opline) ++;
    return (0);
  } else {
    tmp = ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_TMP_HANDLER(execute_data);
    return (tmp);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_SPEC_CONST_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  fast_add_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, tmp);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SUB_SPEC_CONST_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  fast_sub_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, tmp);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_MUL_SPEC_CONST_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  fast_mul_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, tmp);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_DIV_SPEC_CONST_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  fast_div_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, tmp);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_MOD_SPEC_CONST_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  fast_mod_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, tmp);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SL_SPEC_CONST_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  shift_left_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, tmp);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SR_SPEC_CONST_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  shift_right_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, tmp);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_CONCAT_SPEC_CONST_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  concat_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, tmp);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_IDENTICAL_SPEC_CONST_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  is_identical_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, tmp);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_NOT_IDENTICAL_SPEC_CONST_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *result ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  is_identical_function(result, opline->op1.zv, tmp);
  result->value.lval = (long )(! result->value.lval);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_EQUAL_SPEC_CONST_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  int tmp___0 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    tmp___0 = fast_equal_function(result, opline->op1.zv, tmp);
    __z->value.lval = (long )(tmp___0 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_NOT_EQUAL_SPEC_CONST_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  int tmp___0 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    tmp___0 = fast_not_equal_function(result, opline->op1.zv, tmp);
    __z->value.lval = (long )(tmp___0 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_SMALLER_SPEC_CONST_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  int tmp___0 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    tmp___0 = fast_is_smaller_function(result, opline->op1.zv, tmp);
    __z->value.lval = (long )(tmp___0 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  int tmp___0 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    tmp___0 = fast_is_smaller_or_equal_function(result, opline->op1.zv, tmp);
    __z->value.lval = (long )(tmp___0 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_OR_SPEC_CONST_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  bitwise_or_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, tmp);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_AND_SPEC_CONST_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  bitwise_and_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, tmp);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_XOR_SPEC_CONST_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  bitwise_xor_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, tmp);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BOOL_XOR_SPEC_CONST_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  boolean_xor_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, tmp);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_fetch_var_address_helper_SPEC_CONST_VAR)(int type , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *varname ;
  zval **retval ;
  zval tmp_varname ;
  HashTable *target_symbol_table ;
  ulong hash_value ;
  long tmp ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  zval __attribute__((__visibility__("default")))  **tmp___1 ;
  ulong __attribute__((__visibility__("default")))  tmp___2 ;
  int __attribute__((__visibility__("default")))  tmp___3 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_uint tmp___5 ;
  zend_bool tmp___6 ;
  temp_variable *__t ;
  zend_free_op free_res ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___7 ;
  zend_uint tmp___8 ;
  zend_bool tmp___9 ;

  {
  opline = execute_data->opline;
  varname = opline->op1.zv;
  if (1 << 2 != 1 << 3) {
    if (1 << 2 == 1) {
      if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
        ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
      } else {
        tmp___0 = zend_fetch_class_by_name((char const   *)(opline->op2.zv)->value.str.val, (unsigned int )(opline->op2.zv)->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), 0);
        ce = (zend_class_entry *)tmp___0;
        while (1) {
          *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
          break;
        }
      }
    } else {
      ce = ((temp_variable *)((char *)execute_data->Ts + opline->op2.var))->class_entry;
    }
    tmp___1 = zend_std_get_static_property(ce, (char const   *)varname->value.str.val, varname->value.str.len, (unsigned char)0, (struct _zend_literal  const  *)opline->op1.literal);
    retval = (zval **)tmp___1;
  } else {
    target_symbol_table = zend_get_target_symbol_table((int )(opline->extended_value & 1879048192UL));
    hash_value = ((zend_literal *)varname)->hash_value;
    tmp___3 = zend_hash_quick_find((HashTable const   *)target_symbol_table, (char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1), hash_value, (void **)(& retval));
    if (tmp___3 == (int __attribute__((__visibility__("default")))  )-1) {
      switch (type) {
      case 0: 
      case 6: 
      zend_error(1 << 3L, "Undefined variable: %s", varname->value.str.val);
      case 3: 
      retval = & executor_globals.uninitialized_zval_ptr;
      break;
      case 2: 
      zend_error(1 << 3L, "Undefined variable: %s", varname->value.str.val);
      case 1: 
      zval_addref_p(& executor_globals.uninitialized_zval);
      _zend_hash_quick_add_or_update(target_symbol_table, (char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1), hash_value, (void *)(& executor_globals.uninitialized_zval_ptr), sizeof(zval *), (void **)(& retval), 1);
      break;
      }
    } else {

    }
    switch ((int )(opline->extended_value & 1879048192UL)) {
    case 0x00000000: 
    if (1 != 1 << 1) {

    } else {

    }
    break;
    case 0x10000000: 
    break;
    case 0x20000000: 
    zval_update_constant(retval, (void *)1);
    break;
    case 0x40000000: 
    if (1 == 1 << 2) {
      if (! free_op1.var) {
        zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr));
      } else {

      }
    } else {

    }
    break;
    }
  }
  if (opline->extended_value & 67108864UL) {
    tmp___6 = zval_isref_p(*retval);
    if (tmp___6) {

    } else {
      while (1) {
        tmp___5 = zval_refcount_p(*retval);
        if (tmp___5 > 1U) {
          zval_delref_p(*retval);
          while (1) {
            tmp___4 = _emalloc(sizeof(zval_gc_info ));
            new_zv = (zval *)tmp___4;
            ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv->value = (*retval)->value;
              new_zv->type = (*retval)->type;
              break;
            }
            zval_set_refcount_p(new_zv, 1U);
            zval_unset_isref_p(new_zv);
            break;
          }
          *retval = new_zv;
          _zval_copy_ctor(new_zv);
        } else {

        }
        break;
      }
      zval_set_isref_p(*retval);
    }
  } else {

  }
  zval_addref_p(*retval);
  switch (type) {
  case 0: 
  case 3: 
  while (1) {
    __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
    __t->var.ptr = *retval;
    __t->var.ptr_ptr = & __t->var.ptr;
    break;
  }
  break;
  case 6: 
  zend_pzval_unlock_func(*retval, & free_res, 1);
  if ((unsigned int )retval != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
    tmp___9 = zval_isref_p(*retval);
    if (tmp___9) {

    } else {
      while (1) {
        tmp___8 = zval_refcount_p(*retval);
        if (tmp___8 > 1U) {
          zval_delref_p(*retval);
          while (1) {
            tmp___7 = _emalloc(sizeof(zval_gc_info ));
            new_zv___0 = (zval *)tmp___7;
            ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv___0->value = (*retval)->value;
              new_zv___0->type = (*retval)->type;
              break;
            }
            zval_set_refcount_p(new_zv___0, 1U);
            zval_unset_isref_p(new_zv___0);
            break;
          }
          *retval = new_zv___0;
          _zval_copy_ctor(new_zv___0);
        } else {

        }
        break;
      }
    }
  } else {

  }
  zval_addref_p(*retval);
  if (free_res.var) {
    i_zval_ptr_dtor(free_res.var);
  } else {

  }
  default: 
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = retval;
  break;
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_R_SPEC_CONST_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_CONST_VAR(0, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_W_SPEC_CONST_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_CONST_VAR(1, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_RW_SPEC_CONST_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_CONST_VAR(2, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_FUNC_ARG_SPEC_CONST_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  unsigned int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
  opline = execute_data->opline;
  if (execute_data->fbc) {
    if ((execute_data->fbc)->common.arg_info) {
      if ((opline->extended_value & 1048575UL) <= (unsigned long )(execute_data->fbc)->common.num_args) {
        tmp___1 = (unsigned int )((int )((execute_data->fbc)->common.arg_info + ((opline->extended_value & 1048575UL) - 1UL))->pass_by_reference & 3);
      } else {
        tmp___1 = (execute_data->fbc)->common.fn_flags & 50331648U;
      }
    } else {
      tmp___1 = (execute_data->fbc)->common.fn_flags & 50331648U;
    }
    if (tmp___1) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___2 = zend_fetch_var_address_helper_SPEC_CONST_VAR(tmp___0, execute_data);
  return (tmp___2);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_UNSET_SPEC_CONST_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_CONST_VAR(6, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_IS_SPEC_CONST_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_CONST_VAR(3, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *function_name ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  char *function_name_strval ;
  int function_name_strlen ;
  zend_free_op free_op2 ;
  long tmp___1 ;
  zend_literal *tmp___2 ;
  union _zend_function  __attribute__((__visibility__("default"))) *tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___7 ;
  zend_function *tmp___8 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___9 ;
  zend_bool __attribute__((__visibility__("default")))  tmp___10 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___11 ;
  zval *tmp___12 ;

  {
  opline = execute_data->opline;
  zend_ptr_stack_3_push(& executor_globals.arg_types_stack, (void *)execute_data->fbc, (void *)execute_data->object, (void *)execute_data->called_scope);
  if (*((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot)) {
    ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot);
  } else {
    tmp = zend_fetch_class_by_name((char const   *)(opline->op1.zv)->value.str.val, (unsigned int )(opline->op1.zv)->value.str.len, (zend_literal const   *)(opline->op1.literal + 1), (int )opline->extended_value);
    ce = (zend_class_entry *)tmp;
    tmp___0 = __builtin_expect((long )((unsigned int )ce == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Class \'%s\' not found", (opline->op1.zv)->value.str.val);
    } else {

    }
    while (1) {
      *((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot) = (void *)ce;
      break;
    }
  }
  execute_data->called_scope = ce;
  if (1 << 2 == 1) {
    if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
      execute_data->fbc = (zend_function *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if (1 << 2 != 1 << 3) {
      function_name_strval = (char *)((void *)0);
      function_name_strlen = 0;
      if (1 << 2 == 1) {
        function_name_strval = (opline->op2.zv)->value.str.val;
        function_name_strlen = (opline->op2.zv)->value.str.len;
      } else {
        function_name = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
        tmp___1 = __builtin_expect((long )((int )function_name->type != 6), 0L);
        if (tmp___1) {
          zend_error_noreturn(1, "Function name must be a string");
        } else {
          function_name_strval = function_name->value.str.val;
          function_name_strlen = function_name->value.str.len;
        }
      }
      if (function_name_strval) {
        if (ce->get_static_method) {
          execute_data->fbc = (*(ce->get_static_method))(ce, function_name_strval, function_name_strlen);
        } else {
          if (1 << 2 == 1) {
            tmp___2 = opline->op2.literal + 1;
          } else {
            tmp___2 = (zend_literal *)((void *)0);
          }
          tmp___3 = zend_std_get_static_method(ce, (char const   *)function_name_strval, function_name_strlen, (struct _zend_literal  const  *)tmp___2);
          execute_data->fbc = (zend_function *)tmp___3;
        }
        tmp___4 = __builtin_expect((long )((unsigned int )execute_data->fbc == (unsigned int )((void *)0)), 0L);
        if (tmp___4) {
          zend_error_noreturn(1, "Call to undefined method %s::%s()", ce->name, function_name_strval);
        } else {

        }
        if (1 << 2 == 1) {
          tmp___5 = __builtin_expect((long )(((execute_data->fbc)->common.fn_flags & 6291456U) == 0U), 1L);
          if (tmp___5) {
            while (1) {
              *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)execute_data->fbc;
              break;
            }
          } else {

          }
        } else {

        }
      } else {

      }
      if (1 << 2 != 1) {
        if (free_op2.var) {
          i_zval_ptr_dtor(free_op2.var);
        } else {

        }
      } else {

      }
    } else {
      tmp___6 = __builtin_expect((long )((unsigned int )ce->constructor == (unsigned int )((void *)0)), 0L);
      if (tmp___6) {
        zend_error_noreturn(1, "Cannot call constructor");
      } else {

      }
      if (executor_globals.This) {
        tmp___7 = zend_get_class_entry((zval const   *)executor_globals.This);
        if ((unsigned int )tmp___7 != (unsigned int )(ce->constructor)->common.scope) {
          if ((ce->constructor)->common.fn_flags & 1024U) {
            zend_error_noreturn(1, "Cannot call private %s::__construct()", ce->name);
          } else {

          }
        } else {

        }
      } else {

      }
      execute_data->fbc = ce->constructor;
    }
  }
  if ((execute_data->fbc)->common.fn_flags & 1U) {
    execute_data->object = (zval *)((void *)0);
  } else {
    if (executor_globals.This) {
      if (((executor_globals.This)->value.obj.handlers)->get_class_entry) {
        tmp___9 = zend_get_class_entry((zval const   *)executor_globals.This);
        tmp___10 = instanceof_function((zend_class_entry const   *)tmp___9, (zend_class_entry const   *)ce);
        if (tmp___10) {

        } else {
          if ((execute_data->fbc)->common.fn_flags & 65536U) {
            zend_error(1 << 11L, "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", ((execute_data->fbc)->common.scope)->name, (execute_data->fbc)->common.function_name);
          } else {
            zend_error_noreturn(1, "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", ((execute_data->fbc)->common.scope)->name, (execute_data->fbc)->common.function_name);
          }
        }
      } else {

      }
    } else {

    }
    tmp___12 = executor_globals.This;
    execute_data->object = tmp___12;
    if (tmp___12) {
      zval_addref_p(execute_data->object);
      tmp___11 = zend_get_class_entry((zval const   *)execute_data->object);
      execute_data->called_scope = (zend_class_entry *)tmp___11;
    } else {

    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_CASE_SPEC_CONST_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  if (1 == 1 << 2) {
    zval_addref_p(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr);
  } else {

  }
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  is_equal_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, tmp);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *expr_ptr ;
  zval **expr_ptr_ptr ;
  long tmp ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_uint tmp___1 ;
  zend_bool tmp___2 ;
  zval *new_expr ;
  void __attribute__((__visibility__("default")))  *tmp___3 ;
  zval *new_expr___0 ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_bool tmp___5 ;
  zend_free_op free_op2 ;
  zval *offset ;
  zval *tmp___6 ;
  ulong hval ;
  long tmp___7 ;
  register char const   *tmp___8 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___9 ;

  {
  opline = execute_data->opline;
  if (1 == 1 << 2) {
    goto _L___0;
  } else {
    if (1 == 1 << 4) {
      _L___0: /* CIL Label */ 
      if (opline->extended_value) {
        expr_ptr_ptr = (zval **)((void *)0);
        if (1 == 1 << 2) {
          tmp = __builtin_expect((long )((unsigned int )expr_ptr_ptr == (unsigned int )((void *)0)), 0L);
          if (tmp) {
            zend_error_noreturn(1, "Cannot create references to/from string offsets");
          } else {

          }
        } else {

        }
        tmp___2 = zval_isref_p(*expr_ptr_ptr);
        if (tmp___2) {

        } else {
          while (1) {
            tmp___1 = zval_refcount_p(*expr_ptr_ptr);
            if (tmp___1 > 1U) {
              zval_delref_p(*expr_ptr_ptr);
              while (1) {
                tmp___0 = _emalloc(sizeof(zval_gc_info ));
                new_zv = (zval *)tmp___0;
                ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv->value = (*expr_ptr_ptr)->value;
                  new_zv->type = (*expr_ptr_ptr)->type;
                  break;
                }
                zval_set_refcount_p(new_zv, 1U);
                zval_unset_isref_p(new_zv);
                break;
              }
              *expr_ptr_ptr = new_zv;
              _zval_copy_ctor(new_zv);
            } else {

            }
            break;
          }
          zval_set_isref_p(*expr_ptr_ptr);
        }
        expr_ptr = *expr_ptr_ptr;
        zval_addref_p(expr_ptr);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      expr_ptr = opline->op1.zv;
      while (1) {
        tmp___4 = _emalloc(sizeof(zval_gc_info ));
        new_expr___0 = (zval *)tmp___4;
        ((zval_gc_info *)new_expr___0)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      while (1) {
        while (1) {
          new_expr___0->value = expr_ptr->value;
          new_expr___0->type = expr_ptr->type;
          break;
        }
        zval_set_refcount_p(new_expr___0, 1U);
        zval_unset_isref_p(new_expr___0);
        break;
      }
      expr_ptr = new_expr___0;
      _zval_copy_ctor(expr_ptr);
    }
  }
  if (1 << 2 != 1 << 3) {
    tmp___6 = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    offset = tmp___6;
    switch ((int )offset->type) {
    case 2: 
    tmp___7 = zend_dval_to_lval(offset->value.dval);
    hval = (unsigned long )tmp___7;
    goto num_index;
    case 1: 
    case 3: 
    hval = (unsigned long )offset->value.lval;
    num_index: 
    _zend_hash_index_update_or_next_insert(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, hval, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    case 6: 
    if (1 << 2 == 1) {
      hval = ((zend_literal *)offset)->hash_value;
    } else {
      while (1) {
        tmp___8 = (char const   *)offset->value.str.val;
        if ((int const   )*tmp___8 == 45) {
          tmp___8 ++;
        } else {

        }
        if ((int const   )*tmp___8 >= 48) {
          if ((int const   )*tmp___8 <= 57) {
            end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
            if ((int const   )*end != 0) {
              break;
            } else {
              if ((int const   )*tmp___8 == 48) {
                if (offset->value.str.len + 1 > 2) {
                  break;
                } else {
                  goto _L___1;
                }
              } else {
                _L___1: /* CIL Label */ 
                if (end - tmp___8 > 10) {
                  break;
                } else {
                  if (end - tmp___8 == 10) {
                    if ((int const   )*tmp___8 > 50) {
                      break;
                    } else {

                    }
                  } else {

                  }
                }
              }
            }
            hval = (unsigned long )((int const   )*tmp___8 - 48);
            while (1) {
              tmp___8 ++;
              if ((unsigned int )tmp___8 != (unsigned int )end) {
                if ((int const   )*tmp___8 >= 48) {
                  if ((int const   )*tmp___8 <= 57) {

                  } else {
                    break;
                  }
                } else {
                  break;
                }
              } else {
                break;
              }
              hval = hval * 10UL + (ulong )((int const   )*tmp___8 - 48);
            }
            if ((unsigned int )tmp___8 == (unsigned int )end) {
              if ((int )*(offset->value.str.val) == 45) {
                if (hval - 1UL > 2147483647UL) {
                  break;
                } else {

                }
                hval = (unsigned long )(- ((long )hval));
              } else {
                if (hval > 2147483647UL) {
                  break;
                } else {

                }
              }
              goto num_index;
            } else {

            }
          } else {

          }
        } else {

        }
        break;
      }
      if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
        if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
          hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
        } else {
          tmp___9 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___9;
        }
      } else {
        tmp___9 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
        hval = (unsigned long )tmp___9;
      }
    }
    _zend_hash_quick_add_or_update(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    case 0: 
    _zend_hash_add_or_update(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, "", sizeof(""), (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    default: 
    zend_error(1 << 1L, "Illegal offset type");
    i_zval_ptr_dtor(expr_ptr);
    break;
    }
    if (free_op2.var) {
      i_zval_ptr_dtor(free_op2.var);
    } else {

    }
  } else {
    _zend_hash_index_update_or_next_insert(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, 0UL, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1 << 2);
  }
  if (1 == 1 << 2) {
    goto _L___2;
  } else {
    if (1 == 1 << 4) {
      _L___2: /* CIL Label */ 
      if (opline->extended_value) {

      } else {

      }
    } else {

    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_ARRAY_SPEC_CONST_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  int tmp ;

  {
  opline = execute_data->opline;
  _array_init(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, 0U);
  if (1 == 1 << 3) {
    (execute_data->opline) ++;
    return (0);
  } else {
    tmp = ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_VAR_HANDLER(execute_data);
    return (tmp);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_UNSET_VAR_SPEC_CONST_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval tmp ;
  zval *varname ;
  HashTable *target_symbol_table ;
  zend_compiled_variable *cv ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  ulong hash_value ;
  ulong tmp___1 ;

  {
  opline = execute_data->opline;
  if (1 == 1 << 4) {
    if (1 << 2 == 1 << 3) {
      if (opline->extended_value & 8388608UL) {
        if (executor_globals.active_symbol_table) {
          cv = (executor_globals.active_op_array)->vars + opline->op1.var;
          zend_delete_variable(execute_data->prev_execute_data, executor_globals.active_symbol_table, cv->name, cv->name_len + 1, cv->hash_value);
          *(execute_data->CVs + opline->op1.var) = (zval **)((void *)0);
        } else {
          if (*(execute_data->CVs + opline->op1.var)) {
            i_zval_ptr_dtor(*(*(execute_data->CVs + opline->op1.var)));
            *(execute_data->CVs + opline->op1.var) = (zval **)((void *)0);
          } else {

          }
        }
        (execute_data->opline) ++;
        return (0);
      } else {

      }
    } else {

    }
  } else {

  }
  varname = opline->op1.zv;
  if (1 == 1 << 2) {
    zval_addref_p(varname);
  } else {
    if (1 == 1 << 4) {
      zval_addref_p(varname);
    } else {

    }
  }
  if (1 << 2 != 1 << 3) {
    if (1 << 2 == 1) {
      if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
        ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
      } else {
        tmp___0 = zend_fetch_class_by_name((char const   *)(opline->op2.zv)->value.str.val, (unsigned int )(opline->op2.zv)->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), 0);
        ce = (zend_class_entry *)tmp___0;
        while (1) {
          *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
          break;
        }
      }
    } else {
      ce = ((temp_variable *)((char *)execute_data->Ts + opline->op2.var))->class_entry;
    }
    zend_std_unset_static_property(ce, (char const   *)varname->value.str.val, varname->value.str.len, (struct _zend_literal  const  *)opline->op1.literal);
  } else {
    tmp___1 = zend_inline_hash_func((char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1));
    hash_value = tmp___1;
    target_symbol_table = zend_get_target_symbol_table((int )(opline->extended_value & 1879048192UL));
    zend_delete_variable(execute_data, target_symbol_table, (char const   *)varname->value.str.val, varname->value.str.len + 1, hash_value);
  }
  if (1 == 1 << 2) {
    i_zval_ptr_dtor(varname);
  } else {
    if (1 == 1 << 4) {
      i_zval_ptr_dtor(varname);
    } else {

    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ISSET_ISEMPTY_VAR_SPEC_CONST_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **value ;
  zend_bool isset ;
  zend_compiled_variable *cv ;
  int __attribute__((__visibility__("default")))  tmp ;
  HashTable *target_symbol_table ;
  zval tmp___0 ;
  zval *varname ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___1 ;
  zval __attribute__((__visibility__("default")))  **tmp___2 ;
  int __attribute__((__visibility__("default")))  tmp___3 ;
  zval *__z ;
  zval *__z___0 ;
  zval *__z___1 ;
  zval *__z___2 ;
  int tmp___4 ;

  {
  opline = execute_data->opline;
  isset = (zend_bool )1;
  if (1 == 1 << 4) {
    if (1 << 2 == 1 << 3) {
      if (opline->extended_value & 8388608UL) {
        if (*(execute_data->CVs + opline->op1.var)) {
          value = *(execute_data->CVs + opline->op1.var);
        } else {
          if (executor_globals.active_symbol_table) {
            cv = (executor_globals.active_op_array)->vars + opline->op1.var;
            tmp = zend_hash_quick_find((HashTable const   *)executor_globals.active_symbol_table, cv->name, (unsigned int )(cv->name_len + 1), cv->hash_value, (void **)(& value));
            if (tmp == (int __attribute__((__visibility__("default")))  )-1) {
              isset = (unsigned char)0;
            } else {

            }
          } else {
            isset = (unsigned char)0;
          }
        }
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    _L: /* CIL Label */ 
    varname = opline->op1.zv;
    if (1 << 2 != 1 << 3) {
      if (1 << 2 == 1) {
        if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
          ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
        } else {
          tmp___1 = zend_fetch_class_by_name((char const   *)(opline->op2.zv)->value.str.val, (unsigned int )(opline->op2.zv)->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), 0);
          ce = (zend_class_entry *)tmp___1;
          while (1) {
            *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
            break;
          }
        }
      } else {
        ce = ((temp_variable *)((char *)execute_data->Ts + opline->op2.var))->class_entry;
      }
      tmp___2 = zend_std_get_static_property(ce, (char const   *)varname->value.str.val, varname->value.str.len, (unsigned char)1, (struct _zend_literal  const  *)opline->op1.literal);
      value = (zval **)tmp___2;
      if (! value) {
        isset = (unsigned char)0;
      } else {

      }
    } else {
      target_symbol_table = zend_get_target_symbol_table((int )(opline->extended_value & 1879048192UL));
      tmp___3 = zend_hash_find((HashTable const   *)target_symbol_table, (char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1), (void **)(& value));
      if (tmp___3 == (int __attribute__((__visibility__("default")))  )-1) {
        isset = (unsigned char)0;
      } else {

      }
    }
  }
  if (opline->extended_value & 33554432UL) {
    if (isset) {
      if ((int )(*value)->type != 0) {
        while (1) {
          __z = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
          __z->value.lval = 1L;
          __z->type = (unsigned char)3;
          break;
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      while (1) {
        __z___0 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
        __z___0->value.lval = 0L;
        __z___0->type = (unsigned char)3;
        break;
      }
    }
  } else {
    if (! isset) {
      goto _L___2;
    } else {
      tmp___4 = i_zend_is_true(*value);
      if (tmp___4) {
        while (1) {
          __z___2 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
          __z___2->value.lval = 0L;
          __z___2->type = (unsigned char)3;
          break;
        }
      } else {
        _L___2: /* CIL Label */ 
        while (1) {
          __z___1 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
          __z___1->value.lval = 1L;
          __z___1->type = (unsigned char)3;
          break;
        }
      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_fetch_var_address_helper_SPEC_CONST_UNUSED)(int type , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *varname ;
  zval **retval ;
  zval tmp_varname ;
  HashTable *target_symbol_table ;
  ulong hash_value ;
  long tmp ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  zval __attribute__((__visibility__("default")))  **tmp___1 ;
  ulong __attribute__((__visibility__("default")))  tmp___2 ;
  int __attribute__((__visibility__("default")))  tmp___3 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_uint tmp___5 ;
  zend_bool tmp___6 ;
  temp_variable *__t ;
  zend_free_op free_res ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___7 ;
  zend_uint tmp___8 ;
  zend_bool tmp___9 ;

  {
  opline = execute_data->opline;
  varname = opline->op1.zv;
  if (1 << 3 != 1 << 3) {
    if (1 << 3 == 1) {
      if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
        ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
      } else {
        tmp___0 = zend_fetch_class_by_name((char const   *)(opline->op2.zv)->value.str.val, (unsigned int )(opline->op2.zv)->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), 0);
        ce = (zend_class_entry *)tmp___0;
        while (1) {
          *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
          break;
        }
      }
    } else {
      ce = ((temp_variable *)((char *)execute_data->Ts + opline->op2.var))->class_entry;
    }
    tmp___1 = zend_std_get_static_property(ce, (char const   *)varname->value.str.val, varname->value.str.len, (unsigned char)0, (struct _zend_literal  const  *)opline->op1.literal);
    retval = (zval **)tmp___1;
  } else {
    target_symbol_table = zend_get_target_symbol_table((int )(opline->extended_value & 1879048192UL));
    hash_value = ((zend_literal *)varname)->hash_value;
    tmp___3 = zend_hash_quick_find((HashTable const   *)target_symbol_table, (char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1), hash_value, (void **)(& retval));
    if (tmp___3 == (int __attribute__((__visibility__("default")))  )-1) {
      switch (type) {
      case 0: 
      case 6: 
      zend_error(1 << 3L, "Undefined variable: %s", varname->value.str.val);
      case 3: 
      retval = & executor_globals.uninitialized_zval_ptr;
      break;
      case 2: 
      zend_error(1 << 3L, "Undefined variable: %s", varname->value.str.val);
      case 1: 
      zval_addref_p(& executor_globals.uninitialized_zval);
      _zend_hash_quick_add_or_update(target_symbol_table, (char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1), hash_value, (void *)(& executor_globals.uninitialized_zval_ptr), sizeof(zval *), (void **)(& retval), 1);
      break;
      }
    } else {

    }
    switch ((int )(opline->extended_value & 1879048192UL)) {
    case 0x00000000: 
    if (1 != 1 << 1) {

    } else {

    }
    break;
    case 0x10000000: 
    break;
    case 0x20000000: 
    zval_update_constant(retval, (void *)1);
    break;
    case 0x40000000: 
    if (1 == 1 << 2) {
      if (! free_op1.var) {
        zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr));
      } else {

      }
    } else {

    }
    break;
    }
  }
  if (opline->extended_value & 67108864UL) {
    tmp___6 = zval_isref_p(*retval);
    if (tmp___6) {

    } else {
      while (1) {
        tmp___5 = zval_refcount_p(*retval);
        if (tmp___5 > 1U) {
          zval_delref_p(*retval);
          while (1) {
            tmp___4 = _emalloc(sizeof(zval_gc_info ));
            new_zv = (zval *)tmp___4;
            ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv->value = (*retval)->value;
              new_zv->type = (*retval)->type;
              break;
            }
            zval_set_refcount_p(new_zv, 1U);
            zval_unset_isref_p(new_zv);
            break;
          }
          *retval = new_zv;
          _zval_copy_ctor(new_zv);
        } else {

        }
        break;
      }
      zval_set_isref_p(*retval);
    }
  } else {

  }
  zval_addref_p(*retval);
  switch (type) {
  case 0: 
  case 3: 
  while (1) {
    __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
    __t->var.ptr = *retval;
    __t->var.ptr_ptr = & __t->var.ptr;
    break;
  }
  break;
  case 6: 
  zend_pzval_unlock_func(*retval, & free_res, 1);
  if ((unsigned int )retval != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
    tmp___9 = zval_isref_p(*retval);
    if (tmp___9) {

    } else {
      while (1) {
        tmp___8 = zval_refcount_p(*retval);
        if (tmp___8 > 1U) {
          zval_delref_p(*retval);
          while (1) {
            tmp___7 = _emalloc(sizeof(zval_gc_info ));
            new_zv___0 = (zval *)tmp___7;
            ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv___0->value = (*retval)->value;
              new_zv___0->type = (*retval)->type;
              break;
            }
            zval_set_refcount_p(new_zv___0, 1U);
            zval_unset_isref_p(new_zv___0);
            break;
          }
          *retval = new_zv___0;
          _zval_copy_ctor(new_zv___0);
        } else {

        }
        break;
      }
    }
  } else {

  }
  zval_addref_p(*retval);
  if (free_res.var) {
    i_zval_ptr_dtor(free_res.var);
  } else {

  }
  default: 
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = retval;
  break;
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_R_SPEC_CONST_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_CONST_UNUSED(0, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_W_SPEC_CONST_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_CONST_UNUSED(1, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_RW_SPEC_CONST_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_CONST_UNUSED(2, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_FUNC_ARG_SPEC_CONST_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  unsigned int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
  opline = execute_data->opline;
  if (execute_data->fbc) {
    if ((execute_data->fbc)->common.arg_info) {
      if ((opline->extended_value & 1048575UL) <= (unsigned long )(execute_data->fbc)->common.num_args) {
        tmp___1 = (unsigned int )((int )((execute_data->fbc)->common.arg_info + ((opline->extended_value & 1048575UL) - 1UL))->pass_by_reference & 3);
      } else {
        tmp___1 = (execute_data->fbc)->common.fn_flags & 50331648U;
      }
    } else {
      tmp___1 = (execute_data->fbc)->common.fn_flags & 50331648U;
    }
    if (tmp___1) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___2 = zend_fetch_var_address_helper_SPEC_CONST_UNUSED(tmp___0, execute_data);
  return (tmp___2);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_UNSET_SPEC_CONST_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_CONST_UNUSED(6, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_IS_SPEC_CONST_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_CONST_UNUSED(3, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *function_name ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  char *function_name_strval ;
  int function_name_strlen ;
  long tmp___1 ;
  zend_literal *tmp___2 ;
  union _zend_function  __attribute__((__visibility__("default"))) *tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___7 ;
  zend_function *tmp___8 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___9 ;
  zend_bool __attribute__((__visibility__("default")))  tmp___10 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___11 ;
  zval *tmp___12 ;

  {
  opline = execute_data->opline;
  zend_ptr_stack_3_push(& executor_globals.arg_types_stack, (void *)execute_data->fbc, (void *)execute_data->object, (void *)execute_data->called_scope);
  if (*((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot)) {
    ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot);
  } else {
    tmp = zend_fetch_class_by_name((char const   *)(opline->op1.zv)->value.str.val, (unsigned int )(opline->op1.zv)->value.str.len, (zend_literal const   *)(opline->op1.literal + 1), (int )opline->extended_value);
    ce = (zend_class_entry *)tmp;
    tmp___0 = __builtin_expect((long )((unsigned int )ce == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Class \'%s\' not found", (opline->op1.zv)->value.str.val);
    } else {

    }
    while (1) {
      *((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot) = (void *)ce;
      break;
    }
  }
  execute_data->called_scope = ce;
  if (1 << 3 == 1) {
    if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
      execute_data->fbc = (zend_function *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if (1 << 3 != 1 << 3) {
      function_name_strval = (char *)((void *)0);
      function_name_strlen = 0;
      if (1 << 3 == 1) {
        function_name_strval = (opline->op2.zv)->value.str.val;
        function_name_strlen = (opline->op2.zv)->value.str.len;
      } else {
        function_name = (zval *)((void *)0);
        tmp___1 = __builtin_expect((long )((int )function_name->type != 6), 0L);
        if (tmp___1) {
          zend_error_noreturn(1, "Function name must be a string");
        } else {
          function_name_strval = function_name->value.str.val;
          function_name_strlen = function_name->value.str.len;
        }
      }
      if (function_name_strval) {
        if (ce->get_static_method) {
          execute_data->fbc = (*(ce->get_static_method))(ce, function_name_strval, function_name_strlen);
        } else {
          if (1 << 3 == 1) {
            tmp___2 = opline->op2.literal + 1;
          } else {
            tmp___2 = (zend_literal *)((void *)0);
          }
          tmp___3 = zend_std_get_static_method(ce, (char const   *)function_name_strval, function_name_strlen, (struct _zend_literal  const  *)tmp___2);
          execute_data->fbc = (zend_function *)tmp___3;
        }
        tmp___4 = __builtin_expect((long )((unsigned int )execute_data->fbc == (unsigned int )((void *)0)), 0L);
        if (tmp___4) {
          zend_error_noreturn(1, "Call to undefined method %s::%s()", ce->name, function_name_strval);
        } else {

        }
        if (1 << 3 == 1) {
          tmp___5 = __builtin_expect((long )(((execute_data->fbc)->common.fn_flags & 6291456U) == 0U), 1L);
          if (tmp___5) {
            while (1) {
              *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)execute_data->fbc;
              break;
            }
          } else {

          }
        } else {

        }
      } else {

      }
      if (1 << 3 != 1) {

      } else {

      }
    } else {
      tmp___6 = __builtin_expect((long )((unsigned int )ce->constructor == (unsigned int )((void *)0)), 0L);
      if (tmp___6) {
        zend_error_noreturn(1, "Cannot call constructor");
      } else {

      }
      if (executor_globals.This) {
        tmp___7 = zend_get_class_entry((zval const   *)executor_globals.This);
        if ((unsigned int )tmp___7 != (unsigned int )(ce->constructor)->common.scope) {
          if ((ce->constructor)->common.fn_flags & 1024U) {
            zend_error_noreturn(1, "Cannot call private %s::__construct()", ce->name);
          } else {

          }
        } else {

        }
      } else {

      }
      execute_data->fbc = ce->constructor;
    }
  }
  if ((execute_data->fbc)->common.fn_flags & 1U) {
    execute_data->object = (zval *)((void *)0);
  } else {
    if (executor_globals.This) {
      if (((executor_globals.This)->value.obj.handlers)->get_class_entry) {
        tmp___9 = zend_get_class_entry((zval const   *)executor_globals.This);
        tmp___10 = instanceof_function((zend_class_entry const   *)tmp___9, (zend_class_entry const   *)ce);
        if (tmp___10) {

        } else {
          if ((execute_data->fbc)->common.fn_flags & 65536U) {
            zend_error(1 << 11L, "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", ((execute_data->fbc)->common.scope)->name, (execute_data->fbc)->common.function_name);
          } else {
            zend_error_noreturn(1, "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", ((execute_data->fbc)->common.scope)->name, (execute_data->fbc)->common.function_name);
          }
        }
      } else {

      }
    } else {

    }
    tmp___12 = executor_globals.This;
    execute_data->object = tmp___12;
    if (tmp___12) {
      zval_addref_p(execute_data->object);
      tmp___11 = zend_get_class_entry((zval const   *)execute_data->object);
      execute_data->called_scope = (zend_class_entry *)tmp___11;
    } else {

    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *expr_ptr ;
  zval **expr_ptr_ptr ;
  long tmp ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_uint tmp___1 ;
  zend_bool tmp___2 ;
  zval *new_expr ;
  void __attribute__((__visibility__("default")))  *tmp___3 ;
  zval *new_expr___0 ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_bool tmp___5 ;
  zval *offset ;
  ulong hval ;
  long tmp___6 ;
  register char const   *tmp___7 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___8 ;

  {
  opline = execute_data->opline;
  if (1 == 1 << 2) {
    goto _L___0;
  } else {
    if (1 == 1 << 4) {
      _L___0: /* CIL Label */ 
      if (opline->extended_value) {
        expr_ptr_ptr = (zval **)((void *)0);
        if (1 == 1 << 2) {
          tmp = __builtin_expect((long )((unsigned int )expr_ptr_ptr == (unsigned int )((void *)0)), 0L);
          if (tmp) {
            zend_error_noreturn(1, "Cannot create references to/from string offsets");
          } else {

          }
        } else {

        }
        tmp___2 = zval_isref_p(*expr_ptr_ptr);
        if (tmp___2) {

        } else {
          while (1) {
            tmp___1 = zval_refcount_p(*expr_ptr_ptr);
            if (tmp___1 > 1U) {
              zval_delref_p(*expr_ptr_ptr);
              while (1) {
                tmp___0 = _emalloc(sizeof(zval_gc_info ));
                new_zv = (zval *)tmp___0;
                ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv->value = (*expr_ptr_ptr)->value;
                  new_zv->type = (*expr_ptr_ptr)->type;
                  break;
                }
                zval_set_refcount_p(new_zv, 1U);
                zval_unset_isref_p(new_zv);
                break;
              }
              *expr_ptr_ptr = new_zv;
              _zval_copy_ctor(new_zv);
            } else {

            }
            break;
          }
          zval_set_isref_p(*expr_ptr_ptr);
        }
        expr_ptr = *expr_ptr_ptr;
        zval_addref_p(expr_ptr);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      expr_ptr = opline->op1.zv;
      while (1) {
        tmp___4 = _emalloc(sizeof(zval_gc_info ));
        new_expr___0 = (zval *)tmp___4;
        ((zval_gc_info *)new_expr___0)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      while (1) {
        while (1) {
          new_expr___0->value = expr_ptr->value;
          new_expr___0->type = expr_ptr->type;
          break;
        }
        zval_set_refcount_p(new_expr___0, 1U);
        zval_unset_isref_p(new_expr___0);
        break;
      }
      expr_ptr = new_expr___0;
      _zval_copy_ctor(expr_ptr);
    }
  }
  if (1 << 3 != 1 << 3) {
    offset = (zval *)((void *)0);
    switch ((int )offset->type) {
    case 2: 
    tmp___6 = zend_dval_to_lval(offset->value.dval);
    hval = (unsigned long )tmp___6;
    goto num_index;
    case 1: 
    case 3: 
    hval = (unsigned long )offset->value.lval;
    num_index: 
    _zend_hash_index_update_or_next_insert(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, hval, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    case 6: 
    if (1 << 3 == 1) {
      hval = ((zend_literal *)offset)->hash_value;
    } else {
      while (1) {
        tmp___7 = (char const   *)offset->value.str.val;
        if ((int const   )*tmp___7 == 45) {
          tmp___7 ++;
        } else {

        }
        if ((int const   )*tmp___7 >= 48) {
          if ((int const   )*tmp___7 <= 57) {
            end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
            if ((int const   )*end != 0) {
              break;
            } else {
              if ((int const   )*tmp___7 == 48) {
                if (offset->value.str.len + 1 > 2) {
                  break;
                } else {
                  goto _L___1;
                }
              } else {
                _L___1: /* CIL Label */ 
                if (end - tmp___7 > 10) {
                  break;
                } else {
                  if (end - tmp___7 == 10) {
                    if ((int const   )*tmp___7 > 50) {
                      break;
                    } else {

                    }
                  } else {

                  }
                }
              }
            }
            hval = (unsigned long )((int const   )*tmp___7 - 48);
            while (1) {
              tmp___7 ++;
              if ((unsigned int )tmp___7 != (unsigned int )end) {
                if ((int const   )*tmp___7 >= 48) {
                  if ((int const   )*tmp___7 <= 57) {

                  } else {
                    break;
                  }
                } else {
                  break;
                }
              } else {
                break;
              }
              hval = hval * 10UL + (ulong )((int const   )*tmp___7 - 48);
            }
            if ((unsigned int )tmp___7 == (unsigned int )end) {
              if ((int )*(offset->value.str.val) == 45) {
                if (hval - 1UL > 2147483647UL) {
                  break;
                } else {

                }
                hval = (unsigned long )(- ((long )hval));
              } else {
                if (hval > 2147483647UL) {
                  break;
                } else {

                }
              }
              goto num_index;
            } else {

            }
          } else {

          }
        } else {

        }
        break;
      }
      if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
        if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
          hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
        } else {
          tmp___8 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___8;
        }
      } else {
        tmp___8 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
        hval = (unsigned long )tmp___8;
      }
    }
    _zend_hash_quick_add_or_update(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    case 0: 
    _zend_hash_add_or_update(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, "", sizeof(""), (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    default: 
    zend_error(1 << 1L, "Illegal offset type");
    i_zval_ptr_dtor(expr_ptr);
    break;
    }
  } else {
    _zend_hash_index_update_or_next_insert(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, 0UL, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1 << 2);
  }
  if (1 == 1 << 2) {
    goto _L___2;
  } else {
    if (1 == 1 << 4) {
      _L___2: /* CIL Label */ 
      if (opline->extended_value) {

      } else {

      }
    } else {

    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_ARRAY_SPEC_CONST_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  int tmp ;

  {
  opline = execute_data->opline;
  _array_init(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, 0U);
  if (1 == 1 << 3) {
    (execute_data->opline) ++;
    return (0);
  } else {
    tmp = ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_UNUSED_HANDLER(execute_data);
    return (tmp);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_UNSET_VAR_SPEC_CONST_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval tmp ;
  zval *varname ;
  HashTable *target_symbol_table ;
  zend_compiled_variable *cv ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  ulong hash_value ;
  ulong tmp___1 ;

  {
  opline = execute_data->opline;
  if (1 == 1 << 4) {
    if (1 << 3 == 1 << 3) {
      if (opline->extended_value & 8388608UL) {
        if (executor_globals.active_symbol_table) {
          cv = (executor_globals.active_op_array)->vars + opline->op1.var;
          zend_delete_variable(execute_data->prev_execute_data, executor_globals.active_symbol_table, cv->name, cv->name_len + 1, cv->hash_value);
          *(execute_data->CVs + opline->op1.var) = (zval **)((void *)0);
        } else {
          if (*(execute_data->CVs + opline->op1.var)) {
            i_zval_ptr_dtor(*(*(execute_data->CVs + opline->op1.var)));
            *(execute_data->CVs + opline->op1.var) = (zval **)((void *)0);
          } else {

          }
        }
        (execute_data->opline) ++;
        return (0);
      } else {

      }
    } else {

    }
  } else {

  }
  varname = opline->op1.zv;
  if (1 == 1 << 2) {
    zval_addref_p(varname);
  } else {
    if (1 == 1 << 4) {
      zval_addref_p(varname);
    } else {

    }
  }
  if (1 << 3 != 1 << 3) {
    if (1 << 3 == 1) {
      if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
        ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
      } else {
        tmp___0 = zend_fetch_class_by_name((char const   *)(opline->op2.zv)->value.str.val, (unsigned int )(opline->op2.zv)->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), 0);
        ce = (zend_class_entry *)tmp___0;
        while (1) {
          *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
          break;
        }
      }
    } else {
      ce = ((temp_variable *)((char *)execute_data->Ts + opline->op2.var))->class_entry;
    }
    zend_std_unset_static_property(ce, (char const   *)varname->value.str.val, varname->value.str.len, (struct _zend_literal  const  *)opline->op1.literal);
  } else {
    tmp___1 = zend_inline_hash_func((char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1));
    hash_value = tmp___1;
    target_symbol_table = zend_get_target_symbol_table((int )(opline->extended_value & 1879048192UL));
    zend_delete_variable(execute_data, target_symbol_table, (char const   *)varname->value.str.val, varname->value.str.len + 1, hash_value);
  }
  if (1 == 1 << 2) {
    i_zval_ptr_dtor(varname);
  } else {
    if (1 == 1 << 4) {
      i_zval_ptr_dtor(varname);
    } else {

    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ISSET_ISEMPTY_VAR_SPEC_CONST_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **value ;
  zend_bool isset ;
  zend_compiled_variable *cv ;
  int __attribute__((__visibility__("default")))  tmp ;
  HashTable *target_symbol_table ;
  zval tmp___0 ;
  zval *varname ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___1 ;
  zval __attribute__((__visibility__("default")))  **tmp___2 ;
  int __attribute__((__visibility__("default")))  tmp___3 ;
  zval *__z ;
  zval *__z___0 ;
  zval *__z___1 ;
  zval *__z___2 ;
  int tmp___4 ;

  {
  opline = execute_data->opline;
  isset = (zend_bool )1;
  if (1 == 1 << 4) {
    if (1 << 3 == 1 << 3) {
      if (opline->extended_value & 8388608UL) {
        if (*(execute_data->CVs + opline->op1.var)) {
          value = *(execute_data->CVs + opline->op1.var);
        } else {
          if (executor_globals.active_symbol_table) {
            cv = (executor_globals.active_op_array)->vars + opline->op1.var;
            tmp = zend_hash_quick_find((HashTable const   *)executor_globals.active_symbol_table, cv->name, (unsigned int )(cv->name_len + 1), cv->hash_value, (void **)(& value));
            if (tmp == (int __attribute__((__visibility__("default")))  )-1) {
              isset = (unsigned char)0;
            } else {

            }
          } else {
            isset = (unsigned char)0;
          }
        }
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    _L: /* CIL Label */ 
    varname = opline->op1.zv;
    if (1 << 3 != 1 << 3) {
      if (1 << 3 == 1) {
        if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
          ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
        } else {
          tmp___1 = zend_fetch_class_by_name((char const   *)(opline->op2.zv)->value.str.val, (unsigned int )(opline->op2.zv)->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), 0);
          ce = (zend_class_entry *)tmp___1;
          while (1) {
            *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
            break;
          }
        }
      } else {
        ce = ((temp_variable *)((char *)execute_data->Ts + opline->op2.var))->class_entry;
      }
      tmp___2 = zend_std_get_static_property(ce, (char const   *)varname->value.str.val, varname->value.str.len, (unsigned char)1, (struct _zend_literal  const  *)opline->op1.literal);
      value = (zval **)tmp___2;
      if (! value) {
        isset = (unsigned char)0;
      } else {

      }
    } else {
      target_symbol_table = zend_get_target_symbol_table((int )(opline->extended_value & 1879048192UL));
      tmp___3 = zend_hash_find((HashTable const   *)target_symbol_table, (char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1), (void **)(& value));
      if (tmp___3 == (int __attribute__((__visibility__("default")))  )-1) {
        isset = (unsigned char)0;
      } else {

      }
    }
  }
  if (opline->extended_value & 33554432UL) {
    if (isset) {
      if ((int )(*value)->type != 0) {
        while (1) {
          __z = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
          __z->value.lval = 1L;
          __z->type = (unsigned char)3;
          break;
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      while (1) {
        __z___0 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
        __z___0->value.lval = 0L;
        __z___0->type = (unsigned char)3;
        break;
      }
    }
  } else {
    if (! isset) {
      goto _L___2;
    } else {
      tmp___4 = i_zend_is_true(*value);
      if (tmp___4) {
        while (1) {
          __z___2 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
          __z___2->value.lval = 0L;
          __z___2->type = (unsigned char)3;
          break;
        }
      } else {
        _L___2: /* CIL Label */ 
        while (1) {
          __z___1 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
          __z___1->value.lval = 1L;
          __z___1->type = (unsigned char)3;
          break;
        }
      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_DECLARE_LAMBDA_FUNCTION_SPEC_CONST_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_function *op_array ;
  int __attribute__((__visibility__("default")))  tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  opline = execute_data->opline;
  tmp = zend_hash_quick_find((HashTable const   *)executor_globals.function_table, (char const   *)(opline->op1.zv)->value.str.val, (unsigned int )(opline->op1.zv)->value.str.len, ((zend_literal *)opline->op1.zv)->hash_value, (void **)((void *)(& op_array)));
  tmp___0 = __builtin_expect((long )(tmp == (int __attribute__((__visibility__("default")))  )-1), 0L);
  if (tmp___0) {
    zend_error_noreturn(1, "Base lambda function for closure not found");
  } else {
    tmp___1 = __builtin_expect((long )((int )op_array->type != 2), 0L);
    if (tmp___1) {
      zend_error_noreturn(1, "Base lambda function for closure not found");
    } else {

    }
  }
  zend_create_closure(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, op_array, executor_globals.scope, executor_globals.This);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_SPEC_CONST_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  fast_add_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, tmp);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SUB_SPEC_CONST_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  fast_sub_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, tmp);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_MUL_SPEC_CONST_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  fast_mul_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, tmp);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_DIV_SPEC_CONST_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  fast_div_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, tmp);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_MOD_SPEC_CONST_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  fast_mod_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, tmp);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SL_SPEC_CONST_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  shift_left_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, tmp);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SR_SPEC_CONST_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  shift_right_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, tmp);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_CONCAT_SPEC_CONST_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  concat_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, tmp);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_IDENTICAL_SPEC_CONST_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  is_identical_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, tmp);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_NOT_IDENTICAL_SPEC_CONST_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *result ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  is_identical_function(result, opline->op1.zv, tmp);
  result->value.lval = (long )(! result->value.lval);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_EQUAL_SPEC_CONST_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  int tmp___0 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
    tmp___0 = fast_equal_function(result, opline->op1.zv, tmp);
    __z->value.lval = (long )(tmp___0 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_NOT_EQUAL_SPEC_CONST_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  int tmp___0 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
    tmp___0 = fast_not_equal_function(result, opline->op1.zv, tmp);
    __z->value.lval = (long )(tmp___0 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_SMALLER_SPEC_CONST_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  int tmp___0 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
    tmp___0 = fast_is_smaller_function(result, opline->op1.zv, tmp);
    __z->value.lval = (long )(tmp___0 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  int tmp___0 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
    tmp___0 = fast_is_smaller_or_equal_function(result, opline->op1.zv, tmp);
    __z->value.lval = (long )(tmp___0 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_OR_SPEC_CONST_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  bitwise_or_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, tmp);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_AND_SPEC_CONST_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  bitwise_and_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, tmp);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_XOR_SPEC_CONST_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  bitwise_xor_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, tmp);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BOOL_XOR_SPEC_CONST_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  boolean_xor_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, tmp);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *function_name ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  char *function_name_strval ;
  int function_name_strlen ;
  long tmp___1 ;
  zend_literal *tmp___2 ;
  union _zend_function  __attribute__((__visibility__("default"))) *tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___7 ;
  zend_function *tmp___8 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___9 ;
  zend_bool __attribute__((__visibility__("default")))  tmp___10 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___11 ;
  zval *tmp___12 ;

  {
  opline = execute_data->opline;
  zend_ptr_stack_3_push(& executor_globals.arg_types_stack, (void *)execute_data->fbc, (void *)execute_data->object, (void *)execute_data->called_scope);
  if (*((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot)) {
    ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot);
  } else {
    tmp = zend_fetch_class_by_name((char const   *)(opline->op1.zv)->value.str.val, (unsigned int )(opline->op1.zv)->value.str.len, (zend_literal const   *)(opline->op1.literal + 1), (int )opline->extended_value);
    ce = (zend_class_entry *)tmp;
    tmp___0 = __builtin_expect((long )((unsigned int )ce == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Class \'%s\' not found", (opline->op1.zv)->value.str.val);
    } else {

    }
    while (1) {
      *((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot) = (void *)ce;
      break;
    }
  }
  execute_data->called_scope = ce;
  if (1 << 4 == 1) {
    if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
      execute_data->fbc = (zend_function *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if (1 << 4 != 1 << 3) {
      function_name_strval = (char *)((void *)0);
      function_name_strlen = 0;
      if (1 << 4 == 1) {
        function_name_strval = (opline->op2.zv)->value.str.val;
        function_name_strlen = (opline->op2.zv)->value.str.len;
      } else {
        function_name = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
        tmp___1 = __builtin_expect((long )((int )function_name->type != 6), 0L);
        if (tmp___1) {
          zend_error_noreturn(1, "Function name must be a string");
        } else {
          function_name_strval = function_name->value.str.val;
          function_name_strlen = function_name->value.str.len;
        }
      }
      if (function_name_strval) {
        if (ce->get_static_method) {
          execute_data->fbc = (*(ce->get_static_method))(ce, function_name_strval, function_name_strlen);
        } else {
          if (1 << 4 == 1) {
            tmp___2 = opline->op2.literal + 1;
          } else {
            tmp___2 = (zend_literal *)((void *)0);
          }
          tmp___3 = zend_std_get_static_method(ce, (char const   *)function_name_strval, function_name_strlen, (struct _zend_literal  const  *)tmp___2);
          execute_data->fbc = (zend_function *)tmp___3;
        }
        tmp___4 = __builtin_expect((long )((unsigned int )execute_data->fbc == (unsigned int )((void *)0)), 0L);
        if (tmp___4) {
          zend_error_noreturn(1, "Call to undefined method %s::%s()", ce->name, function_name_strval);
        } else {

        }
        if (1 << 4 == 1) {
          tmp___5 = __builtin_expect((long )(((execute_data->fbc)->common.fn_flags & 6291456U) == 0U), 1L);
          if (tmp___5) {
            while (1) {
              *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)execute_data->fbc;
              break;
            }
          } else {

          }
        } else {

        }
      } else {

      }
      if (1 << 4 != 1) {

      } else {

      }
    } else {
      tmp___6 = __builtin_expect((long )((unsigned int )ce->constructor == (unsigned int )((void *)0)), 0L);
      if (tmp___6) {
        zend_error_noreturn(1, "Cannot call constructor");
      } else {

      }
      if (executor_globals.This) {
        tmp___7 = zend_get_class_entry((zval const   *)executor_globals.This);
        if ((unsigned int )tmp___7 != (unsigned int )(ce->constructor)->common.scope) {
          if ((ce->constructor)->common.fn_flags & 1024U) {
            zend_error_noreturn(1, "Cannot call private %s::__construct()", ce->name);
          } else {

          }
        } else {

        }
      } else {

      }
      execute_data->fbc = ce->constructor;
    }
  }
  if ((execute_data->fbc)->common.fn_flags & 1U) {
    execute_data->object = (zval *)((void *)0);
  } else {
    if (executor_globals.This) {
      if (((executor_globals.This)->value.obj.handlers)->get_class_entry) {
        tmp___9 = zend_get_class_entry((zval const   *)executor_globals.This);
        tmp___10 = instanceof_function((zend_class_entry const   *)tmp___9, (zend_class_entry const   *)ce);
        if (tmp___10) {

        } else {
          if ((execute_data->fbc)->common.fn_flags & 65536U) {
            zend_error(1 << 11L, "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", ((execute_data->fbc)->common.scope)->name, (execute_data->fbc)->common.function_name);
          } else {
            zend_error_noreturn(1, "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", ((execute_data->fbc)->common.scope)->name, (execute_data->fbc)->common.function_name);
          }
        }
      } else {

      }
    } else {

    }
    tmp___12 = executor_globals.This;
    execute_data->object = tmp___12;
    if (tmp___12) {
      zval_addref_p(execute_data->object);
      tmp___11 = zend_get_class_entry((zval const   *)execute_data->object);
      execute_data->called_scope = (zend_class_entry *)tmp___11;
    } else {

    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_CATCH_SPEC_CONST_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_class_entry *ce ;
  zend_class_entry *catch_ce ;
  zval *exception ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_bool __attribute__((__visibility__("default")))  tmp___1 ;
  zend_compiled_variable *cv ;
  long tmp___2 ;

  {
  opline = execute_data->opline;
  zend_exception_restore();
  if ((unsigned int )executor_globals.exception == (unsigned int )((void *)0)) {
    execute_data->opline = (execute_data->op_array)->opcodes + opline->extended_value;
    return (0);
  } else {

  }
  if (*((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot)) {
    catch_ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot);
  } else {
    tmp = zend_fetch_class_by_name((char const   *)(opline->op1.zv)->value.str.val, (unsigned int )(opline->op1.zv)->value.str.len, (zend_literal const   *)(opline->op1.literal + 1), 0x80);
    catch_ce = (zend_class_entry *)tmp;
    while (1) {
      *((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot) = (void *)catch_ce;
      break;
    }
  }
  tmp___0 = zend_get_class_entry((zval const   *)executor_globals.exception);
  ce = (zend_class_entry *)tmp___0;
  if ((unsigned int )ce != (unsigned int )catch_ce) {
    tmp___1 = instanceof_function((zend_class_entry const   *)ce, (zend_class_entry const   *)catch_ce);
    if (tmp___1) {

    } else {
      if (opline->result.num) {
        zend_throw_exception_internal((zval *)((void *)0));
        return (0);
      } else {

      }
      execute_data->opline = (execute_data->op_array)->opcodes + opline->extended_value;
      return (0);
    }
  } else {

  }
  exception = executor_globals.exception;
  if (! executor_globals.active_symbol_table) {
    if (*(execute_data->CVs + opline->op2.var)) {
      i_zval_ptr_dtor(*(*(execute_data->CVs + opline->op2.var)));
    } else {

    }
    *(execute_data->CVs + opline->op2.var) = (zval **)execute_data->CVs + ((zend_uint )(execute_data->op_array)->last_var + opline->op2.var);
    *(*(execute_data->CVs + opline->op2.var)) = executor_globals.exception;
  } else {
    cv = (executor_globals.active_op_array)->vars + opline->op2.var;
    _zend_hash_quick_add_or_update(executor_globals.active_symbol_table, cv->name, (unsigned int )(cv->name_len + 1), cv->hash_value, (void *)(& executor_globals.exception), sizeof(zval *), (void **)(execute_data->CVs + opline->op2.var), 1);
  }
  tmp___2 = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )exception), 0L);
  if (tmp___2) {
    zval_addref_p(executor_globals.exception);
    return (0);
  } else {
    executor_globals.exception = (zval *)((void *)0);
    (execute_data->opline) ++;
    return (0);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_CASE_SPEC_CONST_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  if (1 == 1 << 2) {
    zval_addref_p(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr);
  } else {

  }
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  is_equal_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, opline->op1.zv, tmp);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *expr_ptr ;
  zval **expr_ptr_ptr ;
  long tmp ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_uint tmp___1 ;
  zend_bool tmp___2 ;
  zval *new_expr ;
  void __attribute__((__visibility__("default")))  *tmp___3 ;
  zval *new_expr___0 ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_bool tmp___5 ;
  zval *offset ;
  zval *tmp___6 ;
  ulong hval ;
  long tmp___7 ;
  register char const   *tmp___8 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___9 ;

  {
  opline = execute_data->opline;
  if (1 == 1 << 2) {
    goto _L___0;
  } else {
    if (1 == 1 << 4) {
      _L___0: /* CIL Label */ 
      if (opline->extended_value) {
        expr_ptr_ptr = (zval **)((void *)0);
        if (1 == 1 << 2) {
          tmp = __builtin_expect((long )((unsigned int )expr_ptr_ptr == (unsigned int )((void *)0)), 0L);
          if (tmp) {
            zend_error_noreturn(1, "Cannot create references to/from string offsets");
          } else {

          }
        } else {

        }
        tmp___2 = zval_isref_p(*expr_ptr_ptr);
        if (tmp___2) {

        } else {
          while (1) {
            tmp___1 = zval_refcount_p(*expr_ptr_ptr);
            if (tmp___1 > 1U) {
              zval_delref_p(*expr_ptr_ptr);
              while (1) {
                tmp___0 = _emalloc(sizeof(zval_gc_info ));
                new_zv = (zval *)tmp___0;
                ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv->value = (*expr_ptr_ptr)->value;
                  new_zv->type = (*expr_ptr_ptr)->type;
                  break;
                }
                zval_set_refcount_p(new_zv, 1U);
                zval_unset_isref_p(new_zv);
                break;
              }
              *expr_ptr_ptr = new_zv;
              _zval_copy_ctor(new_zv);
            } else {

            }
            break;
          }
          zval_set_isref_p(*expr_ptr_ptr);
        }
        expr_ptr = *expr_ptr_ptr;
        zval_addref_p(expr_ptr);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      expr_ptr = opline->op1.zv;
      while (1) {
        tmp___4 = _emalloc(sizeof(zval_gc_info ));
        new_expr___0 = (zval *)tmp___4;
        ((zval_gc_info *)new_expr___0)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      while (1) {
        while (1) {
          new_expr___0->value = expr_ptr->value;
          new_expr___0->type = expr_ptr->type;
          break;
        }
        zval_set_refcount_p(new_expr___0, 1U);
        zval_unset_isref_p(new_expr___0);
        break;
      }
      expr_ptr = new_expr___0;
      _zval_copy_ctor(expr_ptr);
    }
  }
  if (1 << 4 != 1 << 3) {
    tmp___6 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
    offset = tmp___6;
    switch ((int )offset->type) {
    case 2: 
    tmp___7 = zend_dval_to_lval(offset->value.dval);
    hval = (unsigned long )tmp___7;
    goto num_index;
    case 1: 
    case 3: 
    hval = (unsigned long )offset->value.lval;
    num_index: 
    _zend_hash_index_update_or_next_insert(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, hval, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    case 6: 
    if (1 << 4 == 1) {
      hval = ((zend_literal *)offset)->hash_value;
    } else {
      while (1) {
        tmp___8 = (char const   *)offset->value.str.val;
        if ((int const   )*tmp___8 == 45) {
          tmp___8 ++;
        } else {

        }
        if ((int const   )*tmp___8 >= 48) {
          if ((int const   )*tmp___8 <= 57) {
            end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
            if ((int const   )*end != 0) {
              break;
            } else {
              if ((int const   )*tmp___8 == 48) {
                if (offset->value.str.len + 1 > 2) {
                  break;
                } else {
                  goto _L___1;
                }
              } else {
                _L___1: /* CIL Label */ 
                if (end - tmp___8 > 10) {
                  break;
                } else {
                  if (end - tmp___8 == 10) {
                    if ((int const   )*tmp___8 > 50) {
                      break;
                    } else {

                    }
                  } else {

                  }
                }
              }
            }
            hval = (unsigned long )((int const   )*tmp___8 - 48);
            while (1) {
              tmp___8 ++;
              if ((unsigned int )tmp___8 != (unsigned int )end) {
                if ((int const   )*tmp___8 >= 48) {
                  if ((int const   )*tmp___8 <= 57) {

                  } else {
                    break;
                  }
                } else {
                  break;
                }
              } else {
                break;
              }
              hval = hval * 10UL + (ulong )((int const   )*tmp___8 - 48);
            }
            if ((unsigned int )tmp___8 == (unsigned int )end) {
              if ((int )*(offset->value.str.val) == 45) {
                if (hval - 1UL > 2147483647UL) {
                  break;
                } else {

                }
                hval = (unsigned long )(- ((long )hval));
              } else {
                if (hval > 2147483647UL) {
                  break;
                } else {

                }
              }
              goto num_index;
            } else {

            }
          } else {

          }
        } else {

        }
        break;
      }
      if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
        if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
          hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
        } else {
          tmp___9 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___9;
        }
      } else {
        tmp___9 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
        hval = (unsigned long )tmp___9;
      }
    }
    _zend_hash_quick_add_or_update(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    case 0: 
    _zend_hash_add_or_update(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, "", sizeof(""), (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    default: 
    zend_error(1 << 1L, "Illegal offset type");
    i_zval_ptr_dtor(expr_ptr);
    break;
    }
  } else {
    _zend_hash_index_update_or_next_insert(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, 0UL, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1 << 2);
  }
  if (1 == 1 << 2) {
    goto _L___2;
  } else {
    if (1 == 1 << 4) {
      _L___2: /* CIL Label */ 
      if (opline->extended_value) {

      } else {

      }
    } else {

    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_ARRAY_SPEC_CONST_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  int tmp ;

  {
  opline = execute_data->opline;
  _array_init(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, 0U);
  if (1 == 1 << 3) {
    (execute_data->opline) ++;
    return (0);
  } else {
    tmp = ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CV_HANDLER(execute_data);
    return (tmp);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_NOT_SPEC_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  bitwise_not_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp);
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BOOL_NOT_SPEC_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  boolean_not_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp);
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ECHO_SPEC_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval z_copy ;
  zval *z ;
  int __attribute__((__visibility__("default")))  tmp ;
  long tmp___0 ;

  {
  opline = execute_data->opline;
  z = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 1 != 1) {
    tmp___0 = __builtin_expect((long )((int )z->type == 5), 0L);
    if (tmp___0) {
      if ((unsigned int )(z->value.obj.handlers)->get_method != (unsigned int )((void *)0)) {
        if (1 << 1 == 1 << 1) {
          z->refcount__gc = 1U;
          z->is_ref__gc = (unsigned char)0;
        } else {

        }
        tmp = zend_std_cast_object_tostring(z, & z_copy, 6);
        if (tmp == (int __attribute__((__visibility__("default")))  )0) {
          zend_print_variable(& z_copy);
          _zval_dtor(& z_copy);
        } else {
          zend_print_variable(z);
        }
      } else {
        zend_print_variable(z);
      }
    } else {
      zend_print_variable(z);
    }
  } else {
    zend_print_variable(z);
  }
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_PRINT_SPEC_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *__z ;
  int tmp ;

  {
  opline = execute_data->opline;
  __z = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  __z->value.lval = 1L;
  __z->type = (unsigned char)1;
  tmp = ZEND_ECHO_SPEC_TMP_HANDLER(execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_JMPZ_SPEC_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *val ;
  int ret ;
  long tmp ;
  long tmp___0 ;

  {
  opline = execute_data->opline;
  val = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 1 == 1 << 1) {
    tmp___0 = __builtin_expect((long )((int )val->type == 3), 1L);
    if (tmp___0) {
      ret = (int )val->value.lval;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    ret = i_zend_is_true(val);
    _zval_dtor(free_op1.var);
    tmp = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
    if (tmp) {
      return (0);
    } else {

    }
  }
  if (! ret) {
    execute_data->opline = opline->op2.jmp_addr;
    return (0);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_JMPNZ_SPEC_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *val ;
  int ret ;
  long tmp ;
  long tmp___0 ;

  {
  opline = execute_data->opline;
  val = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 1 == 1 << 1) {
    tmp___0 = __builtin_expect((long )((int )val->type == 3), 1L);
    if (tmp___0) {
      ret = (int )val->value.lval;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    ret = i_zend_is_true(val);
    _zval_dtor(free_op1.var);
    tmp = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
    if (tmp) {
      return (0);
    } else {

    }
  }
  if (ret) {
    execute_data->opline = opline->op2.jmp_addr;
    return (0);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_JMPZNZ_SPEC_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *val ;
  int retval ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  opline = execute_data->opline;
  val = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 1 == 1 << 1) {
    tmp___0 = __builtin_expect((long )((int )val->type == 3), 1L);
    if (tmp___0) {
      retval = (int )val->value.lval;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    retval = i_zend_is_true(val);
    _zval_dtor(free_op1.var);
    tmp = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
    if (tmp) {
      return (0);
    } else {

    }
  }
  tmp___1 = __builtin_expect((long )(retval != 0), 1L);
  if (tmp___1) {
    execute_data->opline = (execute_data->op_array)->opcodes + opline->extended_value;
    return (0);
  } else {
    execute_data->opline = (execute_data->op_array)->opcodes + opline->op2.opline_num;
    return (0);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_JMPZ_EX_SPEC_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *val ;
  int retval ;
  long tmp ;
  long tmp___0 ;

  {
  opline = execute_data->opline;
  val = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 1 == 1 << 1) {
    tmp___0 = __builtin_expect((long )((int )val->type == 3), 1L);
    if (tmp___0) {
      retval = (int )val->value.lval;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    retval = i_zend_is_true(val);
    _zval_dtor(free_op1.var);
    tmp = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
    if (tmp) {
      return (0);
    } else {

    }
  }
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.lval = (long )retval;
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.type = (unsigned char)3;
  if (! retval) {
    execute_data->opline = opline->op2.jmp_addr;
    return (0);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_JMPNZ_EX_SPEC_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *val ;
  int retval ;
  long tmp ;
  long tmp___0 ;

  {
  opline = execute_data->opline;
  val = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 1 == 1 << 1) {
    tmp___0 = __builtin_expect((long )((int )val->type == 3), 1L);
    if (tmp___0) {
      retval = (int )val->value.lval;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    retval = i_zend_is_true(val);
    _zval_dtor(free_op1.var);
    tmp = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
    if (tmp) {
      return (0);
    } else {

    }
  }
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.lval = (long )retval;
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.type = (unsigned char)3;
  if (retval) {
    execute_data->opline = opline->op2.jmp_addr;
    return (0);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FREE_SPEC_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;

  {
  opline = execute_data->opline;
  if (1 << 1 == 1 << 1) {
    _zval_dtor(& ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->tmp_var);
  } else {
    i_zval_ptr_dtor(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr);
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_RETURN_SPEC_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *retval_ptr ;
  zend_free_op free_op1 ;
  zval *ret ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zval *ret___0 ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_bool tmp___1 ;
  zend_uint tmp___2 ;
  zval *ret___1 ;
  void __attribute__((__visibility__("default")))  *tmp___3 ;
  int tmp___4 ;

  {
  opline = execute_data->opline;
  retval_ptr = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (! executor_globals.return_value_ptr_ptr) {
    if (1 << 1 == 1 << 1) {
      _zval_dtor(free_op1.var);
    } else {

    }
  } else {
    if (0) {
      if (1 << 1 == 1) {
        goto _L___0;
      } else {
        tmp___1 = zval_isref_p(retval_ptr);
        if (tmp___1) {
          tmp___2 = zval_refcount_p(retval_ptr);
          if (tmp___2 > 0U) {
            _L___0: /* CIL Label */ 
            while (1) {
              tmp = _emalloc(sizeof(zval_gc_info ));
              ret = (zval *)tmp;
              ((zval_gc_info *)ret)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                ret->value = retval_ptr->value;
                ret->type = retval_ptr->type;
                break;
              }
              zval_set_refcount_p(ret, 1U);
              zval_unset_isref_p(ret);
              break;
            }
            _zval_copy_ctor(ret);
            *(executor_globals.return_value_ptr_ptr) = ret;
          } else {
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
          if (1 << 1 == 1 << 4) {
            goto _L;
          } else {
            if (1 << 1 == 1 << 2) {
              _L: /* CIL Label */ 
              if ((unsigned int )retval_ptr == (unsigned int )(& executor_globals.uninitialized_zval)) {
                while (1) {
                  tmp___0 = _emalloc(sizeof(zval_gc_info ));
                  ret___0 = (zval *)tmp___0;
                  ((zval_gc_info *)ret___0)->u.buffered = (gc_root_buffer *)((void *)0);
                  break;
                }
                *ret___0 = (struct _zval_struct )zval_used_for_init;
                *(executor_globals.return_value_ptr_ptr) = ret___0;
              } else {
                *(executor_globals.return_value_ptr_ptr) = retval_ptr;
                zval_addref_p(retval_ptr);
              }
            } else {
              *(executor_globals.return_value_ptr_ptr) = retval_ptr;
              zval_addref_p(retval_ptr);
            }
          }
        }
      }
    } else {
      while (1) {
        tmp___3 = _emalloc(sizeof(zval_gc_info ));
        ret___1 = (zval *)tmp___3;
        ((zval_gc_info *)ret___1)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      while (1) {
        while (1) {
          ret___1->value = retval_ptr->value;
          ret___1->type = retval_ptr->type;
          break;
        }
        zval_set_refcount_p(ret___1, 1U);
        zval_unset_isref_p(ret___1);
        break;
      }
      *(executor_globals.return_value_ptr_ptr) = ret___1;
    }
  }
  tmp___4 = zend_leave_helper_SPEC(execute_data);
  return (tmp___4);
}
}
static int ( __attribute__((__fastcall__)) ZEND_RETURN_BY_REF_SPEC_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *retval_ptr ;
  zval **retval_ptr_ptr ;
  zend_free_op free_op1 ;
  zval *ret ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zval *ret___0 ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  long tmp___1 ;
  zend_bool tmp___2 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___3 ;
  zend_uint tmp___4 ;
  zend_bool tmp___5 ;
  int tmp___6 ;

  {
  opline = execute_data->opline;
  while (1) {
    if (1 << 1 == 1) {
      goto _L;
    } else {
      if (1 << 1 == 1 << 1) {
        _L: /* CIL Label */ 
        zend_error(1 << 3L, "Only variable references should be returned by reference");
        retval_ptr = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
        if (! executor_globals.return_value_ptr_ptr) {
          if (1 << 1 == 1 << 1) {
            _zval_dtor(free_op1.var);
          } else {

          }
        } else {
          while (1) {
            tmp___0 = _emalloc(sizeof(zval_gc_info ));
            ret___0 = (zval *)tmp___0;
            ((zval_gc_info *)ret___0)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              ret___0->value = retval_ptr->value;
              ret___0->type = retval_ptr->type;
              break;
            }
            zval_set_refcount_p(ret___0, 1U);
            zval_unset_isref_p(ret___0);
            break;
          }
          *(executor_globals.return_value_ptr_ptr) = ret___0;
        }
        break;
      } else {

      }
    }
    retval_ptr_ptr = (zval **)((void *)0);
    if (1 << 1 == 1 << 2) {
      tmp___1 = __builtin_expect((long )((unsigned int )retval_ptr_ptr == (unsigned int )((void *)0)), 0L);
      if (tmp___1) {
        zend_error_noreturn(1, "Cannot return string offsets by reference");
      } else {

      }
    } else {

    }
    if (1 << 1 == 1 << 2) {
      tmp___2 = zval_isref_p(*retval_ptr_ptr);
      if (tmp___2) {

      } else {
        if (opline->extended_value == 1UL) {
          if (((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.fcall_returned_reference) {

          } else {
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
          if ((unsigned int )((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr == (unsigned int )(& ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr)) {
            zend_error(1 << 3L, "Only variable references should be returned by reference");
            if (executor_globals.return_value_ptr_ptr) {
              retval_ptr = *retval_ptr_ptr;
              *(executor_globals.return_value_ptr_ptr) = retval_ptr;
              zval_addref_p(retval_ptr);
            } else {

            }
            break;
          } else {

          }
        }
      }
    } else {

    }
    if (executor_globals.return_value_ptr_ptr) {
      tmp___5 = zval_isref_p(*retval_ptr_ptr);
      if (tmp___5) {

      } else {
        while (1) {
          tmp___4 = zval_refcount_p(*retval_ptr_ptr);
          if (tmp___4 > 1U) {
            zval_delref_p(*retval_ptr_ptr);
            while (1) {
              tmp___3 = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp___3;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*retval_ptr_ptr)->value;
                new_zv->type = (*retval_ptr_ptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *retval_ptr_ptr = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
        zval_set_isref_p(*retval_ptr_ptr);
      }
      zval_addref_p(*retval_ptr_ptr);
      *(executor_globals.return_value_ptr_ptr) = *retval_ptr_ptr;
    } else {

    }
    break;
  }
  tmp___6 = zend_leave_helper_SPEC(execute_data);
  return (tmp___6);
}
}
static int ( __attribute__((__fastcall__)) ZEND_THROW_SPEC_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *value ;
  zval *exception ;
  zend_free_op free_op1 ;
  long tmp ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;

  {
  opline = execute_data->opline;
  value = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 1 == 1) {
    zend_error_noreturn(1, "Can only throw objects");
  } else {
    tmp = __builtin_expect((long )((int )value->type != 5), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Can only throw objects");
    } else {

    }
  }
  zend_exception_save();
  while (1) {
    tmp___0 = _emalloc(sizeof(zval_gc_info ));
    exception = (zval *)tmp___0;
    ((zval_gc_info *)exception)->u.buffered = (gc_root_buffer *)((void *)0);
    break;
  }
  while (1) {
    while (1) {
      exception->value = value->value;
      exception->type = value->type;
      break;
    }
    zval_set_refcount_p(exception, 1U);
    zval_unset_isref_p(exception);
    break;
  }
  zend_throw_exception_object(exception);
  zend_exception_restore();
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SEND_VAL_SPEC_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  unsigned int tmp ;
  zval *valptr ;
  zval *value ;
  zend_free_op free_op1 ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;

  {
  opline = execute_data->opline;
  if (opline->extended_value == 61UL) {
    if (execute_data->fbc) {
      if ((execute_data->fbc)->common.arg_info) {
        if (opline->op2.opline_num <= (execute_data->fbc)->common.num_args) {
          tmp = (unsigned int )((int )((execute_data->fbc)->common.arg_info + (opline->op2.opline_num - 1U))->pass_by_reference & 1);
        } else {
          tmp = (execute_data->fbc)->common.fn_flags & 16777216U;
        }
      } else {
        tmp = (execute_data->fbc)->common.fn_flags & 16777216U;
      }
      if (tmp) {
        zend_error_noreturn(1, "Cannot pass parameter %d by reference", opline->op2.opline_num);
      } else {

      }
    } else {

    }
  } else {

  }
  value = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  while (1) {
    tmp___0 = _emalloc(sizeof(zval_gc_info ));
    valptr = (zval *)tmp___0;
    ((zval_gc_info *)valptr)->u.buffered = (gc_root_buffer *)((void *)0);
    break;
  }
  while (1) {
    while (1) {
      valptr->value = value->value;
      valptr->type = value->type;
      break;
    }
    zval_set_refcount_p(valptr, 1U);
    zval_unset_isref_p(valptr);
    break;
  }
  zend_vm_stack_push((void *)valptr);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BOOL_SPEC_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *retval ;
  zval *__z ;
  zval *tmp ;
  int tmp___0 ;

  {
  opline = execute_data->opline;
  retval = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = retval;
    tmp = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    tmp___0 = i_zend_is_true(tmp);
    __z->value.lval = (long )(tmp___0 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_CLONE_SPEC_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *obj ;
  zend_class_entry *ce ;
  zend_function *clone ;
  zend_object_value (*clone_call)(zval *object ) ;
  long tmp ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  long tmp___1 ;
  char const   *tmp___2 ;
  long tmp___3 ;
  char const   *tmp___4 ;
  int __attribute__((__visibility__("default")))  tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  zval *retval ;
  void __attribute__((__visibility__("default")))  *tmp___8 ;
  temp_variable *__t ;
  long tmp___9 ;
  long tmp___10 ;

  {
  opline = execute_data->opline;
  obj = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 1 == 1) {
    zend_error_noreturn(1, "__clone method called on non-object");
  } else {
    tmp = __builtin_expect((long )((int )obj->type != 5), 0L);
    if (tmp) {
      zend_error_noreturn(1, "__clone method called on non-object");
    } else {

    }
  }
  tmp___0 = zend_get_class_entry((zval const   *)obj);
  ce = (zend_class_entry *)tmp___0;
  if (ce) {
    clone = ce->clone;
  } else {
    clone = (zend_function *)((void *)0);
  }
  clone_call = (zend_object_value (*)(zval *object ))(obj->value.obj.handlers)->clone_obj;
  tmp___1 = __builtin_expect((long )((unsigned int )clone_call == (unsigned int )((void *)0)), 0L);
  if (tmp___1) {
    if (ce) {
      zend_error_noreturn(1, "Trying to clone an uncloneable object of class %s", ce->name);
    } else {
      zend_error_noreturn(1, "Trying to clone an uncloneable object");
    }
  } else {

  }
  if (ce) {
    if (clone) {
      if (clone->op_array.fn_flags & 1024U) {
        tmp___3 = __builtin_expect((long )((unsigned int )ce != (unsigned int )executor_globals.scope), 0L);
        if (tmp___3) {
          if (executor_globals.scope) {
            tmp___2 = (executor_globals.scope)->name;
          } else {
            tmp___2 = "";
          }
          zend_error_noreturn(1, "Call to private %s::__clone() from context \'%s\'", ce->name, tmp___2);
        } else {

        }
      } else {
        if (clone->common.fn_flags & 512U) {
          tmp___5 = zend_check_protected(clone->common.scope, executor_globals.scope);
          if (tmp___5) {
            tmp___6 = 0;
          } else {
            tmp___6 = 1;
          }
          tmp___7 = __builtin_expect((long )tmp___6, 0L);
          if (tmp___7) {
            if (executor_globals.scope) {
              tmp___4 = (executor_globals.scope)->name;
            } else {
              tmp___4 = "";
            }
            zend_error_noreturn(1, "Call to protected %s::__clone() from context \'%s\'", ce->name, tmp___4);
          } else {

          }
        } else {

        }
      }
    } else {

    }
  } else {

  }
  tmp___10 = __builtin_expect((long )((unsigned int )executor_globals.exception == (unsigned int )((void *)0)), 1L);
  if (tmp___10) {
    while (1) {
      tmp___8 = _emalloc(sizeof(zval_gc_info ));
      retval = (zval *)tmp___8;
      ((zval_gc_info *)retval)->u.buffered = (gc_root_buffer *)((void *)0);
      break;
    }
    retval->value.obj = (*clone_call)(obj);
    retval->type = (unsigned char)5;
    zval_set_refcount_p(retval, 1U);
    zval_set_isref_p(retval);
    if (! (! ((int )opline->result_type & (1 << 5)))) {
      i_zval_ptr_dtor(retval);
    } else {
      tmp___9 = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
      if (tmp___9) {
        i_zval_ptr_dtor(retval);
      } else {
        while (1) {
          __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
          __t->var.ptr = retval;
          __t->var.ptr_ptr = & __t->var.ptr;
          break;
        }
      }
    }
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_CAST_SPEC_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *expr ;
  zval *result ;
  zval var_copy ;
  int use_copy ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  expr = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (opline->extended_value != 6UL) {
    while (1) {
      result->value = expr->value;
      result->type = expr->type;
      break;
    }
  } else {

  }
  switch ((int )opline->extended_value) {
  case 0: 
  convert_to_null(result);
  break;
  case 3: 
  convert_to_boolean(result);
  break;
  case 1: 
  convert_to_long(result);
  break;
  case 2: 
  convert_to_double(result);
  break;
  case 6: 
  zend_make_printable_zval(expr, & var_copy, & use_copy);
  if (use_copy) {
    while (1) {
      result->value = var_copy.value;
      result->type = var_copy.type;
      break;
    }
    _zval_dtor(free_op1.var);
  } else {
    while (1) {
      result->value = expr->value;
      result->type = expr->type;
      break;
    }
  }
  break;
  case 4: 
  convert_to_array(result);
  break;
  case 5: 
  convert_to_object(result);
  break;
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INCLUDE_OR_EVAL_SPEC_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_op_array *new_op_array ;
  zend_free_op free_op1 ;
  zval *inc_filename ;
  zval tmp_inc_filename ;
  zend_bool failure_retval ;
  zend_file_handle file_handle ;
  char *resolved_path ;
  char __attribute__((__visibility__("default")))  *tmp ;
  size_t tmp___0 ;
  int __attribute__((__visibility__("default")))  tmp___1 ;
  char __attribute__((__visibility__("default")))  *tmp___2 ;
  int tmp___3 ;
  zend_op_array __attribute__((__visibility__("default")))  *tmp___4 ;
  size_t tmp___5 ;
  int __attribute__((__visibility__("default")))  tmp___6 ;
  int __attribute__((__visibility__("default")))  tmp___7 ;
  zend_op_array __attribute__((__visibility__("default")))  *tmp___8 ;
  char *eval_desc ;
  char __attribute__((__visibility__("default")))  *tmp___9 ;
  zend_op_array __attribute__((__visibility__("default")))  *tmp___10 ;
  size_t tmp___11 ;
  long tmp___12 ;
  zval *retval ;
  void __attribute__((__visibility__("default")))  *tmp___13 ;
  zval *__z ;
  long tmp___14 ;
  zval *retval___0 ;
  void __attribute__((__visibility__("default")))  *tmp___15 ;
  zval *__z___0 ;
  temp_variable *__t ;
  long tmp___16 ;
  long tmp___17 ;

  {
  opline = execute_data->opline;
  new_op_array = (zend_op_array *)((void *)0);
  failure_retval = (zend_bool )0;
  inc_filename = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if ((int )inc_filename->type != 6) {
    while (1) {
      tmp_inc_filename.value = inc_filename->value;
      tmp_inc_filename.type = inc_filename->type;
      break;
    }
    _zval_copy_ctor(& tmp_inc_filename);
    if ((int )tmp_inc_filename.type != 6) {
      _convert_to_string(& tmp_inc_filename);
    } else {

    }
    inc_filename = & tmp_inc_filename;
  } else {

  }
  if (opline->extended_value != 1UL) {
    tmp___11 = strlen((char const   *)inc_filename->value.str.val);
    if (tmp___11 != (size_t )inc_filename->value.str.len) {
      if (opline->extended_value == (ulong )(1 << 2)) {
        zend_message_dispatcher(1L, (void const   *)inc_filename->value.str.val);
      } else {
        if (opline->extended_value == (ulong )(1 << 1)) {
          zend_message_dispatcher(1L, (void const   *)inc_filename->value.str.val);
        } else {
          zend_message_dispatcher(2L, (void const   *)inc_filename->value.str.val);
        }
      }
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    switch ((int )opline->extended_value) {
    case 1 << 2: 
    case 1 << 4: 
    tmp = (*zend_resolve_path)((char const   *)inc_filename->value.str.val, inc_filename->value.str.len);
    resolved_path = (char *)tmp;
    if (resolved_path) {
      tmp___0 = strlen((char const   *)resolved_path);
      tmp___1 = zend_hash_exists((HashTable const   *)(& executor_globals.included_files), (char const   *)resolved_path, tmp___0 + 1U);
      failure_retval = (unsigned char )tmp___1;
    } else {
      resolved_path = inc_filename->value.str.val;
    }
    if (failure_retval) {

    } else {
      tmp___7 = zend_stream_open((char const   *)resolved_path, & file_handle);
      if (0 == (int )tmp___7) {
        if (! file_handle.opened_path) {
          tmp___2 = _estrdup((char const   *)resolved_path);
          file_handle.opened_path = (char *)tmp___2;
        } else {

        }
        tmp___5 = strlen((char const   *)file_handle.opened_path);
        tmp___6 = zend_hash_add_empty_element(& executor_globals.included_files, (char const   *)file_handle.opened_path, tmp___5 + 1U);
        if (tmp___6 == (int __attribute__((__visibility__("default")))  )0) {
          if (opline->extended_value == (ulong )(1 << 2)) {
            tmp___3 = 1 << 1;
          } else {
            tmp___3 = 1 << 3;
          }
          tmp___4 = (*zend_compile_file)(& file_handle, tmp___3);
          new_op_array = (zend_op_array *)tmp___4;
          zend_destroy_file_handle(& file_handle);
        } else {
          zend_file_handle_dtor(& file_handle);
          failure_retval = (unsigned char)1;
        }
      } else {
        if (opline->extended_value == (ulong )(1 << 2)) {
          zend_message_dispatcher(1L, (void const   *)inc_filename->value.str.val);
        } else {
          zend_message_dispatcher(2L, (void const   *)inc_filename->value.str.val);
        }
      }
    }
    if ((unsigned int )resolved_path != (unsigned int )inc_filename->value.str.val) {
      _efree((void *)resolved_path);
    } else {

    }
    break;
    case 1 << 1: 
    case 1 << 3: 
    tmp___8 = compile_filename((int )opline->extended_value, inc_filename);
    new_op_array = (zend_op_array *)tmp___8;
    break;
    case 1: 
    tmp___9 = zend_make_compiled_string_description("eval()\'d code");
    eval_desc = (char *)tmp___9;
    tmp___10 = (*zend_compile_string)(inc_filename, eval_desc);
    new_op_array = (zend_op_array *)tmp___10;
    _efree((void *)eval_desc);
    break;
    }
  }
  if ((unsigned int )inc_filename == (unsigned int )(& tmp_inc_filename)) {
    _zval_dtor(& tmp_inc_filename);
  } else {

  }
  _zval_dtor(free_op1.var);
  tmp___17 = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
  if (tmp___17) {
    return (0);
  } else {
    tmp___16 = __builtin_expect((long )((unsigned int )new_op_array != (unsigned int )((void *)0)), 1L);
    if (tmp___16) {
      execute_data->original_return_value = executor_globals.return_value_ptr_ptr;
      executor_globals.active_op_array = new_op_array;
      if (! ((int )opline->result_type & (1 << 5))) {
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = (zval *)((void *)0);
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
        executor_globals.return_value_ptr_ptr = ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr;
      } else {
        executor_globals.return_value_ptr_ptr = (zval **)((void *)0);
      }
      execute_data->current_object = execute_data->object;
      execute_data->function_state.function = (zend_function *)new_op_array;
      execute_data->object = (zval *)((void *)0);
      if (! executor_globals.active_symbol_table) {
        zend_rebuild_symbol_table();
      } else {

      }
      tmp___12 = __builtin_expect((long )((unsigned int )zend_execute == (unsigned int )(& execute)), 1L);
      if (tmp___12) {
        return (2);
      } else {
        (*zend_execute)(new_op_array);
      }
      execute_data->function_state.function = (zend_function *)execute_data->op_array;
      execute_data->object = execute_data->current_object;
      executor_globals.opline_ptr = & execute_data->opline;
      executor_globals.active_op_array = execute_data->op_array;
      executor_globals.return_value_ptr_ptr = execute_data->original_return_value;
      destroy_op_array(new_op_array);
      _efree((void *)new_op_array);
      tmp___14 = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
      if (tmp___14) {
        zend_throw_exception_internal((zval *)((void *)0));
        return (0);
      } else {
        if (! ((int )opline->result_type & (1 << 5))) {
          if (! ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr) {
            while (1) {
              tmp___13 = _emalloc(sizeof(zval_gc_info ));
              retval = (zval *)tmp___13;
              ((zval_gc_info *)retval)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              __z = retval;
              __z->value.lval = 1L;
              __z->type = (unsigned char)3;
              break;
            }
            retval->refcount__gc = 1U;
            retval->is_ref__gc = (unsigned char)0;
            ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = retval;
          } else {

          }
        } else {

        }
      }
    } else {
      if (! ((int )opline->result_type & (1 << 5))) {
        while (1) {
          tmp___15 = _emalloc(sizeof(zval_gc_info ));
          retval___0 = (zval *)tmp___15;
          ((zval_gc_info *)retval___0)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          __z___0 = retval___0;
          __z___0->value.lval = (long )((int )failure_retval != 0);
          __z___0->type = (unsigned char)3;
          break;
        }
        retval___0->refcount__gc = 1U;
        retval___0->is_ref__gc = (unsigned char)0;
        while (1) {
          __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
          __t->var.ptr = retval___0;
          __t->var.ptr_ptr = & __t->var.ptr;
          break;
        }
      } else {

      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FE_RESET_SPEC_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *array_ptr ;
  zval **array_ptr_ptr ;
  HashTable *fe_ht ;
  zend_object_iterator *iter ;
  zend_class_entry *ce ;
  zend_bool is_empty ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___1 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_uint tmp___3 ;
  zend_bool tmp___4 ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  zend_uint tmp___6 ;
  zend_bool tmp___7 ;
  zval *tmp___8 ;
  void __attribute__((__visibility__("default")))  *tmp___9 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___10 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___11 ;
  zval *tmp___12 ;
  void __attribute__((__visibility__("default")))  *tmp___13 ;
  zend_bool tmp___14 ;
  zend_uint tmp___15 ;
  zval __attribute__((__visibility__("default")))  *tmp___16 ;
  long tmp___17 ;
  long tmp___18 ;
  int tmp___19 ;
  long tmp___20 ;
  zend_object *zobj ;
  zend_object __attribute__((__visibility__("default")))  *tmp___21 ;
  char *str_key ;
  uint str_key_len ;
  ulong int_key ;
  zend_uchar key_type ;
  int __attribute__((__visibility__("default")))  tmp___22 ;
  int __attribute__((__visibility__("default")))  tmp___23 ;
  int __attribute__((__visibility__("default")))  tmp___24 ;
  int tmp___25 ;
  int __attribute__((__visibility__("default")))  tmp___26 ;
  int __attribute__((__visibility__("default")))  tmp___27 ;
  int tmp___28 ;
  int __attribute__((__visibility__("default")))  tmp___29 ;
  HashTable *tmp___30 ;
  HashTable *tmp___31 ;
  long tmp___32 ;

  {
  opline = execute_data->opline;
  iter = (zend_object_iterator *)((void *)0);
  ce = (zend_class_entry *)((void *)0);
  is_empty = (zend_bool )0;
  if (1 << 1 == 1 << 4) {
    goto _L___4;
  } else {
    if (1 << 1 == 1 << 2) {
      _L___4: /* CIL Label */ 
      if (opline->extended_value & 1UL) {
        array_ptr_ptr = (zval **)((void *)0);
        if ((unsigned int )array_ptr_ptr == (unsigned int )((void *)0)) {
          goto _L___0;
        } else {
          if ((unsigned int )array_ptr_ptr == (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
            _L___0: /* CIL Label */ 
            while (1) {
              tmp = _emalloc(sizeof(zval_gc_info ));
              array_ptr = (zval *)tmp;
              ((zval_gc_info *)array_ptr)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            array_ptr->refcount__gc = 1U;
            array_ptr->is_ref__gc = (unsigned char)0;
            array_ptr->type = (unsigned char)0;
          } else {
            if ((int )(*array_ptr_ptr)->type == 5) {
              if ((unsigned int )((*array_ptr_ptr)->value.obj.handlers)->get_class_entry == (unsigned int )((void *)0)) {
                zend_error(1 << 1L, "foreach() cannot iterate over objects without PHP class");
                tmp___0 = __builtin_expect((long )(! executor_globals.exception), 1L);
                if (tmp___0) {
                  execute_data->opline = (execute_data->op_array)->opcodes + opline->op2.opline_num;
                } else {

                }
                return (0);
              } else {

              }
              tmp___1 = zend_get_class_entry((zval const   *)*array_ptr_ptr);
              ce = (zend_class_entry *)tmp___1;
              if (! ce) {
                goto _L;
              } else {
                if ((unsigned int )ce->get_iterator == (unsigned int )((void *)0)) {
                  _L: /* CIL Label */ 
                  tmp___4 = zval_isref_p(*array_ptr_ptr);
                  if (tmp___4) {

                  } else {
                    while (1) {
                      tmp___3 = zval_refcount_p(*array_ptr_ptr);
                      if (tmp___3 > 1U) {
                        zval_delref_p(*array_ptr_ptr);
                        while (1) {
                          tmp___2 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___2;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*array_ptr_ptr)->value;
                            new_zv->type = (*array_ptr_ptr)->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *array_ptr_ptr = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  }
                  zval_addref_p(*array_ptr_ptr);
                } else {

                }
              }
              array_ptr = *array_ptr_ptr;
            } else {
              if ((int )(*array_ptr_ptr)->type == 4) {
                tmp___7 = zval_isref_p(*array_ptr_ptr);
                if (tmp___7) {

                } else {
                  while (1) {
                    tmp___6 = zval_refcount_p(*array_ptr_ptr);
                    if (tmp___6 > 1U) {
                      zval_delref_p(*array_ptr_ptr);
                      while (1) {
                        tmp___5 = _emalloc(sizeof(zval_gc_info ));
                        new_zv___0 = (zval *)tmp___5;
                        ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                        break;
                      }
                      while (1) {
                        while (1) {
                          new_zv___0->value = (*array_ptr_ptr)->value;
                          new_zv___0->type = (*array_ptr_ptr)->type;
                          break;
                        }
                        zval_set_refcount_p(new_zv___0, 1U);
                        zval_unset_isref_p(new_zv___0);
                        break;
                      }
                      *array_ptr_ptr = new_zv___0;
                      _zval_copy_ctor(new_zv___0);
                    } else {

                    }
                    break;
                  }
                }
                if (opline->extended_value & 1UL) {
                  zval_set_isref_p(*array_ptr_ptr);
                } else {

                }
              } else {

              }
              array_ptr = *array_ptr_ptr;
              zval_addref_p(array_ptr);
            }
          }
        }
      } else {
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ 
      array_ptr = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
      if (1) {
        while (1) {
          tmp___9 = _emalloc(sizeof(zval_gc_info ));
          tmp___8 = (zval *)tmp___9;
          ((zval_gc_info *)tmp___8)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            tmp___8->value = array_ptr->value;
            tmp___8->type = array_ptr->type;
            break;
          }
          zval_set_refcount_p(tmp___8, 1U);
          zval_unset_isref_p(tmp___8);
          break;
        }
        array_ptr = tmp___8;
        if ((int )array_ptr->type == 5) {
          tmp___10 = zend_get_class_entry((zval const   *)array_ptr);
          ce = (zend_class_entry *)tmp___10;
          if (ce) {
            if (ce->get_iterator) {
              zval_delref_p(array_ptr);
            } else {

            }
          } else {

          }
        } else {

        }
      } else {
        if ((int )array_ptr->type == 5) {
          tmp___11 = zend_get_class_entry((zval const   *)array_ptr);
          ce = (zend_class_entry *)tmp___11;
          if (! ce) {
            zval_addref_p(array_ptr);
          } else {
            if (! ce->get_iterator) {
              zval_addref_p(array_ptr);
            } else {

            }
          }
        } else {
          if (1 << 1 == 1) {
            goto _L___1;
          } else {
            if (1 << 1 == 1 << 4) {
              goto _L___2;
            } else {
              if (1 << 1 == 1 << 2) {
                _L___2: /* CIL Label */ 
                tmp___14 = zval_isref_p(array_ptr);
                if (tmp___14) {
                  zval_addref_p(array_ptr);
                } else {
                  tmp___15 = zval_refcount_p(array_ptr);
                  if (tmp___15 > 1U) {
                    _L___1: /* CIL Label */ 
                    while (1) {
                      tmp___13 = _emalloc(sizeof(zval_gc_info ));
                      tmp___12 = (zval *)tmp___13;
                      ((zval_gc_info *)tmp___12)->u.buffered = (gc_root_buffer *)((void *)0);
                      break;
                    }
                    while (1) {
                      while (1) {
                        tmp___12->value = array_ptr->value;
                        tmp___12->type = array_ptr->type;
                        break;
                      }
                      zval_set_refcount_p(tmp___12, 1U);
                      zval_unset_isref_p(tmp___12);
                      break;
                    }
                    _zval_copy_ctor(tmp___12);
                    array_ptr = tmp___12;
                  } else {
                    zval_addref_p(array_ptr);
                  }
                }
              } else {
                zval_addref_p(array_ptr);
              }
            }
          }
        }
      }
    }
  }
  if (ce) {
    if (ce->get_iterator) {
      iter = (*(ce->get_iterator))(ce, array_ptr, (int )(opline->extended_value & (unsigned long )(1 << 1)));
      if (iter) {
        tmp___17 = __builtin_expect((long )((unsigned int )executor_globals.exception == (unsigned int )((void *)0)), 1L);
        if (tmp___17) {
          tmp___16 = zend_iterator_wrap(iter);
          array_ptr = (zval *)tmp___16;
        } else {
          goto _L___5;
        }
      } else {
        _L___5: /* CIL Label */ 
        if (! executor_globals.exception) {
          zend_throw_exception_ex((zend_class_entry *)((void *)0), 0L, (char *)"Object of type %s did not create an Iterator", ce->name);
        } else {

        }
        zend_throw_exception_internal((zval *)((void *)0));
        return (0);
      }
    } else {

    }
  } else {

  }
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->fe.ptr = array_ptr;
  if (iter) {
    iter->index = 0UL;
    if ((iter->funcs)->rewind) {
      (*((iter->funcs)->rewind))(iter);
      tmp___18 = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
      if (tmp___18) {
        i_zval_ptr_dtor(array_ptr);
        return (0);
      } else {

      }
    } else {

    }
    tmp___19 = (*((iter->funcs)->valid))(iter);
    is_empty = (unsigned char )(tmp___19 != 0);
    tmp___20 = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
    if (tmp___20) {
      i_zval_ptr_dtor(array_ptr);
      return (0);
    } else {

    }
    iter->index = 4294967295UL;
  } else {
    if ((int )array_ptr->type == 4) {
      fe_ht = array_ptr->value.ht;
    } else {
      if ((int )array_ptr->type == 5) {
        tmp___30 = (*((array_ptr->value.obj.handlers)->get_properties))(array_ptr);
        tmp___31 = tmp___30;
      } else {
        tmp___31 = (HashTable *)((void *)0);
      }
      fe_ht = tmp___31;
    }
    if ((unsigned int )fe_ht != (unsigned int )((void *)0)) {
      zend_hash_internal_pointer_reset_ex(fe_ht, (HashPosition *)((void *)0));
      if (ce) {
        tmp___21 = zend_objects_get_address((zval const   *)array_ptr);
        zobj = (zend_object *)tmp___21;
        while (1) {
          tmp___26 = zend_hash_get_current_key_type_ex(fe_ht, (HashPosition *)((void *)0));
          if (tmp___26 == (int __attribute__((__visibility__("default")))  )3) {
            tmp___25 = -1;
          } else {
            tmp___25 = 0;
          }
          if (tmp___25 == 0) {

          } else {
            break;
          }
          tmp___22 = zend_hash_get_current_key_ex((HashTable const   *)fe_ht, & str_key, & str_key_len, & int_key, (unsigned char)0, (HashPosition *)((void *)0));
          key_type = (unsigned char )tmp___22;
          if ((int )key_type != 3) {
            if ((int )key_type == 2) {
              break;
            } else {
              tmp___23 = zend_check_property_access(zobj, (char const   *)str_key, (int )(str_key_len - 1U));
              if (tmp___23 == (int __attribute__((__visibility__("default")))  )0) {
                break;
              } else {

              }
            }
          } else {

          }
          zend_hash_move_forward_ex(fe_ht, (HashPosition *)((void *)0));
        }
      } else {

      }
      tmp___29 = zend_hash_get_current_key_type_ex(fe_ht, (HashPosition *)((void *)0));
      if (tmp___29 == (int __attribute__((__visibility__("default")))  )3) {
        tmp___28 = -1;
      } else {
        tmp___28 = 0;
      }
      is_empty = (unsigned char )(tmp___28 != 0);
      zend_hash_get_pointer((HashTable const   *)fe_ht, & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->fe.fe_pos);
    } else {
      zend_error(1 << 1L, "Invalid argument supplied for foreach()");
      is_empty = (unsigned char)1;
    }
  }
  if (is_empty) {
    tmp___32 = __builtin_expect((long )(! executor_globals.exception), 1L);
    if (tmp___32) {
      execute_data->opline = (execute_data->op_array)->opcodes + opline->op2.opline_num;
    } else {

    }
    return (0);
  } else {
    (execute_data->opline) ++;
    return (0);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_EXIT_SPEC_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *ptr ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  if (1 << 1 != 1 << 3) {
    tmp = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    ptr = tmp;
    if ((int )ptr->type == 1) {
      executor_globals.exit_status = (int )ptr->value.lval;
    } else {
      zend_print_variable(ptr);
    }
    _zval_dtor(free_op1.var);
  } else {

  }
  _zend_bailout((char *)"/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-12-18-beda5efd41-622412d8e6/php/Zend/zend_vm_execute.h", 7154U);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_END_SILENCE_SPEC_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval restored_error_reporting ;
  int tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  opline = execute_data->opline;
  if (! executor_globals.error_reporting) {
    if (((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->tmp_var.value.lval != 0L) {
      restored_error_reporting.type = (unsigned char)1;
      restored_error_reporting.value.lval = ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->tmp_var.value.lval;
      executor_globals.error_reporting = (int )restored_error_reporting.value.lval;
      if ((int )restored_error_reporting.type != 6) {
        _convert_to_string(& restored_error_reporting);
      } else {

      }
      tmp___1 = __builtin_expect((long )((unsigned int )executor_globals.error_reporting_ini_entry != (unsigned int )((void *)0)), 1L);
      if (tmp___1) {
        if ((executor_globals.error_reporting_ini_entry)->modified) {
          if ((unsigned int )(executor_globals.error_reporting_ini_entry)->value != (unsigned int )(executor_globals.error_reporting_ini_entry)->orig_value) {
            tmp = 1;
          } else {
            tmp = 0;
          }
        } else {
          tmp = 0;
        }
        tmp___0 = __builtin_expect((long )tmp, 1L);
        if (tmp___0) {
          _efree((void *)(executor_globals.error_reporting_ini_entry)->value);
        } else {

        }
        (executor_globals.error_reporting_ini_entry)->value = restored_error_reporting.value.str.val;
        (executor_globals.error_reporting_ini_entry)->value_length = (unsigned int )restored_error_reporting.value.str.len;
      } else {
        _zval_dtor(& restored_error_reporting);
      }
    } else {

    }
  } else {

  }
  if ((unsigned int )execute_data->old_error_reporting == (unsigned int )(& ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->tmp_var)) {
    execute_data->old_error_reporting = (zval *)((void *)0);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_JMP_SET_SPEC_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *value ;
  long tmp ;
  int tmp___0 ;

  {
  opline = execute_data->opline;
  value = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  tmp___0 = i_zend_is_true(value);
  if (tmp___0) {
    while (1) {
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value = value->value;
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.type = value->type;
      break;
    }
    tmp = __builtin_expect((long )(! executor_globals.exception), 1L);
    if (tmp) {
      execute_data->opline = opline->op2.jmp_addr;
    } else {

    }
    return (0);
  } else {

  }
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_JMP_SET_VAR_SPEC_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *value ;
  zval *ret ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  value = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  tmp___1 = i_zend_is_true(value);
  if (tmp___1) {
    if (1 << 1 == 1 << 2) {
      zval_addref_p(value);
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = value;
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
    } else {
      if (1 << 1 == 1 << 4) {
        zval_addref_p(value);
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = value;
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
      } else {
        while (1) {
          tmp = _emalloc(sizeof(zval_gc_info ));
          ret = (zval *)tmp;
          ((zval_gc_info *)ret)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            ret->value = value->value;
            ret->type = value->type;
            break;
          }
          zval_set_refcount_p(ret, 1U);
          zval_unset_isref_p(ret);
          break;
        }
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = ret;
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
      }
    }
    tmp___0 = __builtin_expect((long )(! executor_globals.exception), 1L);
    if (tmp___0) {
      execute_data->opline = opline->op2.jmp_addr;
    } else {

    }
    return (0);
  } else {

  }
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_QM_ASSIGN_SPEC_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *value ;

  {
  opline = execute_data->opline;
  value = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  while (1) {
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value = value->value;
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.type = value->type;
    break;
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_QM_ASSIGN_VAR_SPEC_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *value ;
  zval *ret ;
  void __attribute__((__visibility__("default")))  *tmp ;

  {
  opline = execute_data->opline;
  value = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 1 == 1 << 2) {
    zval_addref_p(value);
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = value;
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
  } else {
    if (1 << 1 == 1 << 4) {
      zval_addref_p(value);
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = value;
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
    } else {
      while (1) {
        tmp = _emalloc(sizeof(zval_gc_info ));
        ret = (zval *)tmp;
        ((zval_gc_info *)ret)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      while (1) {
        while (1) {
          ret->value = value->value;
          ret->type = value->type;
          break;
        }
        zval_set_refcount_p(ret, 1U);
        zval_unset_isref_p(ret);
        break;
      }
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = ret;
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INSTANCEOF_SPEC_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *expr ;
  zend_bool result ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp ;
  zend_bool __attribute__((__visibility__("default")))  tmp___0 ;
  zval *__z ;

  {
  opline = execute_data->opline;
  expr = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if ((int )expr->type == 5) {
    if ((expr->value.obj.handlers)->get_class_entry) {
      tmp = zend_get_class_entry((zval const   *)expr);
      tmp___0 = instanceof_function((zend_class_entry const   *)tmp, (zend_class_entry const   *)((temp_variable *)((char *)execute_data->Ts + opline->op2.var))->class_entry);
      result = (unsigned char )tmp___0;
    } else {
      result = (unsigned char)0;
    }
  } else {
    result = (unsigned char)0;
  }
  while (1) {
    __z = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
    __z->value.lval = (long )((int )result != 0);
    __z->type = (unsigned char)3;
    break;
  }
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_SPEC_TMP_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  fast_add_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp, opline->op2.zv);
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SUB_SPEC_TMP_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  fast_sub_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp, opline->op2.zv);
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_MUL_SPEC_TMP_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  fast_mul_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp, opline->op2.zv);
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_DIV_SPEC_TMP_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  fast_div_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp, opline->op2.zv);
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_MOD_SPEC_TMP_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  fast_mod_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp, opline->op2.zv);
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SL_SPEC_TMP_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  shift_left_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp, opline->op2.zv);
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SR_SPEC_TMP_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  shift_right_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp, opline->op2.zv);
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_CONCAT_SPEC_TMP_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  concat_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp, opline->op2.zv);
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_IDENTICAL_SPEC_TMP_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  is_identical_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp, opline->op2.zv);
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_NOT_IDENTICAL_SPEC_TMP_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *result ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  tmp = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  is_identical_function(result, tmp, opline->op2.zv);
  result->value.lval = (long )(! result->value.lval);
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_EQUAL_SPEC_TMP_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  int tmp___0 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    tmp___0 = fast_equal_function(result, tmp, opline->op2.zv);
    __z->value.lval = (long )(tmp___0 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_NOT_EQUAL_SPEC_TMP_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  int tmp___0 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    tmp___0 = fast_not_equal_function(result, tmp, opline->op2.zv);
    __z->value.lval = (long )(tmp___0 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_SMALLER_SPEC_TMP_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  int tmp___0 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    tmp___0 = fast_is_smaller_function(result, tmp, opline->op2.zv);
    __z->value.lval = (long )(tmp___0 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMP_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  int tmp___0 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    tmp___0 = fast_is_smaller_or_equal_function(result, tmp, opline->op2.zv);
    __z->value.lval = (long )(tmp___0 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_OR_SPEC_TMP_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  bitwise_or_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp, opline->op2.zv);
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_AND_SPEC_TMP_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  bitwise_and_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp, opline->op2.zv);
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_XOR_SPEC_TMP_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  bitwise_xor_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp, opline->op2.zv);
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BOOL_XOR_SPEC_TMP_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  boolean_xor_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp, opline->op2.zv);
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_fetch_var_address_helper_SPEC_TMP_CONST)(int type , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *varname ;
  zval **retval ;
  zval tmp_varname ;
  HashTable *target_symbol_table ;
  ulong hash_value ;
  long tmp ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_literal *tmp___1 ;
  zval __attribute__((__visibility__("default")))  **tmp___2 ;
  ulong __attribute__((__visibility__("default")))  tmp___3 ;
  int __attribute__((__visibility__("default")))  tmp___4 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  zend_uint tmp___6 ;
  zend_bool tmp___7 ;
  temp_variable *__t ;
  zend_free_op free_res ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___8 ;
  zend_uint tmp___9 ;
  zend_bool tmp___10 ;

  {
  opline = execute_data->opline;
  varname = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 1 != 1) {
    tmp = __builtin_expect((long )((int )varname->type != 6), 0L);
    if (tmp) {
      while (1) {
        tmp_varname.value = varname->value;
        tmp_varname.type = varname->type;
        break;
      }
      _zval_copy_ctor(& tmp_varname);
      zval_set_refcount_p(& tmp_varname, 1U);
      zval_unset_isref_p(& tmp_varname);
      if ((int )tmp_varname.type != 6) {
        _convert_to_string(& tmp_varname);
      } else {

      }
      varname = & tmp_varname;
    } else {

    }
  } else {

  }
  if (1 != 1 << 3) {
    if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
      ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
    } else {
      tmp___0 = zend_fetch_class_by_name((char const   *)(opline->op2.zv)->value.str.val, (unsigned int )(opline->op2.zv)->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), 0);
      ce = (zend_class_entry *)tmp___0;
      while (1) {
        *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
        break;
      }
    }
    if (1 << 1 == 1) {
      tmp___1 = opline->op1.literal;
    } else {
      tmp___1 = (zend_literal *)((void *)0);
    }
    tmp___2 = zend_std_get_static_property(ce, (char const   *)varname->value.str.val, varname->value.str.len, (unsigned char)0, (struct _zend_literal  const  *)tmp___1);
    retval = (zval **)tmp___2;
    _zval_dtor(free_op1.var);
  } else {
    target_symbol_table = zend_get_target_symbol_table((int )(opline->extended_value & 1879048192UL));
    if (1 << 1 == 1) {
      hash_value = ((zend_literal *)varname)->hash_value;
    } else {
      if ((unsigned int )varname->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
        if ((unsigned int )varname->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
          hash_value = ((Bucket *)(varname->value.str.val - sizeof(Bucket )))->h;
        } else {
          tmp___3 = zend_hash_func((char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1));
          hash_value = (unsigned long )tmp___3;
        }
      } else {
        tmp___3 = zend_hash_func((char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1));
        hash_value = (unsigned long )tmp___3;
      }
    }
    tmp___4 = zend_hash_quick_find((HashTable const   *)target_symbol_table, (char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1), hash_value, (void **)(& retval));
    if (tmp___4 == (int __attribute__((__visibility__("default")))  )-1) {
      switch (type) {
      case 0: 
      case 6: 
      zend_error(1 << 3L, "Undefined variable: %s", varname->value.str.val);
      case 3: 
      retval = & executor_globals.uninitialized_zval_ptr;
      break;
      case 2: 
      zend_error(1 << 3L, "Undefined variable: %s", varname->value.str.val);
      case 1: 
      zval_addref_p(& executor_globals.uninitialized_zval);
      _zend_hash_quick_add_or_update(target_symbol_table, (char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1), hash_value, (void *)(& executor_globals.uninitialized_zval_ptr), sizeof(zval *), (void **)(& retval), 1);
      break;
      }
    } else {

    }
    switch ((int )(opline->extended_value & 1879048192UL)) {
    case 0x00000000: 
    if (1 << 1 != 1 << 1) {
      _zval_dtor(free_op1.var);
    } else {

    }
    break;
    case 0x10000000: 
    _zval_dtor(free_op1.var);
    break;
    case 0x20000000: 
    zval_update_constant(retval, (void *)1);
    break;
    case 0x40000000: 
    if (1 << 1 == 1 << 2) {
      if (! free_op1.var) {
        zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr));
      } else {

      }
    } else {

    }
    break;
    }
  }
  if (1 << 1 != 1) {
    if ((unsigned int )varname == (unsigned int )(& tmp_varname)) {
      _zval_dtor(& tmp_varname);
    } else {

    }
  } else {

  }
  if (opline->extended_value & 67108864UL) {
    tmp___7 = zval_isref_p(*retval);
    if (tmp___7) {

    } else {
      while (1) {
        tmp___6 = zval_refcount_p(*retval);
        if (tmp___6 > 1U) {
          zval_delref_p(*retval);
          while (1) {
            tmp___5 = _emalloc(sizeof(zval_gc_info ));
            new_zv = (zval *)tmp___5;
            ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv->value = (*retval)->value;
              new_zv->type = (*retval)->type;
              break;
            }
            zval_set_refcount_p(new_zv, 1U);
            zval_unset_isref_p(new_zv);
            break;
          }
          *retval = new_zv;
          _zval_copy_ctor(new_zv);
        } else {

        }
        break;
      }
      zval_set_isref_p(*retval);
    }
  } else {

  }
  zval_addref_p(*retval);
  switch (type) {
  case 0: 
  case 3: 
  while (1) {
    __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
    __t->var.ptr = *retval;
    __t->var.ptr_ptr = & __t->var.ptr;
    break;
  }
  break;
  case 6: 
  zend_pzval_unlock_func(*retval, & free_res, 1);
  if ((unsigned int )retval != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
    tmp___10 = zval_isref_p(*retval);
    if (tmp___10) {

    } else {
      while (1) {
        tmp___9 = zval_refcount_p(*retval);
        if (tmp___9 > 1U) {
          zval_delref_p(*retval);
          while (1) {
            tmp___8 = _emalloc(sizeof(zval_gc_info ));
            new_zv___0 = (zval *)tmp___8;
            ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv___0->value = (*retval)->value;
              new_zv___0->type = (*retval)->type;
              break;
            }
            zval_set_refcount_p(new_zv___0, 1U);
            zval_unset_isref_p(new_zv___0);
            break;
          }
          *retval = new_zv___0;
          _zval_copy_ctor(new_zv___0);
        } else {

        }
        break;
      }
    }
  } else {

  }
  zval_addref_p(*retval);
  if (free_res.var) {
    i_zval_ptr_dtor(free_res.var);
  } else {

  }
  default: 
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = retval;
  break;
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_R_SPEC_TMP_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_TMP_CONST(0, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_W_SPEC_TMP_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_TMP_CONST(1, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_RW_SPEC_TMP_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_TMP_CONST(2, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_FUNC_ARG_SPEC_TMP_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  unsigned int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
  opline = execute_data->opline;
  if (execute_data->fbc) {
    if ((execute_data->fbc)->common.arg_info) {
      if ((opline->extended_value & 1048575UL) <= (unsigned long )(execute_data->fbc)->common.num_args) {
        tmp___1 = (unsigned int )((int )((execute_data->fbc)->common.arg_info + ((opline->extended_value & 1048575UL) - 1UL))->pass_by_reference & 3);
      } else {
        tmp___1 = (execute_data->fbc)->common.fn_flags & 50331648U;
      }
    } else {
      tmp___1 = (execute_data->fbc)->common.fn_flags & 50331648U;
    }
    if (tmp___1) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___2 = zend_fetch_var_address_helper_SPEC_TMP_CONST(tmp___0, execute_data);
  return (tmp___2);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_UNSET_SPEC_TMP_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_TMP_CONST(6, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_IS_SPEC_TMP_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_TMP_CONST(3, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_TMP_VAR_SPEC_TMP_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *container ;
  temp_variable *__t ;
  zval *value ;
  zval **tmp ;
  temp_variable *__t___0 ;
  long tmp___0 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  tmp___0 = __builtin_expect((long )((int )container->type != 4), 0L);
  if (tmp___0) {
    zval_addref_p(& executor_globals.uninitialized_zval);
    while (1) {
      __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
      __t->var.ptr = & executor_globals.uninitialized_zval;
      __t->var.ptr_ptr = & __t->var.ptr;
      break;
    }
  } else {
    tmp = zend_fetch_dimension_address_inner(container->value.ht, (zval const   *)opline->op2.zv, 1, 0);
    value = *tmp;
    zval_addref_p(value);
    while (1) {
      __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
      __t___0->var.ptr = value;
      __t___0->var.ptr_ptr = & __t___0->var.ptr;
      break;
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_CHAR_SPEC_TMP_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *str ;

  {
  opline = execute_data->opline;
  str = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  if (1 << 1 == 1 << 3) {
    str->value.str.val = (char *)((void *)0);
    str->value.str.len = 0;
    str->type = (unsigned char)6;
    str->refcount__gc = 1U;
    str->is_ref__gc = (unsigned char)0;
  } else {

  }
  add_char_to_string(str, (zval const   *)str, (zval const   *)opline->op2.zv);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_STRING_SPEC_TMP_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *str ;

  {
  opline = execute_data->opline;
  str = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  if (1 << 1 == 1 << 3) {
    str->value.str.val = (char *)((void *)0);
    str->value.str.len = 0;
    str->type = (unsigned char)6;
    str->refcount__gc = 1U;
    str->is_ref__gc = (unsigned char)0;
  } else {

  }
  add_string_to_string(str, (zval const   *)str, (zval const   *)opline->op2.zv);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_METHOD_CALL_SPEC_TMP_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *function_name ;
  char *function_name_strval ;
  int function_name_strlen ;
  zend_free_op free_op1 ;
  long tmp ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  zval *object ;
  long tmp___1 ;
  zend_class_entry *tmp___2 ;
  zend_class_entry *tmp___3 ;
  char const   *tmp___4 ;
  zend_class_entry *tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  zend_function *tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  zval *this_ptr ;
  void __attribute__((__visibility__("default")))  *tmp___12 ;
  zend_bool tmp___13 ;

  {
  opline = execute_data->opline;
  zend_ptr_stack_3_push(& executor_globals.arg_types_stack, (void *)execute_data->fbc, (void *)execute_data->object, (void *)execute_data->called_scope);
  function_name = opline->op2.zv;
  function_name_strval = function_name->value.str.val;
  function_name_strlen = function_name->value.str.len;
  execute_data->object = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  tmp___10 = __builtin_expect((long )((unsigned int )execute_data->object != (unsigned int )((void *)0)), 1L);
  if (tmp___10) {
    tmp___11 = __builtin_expect((long )((int )(execute_data->object)->type == 5), 1L);
    if (tmp___11) {
      tmp___0 = zend_get_class_entry((zval const   *)execute_data->object);
      execute_data->called_scope = (zend_class_entry *)tmp___0;
      if ((unsigned int )*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) == (unsigned int )execute_data->called_scope) {
        tmp___9 = (zend_function *)*((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U));
      } else {
        tmp___9 = (zend_function *)((void *)0);
      }
      execute_data->fbc = tmp___9;
      if ((unsigned int )tmp___9 == (unsigned int )((void *)0)) {
        object = execute_data->object;
        tmp___1 = __builtin_expect((long )((unsigned int )((execute_data->object)->value.obj.handlers)->get_method == (unsigned int )((void *)0)), 0L);
        if (tmp___1) {
          zend_error_noreturn(1, "Object does not support method calls");
        } else {

        }
        execute_data->fbc = (*(((execute_data->object)->value.obj.handlers)->get_method))(& execute_data->object, function_name_strval, function_name_strlen, (struct _zend_literal  const  *)(opline->op2.literal + 1));
        tmp___6 = __builtin_expect((long )((unsigned int )execute_data->fbc == (unsigned int )((void *)0)), 0L);
        if (tmp___6) {
          if (execute_data->object) {
            if ((int )(execute_data->object)->type == 5) {
              if ((unsigned int )((execute_data->object)->value.obj.handlers)->get_class_entry != (unsigned int )((void *)0)) {
                tmp___5 = (*(((execute_data->object)->value.obj.handlers)->get_class_entry))((zval const   *)execute_data->object);
                if (tmp___5) {
                  tmp___3 = (*(((execute_data->object)->value.obj.handlers)->get_class_entry))((zval const   *)execute_data->object);
                  tmp___4 = tmp___3->name;
                } else {
                  tmp___4 = "";
                }
              } else {
                tmp___4 = "";
              }
            } else {
              tmp___4 = "";
            }
          } else {
            tmp___4 = "";
          }
          zend_error_noreturn(1, "Call to undefined method %s::%s()", tmp___4, function_name_strval);
        } else {

        }
        tmp___7 = __builtin_expect((long )(((execute_data->fbc)->common.fn_flags & 6291456U) == 0U), 1L);
        if (tmp___7) {
          tmp___8 = __builtin_expect((long )((unsigned int )execute_data->object == (unsigned int )object), 1L);
          if (tmp___8) {
            while (1) {
              *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)execute_data->called_scope;
              *((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U)) = (void *)execute_data->fbc;
              break;
            }
          } else {

          }
        } else {

        }
      } else {

      }
    } else {
      zend_error_noreturn(1, "Call to a member function %s() on a non-object", function_name_strval);
    }
  } else {
    zend_error_noreturn(1, "Call to a member function %s() on a non-object", function_name_strval);
  }
  if (((execute_data->fbc)->common.fn_flags & 1U) != 0U) {
    execute_data->object = (zval *)((void *)0);
  } else {
    tmp___13 = zval_isref_p(execute_data->object);
    if (tmp___13) {
      while (1) {
        tmp___12 = _emalloc(sizeof(zval_gc_info ));
        this_ptr = (zval *)tmp___12;
        ((zval_gc_info *)this_ptr)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      while (1) {
        while (1) {
          this_ptr->value = (execute_data->object)->value;
          this_ptr->type = (execute_data->object)->type;
          break;
        }
        zval_set_refcount_p(this_ptr, 1U);
        zval_unset_isref_p(this_ptr);
        break;
      }
      _zval_copy_ctor(this_ptr);
      execute_data->object = this_ptr;
    } else {
      zval_addref_p(execute_data->object);
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_CASE_SPEC_TMP_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  if (1 << 1 == 1 << 2) {
    zval_addref_p(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr);
  } else {

  }
  tmp = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  is_equal_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp, opline->op2.zv);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *expr_ptr ;
  zval **expr_ptr_ptr ;
  long tmp ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_uint tmp___1 ;
  zend_bool tmp___2 ;
  zval *new_expr ;
  void __attribute__((__visibility__("default")))  *tmp___3 ;
  zval *new_expr___0 ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_bool tmp___5 ;
  zval *offset ;
  ulong hval ;
  long tmp___6 ;
  register char const   *tmp___7 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___8 ;

  {
  opline = execute_data->opline;
  if (1 << 1 == 1 << 2) {
    goto _L___1;
  } else {
    if (1 << 1 == 1 << 4) {
      _L___1: /* CIL Label */ 
      if (opline->extended_value) {
        expr_ptr_ptr = (zval **)((void *)0);
        if (1 << 1 == 1 << 2) {
          tmp = __builtin_expect((long )((unsigned int )expr_ptr_ptr == (unsigned int )((void *)0)), 0L);
          if (tmp) {
            zend_error_noreturn(1, "Cannot create references to/from string offsets");
          } else {

          }
        } else {

        }
        tmp___2 = zval_isref_p(*expr_ptr_ptr);
        if (tmp___2) {

        } else {
          while (1) {
            tmp___1 = zval_refcount_p(*expr_ptr_ptr);
            if (tmp___1 > 1U) {
              zval_delref_p(*expr_ptr_ptr);
              while (1) {
                tmp___0 = _emalloc(sizeof(zval_gc_info ));
                new_zv = (zval *)tmp___0;
                ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv->value = (*expr_ptr_ptr)->value;
                  new_zv->type = (*expr_ptr_ptr)->type;
                  break;
                }
                zval_set_refcount_p(new_zv, 1U);
                zval_unset_isref_p(new_zv);
                break;
              }
              *expr_ptr_ptr = new_zv;
              _zval_copy_ctor(new_zv);
            } else {

            }
            break;
          }
          zval_set_isref_p(*expr_ptr_ptr);
        }
        expr_ptr = *expr_ptr_ptr;
        zval_addref_p(expr_ptr);
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      expr_ptr = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
      if (1) {
        while (1) {
          tmp___3 = _emalloc(sizeof(zval_gc_info ));
          new_expr = (zval *)tmp___3;
          ((zval_gc_info *)new_expr)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            new_expr->value = expr_ptr->value;
            new_expr->type = expr_ptr->type;
            break;
          }
          zval_set_refcount_p(new_expr, 1U);
          zval_unset_isref_p(new_expr);
          break;
        }
        expr_ptr = new_expr;
      } else {
        if (1 << 1 == 1) {
          goto _L;
        } else {
          tmp___5 = zval_isref_p(expr_ptr);
          if (tmp___5) {
            _L: /* CIL Label */ 
            while (1) {
              tmp___4 = _emalloc(sizeof(zval_gc_info ));
              new_expr___0 = (zval *)tmp___4;
              ((zval_gc_info *)new_expr___0)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_expr___0->value = expr_ptr->value;
                new_expr___0->type = expr_ptr->type;
                break;
              }
              zval_set_refcount_p(new_expr___0, 1U);
              zval_unset_isref_p(new_expr___0);
              break;
            }
            expr_ptr = new_expr___0;
            _zval_copy_ctor(expr_ptr);
          } else {
            zval_addref_p(expr_ptr);
          }
        }
      }
    }
  }
  if (1 != 1 << 3) {
    offset = opline->op2.zv;
    switch ((int )offset->type) {
    case 2: 
    tmp___6 = zend_dval_to_lval(offset->value.dval);
    hval = (unsigned long )tmp___6;
    goto num_index;
    case 1: 
    case 3: 
    hval = (unsigned long )offset->value.lval;
    num_index: 
    _zend_hash_index_update_or_next_insert(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, hval, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    case 6: 
    if (1) {
      hval = ((zend_literal *)offset)->hash_value;
    } else {
      while (1) {
        tmp___7 = (char const   *)offset->value.str.val;
        if ((int const   )*tmp___7 == 45) {
          tmp___7 ++;
        } else {

        }
        if ((int const   )*tmp___7 >= 48) {
          if ((int const   )*tmp___7 <= 57) {
            end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
            if ((int const   )*end != 0) {
              break;
            } else {
              if ((int const   )*tmp___7 == 48) {
                if (offset->value.str.len + 1 > 2) {
                  break;
                } else {
                  goto _L___2;
                }
              } else {
                _L___2: /* CIL Label */ 
                if (end - tmp___7 > 10) {
                  break;
                } else {
                  if (end - tmp___7 == 10) {
                    if ((int const   )*tmp___7 > 50) {
                      break;
                    } else {

                    }
                  } else {

                  }
                }
              }
            }
            hval = (unsigned long )((int const   )*tmp___7 - 48);
            while (1) {
              tmp___7 ++;
              if ((unsigned int )tmp___7 != (unsigned int )end) {
                if ((int const   )*tmp___7 >= 48) {
                  if ((int const   )*tmp___7 <= 57) {

                  } else {
                    break;
                  }
                } else {
                  break;
                }
              } else {
                break;
              }
              hval = hval * 10UL + (ulong )((int const   )*tmp___7 - 48);
            }
            if ((unsigned int )tmp___7 == (unsigned int )end) {
              if ((int )*(offset->value.str.val) == 45) {
                if (hval - 1UL > 2147483647UL) {
                  break;
                } else {

                }
                hval = (unsigned long )(- ((long )hval));
              } else {
                if (hval > 2147483647UL) {
                  break;
                } else {

                }
              }
              goto num_index;
            } else {

            }
          } else {

          }
        } else {

        }
        break;
      }
      if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
        if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
          hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
        } else {
          tmp___8 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___8;
        }
      } else {
        tmp___8 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
        hval = (unsigned long )tmp___8;
      }
    }
    _zend_hash_quick_add_or_update(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    case 0: 
    _zend_hash_add_or_update(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, "", sizeof(""), (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    default: 
    zend_error(1 << 1L, "Illegal offset type");
    i_zval_ptr_dtor(expr_ptr);
    break;
    }
  } else {
    _zend_hash_index_update_or_next_insert(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, 0UL, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1 << 2);
  }
  if (1 << 1 == 1 << 2) {
    goto _L___3;
  } else {
    if (1 << 1 == 1 << 4) {
      _L___3: /* CIL Label */ 
      if (opline->extended_value) {

      } else {

      }
    } else {

    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_ARRAY_SPEC_TMP_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  int tmp ;

  {
  opline = execute_data->opline;
  _array_init(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, 0U);
  if (1 << 1 == 1 << 3) {
    (execute_data->opline) ++;
    return (0);
  } else {
    tmp = ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CONST_HANDLER(execute_data);
    return (tmp);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_UNSET_VAR_SPEC_TMP_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval tmp ;
  zval *varname ;
  HashTable *target_symbol_table ;
  zend_free_op free_op1 ;
  zend_compiled_variable *cv ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_literal *tmp___1 ;
  ulong hash_value ;
  ulong tmp___2 ;

  {
  opline = execute_data->opline;
  if (1 << 1 == 1 << 4) {
    if (1 == 1 << 3) {
      if (opline->extended_value & 8388608UL) {
        if (executor_globals.active_symbol_table) {
          cv = (executor_globals.active_op_array)->vars + opline->op1.var;
          zend_delete_variable(execute_data->prev_execute_data, executor_globals.active_symbol_table, cv->name, cv->name_len + 1, cv->hash_value);
          *(execute_data->CVs + opline->op1.var) = (zval **)((void *)0);
        } else {
          if (*(execute_data->CVs + opline->op1.var)) {
            i_zval_ptr_dtor(*(*(execute_data->CVs + opline->op1.var)));
            *(execute_data->CVs + opline->op1.var) = (zval **)((void *)0);
          } else {

          }
        }
        (execute_data->opline) ++;
        return (0);
      } else {

      }
    } else {

    }
  } else {

  }
  varname = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 1 != 1) {
    if ((int )varname->type != 6) {
      while (1) {
        tmp.value = varname->value;
        tmp.type = varname->type;
        break;
      }
      _zval_copy_ctor(& tmp);
      if ((int )tmp.type != 6) {
        _convert_to_string(& tmp);
      } else {

      }
      varname = & tmp;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if (1 << 1 == 1 << 2) {
      zval_addref_p(varname);
    } else {
      if (1 << 1 == 1 << 4) {
        zval_addref_p(varname);
      } else {

      }
    }
  }
  if (1 != 1 << 3) {
    if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
      ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
    } else {
      tmp___0 = zend_fetch_class_by_name((char const   *)(opline->op2.zv)->value.str.val, (unsigned int )(opline->op2.zv)->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), 0);
      ce = (zend_class_entry *)tmp___0;
      while (1) {
        *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
        break;
      }
    }
    if (1 << 1 == 1) {
      tmp___1 = opline->op1.literal;
    } else {
      tmp___1 = (zend_literal *)((void *)0);
    }
    zend_std_unset_static_property(ce, (char const   *)varname->value.str.val, varname->value.str.len, (struct _zend_literal  const  *)tmp___1);
  } else {
    tmp___2 = zend_inline_hash_func((char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1));
    hash_value = tmp___2;
    target_symbol_table = zend_get_target_symbol_table((int )(opline->extended_value & 1879048192UL));
    zend_delete_variable(execute_data, target_symbol_table, (char const   *)varname->value.str.val, varname->value.str.len + 1, hash_value);
  }
  if (1 << 1 != 1) {
    if ((unsigned int )varname == (unsigned int )(& tmp)) {
      _zval_dtor(& tmp);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if (1 << 1 == 1 << 2) {
      i_zval_ptr_dtor(varname);
    } else {
      if (1 << 1 == 1 << 4) {
        i_zval_ptr_dtor(varname);
      } else {

      }
    }
  }
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ISSET_ISEMPTY_VAR_SPEC_TMP_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **value ;
  zend_bool isset ;
  zend_compiled_variable *cv ;
  int __attribute__((__visibility__("default")))  tmp ;
  HashTable *target_symbol_table ;
  zend_free_op free_op1 ;
  zval tmp___0 ;
  zval *varname ;
  zval *tmp___1 ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_literal *tmp___3 ;
  zval __attribute__((__visibility__("default")))  **tmp___4 ;
  int __attribute__((__visibility__("default")))  tmp___5 ;
  zval *__z ;
  zval *__z___0 ;
  zval *__z___1 ;
  zval *__z___2 ;
  int tmp___6 ;

  {
  opline = execute_data->opline;
  isset = (zend_bool )1;
  if (1 << 1 == 1 << 4) {
    if (1 == 1 << 3) {
      if (opline->extended_value & 8388608UL) {
        if (*(execute_data->CVs + opline->op1.var)) {
          value = *(execute_data->CVs + opline->op1.var);
        } else {
          if (executor_globals.active_symbol_table) {
            cv = (executor_globals.active_op_array)->vars + opline->op1.var;
            tmp = zend_hash_quick_find((HashTable const   *)executor_globals.active_symbol_table, cv->name, (unsigned int )(cv->name_len + 1), cv->hash_value, (void **)(& value));
            if (tmp == (int __attribute__((__visibility__("default")))  )-1) {
              isset = (unsigned char)0;
            } else {

            }
          } else {
            isset = (unsigned char)0;
          }
        }
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    _L: /* CIL Label */ 
    tmp___1 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    varname = tmp___1;
    if (1 << 1 != 1) {
      if ((int )varname->type != 6) {
        while (1) {
          tmp___0.value = varname->value;
          tmp___0.type = varname->type;
          break;
        }
        _zval_copy_ctor(& tmp___0);
        if ((int )tmp___0.type != 6) {
          _convert_to_string(& tmp___0);
        } else {

        }
        varname = & tmp___0;
      } else {

      }
    } else {

    }
    if (1 != 1 << 3) {
      if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
        ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
      } else {
        tmp___2 = zend_fetch_class_by_name((char const   *)(opline->op2.zv)->value.str.val, (unsigned int )(opline->op2.zv)->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), 0);
        ce = (zend_class_entry *)tmp___2;
        while (1) {
          *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
          break;
        }
      }
      if (1 << 1 == 1) {
        tmp___3 = opline->op1.literal;
      } else {
        tmp___3 = (zend_literal *)((void *)0);
      }
      tmp___4 = zend_std_get_static_property(ce, (char const   *)varname->value.str.val, varname->value.str.len, (unsigned char)1, (struct _zend_literal  const  *)tmp___3);
      value = (zval **)tmp___4;
      if (! value) {
        isset = (unsigned char)0;
      } else {

      }
    } else {
      target_symbol_table = zend_get_target_symbol_table((int )(opline->extended_value & 1879048192UL));
      tmp___5 = zend_hash_find((HashTable const   *)target_symbol_table, (char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1), (void **)(& value));
      if (tmp___5 == (int __attribute__((__visibility__("default")))  )-1) {
        isset = (unsigned char)0;
      } else {

      }
    }
    if (1 << 1 != 1) {
      if ((unsigned int )varname == (unsigned int )(& tmp___0)) {
        _zval_dtor(& tmp___0);
      } else {

      }
    } else {

    }
    _zval_dtor(free_op1.var);
  }
  if (opline->extended_value & 33554432UL) {
    if (isset) {
      if ((int )(*value)->type != 0) {
        while (1) {
          __z = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
          __z->value.lval = 1L;
          __z->type = (unsigned char)3;
          break;
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      while (1) {
        __z___0 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
        __z___0->value.lval = 0L;
        __z___0->type = (unsigned char)3;
        break;
      }
    }
  } else {
    if (! isset) {
      goto _L___2;
    } else {
      tmp___6 = i_zend_is_true(*value);
      if (tmp___6) {
        while (1) {
          __z___2 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
          __z___2->value.lval = 0L;
          __z___2->type = (unsigned char)3;
          break;
        }
      } else {
        _L___2: /* CIL Label */ 
        while (1) {
          __z___1 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
          __z___1->value.lval = 1L;
          __z___1->type = (unsigned char)3;
          break;
        }
      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_SPEC_TMP_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  fast_add_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op1.var);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SUB_SPEC_TMP_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  fast_sub_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op1.var);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_MUL_SPEC_TMP_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  fast_mul_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op1.var);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_DIV_SPEC_TMP_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  fast_div_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op1.var);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_MOD_SPEC_TMP_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  fast_mod_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op1.var);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SL_SPEC_TMP_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  shift_left_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op1.var);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SR_SPEC_TMP_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  shift_right_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op1.var);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_CONCAT_SPEC_TMP_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  concat_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op1.var);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_IDENTICAL_SPEC_TMP_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  is_identical_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op1.var);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_NOT_IDENTICAL_SPEC_TMP_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *result ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  is_identical_function(result, tmp___0, tmp);
  result->value.lval = (long )(! result->value.lval);
  _zval_dtor(free_op1.var);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_EQUAL_SPEC_TMP_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  zval *tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    tmp___1 = fast_equal_function(result, tmp___0, tmp);
    __z->value.lval = (long )(tmp___1 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  _zval_dtor(free_op1.var);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_NOT_EQUAL_SPEC_TMP_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  zval *tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    tmp___1 = fast_not_equal_function(result, tmp___0, tmp);
    __z->value.lval = (long )(tmp___1 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  _zval_dtor(free_op1.var);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_SMALLER_SPEC_TMP_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  zval *tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    tmp___1 = fast_is_smaller_function(result, tmp___0, tmp);
    __z->value.lval = (long )(tmp___1 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  _zval_dtor(free_op1.var);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMP_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  zval *tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    tmp___1 = fast_is_smaller_or_equal_function(result, tmp___0, tmp);
    __z->value.lval = (long )(tmp___1 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  _zval_dtor(free_op1.var);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_OR_SPEC_TMP_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  bitwise_or_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op1.var);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_AND_SPEC_TMP_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  bitwise_and_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op1.var);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_XOR_SPEC_TMP_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  bitwise_xor_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op1.var);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BOOL_XOR_SPEC_TMP_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  boolean_xor_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op1.var);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_VAR_SPEC_TMP_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *str ;
  zval *var ;
  zval var_copy ;
  int use_copy ;

  {
  opline = execute_data->opline;
  str = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  use_copy = 0;
  var = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if (1 << 1 == 1 << 3) {
    str->value.str.val = (char *)((void *)0);
    str->value.str.len = 0;
    str->type = (unsigned char)6;
    str->refcount__gc = 1U;
    str->is_ref__gc = (unsigned char)0;
  } else {

  }
  if ((int )var->type != 6) {
    zend_make_printable_zval(var, & var_copy, & use_copy);
    if (use_copy) {
      var = & var_copy;
    } else {

    }
  } else {

  }
  add_string_to_string(str, (zval const   *)str, (zval const   *)var);
  if (use_copy) {
    _zval_dtor(var);
  } else {

  }
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_METHOD_CALL_SPEC_TMP_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *function_name ;
  char *function_name_strval ;
  int function_name_strlen ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  long tmp ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  zval *object ;
  long tmp___1 ;
  zend_literal *tmp___2 ;
  zend_class_entry *tmp___3 ;
  zend_class_entry *tmp___4 ;
  char const   *tmp___5 ;
  zend_class_entry *tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  zend_function *tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  zval *this_ptr ;
  void __attribute__((__visibility__("default")))  *tmp___13 ;
  zend_bool tmp___14 ;

  {
  opline = execute_data->opline;
  zend_ptr_stack_3_push(& executor_globals.arg_types_stack, (void *)execute_data->fbc, (void *)execute_data->object, (void *)execute_data->called_scope);
  function_name = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if (1 << 1 != 1) {
    tmp = __builtin_expect((long )((int )function_name->type != 6), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Method name must be a string");
    } else {

    }
  } else {

  }
  function_name_strval = function_name->value.str.val;
  function_name_strlen = function_name->value.str.len;
  execute_data->object = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  tmp___11 = __builtin_expect((long )((unsigned int )execute_data->object != (unsigned int )((void *)0)), 1L);
  if (tmp___11) {
    tmp___12 = __builtin_expect((long )((int )(execute_data->object)->type == 5), 1L);
    if (tmp___12) {
      tmp___0 = zend_get_class_entry((zval const   *)execute_data->object);
      execute_data->called_scope = (zend_class_entry *)tmp___0;
      if (1 << 1 != 1) {
        goto _L;
      } else {
        if ((unsigned int )*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) == (unsigned int )execute_data->called_scope) {
          tmp___10 = (zend_function *)*((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U));
        } else {
          tmp___10 = (zend_function *)((void *)0);
        }
        execute_data->fbc = tmp___10;
        if ((unsigned int )tmp___10 == (unsigned int )((void *)0)) {
          _L: /* CIL Label */ 
          object = execute_data->object;
          tmp___1 = __builtin_expect((long )((unsigned int )((execute_data->object)->value.obj.handlers)->get_method == (unsigned int )((void *)0)), 0L);
          if (tmp___1) {
            zend_error_noreturn(1, "Object does not support method calls");
          } else {

          }
          if (1 << 1 == 1) {
            tmp___2 = opline->op2.literal + 1;
          } else {
            tmp___2 = (zend_literal *)((void *)0);
          }
          execute_data->fbc = (*(((execute_data->object)->value.obj.handlers)->get_method))(& execute_data->object, function_name_strval, function_name_strlen, (struct _zend_literal  const  *)tmp___2);
          tmp___7 = __builtin_expect((long )((unsigned int )execute_data->fbc == (unsigned int )((void *)0)), 0L);
          if (tmp___7) {
            if (execute_data->object) {
              if ((int )(execute_data->object)->type == 5) {
                if ((unsigned int )((execute_data->object)->value.obj.handlers)->get_class_entry != (unsigned int )((void *)0)) {
                  tmp___6 = (*(((execute_data->object)->value.obj.handlers)->get_class_entry))((zval const   *)execute_data->object);
                  if (tmp___6) {
                    tmp___4 = (*(((execute_data->object)->value.obj.handlers)->get_class_entry))((zval const   *)execute_data->object);
                    tmp___5 = tmp___4->name;
                  } else {
                    tmp___5 = "";
                  }
                } else {
                  tmp___5 = "";
                }
              } else {
                tmp___5 = "";
              }
            } else {
              tmp___5 = "";
            }
            zend_error_noreturn(1, "Call to undefined method %s::%s()", tmp___5, function_name_strval);
          } else {

          }
          if (1 << 1 == 1) {
            tmp___8 = __builtin_expect((long )(((execute_data->fbc)->common.fn_flags & 6291456U) == 0U), 1L);
            if (tmp___8) {
              tmp___9 = __builtin_expect((long )((unsigned int )execute_data->object == (unsigned int )object), 1L);
              if (tmp___9) {
                while (1) {
                  *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)execute_data->called_scope;
                  *((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U)) = (void *)execute_data->fbc;
                  break;
                }
              } else {

              }
            } else {

            }
          } else {

          }
        } else {

        }
      }
    } else {
      zend_error_noreturn(1, "Call to a member function %s() on a non-object", function_name_strval);
    }
  } else {
    zend_error_noreturn(1, "Call to a member function %s() on a non-object", function_name_strval);
  }
  if (((execute_data->fbc)->common.fn_flags & 1U) != 0U) {
    execute_data->object = (zval *)((void *)0);
  } else {
    tmp___14 = zval_isref_p(execute_data->object);
    if (tmp___14) {
      while (1) {
        tmp___13 = _emalloc(sizeof(zval_gc_info ));
        this_ptr = (zval *)tmp___13;
        ((zval_gc_info *)this_ptr)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      while (1) {
        while (1) {
          this_ptr->value = (execute_data->object)->value;
          this_ptr->type = (execute_data->object)->type;
          break;
        }
        zval_set_refcount_p(this_ptr, 1U);
        zval_unset_isref_p(this_ptr);
        break;
      }
      _zval_copy_ctor(this_ptr);
      execute_data->object = this_ptr;
    } else {
      zval_addref_p(execute_data->object);
    }
  }
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_CASE_SPEC_TMP_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  if (1 << 1 == 1 << 2) {
    zval_addref_p(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr);
  } else {

  }
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  is_equal_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *expr_ptr ;
  zval **expr_ptr_ptr ;
  long tmp ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_uint tmp___1 ;
  zend_bool tmp___2 ;
  zval *new_expr ;
  void __attribute__((__visibility__("default")))  *tmp___3 ;
  zval *new_expr___0 ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_bool tmp___5 ;
  zend_free_op free_op2 ;
  zval *offset ;
  zval *tmp___6 ;
  ulong hval ;
  long tmp___7 ;
  register char const   *tmp___8 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___9 ;

  {
  opline = execute_data->opline;
  if (1 << 1 == 1 << 2) {
    goto _L___1;
  } else {
    if (1 << 1 == 1 << 4) {
      _L___1: /* CIL Label */ 
      if (opline->extended_value) {
        expr_ptr_ptr = (zval **)((void *)0);
        if (1 << 1 == 1 << 2) {
          tmp = __builtin_expect((long )((unsigned int )expr_ptr_ptr == (unsigned int )((void *)0)), 0L);
          if (tmp) {
            zend_error_noreturn(1, "Cannot create references to/from string offsets");
          } else {

          }
        } else {

        }
        tmp___2 = zval_isref_p(*expr_ptr_ptr);
        if (tmp___2) {

        } else {
          while (1) {
            tmp___1 = zval_refcount_p(*expr_ptr_ptr);
            if (tmp___1 > 1U) {
              zval_delref_p(*expr_ptr_ptr);
              while (1) {
                tmp___0 = _emalloc(sizeof(zval_gc_info ));
                new_zv = (zval *)tmp___0;
                ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv->value = (*expr_ptr_ptr)->value;
                  new_zv->type = (*expr_ptr_ptr)->type;
                  break;
                }
                zval_set_refcount_p(new_zv, 1U);
                zval_unset_isref_p(new_zv);
                break;
              }
              *expr_ptr_ptr = new_zv;
              _zval_copy_ctor(new_zv);
            } else {

            }
            break;
          }
          zval_set_isref_p(*expr_ptr_ptr);
        }
        expr_ptr = *expr_ptr_ptr;
        zval_addref_p(expr_ptr);
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      expr_ptr = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
      if (1) {
        while (1) {
          tmp___3 = _emalloc(sizeof(zval_gc_info ));
          new_expr = (zval *)tmp___3;
          ((zval_gc_info *)new_expr)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            new_expr->value = expr_ptr->value;
            new_expr->type = expr_ptr->type;
            break;
          }
          zval_set_refcount_p(new_expr, 1U);
          zval_unset_isref_p(new_expr);
          break;
        }
        expr_ptr = new_expr;
      } else {
        if (1 << 1 == 1) {
          goto _L;
        } else {
          tmp___5 = zval_isref_p(expr_ptr);
          if (tmp___5) {
            _L: /* CIL Label */ 
            while (1) {
              tmp___4 = _emalloc(sizeof(zval_gc_info ));
              new_expr___0 = (zval *)tmp___4;
              ((zval_gc_info *)new_expr___0)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_expr___0->value = expr_ptr->value;
                new_expr___0->type = expr_ptr->type;
                break;
              }
              zval_set_refcount_p(new_expr___0, 1U);
              zval_unset_isref_p(new_expr___0);
              break;
            }
            expr_ptr = new_expr___0;
            _zval_copy_ctor(expr_ptr);
          } else {
            zval_addref_p(expr_ptr);
          }
        }
      }
    }
  }
  if (1 << 1 != 1 << 3) {
    tmp___6 = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    offset = tmp___6;
    switch ((int )offset->type) {
    case 2: 
    tmp___7 = zend_dval_to_lval(offset->value.dval);
    hval = (unsigned long )tmp___7;
    goto num_index;
    case 1: 
    case 3: 
    hval = (unsigned long )offset->value.lval;
    num_index: 
    _zend_hash_index_update_or_next_insert(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, hval, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    case 6: 
    if (1 << 1 == 1) {
      hval = ((zend_literal *)offset)->hash_value;
    } else {
      while (1) {
        tmp___8 = (char const   *)offset->value.str.val;
        if ((int const   )*tmp___8 == 45) {
          tmp___8 ++;
        } else {

        }
        if ((int const   )*tmp___8 >= 48) {
          if ((int const   )*tmp___8 <= 57) {
            end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
            if ((int const   )*end != 0) {
              break;
            } else {
              if ((int const   )*tmp___8 == 48) {
                if (offset->value.str.len + 1 > 2) {
                  break;
                } else {
                  goto _L___2;
                }
              } else {
                _L___2: /* CIL Label */ 
                if (end - tmp___8 > 10) {
                  break;
                } else {
                  if (end - tmp___8 == 10) {
                    if ((int const   )*tmp___8 > 50) {
                      break;
                    } else {

                    }
                  } else {

                  }
                }
              }
            }
            hval = (unsigned long )((int const   )*tmp___8 - 48);
            while (1) {
              tmp___8 ++;
              if ((unsigned int )tmp___8 != (unsigned int )end) {
                if ((int const   )*tmp___8 >= 48) {
                  if ((int const   )*tmp___8 <= 57) {

                  } else {
                    break;
                  }
                } else {
                  break;
                }
              } else {
                break;
              }
              hval = hval * 10UL + (ulong )((int const   )*tmp___8 - 48);
            }
            if ((unsigned int )tmp___8 == (unsigned int )end) {
              if ((int )*(offset->value.str.val) == 45) {
                if (hval - 1UL > 2147483647UL) {
                  break;
                } else {

                }
                hval = (unsigned long )(- ((long )hval));
              } else {
                if (hval > 2147483647UL) {
                  break;
                } else {

                }
              }
              goto num_index;
            } else {

            }
          } else {

          }
        } else {

        }
        break;
      }
      if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
        if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
          hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
        } else {
          tmp___9 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___9;
        }
      } else {
        tmp___9 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
        hval = (unsigned long )tmp___9;
      }
    }
    _zend_hash_quick_add_or_update(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    case 0: 
    _zend_hash_add_or_update(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, "", sizeof(""), (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    default: 
    zend_error(1 << 1L, "Illegal offset type");
    i_zval_ptr_dtor(expr_ptr);
    break;
    }
    _zval_dtor(free_op2.var);
  } else {
    _zend_hash_index_update_or_next_insert(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, 0UL, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1 << 2);
  }
  if (1 << 1 == 1 << 2) {
    goto _L___3;
  } else {
    if (1 << 1 == 1 << 4) {
      _L___3: /* CIL Label */ 
      if (opline->extended_value) {

      } else {

      }
    } else {

    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_ARRAY_SPEC_TMP_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  int tmp ;

  {
  opline = execute_data->opline;
  _array_init(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, 0U);
  if (1 << 1 == 1 << 3) {
    (execute_data->opline) ++;
    return (0);
  } else {
    tmp = ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_TMP_HANDLER(execute_data);
    return (tmp);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_SPEC_TMP_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  fast_add_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op1.var);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SUB_SPEC_TMP_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  fast_sub_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op1.var);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_MUL_SPEC_TMP_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  fast_mul_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op1.var);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_DIV_SPEC_TMP_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  fast_div_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op1.var);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_MOD_SPEC_TMP_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  fast_mod_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op1.var);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SL_SPEC_TMP_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  shift_left_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op1.var);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SR_SPEC_TMP_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  shift_right_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op1.var);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_CONCAT_SPEC_TMP_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  concat_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op1.var);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_IDENTICAL_SPEC_TMP_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  is_identical_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op1.var);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_NOT_IDENTICAL_SPEC_TMP_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *result ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  is_identical_function(result, tmp___0, tmp);
  result->value.lval = (long )(! result->value.lval);
  _zval_dtor(free_op1.var);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_EQUAL_SPEC_TMP_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  zval *tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    tmp___1 = fast_equal_function(result, tmp___0, tmp);
    __z->value.lval = (long )(tmp___1 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  _zval_dtor(free_op1.var);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_NOT_EQUAL_SPEC_TMP_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  zval *tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    tmp___1 = fast_not_equal_function(result, tmp___0, tmp);
    __z->value.lval = (long )(tmp___1 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  _zval_dtor(free_op1.var);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_SMALLER_SPEC_TMP_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  zval *tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    tmp___1 = fast_is_smaller_function(result, tmp___0, tmp);
    __z->value.lval = (long )(tmp___1 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  _zval_dtor(free_op1.var);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMP_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  zval *tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    tmp___1 = fast_is_smaller_or_equal_function(result, tmp___0, tmp);
    __z->value.lval = (long )(tmp___1 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  _zval_dtor(free_op1.var);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_OR_SPEC_TMP_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  bitwise_or_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op1.var);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_AND_SPEC_TMP_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  bitwise_and_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op1.var);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_XOR_SPEC_TMP_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  bitwise_xor_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op1.var);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BOOL_XOR_SPEC_TMP_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  boolean_xor_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op1.var);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_fetch_var_address_helper_SPEC_TMP_VAR)(int type , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *varname ;
  zval **retval ;
  zval tmp_varname ;
  HashTable *target_symbol_table ;
  ulong hash_value ;
  long tmp ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_literal *tmp___1 ;
  zval __attribute__((__visibility__("default")))  **tmp___2 ;
  ulong __attribute__((__visibility__("default")))  tmp___3 ;
  int __attribute__((__visibility__("default")))  tmp___4 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  zend_uint tmp___6 ;
  zend_bool tmp___7 ;
  temp_variable *__t ;
  zend_free_op free_res ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___8 ;
  zend_uint tmp___9 ;
  zend_bool tmp___10 ;

  {
  opline = execute_data->opline;
  varname = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 1 != 1) {
    tmp = __builtin_expect((long )((int )varname->type != 6), 0L);
    if (tmp) {
      while (1) {
        tmp_varname.value = varname->value;
        tmp_varname.type = varname->type;
        break;
      }
      _zval_copy_ctor(& tmp_varname);
      zval_set_refcount_p(& tmp_varname, 1U);
      zval_unset_isref_p(& tmp_varname);
      if ((int )tmp_varname.type != 6) {
        _convert_to_string(& tmp_varname);
      } else {

      }
      varname = & tmp_varname;
    } else {

    }
  } else {

  }
  if (1 << 2 != 1 << 3) {
    if (1 << 2 == 1) {
      if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
        ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
      } else {
        tmp___0 = zend_fetch_class_by_name((char const   *)(opline->op2.zv)->value.str.val, (unsigned int )(opline->op2.zv)->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), 0);
        ce = (zend_class_entry *)tmp___0;
        while (1) {
          *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
          break;
        }
      }
    } else {
      ce = ((temp_variable *)((char *)execute_data->Ts + opline->op2.var))->class_entry;
    }
    if (1 << 1 == 1) {
      tmp___1 = opline->op1.literal;
    } else {
      tmp___1 = (zend_literal *)((void *)0);
    }
    tmp___2 = zend_std_get_static_property(ce, (char const   *)varname->value.str.val, varname->value.str.len, (unsigned char)0, (struct _zend_literal  const  *)tmp___1);
    retval = (zval **)tmp___2;
    _zval_dtor(free_op1.var);
  } else {
    target_symbol_table = zend_get_target_symbol_table((int )(opline->extended_value & 1879048192UL));
    if (1 << 1 == 1) {
      hash_value = ((zend_literal *)varname)->hash_value;
    } else {
      if ((unsigned int )varname->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
        if ((unsigned int )varname->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
          hash_value = ((Bucket *)(varname->value.str.val - sizeof(Bucket )))->h;
        } else {
          tmp___3 = zend_hash_func((char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1));
          hash_value = (unsigned long )tmp___3;
        }
      } else {
        tmp___3 = zend_hash_func((char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1));
        hash_value = (unsigned long )tmp___3;
      }
    }
    tmp___4 = zend_hash_quick_find((HashTable const   *)target_symbol_table, (char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1), hash_value, (void **)(& retval));
    if (tmp___4 == (int __attribute__((__visibility__("default")))  )-1) {
      switch (type) {
      case 0: 
      case 6: 
      zend_error(1 << 3L, "Undefined variable: %s", varname->value.str.val);
      case 3: 
      retval = & executor_globals.uninitialized_zval_ptr;
      break;
      case 2: 
      zend_error(1 << 3L, "Undefined variable: %s", varname->value.str.val);
      case 1: 
      zval_addref_p(& executor_globals.uninitialized_zval);
      _zend_hash_quick_add_or_update(target_symbol_table, (char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1), hash_value, (void *)(& executor_globals.uninitialized_zval_ptr), sizeof(zval *), (void **)(& retval), 1);
      break;
      }
    } else {

    }
    switch ((int )(opline->extended_value & 1879048192UL)) {
    case 0x00000000: 
    if (1 << 1 != 1 << 1) {
      _zval_dtor(free_op1.var);
    } else {

    }
    break;
    case 0x10000000: 
    _zval_dtor(free_op1.var);
    break;
    case 0x20000000: 
    zval_update_constant(retval, (void *)1);
    break;
    case 0x40000000: 
    if (1 << 1 == 1 << 2) {
      if (! free_op1.var) {
        zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr));
      } else {

      }
    } else {

    }
    break;
    }
  }
  if (1 << 1 != 1) {
    if ((unsigned int )varname == (unsigned int )(& tmp_varname)) {
      _zval_dtor(& tmp_varname);
    } else {

    }
  } else {

  }
  if (opline->extended_value & 67108864UL) {
    tmp___7 = zval_isref_p(*retval);
    if (tmp___7) {

    } else {
      while (1) {
        tmp___6 = zval_refcount_p(*retval);
        if (tmp___6 > 1U) {
          zval_delref_p(*retval);
          while (1) {
            tmp___5 = _emalloc(sizeof(zval_gc_info ));
            new_zv = (zval *)tmp___5;
            ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv->value = (*retval)->value;
              new_zv->type = (*retval)->type;
              break;
            }
            zval_set_refcount_p(new_zv, 1U);
            zval_unset_isref_p(new_zv);
            break;
          }
          *retval = new_zv;
          _zval_copy_ctor(new_zv);
        } else {

        }
        break;
      }
      zval_set_isref_p(*retval);
    }
  } else {

  }
  zval_addref_p(*retval);
  switch (type) {
  case 0: 
  case 3: 
  while (1) {
    __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
    __t->var.ptr = *retval;
    __t->var.ptr_ptr = & __t->var.ptr;
    break;
  }
  break;
  case 6: 
  zend_pzval_unlock_func(*retval, & free_res, 1);
  if ((unsigned int )retval != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
    tmp___10 = zval_isref_p(*retval);
    if (tmp___10) {

    } else {
      while (1) {
        tmp___9 = zval_refcount_p(*retval);
        if (tmp___9 > 1U) {
          zval_delref_p(*retval);
          while (1) {
            tmp___8 = _emalloc(sizeof(zval_gc_info ));
            new_zv___0 = (zval *)tmp___8;
            ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv___0->value = (*retval)->value;
              new_zv___0->type = (*retval)->type;
              break;
            }
            zval_set_refcount_p(new_zv___0, 1U);
            zval_unset_isref_p(new_zv___0);
            break;
          }
          *retval = new_zv___0;
          _zval_copy_ctor(new_zv___0);
        } else {

        }
        break;
      }
    }
  } else {

  }
  zval_addref_p(*retval);
  if (free_res.var) {
    i_zval_ptr_dtor(free_res.var);
  } else {

  }
  default: 
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = retval;
  break;
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_R_SPEC_TMP_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_TMP_VAR(0, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_W_SPEC_TMP_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_TMP_VAR(1, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_RW_SPEC_TMP_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_TMP_VAR(2, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_FUNC_ARG_SPEC_TMP_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  unsigned int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
  opline = execute_data->opline;
  if (execute_data->fbc) {
    if ((execute_data->fbc)->common.arg_info) {
      if ((opline->extended_value & 1048575UL) <= (unsigned long )(execute_data->fbc)->common.num_args) {
        tmp___1 = (unsigned int )((int )((execute_data->fbc)->common.arg_info + ((opline->extended_value & 1048575UL) - 1UL))->pass_by_reference & 3);
      } else {
        tmp___1 = (execute_data->fbc)->common.fn_flags & 50331648U;
      }
    } else {
      tmp___1 = (execute_data->fbc)->common.fn_flags & 50331648U;
    }
    if (tmp___1) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___2 = zend_fetch_var_address_helper_SPEC_TMP_VAR(tmp___0, execute_data);
  return (tmp___2);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_UNSET_SPEC_TMP_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_TMP_VAR(6, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_IS_SPEC_TMP_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_TMP_VAR(3, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_VAR_SPEC_TMP_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *str ;
  zval *var ;
  zval var_copy ;
  int use_copy ;

  {
  opline = execute_data->opline;
  str = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  use_copy = 0;
  var = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if (1 << 1 == 1 << 3) {
    str->value.str.val = (char *)((void *)0);
    str->value.str.len = 0;
    str->type = (unsigned char)6;
    str->refcount__gc = 1U;
    str->is_ref__gc = (unsigned char)0;
  } else {

  }
  if ((int )var->type != 6) {
    zend_make_printable_zval(var, & var_copy, & use_copy);
    if (use_copy) {
      var = & var_copy;
    } else {

    }
  } else {

  }
  add_string_to_string(str, (zval const   *)str, (zval const   *)var);
  if (use_copy) {
    _zval_dtor(var);
  } else {

  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_METHOD_CALL_SPEC_TMP_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *function_name ;
  char *function_name_strval ;
  int function_name_strlen ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  long tmp ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  zval *object ;
  long tmp___1 ;
  zend_literal *tmp___2 ;
  zend_class_entry *tmp___3 ;
  zend_class_entry *tmp___4 ;
  char const   *tmp___5 ;
  zend_class_entry *tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  zend_function *tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  zval *this_ptr ;
  void __attribute__((__visibility__("default")))  *tmp___13 ;
  zend_bool tmp___14 ;

  {
  opline = execute_data->opline;
  zend_ptr_stack_3_push(& executor_globals.arg_types_stack, (void *)execute_data->fbc, (void *)execute_data->object, (void *)execute_data->called_scope);
  function_name = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if (1 << 2 != 1) {
    tmp = __builtin_expect((long )((int )function_name->type != 6), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Method name must be a string");
    } else {

    }
  } else {

  }
  function_name_strval = function_name->value.str.val;
  function_name_strlen = function_name->value.str.len;
  execute_data->object = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  tmp___11 = __builtin_expect((long )((unsigned int )execute_data->object != (unsigned int )((void *)0)), 1L);
  if (tmp___11) {
    tmp___12 = __builtin_expect((long )((int )(execute_data->object)->type == 5), 1L);
    if (tmp___12) {
      tmp___0 = zend_get_class_entry((zval const   *)execute_data->object);
      execute_data->called_scope = (zend_class_entry *)tmp___0;
      if (1 << 2 != 1) {
        goto _L;
      } else {
        if ((unsigned int )*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) == (unsigned int )execute_data->called_scope) {
          tmp___10 = (zend_function *)*((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U));
        } else {
          tmp___10 = (zend_function *)((void *)0);
        }
        execute_data->fbc = tmp___10;
        if ((unsigned int )tmp___10 == (unsigned int )((void *)0)) {
          _L: /* CIL Label */ 
          object = execute_data->object;
          tmp___1 = __builtin_expect((long )((unsigned int )((execute_data->object)->value.obj.handlers)->get_method == (unsigned int )((void *)0)), 0L);
          if (tmp___1) {
            zend_error_noreturn(1, "Object does not support method calls");
          } else {

          }
          if (1 << 2 == 1) {
            tmp___2 = opline->op2.literal + 1;
          } else {
            tmp___2 = (zend_literal *)((void *)0);
          }
          execute_data->fbc = (*(((execute_data->object)->value.obj.handlers)->get_method))(& execute_data->object, function_name_strval, function_name_strlen, (struct _zend_literal  const  *)tmp___2);
          tmp___7 = __builtin_expect((long )((unsigned int )execute_data->fbc == (unsigned int )((void *)0)), 0L);
          if (tmp___7) {
            if (execute_data->object) {
              if ((int )(execute_data->object)->type == 5) {
                if ((unsigned int )((execute_data->object)->value.obj.handlers)->get_class_entry != (unsigned int )((void *)0)) {
                  tmp___6 = (*(((execute_data->object)->value.obj.handlers)->get_class_entry))((zval const   *)execute_data->object);
                  if (tmp___6) {
                    tmp___4 = (*(((execute_data->object)->value.obj.handlers)->get_class_entry))((zval const   *)execute_data->object);
                    tmp___5 = tmp___4->name;
                  } else {
                    tmp___5 = "";
                  }
                } else {
                  tmp___5 = "";
                }
              } else {
                tmp___5 = "";
              }
            } else {
              tmp___5 = "";
            }
            zend_error_noreturn(1, "Call to undefined method %s::%s()", tmp___5, function_name_strval);
          } else {

          }
          if (1 << 2 == 1) {
            tmp___8 = __builtin_expect((long )(((execute_data->fbc)->common.fn_flags & 6291456U) == 0U), 1L);
            if (tmp___8) {
              tmp___9 = __builtin_expect((long )((unsigned int )execute_data->object == (unsigned int )object), 1L);
              if (tmp___9) {
                while (1) {
                  *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)execute_data->called_scope;
                  *((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U)) = (void *)execute_data->fbc;
                  break;
                }
              } else {

              }
            } else {

            }
          } else {

          }
        } else {

        }
      }
    } else {
      zend_error_noreturn(1, "Call to a member function %s() on a non-object", function_name_strval);
    }
  } else {
    zend_error_noreturn(1, "Call to a member function %s() on a non-object", function_name_strval);
  }
  if (((execute_data->fbc)->common.fn_flags & 1U) != 0U) {
    execute_data->object = (zval *)((void *)0);
  } else {
    tmp___14 = zval_isref_p(execute_data->object);
    if (tmp___14) {
      while (1) {
        tmp___13 = _emalloc(sizeof(zval_gc_info ));
        this_ptr = (zval *)tmp___13;
        ((zval_gc_info *)this_ptr)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      while (1) {
        while (1) {
          this_ptr->value = (execute_data->object)->value;
          this_ptr->type = (execute_data->object)->type;
          break;
        }
        zval_set_refcount_p(this_ptr, 1U);
        zval_unset_isref_p(this_ptr);
        break;
      }
      _zval_copy_ctor(this_ptr);
      execute_data->object = this_ptr;
    } else {
      zval_addref_p(execute_data->object);
    }
  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_CASE_SPEC_TMP_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  if (1 << 1 == 1 << 2) {
    zval_addref_p(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr);
  } else {

  }
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  is_equal_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *expr_ptr ;
  zval **expr_ptr_ptr ;
  long tmp ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_uint tmp___1 ;
  zend_bool tmp___2 ;
  zval *new_expr ;
  void __attribute__((__visibility__("default")))  *tmp___3 ;
  zval *new_expr___0 ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_bool tmp___5 ;
  zend_free_op free_op2 ;
  zval *offset ;
  zval *tmp___6 ;
  ulong hval ;
  long tmp___7 ;
  register char const   *tmp___8 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___9 ;

  {
  opline = execute_data->opline;
  if (1 << 1 == 1 << 2) {
    goto _L___1;
  } else {
    if (1 << 1 == 1 << 4) {
      _L___1: /* CIL Label */ 
      if (opline->extended_value) {
        expr_ptr_ptr = (zval **)((void *)0);
        if (1 << 1 == 1 << 2) {
          tmp = __builtin_expect((long )((unsigned int )expr_ptr_ptr == (unsigned int )((void *)0)), 0L);
          if (tmp) {
            zend_error_noreturn(1, "Cannot create references to/from string offsets");
          } else {

          }
        } else {

        }
        tmp___2 = zval_isref_p(*expr_ptr_ptr);
        if (tmp___2) {

        } else {
          while (1) {
            tmp___1 = zval_refcount_p(*expr_ptr_ptr);
            if (tmp___1 > 1U) {
              zval_delref_p(*expr_ptr_ptr);
              while (1) {
                tmp___0 = _emalloc(sizeof(zval_gc_info ));
                new_zv = (zval *)tmp___0;
                ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv->value = (*expr_ptr_ptr)->value;
                  new_zv->type = (*expr_ptr_ptr)->type;
                  break;
                }
                zval_set_refcount_p(new_zv, 1U);
                zval_unset_isref_p(new_zv);
                break;
              }
              *expr_ptr_ptr = new_zv;
              _zval_copy_ctor(new_zv);
            } else {

            }
            break;
          }
          zval_set_isref_p(*expr_ptr_ptr);
        }
        expr_ptr = *expr_ptr_ptr;
        zval_addref_p(expr_ptr);
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      expr_ptr = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
      if (1) {
        while (1) {
          tmp___3 = _emalloc(sizeof(zval_gc_info ));
          new_expr = (zval *)tmp___3;
          ((zval_gc_info *)new_expr)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            new_expr->value = expr_ptr->value;
            new_expr->type = expr_ptr->type;
            break;
          }
          zval_set_refcount_p(new_expr, 1U);
          zval_unset_isref_p(new_expr);
          break;
        }
        expr_ptr = new_expr;
      } else {
        if (1 << 1 == 1) {
          goto _L;
        } else {
          tmp___5 = zval_isref_p(expr_ptr);
          if (tmp___5) {
            _L: /* CIL Label */ 
            while (1) {
              tmp___4 = _emalloc(sizeof(zval_gc_info ));
              new_expr___0 = (zval *)tmp___4;
              ((zval_gc_info *)new_expr___0)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_expr___0->value = expr_ptr->value;
                new_expr___0->type = expr_ptr->type;
                break;
              }
              zval_set_refcount_p(new_expr___0, 1U);
              zval_unset_isref_p(new_expr___0);
              break;
            }
            expr_ptr = new_expr___0;
            _zval_copy_ctor(expr_ptr);
          } else {
            zval_addref_p(expr_ptr);
          }
        }
      }
    }
  }
  if (1 << 2 != 1 << 3) {
    tmp___6 = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    offset = tmp___6;
    switch ((int )offset->type) {
    case 2: 
    tmp___7 = zend_dval_to_lval(offset->value.dval);
    hval = (unsigned long )tmp___7;
    goto num_index;
    case 1: 
    case 3: 
    hval = (unsigned long )offset->value.lval;
    num_index: 
    _zend_hash_index_update_or_next_insert(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, hval, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    case 6: 
    if (1 << 2 == 1) {
      hval = ((zend_literal *)offset)->hash_value;
    } else {
      while (1) {
        tmp___8 = (char const   *)offset->value.str.val;
        if ((int const   )*tmp___8 == 45) {
          tmp___8 ++;
        } else {

        }
        if ((int const   )*tmp___8 >= 48) {
          if ((int const   )*tmp___8 <= 57) {
            end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
            if ((int const   )*end != 0) {
              break;
            } else {
              if ((int const   )*tmp___8 == 48) {
                if (offset->value.str.len + 1 > 2) {
                  break;
                } else {
                  goto _L___2;
                }
              } else {
                _L___2: /* CIL Label */ 
                if (end - tmp___8 > 10) {
                  break;
                } else {
                  if (end - tmp___8 == 10) {
                    if ((int const   )*tmp___8 > 50) {
                      break;
                    } else {

                    }
                  } else {

                  }
                }
              }
            }
            hval = (unsigned long )((int const   )*tmp___8 - 48);
            while (1) {
              tmp___8 ++;
              if ((unsigned int )tmp___8 != (unsigned int )end) {
                if ((int const   )*tmp___8 >= 48) {
                  if ((int const   )*tmp___8 <= 57) {

                  } else {
                    break;
                  }
                } else {
                  break;
                }
              } else {
                break;
              }
              hval = hval * 10UL + (ulong )((int const   )*tmp___8 - 48);
            }
            if ((unsigned int )tmp___8 == (unsigned int )end) {
              if ((int )*(offset->value.str.val) == 45) {
                if (hval - 1UL > 2147483647UL) {
                  break;
                } else {

                }
                hval = (unsigned long )(- ((long )hval));
              } else {
                if (hval > 2147483647UL) {
                  break;
                } else {

                }
              }
              goto num_index;
            } else {

            }
          } else {

          }
        } else {

        }
        break;
      }
      if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
        if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
          hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
        } else {
          tmp___9 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___9;
        }
      } else {
        tmp___9 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
        hval = (unsigned long )tmp___9;
      }
    }
    _zend_hash_quick_add_or_update(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    case 0: 
    _zend_hash_add_or_update(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, "", sizeof(""), (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    default: 
    zend_error(1 << 1L, "Illegal offset type");
    i_zval_ptr_dtor(expr_ptr);
    break;
    }
    if (free_op2.var) {
      i_zval_ptr_dtor(free_op2.var);
    } else {

    }
  } else {
    _zend_hash_index_update_or_next_insert(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, 0UL, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1 << 2);
  }
  if (1 << 1 == 1 << 2) {
    goto _L___3;
  } else {
    if (1 << 1 == 1 << 4) {
      _L___3: /* CIL Label */ 
      if (opline->extended_value) {

      } else {

      }
    } else {

    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_ARRAY_SPEC_TMP_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  int tmp ;

  {
  opline = execute_data->opline;
  _array_init(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, 0U);
  if (1 << 1 == 1 << 3) {
    (execute_data->opline) ++;
    return (0);
  } else {
    tmp = ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_VAR_HANDLER(execute_data);
    return (tmp);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_UNSET_VAR_SPEC_TMP_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval tmp ;
  zval *varname ;
  HashTable *target_symbol_table ;
  zend_free_op free_op1 ;
  zend_compiled_variable *cv ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_literal *tmp___1 ;
  ulong hash_value ;
  ulong tmp___2 ;

  {
  opline = execute_data->opline;
  if (1 << 1 == 1 << 4) {
    if (1 << 2 == 1 << 3) {
      if (opline->extended_value & 8388608UL) {
        if (executor_globals.active_symbol_table) {
          cv = (executor_globals.active_op_array)->vars + opline->op1.var;
          zend_delete_variable(execute_data->prev_execute_data, executor_globals.active_symbol_table, cv->name, cv->name_len + 1, cv->hash_value);
          *(execute_data->CVs + opline->op1.var) = (zval **)((void *)0);
        } else {
          if (*(execute_data->CVs + opline->op1.var)) {
            i_zval_ptr_dtor(*(*(execute_data->CVs + opline->op1.var)));
            *(execute_data->CVs + opline->op1.var) = (zval **)((void *)0);
          } else {

          }
        }
        (execute_data->opline) ++;
        return (0);
      } else {

      }
    } else {

    }
  } else {

  }
  varname = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 1 != 1) {
    if ((int )varname->type != 6) {
      while (1) {
        tmp.value = varname->value;
        tmp.type = varname->type;
        break;
      }
      _zval_copy_ctor(& tmp);
      if ((int )tmp.type != 6) {
        _convert_to_string(& tmp);
      } else {

      }
      varname = & tmp;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if (1 << 1 == 1 << 2) {
      zval_addref_p(varname);
    } else {
      if (1 << 1 == 1 << 4) {
        zval_addref_p(varname);
      } else {

      }
    }
  }
  if (1 << 2 != 1 << 3) {
    if (1 << 2 == 1) {
      if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
        ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
      } else {
        tmp___0 = zend_fetch_class_by_name((char const   *)(opline->op2.zv)->value.str.val, (unsigned int )(opline->op2.zv)->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), 0);
        ce = (zend_class_entry *)tmp___0;
        while (1) {
          *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
          break;
        }
      }
    } else {
      ce = ((temp_variable *)((char *)execute_data->Ts + opline->op2.var))->class_entry;
    }
    if (1 << 1 == 1) {
      tmp___1 = opline->op1.literal;
    } else {
      tmp___1 = (zend_literal *)((void *)0);
    }
    zend_std_unset_static_property(ce, (char const   *)varname->value.str.val, varname->value.str.len, (struct _zend_literal  const  *)tmp___1);
  } else {
    tmp___2 = zend_inline_hash_func((char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1));
    hash_value = tmp___2;
    target_symbol_table = zend_get_target_symbol_table((int )(opline->extended_value & 1879048192UL));
    zend_delete_variable(execute_data, target_symbol_table, (char const   *)varname->value.str.val, varname->value.str.len + 1, hash_value);
  }
  if (1 << 1 != 1) {
    if ((unsigned int )varname == (unsigned int )(& tmp)) {
      _zval_dtor(& tmp);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if (1 << 1 == 1 << 2) {
      i_zval_ptr_dtor(varname);
    } else {
      if (1 << 1 == 1 << 4) {
        i_zval_ptr_dtor(varname);
      } else {

      }
    }
  }
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ISSET_ISEMPTY_VAR_SPEC_TMP_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **value ;
  zend_bool isset ;
  zend_compiled_variable *cv ;
  int __attribute__((__visibility__("default")))  tmp ;
  HashTable *target_symbol_table ;
  zend_free_op free_op1 ;
  zval tmp___0 ;
  zval *varname ;
  zval *tmp___1 ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_literal *tmp___3 ;
  zval __attribute__((__visibility__("default")))  **tmp___4 ;
  int __attribute__((__visibility__("default")))  tmp___5 ;
  zval *__z ;
  zval *__z___0 ;
  zval *__z___1 ;
  zval *__z___2 ;
  int tmp___6 ;

  {
  opline = execute_data->opline;
  isset = (zend_bool )1;
  if (1 << 1 == 1 << 4) {
    if (1 << 2 == 1 << 3) {
      if (opline->extended_value & 8388608UL) {
        if (*(execute_data->CVs + opline->op1.var)) {
          value = *(execute_data->CVs + opline->op1.var);
        } else {
          if (executor_globals.active_symbol_table) {
            cv = (executor_globals.active_op_array)->vars + opline->op1.var;
            tmp = zend_hash_quick_find((HashTable const   *)executor_globals.active_symbol_table, cv->name, (unsigned int )(cv->name_len + 1), cv->hash_value, (void **)(& value));
            if (tmp == (int __attribute__((__visibility__("default")))  )-1) {
              isset = (unsigned char)0;
            } else {

            }
          } else {
            isset = (unsigned char)0;
          }
        }
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    _L: /* CIL Label */ 
    tmp___1 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    varname = tmp___1;
    if (1 << 1 != 1) {
      if ((int )varname->type != 6) {
        while (1) {
          tmp___0.value = varname->value;
          tmp___0.type = varname->type;
          break;
        }
        _zval_copy_ctor(& tmp___0);
        if ((int )tmp___0.type != 6) {
          _convert_to_string(& tmp___0);
        } else {

        }
        varname = & tmp___0;
      } else {

      }
    } else {

    }
    if (1 << 2 != 1 << 3) {
      if (1 << 2 == 1) {
        if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
          ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
        } else {
          tmp___2 = zend_fetch_class_by_name((char const   *)(opline->op2.zv)->value.str.val, (unsigned int )(opline->op2.zv)->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), 0);
          ce = (zend_class_entry *)tmp___2;
          while (1) {
            *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
            break;
          }
        }
      } else {
        ce = ((temp_variable *)((char *)execute_data->Ts + opline->op2.var))->class_entry;
      }
      if (1 << 1 == 1) {
        tmp___3 = opline->op1.literal;
      } else {
        tmp___3 = (zend_literal *)((void *)0);
      }
      tmp___4 = zend_std_get_static_property(ce, (char const   *)varname->value.str.val, varname->value.str.len, (unsigned char)1, (struct _zend_literal  const  *)tmp___3);
      value = (zval **)tmp___4;
      if (! value) {
        isset = (unsigned char)0;
      } else {

      }
    } else {
      target_symbol_table = zend_get_target_symbol_table((int )(opline->extended_value & 1879048192UL));
      tmp___5 = zend_hash_find((HashTable const   *)target_symbol_table, (char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1), (void **)(& value));
      if (tmp___5 == (int __attribute__((__visibility__("default")))  )-1) {
        isset = (unsigned char)0;
      } else {

      }
    }
    if (1 << 1 != 1) {
      if ((unsigned int )varname == (unsigned int )(& tmp___0)) {
        _zval_dtor(& tmp___0);
      } else {

      }
    } else {

    }
    _zval_dtor(free_op1.var);
  }
  if (opline->extended_value & 33554432UL) {
    if (isset) {
      if ((int )(*value)->type != 0) {
        while (1) {
          __z = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
          __z->value.lval = 1L;
          __z->type = (unsigned char)3;
          break;
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      while (1) {
        __z___0 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
        __z___0->value.lval = 0L;
        __z___0->type = (unsigned char)3;
        break;
      }
    }
  } else {
    if (! isset) {
      goto _L___2;
    } else {
      tmp___6 = i_zend_is_true(*value);
      if (tmp___6) {
        while (1) {
          __z___2 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
          __z___2->value.lval = 0L;
          __z___2->type = (unsigned char)3;
          break;
        }
      } else {
        _L___2: /* CIL Label */ 
        while (1) {
          __z___1 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
          __z___1->value.lval = 1L;
          __z___1->type = (unsigned char)3;
          break;
        }
      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_fetch_var_address_helper_SPEC_TMP_UNUSED)(int type , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *varname ;
  zval **retval ;
  zval tmp_varname ;
  HashTable *target_symbol_table ;
  ulong hash_value ;
  long tmp ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_literal *tmp___1 ;
  zval __attribute__((__visibility__("default")))  **tmp___2 ;
  ulong __attribute__((__visibility__("default")))  tmp___3 ;
  int __attribute__((__visibility__("default")))  tmp___4 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  zend_uint tmp___6 ;
  zend_bool tmp___7 ;
  temp_variable *__t ;
  zend_free_op free_res ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___8 ;
  zend_uint tmp___9 ;
  zend_bool tmp___10 ;

  {
  opline = execute_data->opline;
  varname = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 1 != 1) {
    tmp = __builtin_expect((long )((int )varname->type != 6), 0L);
    if (tmp) {
      while (1) {
        tmp_varname.value = varname->value;
        tmp_varname.type = varname->type;
        break;
      }
      _zval_copy_ctor(& tmp_varname);
      zval_set_refcount_p(& tmp_varname, 1U);
      zval_unset_isref_p(& tmp_varname);
      if ((int )tmp_varname.type != 6) {
        _convert_to_string(& tmp_varname);
      } else {

      }
      varname = & tmp_varname;
    } else {

    }
  } else {

  }
  if (1 << 3 != 1 << 3) {
    if (1 << 3 == 1) {
      if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
        ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
      } else {
        tmp___0 = zend_fetch_class_by_name((char const   *)(opline->op2.zv)->value.str.val, (unsigned int )(opline->op2.zv)->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), 0);
        ce = (zend_class_entry *)tmp___0;
        while (1) {
          *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
          break;
        }
      }
    } else {
      ce = ((temp_variable *)((char *)execute_data->Ts + opline->op2.var))->class_entry;
    }
    if (1 << 1 == 1) {
      tmp___1 = opline->op1.literal;
    } else {
      tmp___1 = (zend_literal *)((void *)0);
    }
    tmp___2 = zend_std_get_static_property(ce, (char const   *)varname->value.str.val, varname->value.str.len, (unsigned char)0, (struct _zend_literal  const  *)tmp___1);
    retval = (zval **)tmp___2;
    _zval_dtor(free_op1.var);
  } else {
    target_symbol_table = zend_get_target_symbol_table((int )(opline->extended_value & 1879048192UL));
    if (1 << 1 == 1) {
      hash_value = ((zend_literal *)varname)->hash_value;
    } else {
      if ((unsigned int )varname->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
        if ((unsigned int )varname->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
          hash_value = ((Bucket *)(varname->value.str.val - sizeof(Bucket )))->h;
        } else {
          tmp___3 = zend_hash_func((char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1));
          hash_value = (unsigned long )tmp___3;
        }
      } else {
        tmp___3 = zend_hash_func((char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1));
        hash_value = (unsigned long )tmp___3;
      }
    }
    tmp___4 = zend_hash_quick_find((HashTable const   *)target_symbol_table, (char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1), hash_value, (void **)(& retval));
    if (tmp___4 == (int __attribute__((__visibility__("default")))  )-1) {
      switch (type) {
      case 0: 
      case 6: 
      zend_error(1 << 3L, "Undefined variable: %s", varname->value.str.val);
      case 3: 
      retval = & executor_globals.uninitialized_zval_ptr;
      break;
      case 2: 
      zend_error(1 << 3L, "Undefined variable: %s", varname->value.str.val);
      case 1: 
      zval_addref_p(& executor_globals.uninitialized_zval);
      _zend_hash_quick_add_or_update(target_symbol_table, (char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1), hash_value, (void *)(& executor_globals.uninitialized_zval_ptr), sizeof(zval *), (void **)(& retval), 1);
      break;
      }
    } else {

    }
    switch ((int )(opline->extended_value & 1879048192UL)) {
    case 0x00000000: 
    if (1 << 1 != 1 << 1) {
      _zval_dtor(free_op1.var);
    } else {

    }
    break;
    case 0x10000000: 
    _zval_dtor(free_op1.var);
    break;
    case 0x20000000: 
    zval_update_constant(retval, (void *)1);
    break;
    case 0x40000000: 
    if (1 << 1 == 1 << 2) {
      if (! free_op1.var) {
        zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr));
      } else {

      }
    } else {

    }
    break;
    }
  }
  if (1 << 1 != 1) {
    if ((unsigned int )varname == (unsigned int )(& tmp_varname)) {
      _zval_dtor(& tmp_varname);
    } else {

    }
  } else {

  }
  if (opline->extended_value & 67108864UL) {
    tmp___7 = zval_isref_p(*retval);
    if (tmp___7) {

    } else {
      while (1) {
        tmp___6 = zval_refcount_p(*retval);
        if (tmp___6 > 1U) {
          zval_delref_p(*retval);
          while (1) {
            tmp___5 = _emalloc(sizeof(zval_gc_info ));
            new_zv = (zval *)tmp___5;
            ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv->value = (*retval)->value;
              new_zv->type = (*retval)->type;
              break;
            }
            zval_set_refcount_p(new_zv, 1U);
            zval_unset_isref_p(new_zv);
            break;
          }
          *retval = new_zv;
          _zval_copy_ctor(new_zv);
        } else {

        }
        break;
      }
      zval_set_isref_p(*retval);
    }
  } else {

  }
  zval_addref_p(*retval);
  switch (type) {
  case 0: 
  case 3: 
  while (1) {
    __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
    __t->var.ptr = *retval;
    __t->var.ptr_ptr = & __t->var.ptr;
    break;
  }
  break;
  case 6: 
  zend_pzval_unlock_func(*retval, & free_res, 1);
  if ((unsigned int )retval != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
    tmp___10 = zval_isref_p(*retval);
    if (tmp___10) {

    } else {
      while (1) {
        tmp___9 = zval_refcount_p(*retval);
        if (tmp___9 > 1U) {
          zval_delref_p(*retval);
          while (1) {
            tmp___8 = _emalloc(sizeof(zval_gc_info ));
            new_zv___0 = (zval *)tmp___8;
            ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv___0->value = (*retval)->value;
              new_zv___0->type = (*retval)->type;
              break;
            }
            zval_set_refcount_p(new_zv___0, 1U);
            zval_unset_isref_p(new_zv___0);
            break;
          }
          *retval = new_zv___0;
          _zval_copy_ctor(new_zv___0);
        } else {

        }
        break;
      }
    }
  } else {

  }
  zval_addref_p(*retval);
  if (free_res.var) {
    i_zval_ptr_dtor(free_res.var);
  } else {

  }
  default: 
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = retval;
  break;
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_R_SPEC_TMP_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_TMP_UNUSED(0, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_W_SPEC_TMP_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_TMP_UNUSED(1, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_RW_SPEC_TMP_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_TMP_UNUSED(2, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_FUNC_ARG_SPEC_TMP_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  unsigned int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
  opline = execute_data->opline;
  if (execute_data->fbc) {
    if ((execute_data->fbc)->common.arg_info) {
      if ((opline->extended_value & 1048575UL) <= (unsigned long )(execute_data->fbc)->common.num_args) {
        tmp___1 = (unsigned int )((int )((execute_data->fbc)->common.arg_info + ((opline->extended_value & 1048575UL) - 1UL))->pass_by_reference & 3);
      } else {
        tmp___1 = (execute_data->fbc)->common.fn_flags & 50331648U;
      }
    } else {
      tmp___1 = (execute_data->fbc)->common.fn_flags & 50331648U;
    }
    if (tmp___1) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___2 = zend_fetch_var_address_helper_SPEC_TMP_UNUSED(tmp___0, execute_data);
  return (tmp___2);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_UNSET_SPEC_TMP_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_TMP_UNUSED(6, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_IS_SPEC_TMP_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_TMP_UNUSED(3, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *expr_ptr ;
  zval **expr_ptr_ptr ;
  long tmp ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_uint tmp___1 ;
  zend_bool tmp___2 ;
  zval *new_expr ;
  void __attribute__((__visibility__("default")))  *tmp___3 ;
  zval *new_expr___0 ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_bool tmp___5 ;
  zval *offset ;
  ulong hval ;
  long tmp___6 ;
  register char const   *tmp___7 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___8 ;

  {
  opline = execute_data->opline;
  if (1 << 1 == 1 << 2) {
    goto _L___1;
  } else {
    if (1 << 1 == 1 << 4) {
      _L___1: /* CIL Label */ 
      if (opline->extended_value) {
        expr_ptr_ptr = (zval **)((void *)0);
        if (1 << 1 == 1 << 2) {
          tmp = __builtin_expect((long )((unsigned int )expr_ptr_ptr == (unsigned int )((void *)0)), 0L);
          if (tmp) {
            zend_error_noreturn(1, "Cannot create references to/from string offsets");
          } else {

          }
        } else {

        }
        tmp___2 = zval_isref_p(*expr_ptr_ptr);
        if (tmp___2) {

        } else {
          while (1) {
            tmp___1 = zval_refcount_p(*expr_ptr_ptr);
            if (tmp___1 > 1U) {
              zval_delref_p(*expr_ptr_ptr);
              while (1) {
                tmp___0 = _emalloc(sizeof(zval_gc_info ));
                new_zv = (zval *)tmp___0;
                ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv->value = (*expr_ptr_ptr)->value;
                  new_zv->type = (*expr_ptr_ptr)->type;
                  break;
                }
                zval_set_refcount_p(new_zv, 1U);
                zval_unset_isref_p(new_zv);
                break;
              }
              *expr_ptr_ptr = new_zv;
              _zval_copy_ctor(new_zv);
            } else {

            }
            break;
          }
          zval_set_isref_p(*expr_ptr_ptr);
        }
        expr_ptr = *expr_ptr_ptr;
        zval_addref_p(expr_ptr);
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      expr_ptr = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
      if (1) {
        while (1) {
          tmp___3 = _emalloc(sizeof(zval_gc_info ));
          new_expr = (zval *)tmp___3;
          ((zval_gc_info *)new_expr)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            new_expr->value = expr_ptr->value;
            new_expr->type = expr_ptr->type;
            break;
          }
          zval_set_refcount_p(new_expr, 1U);
          zval_unset_isref_p(new_expr);
          break;
        }
        expr_ptr = new_expr;
      } else {
        if (1 << 1 == 1) {
          goto _L;
        } else {
          tmp___5 = zval_isref_p(expr_ptr);
          if (tmp___5) {
            _L: /* CIL Label */ 
            while (1) {
              tmp___4 = _emalloc(sizeof(zval_gc_info ));
              new_expr___0 = (zval *)tmp___4;
              ((zval_gc_info *)new_expr___0)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_expr___0->value = expr_ptr->value;
                new_expr___0->type = expr_ptr->type;
                break;
              }
              zval_set_refcount_p(new_expr___0, 1U);
              zval_unset_isref_p(new_expr___0);
              break;
            }
            expr_ptr = new_expr___0;
            _zval_copy_ctor(expr_ptr);
          } else {
            zval_addref_p(expr_ptr);
          }
        }
      }
    }
  }
  if (1 << 3 != 1 << 3) {
    offset = (zval *)((void *)0);
    switch ((int )offset->type) {
    case 2: 
    tmp___6 = zend_dval_to_lval(offset->value.dval);
    hval = (unsigned long )tmp___6;
    goto num_index;
    case 1: 
    case 3: 
    hval = (unsigned long )offset->value.lval;
    num_index: 
    _zend_hash_index_update_or_next_insert(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, hval, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    case 6: 
    if (1 << 3 == 1) {
      hval = ((zend_literal *)offset)->hash_value;
    } else {
      while (1) {
        tmp___7 = (char const   *)offset->value.str.val;
        if ((int const   )*tmp___7 == 45) {
          tmp___7 ++;
        } else {

        }
        if ((int const   )*tmp___7 >= 48) {
          if ((int const   )*tmp___7 <= 57) {
            end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
            if ((int const   )*end != 0) {
              break;
            } else {
              if ((int const   )*tmp___7 == 48) {
                if (offset->value.str.len + 1 > 2) {
                  break;
                } else {
                  goto _L___2;
                }
              } else {
                _L___2: /* CIL Label */ 
                if (end - tmp___7 > 10) {
                  break;
                } else {
                  if (end - tmp___7 == 10) {
                    if ((int const   )*tmp___7 > 50) {
                      break;
                    } else {

                    }
                  } else {

                  }
                }
              }
            }
            hval = (unsigned long )((int const   )*tmp___7 - 48);
            while (1) {
              tmp___7 ++;
              if ((unsigned int )tmp___7 != (unsigned int )end) {
                if ((int const   )*tmp___7 >= 48) {
                  if ((int const   )*tmp___7 <= 57) {

                  } else {
                    break;
                  }
                } else {
                  break;
                }
              } else {
                break;
              }
              hval = hval * 10UL + (ulong )((int const   )*tmp___7 - 48);
            }
            if ((unsigned int )tmp___7 == (unsigned int )end) {
              if ((int )*(offset->value.str.val) == 45) {
                if (hval - 1UL > 2147483647UL) {
                  break;
                } else {

                }
                hval = (unsigned long )(- ((long )hval));
              } else {
                if (hval > 2147483647UL) {
                  break;
                } else {

                }
              }
              goto num_index;
            } else {

            }
          } else {

          }
        } else {

        }
        break;
      }
      if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
        if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
          hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
        } else {
          tmp___8 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___8;
        }
      } else {
        tmp___8 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
        hval = (unsigned long )tmp___8;
      }
    }
    _zend_hash_quick_add_or_update(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    case 0: 
    _zend_hash_add_or_update(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, "", sizeof(""), (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    default: 
    zend_error(1 << 1L, "Illegal offset type");
    i_zval_ptr_dtor(expr_ptr);
    break;
    }
  } else {
    _zend_hash_index_update_or_next_insert(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, 0UL, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1 << 2);
  }
  if (1 << 1 == 1 << 2) {
    goto _L___3;
  } else {
    if (1 << 1 == 1 << 4) {
      _L___3: /* CIL Label */ 
      if (opline->extended_value) {

      } else {

      }
    } else {

    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_ARRAY_SPEC_TMP_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  int tmp ;

  {
  opline = execute_data->opline;
  _array_init(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, 0U);
  if (1 << 1 == 1 << 3) {
    (execute_data->opline) ++;
    return (0);
  } else {
    tmp = ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_UNUSED_HANDLER(execute_data);
    return (tmp);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_UNSET_VAR_SPEC_TMP_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval tmp ;
  zval *varname ;
  HashTable *target_symbol_table ;
  zend_free_op free_op1 ;
  zend_compiled_variable *cv ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_literal *tmp___1 ;
  ulong hash_value ;
  ulong tmp___2 ;

  {
  opline = execute_data->opline;
  if (1 << 1 == 1 << 4) {
    if (1 << 3 == 1 << 3) {
      if (opline->extended_value & 8388608UL) {
        if (executor_globals.active_symbol_table) {
          cv = (executor_globals.active_op_array)->vars + opline->op1.var;
          zend_delete_variable(execute_data->prev_execute_data, executor_globals.active_symbol_table, cv->name, cv->name_len + 1, cv->hash_value);
          *(execute_data->CVs + opline->op1.var) = (zval **)((void *)0);
        } else {
          if (*(execute_data->CVs + opline->op1.var)) {
            i_zval_ptr_dtor(*(*(execute_data->CVs + opline->op1.var)));
            *(execute_data->CVs + opline->op1.var) = (zval **)((void *)0);
          } else {

          }
        }
        (execute_data->opline) ++;
        return (0);
      } else {

      }
    } else {

    }
  } else {

  }
  varname = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 1 != 1) {
    if ((int )varname->type != 6) {
      while (1) {
        tmp.value = varname->value;
        tmp.type = varname->type;
        break;
      }
      _zval_copy_ctor(& tmp);
      if ((int )tmp.type != 6) {
        _convert_to_string(& tmp);
      } else {

      }
      varname = & tmp;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if (1 << 1 == 1 << 2) {
      zval_addref_p(varname);
    } else {
      if (1 << 1 == 1 << 4) {
        zval_addref_p(varname);
      } else {

      }
    }
  }
  if (1 << 3 != 1 << 3) {
    if (1 << 3 == 1) {
      if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
        ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
      } else {
        tmp___0 = zend_fetch_class_by_name((char const   *)(opline->op2.zv)->value.str.val, (unsigned int )(opline->op2.zv)->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), 0);
        ce = (zend_class_entry *)tmp___0;
        while (1) {
          *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
          break;
        }
      }
    } else {
      ce = ((temp_variable *)((char *)execute_data->Ts + opline->op2.var))->class_entry;
    }
    if (1 << 1 == 1) {
      tmp___1 = opline->op1.literal;
    } else {
      tmp___1 = (zend_literal *)((void *)0);
    }
    zend_std_unset_static_property(ce, (char const   *)varname->value.str.val, varname->value.str.len, (struct _zend_literal  const  *)tmp___1);
  } else {
    tmp___2 = zend_inline_hash_func((char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1));
    hash_value = tmp___2;
    target_symbol_table = zend_get_target_symbol_table((int )(opline->extended_value & 1879048192UL));
    zend_delete_variable(execute_data, target_symbol_table, (char const   *)varname->value.str.val, varname->value.str.len + 1, hash_value);
  }
  if (1 << 1 != 1) {
    if ((unsigned int )varname == (unsigned int )(& tmp)) {
      _zval_dtor(& tmp);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if (1 << 1 == 1 << 2) {
      i_zval_ptr_dtor(varname);
    } else {
      if (1 << 1 == 1 << 4) {
        i_zval_ptr_dtor(varname);
      } else {

      }
    }
  }
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ISSET_ISEMPTY_VAR_SPEC_TMP_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **value ;
  zend_bool isset ;
  zend_compiled_variable *cv ;
  int __attribute__((__visibility__("default")))  tmp ;
  HashTable *target_symbol_table ;
  zend_free_op free_op1 ;
  zval tmp___0 ;
  zval *varname ;
  zval *tmp___1 ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_literal *tmp___3 ;
  zval __attribute__((__visibility__("default")))  **tmp___4 ;
  int __attribute__((__visibility__("default")))  tmp___5 ;
  zval *__z ;
  zval *__z___0 ;
  zval *__z___1 ;
  zval *__z___2 ;
  int tmp___6 ;

  {
  opline = execute_data->opline;
  isset = (zend_bool )1;
  if (1 << 1 == 1 << 4) {
    if (1 << 3 == 1 << 3) {
      if (opline->extended_value & 8388608UL) {
        if (*(execute_data->CVs + opline->op1.var)) {
          value = *(execute_data->CVs + opline->op1.var);
        } else {
          if (executor_globals.active_symbol_table) {
            cv = (executor_globals.active_op_array)->vars + opline->op1.var;
            tmp = zend_hash_quick_find((HashTable const   *)executor_globals.active_symbol_table, cv->name, (unsigned int )(cv->name_len + 1), cv->hash_value, (void **)(& value));
            if (tmp == (int __attribute__((__visibility__("default")))  )-1) {
              isset = (unsigned char)0;
            } else {

            }
          } else {
            isset = (unsigned char)0;
          }
        }
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    _L: /* CIL Label */ 
    tmp___1 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    varname = tmp___1;
    if (1 << 1 != 1) {
      if ((int )varname->type != 6) {
        while (1) {
          tmp___0.value = varname->value;
          tmp___0.type = varname->type;
          break;
        }
        _zval_copy_ctor(& tmp___0);
        if ((int )tmp___0.type != 6) {
          _convert_to_string(& tmp___0);
        } else {

        }
        varname = & tmp___0;
      } else {

      }
    } else {

    }
    if (1 << 3 != 1 << 3) {
      if (1 << 3 == 1) {
        if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
          ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
        } else {
          tmp___2 = zend_fetch_class_by_name((char const   *)(opline->op2.zv)->value.str.val, (unsigned int )(opline->op2.zv)->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), 0);
          ce = (zend_class_entry *)tmp___2;
          while (1) {
            *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
            break;
          }
        }
      } else {
        ce = ((temp_variable *)((char *)execute_data->Ts + opline->op2.var))->class_entry;
      }
      if (1 << 1 == 1) {
        tmp___3 = opline->op1.literal;
      } else {
        tmp___3 = (zend_literal *)((void *)0);
      }
      tmp___4 = zend_std_get_static_property(ce, (char const   *)varname->value.str.val, varname->value.str.len, (unsigned char)1, (struct _zend_literal  const  *)tmp___3);
      value = (zval **)tmp___4;
      if (! value) {
        isset = (unsigned char)0;
      } else {

      }
    } else {
      target_symbol_table = zend_get_target_symbol_table((int )(opline->extended_value & 1879048192UL));
      tmp___5 = zend_hash_find((HashTable const   *)target_symbol_table, (char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1), (void **)(& value));
      if (tmp___5 == (int __attribute__((__visibility__("default")))  )-1) {
        isset = (unsigned char)0;
      } else {

      }
    }
    if (1 << 1 != 1) {
      if ((unsigned int )varname == (unsigned int )(& tmp___0)) {
        _zval_dtor(& tmp___0);
      } else {

      }
    } else {

    }
    _zval_dtor(free_op1.var);
  }
  if (opline->extended_value & 33554432UL) {
    if (isset) {
      if ((int )(*value)->type != 0) {
        while (1) {
          __z = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
          __z->value.lval = 1L;
          __z->type = (unsigned char)3;
          break;
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      while (1) {
        __z___0 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
        __z___0->value.lval = 0L;
        __z___0->type = (unsigned char)3;
        break;
      }
    }
  } else {
    if (! isset) {
      goto _L___2;
    } else {
      tmp___6 = i_zend_is_true(*value);
      if (tmp___6) {
        while (1) {
          __z___2 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
          __z___2->value.lval = 0L;
          __z___2->type = (unsigned char)3;
          break;
        }
      } else {
        _L___2: /* CIL Label */ 
        while (1) {
          __z___1 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
          __z___1->value.lval = 1L;
          __z___1->type = (unsigned char)3;
          break;
        }
      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_SPEC_TMP_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  fast_add_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SUB_SPEC_TMP_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  fast_sub_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_MUL_SPEC_TMP_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  fast_mul_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_DIV_SPEC_TMP_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  fast_div_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_MOD_SPEC_TMP_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  fast_mod_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SL_SPEC_TMP_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  shift_left_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SR_SPEC_TMP_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  shift_right_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_CONCAT_SPEC_TMP_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  concat_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_IDENTICAL_SPEC_TMP_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  is_identical_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_NOT_IDENTICAL_SPEC_TMP_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *result ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  is_identical_function(result, tmp___0, tmp);
  result->value.lval = (long )(! result->value.lval);
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_EQUAL_SPEC_TMP_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  zval *tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
    tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    tmp___1 = fast_equal_function(result, tmp___0, tmp);
    __z->value.lval = (long )(tmp___1 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_NOT_EQUAL_SPEC_TMP_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  zval *tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
    tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    tmp___1 = fast_not_equal_function(result, tmp___0, tmp);
    __z->value.lval = (long )(tmp___1 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_SMALLER_SPEC_TMP_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  zval *tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
    tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    tmp___1 = fast_is_smaller_function(result, tmp___0, tmp);
    __z->value.lval = (long )(tmp___1 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMP_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  zval *tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
    tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    tmp___1 = fast_is_smaller_or_equal_function(result, tmp___0, tmp);
    __z->value.lval = (long )(tmp___1 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_OR_SPEC_TMP_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  bitwise_or_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_AND_SPEC_TMP_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  bitwise_and_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_XOR_SPEC_TMP_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  bitwise_xor_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BOOL_XOR_SPEC_TMP_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  boolean_xor_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op1.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_VAR_SPEC_TMP_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *str ;
  zval *var ;
  zval var_copy ;
  int use_copy ;

  {
  opline = execute_data->opline;
  str = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  use_copy = 0;
  var = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  if (1 << 1 == 1 << 3) {
    str->value.str.val = (char *)((void *)0);
    str->value.str.len = 0;
    str->type = (unsigned char)6;
    str->refcount__gc = 1U;
    str->is_ref__gc = (unsigned char)0;
  } else {

  }
  if ((int )var->type != 6) {
    zend_make_printable_zval(var, & var_copy, & use_copy);
    if (use_copy) {
      var = & var_copy;
    } else {

    }
  } else {

  }
  add_string_to_string(str, (zval const   *)str, (zval const   *)var);
  if (use_copy) {
    _zval_dtor(var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_METHOD_CALL_SPEC_TMP_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *function_name ;
  char *function_name_strval ;
  int function_name_strlen ;
  zend_free_op free_op1 ;
  long tmp ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  zval *object ;
  long tmp___1 ;
  zend_literal *tmp___2 ;
  zend_class_entry *tmp___3 ;
  zend_class_entry *tmp___4 ;
  char const   *tmp___5 ;
  zend_class_entry *tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  zend_function *tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  zval *this_ptr ;
  void __attribute__((__visibility__("default")))  *tmp___13 ;
  zend_bool tmp___14 ;

  {
  opline = execute_data->opline;
  zend_ptr_stack_3_push(& executor_globals.arg_types_stack, (void *)execute_data->fbc, (void *)execute_data->object, (void *)execute_data->called_scope);
  function_name = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  if (1 << 4 != 1) {
    tmp = __builtin_expect((long )((int )function_name->type != 6), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Method name must be a string");
    } else {

    }
  } else {

  }
  function_name_strval = function_name->value.str.val;
  function_name_strlen = function_name->value.str.len;
  execute_data->object = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  tmp___11 = __builtin_expect((long )((unsigned int )execute_data->object != (unsigned int )((void *)0)), 1L);
  if (tmp___11) {
    tmp___12 = __builtin_expect((long )((int )(execute_data->object)->type == 5), 1L);
    if (tmp___12) {
      tmp___0 = zend_get_class_entry((zval const   *)execute_data->object);
      execute_data->called_scope = (zend_class_entry *)tmp___0;
      if (1 << 4 != 1) {
        goto _L;
      } else {
        if ((unsigned int )*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) == (unsigned int )execute_data->called_scope) {
          tmp___10 = (zend_function *)*((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U));
        } else {
          tmp___10 = (zend_function *)((void *)0);
        }
        execute_data->fbc = tmp___10;
        if ((unsigned int )tmp___10 == (unsigned int )((void *)0)) {
          _L: /* CIL Label */ 
          object = execute_data->object;
          tmp___1 = __builtin_expect((long )((unsigned int )((execute_data->object)->value.obj.handlers)->get_method == (unsigned int )((void *)0)), 0L);
          if (tmp___1) {
            zend_error_noreturn(1, "Object does not support method calls");
          } else {

          }
          if (1 << 4 == 1) {
            tmp___2 = opline->op2.literal + 1;
          } else {
            tmp___2 = (zend_literal *)((void *)0);
          }
          execute_data->fbc = (*(((execute_data->object)->value.obj.handlers)->get_method))(& execute_data->object, function_name_strval, function_name_strlen, (struct _zend_literal  const  *)tmp___2);
          tmp___7 = __builtin_expect((long )((unsigned int )execute_data->fbc == (unsigned int )((void *)0)), 0L);
          if (tmp___7) {
            if (execute_data->object) {
              if ((int )(execute_data->object)->type == 5) {
                if ((unsigned int )((execute_data->object)->value.obj.handlers)->get_class_entry != (unsigned int )((void *)0)) {
                  tmp___6 = (*(((execute_data->object)->value.obj.handlers)->get_class_entry))((zval const   *)execute_data->object);
                  if (tmp___6) {
                    tmp___4 = (*(((execute_data->object)->value.obj.handlers)->get_class_entry))((zval const   *)execute_data->object);
                    tmp___5 = tmp___4->name;
                  } else {
                    tmp___5 = "";
                  }
                } else {
                  tmp___5 = "";
                }
              } else {
                tmp___5 = "";
              }
            } else {
              tmp___5 = "";
            }
            zend_error_noreturn(1, "Call to undefined method %s::%s()", tmp___5, function_name_strval);
          } else {

          }
          if (1 << 4 == 1) {
            tmp___8 = __builtin_expect((long )(((execute_data->fbc)->common.fn_flags & 6291456U) == 0U), 1L);
            if (tmp___8) {
              tmp___9 = __builtin_expect((long )((unsigned int )execute_data->object == (unsigned int )object), 1L);
              if (tmp___9) {
                while (1) {
                  *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)execute_data->called_scope;
                  *((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U)) = (void *)execute_data->fbc;
                  break;
                }
              } else {

              }
            } else {

            }
          } else {

          }
        } else {

        }
      }
    } else {
      zend_error_noreturn(1, "Call to a member function %s() on a non-object", function_name_strval);
    }
  } else {
    zend_error_noreturn(1, "Call to a member function %s() on a non-object", function_name_strval);
  }
  if (((execute_data->fbc)->common.fn_flags & 1U) != 0U) {
    execute_data->object = (zval *)((void *)0);
  } else {
    tmp___14 = zval_isref_p(execute_data->object);
    if (tmp___14) {
      while (1) {
        tmp___13 = _emalloc(sizeof(zval_gc_info ));
        this_ptr = (zval *)tmp___13;
        ((zval_gc_info *)this_ptr)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      while (1) {
        while (1) {
          this_ptr->value = (execute_data->object)->value;
          this_ptr->type = (execute_data->object)->type;
          break;
        }
        zval_set_refcount_p(this_ptr, 1U);
        zval_unset_isref_p(this_ptr);
        break;
      }
      _zval_copy_ctor(this_ptr);
      execute_data->object = this_ptr;
    } else {
      zval_addref_p(execute_data->object);
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_CASE_SPEC_TMP_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  if (1 << 1 == 1 << 2) {
    zval_addref_p(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr);
  } else {

  }
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  is_equal_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *expr_ptr ;
  zval **expr_ptr_ptr ;
  long tmp ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_uint tmp___1 ;
  zend_bool tmp___2 ;
  zval *new_expr ;
  void __attribute__((__visibility__("default")))  *tmp___3 ;
  zval *new_expr___0 ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_bool tmp___5 ;
  zval *offset ;
  zval *tmp___6 ;
  ulong hval ;
  long tmp___7 ;
  register char const   *tmp___8 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___9 ;

  {
  opline = execute_data->opline;
  if (1 << 1 == 1 << 2) {
    goto _L___1;
  } else {
    if (1 << 1 == 1 << 4) {
      _L___1: /* CIL Label */ 
      if (opline->extended_value) {
        expr_ptr_ptr = (zval **)((void *)0);
        if (1 << 1 == 1 << 2) {
          tmp = __builtin_expect((long )((unsigned int )expr_ptr_ptr == (unsigned int )((void *)0)), 0L);
          if (tmp) {
            zend_error_noreturn(1, "Cannot create references to/from string offsets");
          } else {

          }
        } else {

        }
        tmp___2 = zval_isref_p(*expr_ptr_ptr);
        if (tmp___2) {

        } else {
          while (1) {
            tmp___1 = zval_refcount_p(*expr_ptr_ptr);
            if (tmp___1 > 1U) {
              zval_delref_p(*expr_ptr_ptr);
              while (1) {
                tmp___0 = _emalloc(sizeof(zval_gc_info ));
                new_zv = (zval *)tmp___0;
                ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv->value = (*expr_ptr_ptr)->value;
                  new_zv->type = (*expr_ptr_ptr)->type;
                  break;
                }
                zval_set_refcount_p(new_zv, 1U);
                zval_unset_isref_p(new_zv);
                break;
              }
              *expr_ptr_ptr = new_zv;
              _zval_copy_ctor(new_zv);
            } else {

            }
            break;
          }
          zval_set_isref_p(*expr_ptr_ptr);
        }
        expr_ptr = *expr_ptr_ptr;
        zval_addref_p(expr_ptr);
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      expr_ptr = _get_zval_ptr_tmp(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
      if (1) {
        while (1) {
          tmp___3 = _emalloc(sizeof(zval_gc_info ));
          new_expr = (zval *)tmp___3;
          ((zval_gc_info *)new_expr)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            new_expr->value = expr_ptr->value;
            new_expr->type = expr_ptr->type;
            break;
          }
          zval_set_refcount_p(new_expr, 1U);
          zval_unset_isref_p(new_expr);
          break;
        }
        expr_ptr = new_expr;
      } else {
        if (1 << 1 == 1) {
          goto _L;
        } else {
          tmp___5 = zval_isref_p(expr_ptr);
          if (tmp___5) {
            _L: /* CIL Label */ 
            while (1) {
              tmp___4 = _emalloc(sizeof(zval_gc_info ));
              new_expr___0 = (zval *)tmp___4;
              ((zval_gc_info *)new_expr___0)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_expr___0->value = expr_ptr->value;
                new_expr___0->type = expr_ptr->type;
                break;
              }
              zval_set_refcount_p(new_expr___0, 1U);
              zval_unset_isref_p(new_expr___0);
              break;
            }
            expr_ptr = new_expr___0;
            _zval_copy_ctor(expr_ptr);
          } else {
            zval_addref_p(expr_ptr);
          }
        }
      }
    }
  }
  if (1 << 4 != 1 << 3) {
    tmp___6 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
    offset = tmp___6;
    switch ((int )offset->type) {
    case 2: 
    tmp___7 = zend_dval_to_lval(offset->value.dval);
    hval = (unsigned long )tmp___7;
    goto num_index;
    case 1: 
    case 3: 
    hval = (unsigned long )offset->value.lval;
    num_index: 
    _zend_hash_index_update_or_next_insert(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, hval, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    case 6: 
    if (1 << 4 == 1) {
      hval = ((zend_literal *)offset)->hash_value;
    } else {
      while (1) {
        tmp___8 = (char const   *)offset->value.str.val;
        if ((int const   )*tmp___8 == 45) {
          tmp___8 ++;
        } else {

        }
        if ((int const   )*tmp___8 >= 48) {
          if ((int const   )*tmp___8 <= 57) {
            end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
            if ((int const   )*end != 0) {
              break;
            } else {
              if ((int const   )*tmp___8 == 48) {
                if (offset->value.str.len + 1 > 2) {
                  break;
                } else {
                  goto _L___2;
                }
              } else {
                _L___2: /* CIL Label */ 
                if (end - tmp___8 > 10) {
                  break;
                } else {
                  if (end - tmp___8 == 10) {
                    if ((int const   )*tmp___8 > 50) {
                      break;
                    } else {

                    }
                  } else {

                  }
                }
              }
            }
            hval = (unsigned long )((int const   )*tmp___8 - 48);
            while (1) {
              tmp___8 ++;
              if ((unsigned int )tmp___8 != (unsigned int )end) {
                if ((int const   )*tmp___8 >= 48) {
                  if ((int const   )*tmp___8 <= 57) {

                  } else {
                    break;
                  }
                } else {
                  break;
                }
              } else {
                break;
              }
              hval = hval * 10UL + (ulong )((int const   )*tmp___8 - 48);
            }
            if ((unsigned int )tmp___8 == (unsigned int )end) {
              if ((int )*(offset->value.str.val) == 45) {
                if (hval - 1UL > 2147483647UL) {
                  break;
                } else {

                }
                hval = (unsigned long )(- ((long )hval));
              } else {
                if (hval > 2147483647UL) {
                  break;
                } else {

                }
              }
              goto num_index;
            } else {

            }
          } else {

          }
        } else {

        }
        break;
      }
      if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
        if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
          hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
        } else {
          tmp___9 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___9;
        }
      } else {
        tmp___9 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
        hval = (unsigned long )tmp___9;
      }
    }
    _zend_hash_quick_add_or_update(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    case 0: 
    _zend_hash_add_or_update(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, "", sizeof(""), (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    default: 
    zend_error(1 << 1L, "Illegal offset type");
    i_zval_ptr_dtor(expr_ptr);
    break;
    }
  } else {
    _zend_hash_index_update_or_next_insert(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, 0UL, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1 << 2);
  }
  if (1 << 1 == 1 << 2) {
    goto _L___3;
  } else {
    if (1 << 1 == 1 << 4) {
      _L___3: /* CIL Label */ 
      if (opline->extended_value) {

      } else {

      }
    } else {

    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_ARRAY_SPEC_TMP_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  int tmp ;

  {
  opline = execute_data->opline;
  _array_init(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, 0U);
  if (1 << 1 == 1 << 3) {
    (execute_data->opline) ++;
    return (0);
  } else {
    tmp = ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CV_HANDLER(execute_data);
    return (tmp);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_NOT_SPEC_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  bitwise_not_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BOOL_NOT_SPEC_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  boolean_not_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_PRE_INC_SPEC_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **var_ptr ;
  long tmp ;
  temp_variable *__t ;
  long tmp___0 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zval *val ;
  zval *tmp___4 ;
  long tmp___5 ;
  temp_variable *__t___0 ;

  {
  opline = execute_data->opline;
  var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )var_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot increment/decrement overloaded objects nor string offsets");
    } else {

    }
  } else {

  }
  if (1 << 2 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )*var_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
    if (tmp___0) {
      if (! ((int )opline->result_type & (1 << 5))) {
        zval_addref_p(& executor_globals.uninitialized_zval);
        while (1) {
          __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
          __t->var.ptr = & executor_globals.uninitialized_zval;
          __t->var.ptr_ptr = & __t->var.ptr;
          break;
        }
      } else {

      }
      if (free_op1.var) {
        i_zval_ptr_dtor(free_op1.var);
      } else {

      }
      (execute_data->opline) ++;
      return (0);
    } else {

    }
  } else {

  }
  tmp___3 = zval_isref_p(*var_ptr);
  if (tmp___3) {

  } else {
    while (1) {
      tmp___2 = zval_refcount_p(*var_ptr);
      if (tmp___2 > 1U) {
        zval_delref_p(*var_ptr);
        while (1) {
          tmp___1 = _emalloc(sizeof(zval_gc_info ));
          new_zv = (zval *)tmp___1;
          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            new_zv->value = (*var_ptr)->value;
            new_zv->type = (*var_ptr)->type;
            break;
          }
          zval_set_refcount_p(new_zv, 1U);
          zval_unset_isref_p(new_zv);
          break;
        }
        *var_ptr = new_zv;
        _zval_copy_ctor(new_zv);
      } else {

      }
      break;
    }
  }
  tmp___5 = __builtin_expect((long )((int )(*var_ptr)->type == 5), 0L);
  if (tmp___5) {
    if (((*var_ptr)->value.obj.handlers)->get) {
      if (((*var_ptr)->value.obj.handlers)->set) {
        tmp___4 = (*(((*var_ptr)->value.obj.handlers)->get))(*var_ptr);
        val = tmp___4;
        zval_addref_p(val);
        fast_increment_function(val);
        (*(((*var_ptr)->value.obj.handlers)->set))(var_ptr, val);
        i_zval_ptr_dtor(val);
      } else {
        fast_increment_function(*var_ptr);
      }
    } else {
      fast_increment_function(*var_ptr);
    }
  } else {
    fast_increment_function(*var_ptr);
  }
  if (! ((int )opline->result_type & (1 << 5))) {
    zval_addref_p(*var_ptr);
    while (1) {
      __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
      __t___0->var.ptr = *var_ptr;
      __t___0->var.ptr_ptr = & __t___0->var.ptr;
      break;
    }
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_PRE_DEC_SPEC_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **var_ptr ;
  long tmp ;
  temp_variable *__t ;
  long tmp___0 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zval *val ;
  zval *tmp___4 ;
  long tmp___5 ;
  temp_variable *__t___0 ;

  {
  opline = execute_data->opline;
  var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )var_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot increment/decrement overloaded objects nor string offsets");
    } else {

    }
  } else {

  }
  if (1 << 2 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )*var_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
    if (tmp___0) {
      if (! ((int )opline->result_type & (1 << 5))) {
        zval_addref_p(& executor_globals.uninitialized_zval);
        while (1) {
          __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
          __t->var.ptr = & executor_globals.uninitialized_zval;
          __t->var.ptr_ptr = & __t->var.ptr;
          break;
        }
      } else {

      }
      if (free_op1.var) {
        i_zval_ptr_dtor(free_op1.var);
      } else {

      }
      (execute_data->opline) ++;
      return (0);
    } else {

    }
  } else {

  }
  tmp___3 = zval_isref_p(*var_ptr);
  if (tmp___3) {

  } else {
    while (1) {
      tmp___2 = zval_refcount_p(*var_ptr);
      if (tmp___2 > 1U) {
        zval_delref_p(*var_ptr);
        while (1) {
          tmp___1 = _emalloc(sizeof(zval_gc_info ));
          new_zv = (zval *)tmp___1;
          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            new_zv->value = (*var_ptr)->value;
            new_zv->type = (*var_ptr)->type;
            break;
          }
          zval_set_refcount_p(new_zv, 1U);
          zval_unset_isref_p(new_zv);
          break;
        }
        *var_ptr = new_zv;
        _zval_copy_ctor(new_zv);
      } else {

      }
      break;
    }
  }
  tmp___5 = __builtin_expect((long )((int )(*var_ptr)->type == 5), 0L);
  if (tmp___5) {
    if (((*var_ptr)->value.obj.handlers)->get) {
      if (((*var_ptr)->value.obj.handlers)->set) {
        tmp___4 = (*(((*var_ptr)->value.obj.handlers)->get))(*var_ptr);
        val = tmp___4;
        zval_addref_p(val);
        fast_decrement_function(val);
        (*(((*var_ptr)->value.obj.handlers)->set))(var_ptr, val);
        i_zval_ptr_dtor(val);
      } else {
        fast_decrement_function(*var_ptr);
      }
    } else {
      fast_decrement_function(*var_ptr);
    }
  } else {
    fast_decrement_function(*var_ptr);
  }
  if (! ((int )opline->result_type & (1 << 5))) {
    zval_addref_p(*var_ptr);
    while (1) {
      __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
      __t___0->var.ptr = *var_ptr;
      __t___0->var.ptr_ptr = & __t___0->var.ptr;
      break;
    }
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_POST_INC_SPEC_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **var_ptr ;
  zval *retval ;
  long tmp ;
  long tmp___0 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zval *val ;
  zval *tmp___4 ;
  long tmp___5 ;

  {
  opline = execute_data->opline;
  var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )var_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot increment/decrement overloaded objects nor string offsets");
    } else {

    }
  } else {

  }
  if (1 << 2 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )*var_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
    if (tmp___0) {
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.type = (unsigned char)0;
      if (free_op1.var) {
        i_zval_ptr_dtor(free_op1.var);
      } else {

      }
      (execute_data->opline) ++;
      return (0);
    } else {

    }
  } else {

  }
  retval = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    retval->value = (*var_ptr)->value;
    retval->type = (*var_ptr)->type;
    break;
  }
  _zval_copy_ctor(retval);
  tmp___3 = zval_isref_p(*var_ptr);
  if (tmp___3) {

  } else {
    while (1) {
      tmp___2 = zval_refcount_p(*var_ptr);
      if (tmp___2 > 1U) {
        zval_delref_p(*var_ptr);
        while (1) {
          tmp___1 = _emalloc(sizeof(zval_gc_info ));
          new_zv = (zval *)tmp___1;
          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            new_zv->value = (*var_ptr)->value;
            new_zv->type = (*var_ptr)->type;
            break;
          }
          zval_set_refcount_p(new_zv, 1U);
          zval_unset_isref_p(new_zv);
          break;
        }
        *var_ptr = new_zv;
        _zval_copy_ctor(new_zv);
      } else {

      }
      break;
    }
  }
  tmp___5 = __builtin_expect((long )((int )(*var_ptr)->type == 5), 0L);
  if (tmp___5) {
    if (((*var_ptr)->value.obj.handlers)->get) {
      if (((*var_ptr)->value.obj.handlers)->set) {
        tmp___4 = (*(((*var_ptr)->value.obj.handlers)->get))(*var_ptr);
        val = tmp___4;
        zval_addref_p(val);
        fast_increment_function(val);
        (*(((*var_ptr)->value.obj.handlers)->set))(var_ptr, val);
        i_zval_ptr_dtor(val);
      } else {
        fast_increment_function(*var_ptr);
      }
    } else {
      fast_increment_function(*var_ptr);
    }
  } else {
    fast_increment_function(*var_ptr);
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_POST_DEC_SPEC_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **var_ptr ;
  zval *retval ;
  long tmp ;
  long tmp___0 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zval *val ;
  zval *tmp___4 ;
  long tmp___5 ;

  {
  opline = execute_data->opline;
  var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )var_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot increment/decrement overloaded objects nor string offsets");
    } else {

    }
  } else {

  }
  if (1 << 2 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )*var_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
    if (tmp___0) {
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.type = (unsigned char)0;
      if (free_op1.var) {
        i_zval_ptr_dtor(free_op1.var);
      } else {

      }
      (execute_data->opline) ++;
      return (0);
    } else {

    }
  } else {

  }
  retval = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    retval->value = (*var_ptr)->value;
    retval->type = (*var_ptr)->type;
    break;
  }
  _zval_copy_ctor(retval);
  tmp___3 = zval_isref_p(*var_ptr);
  if (tmp___3) {

  } else {
    while (1) {
      tmp___2 = zval_refcount_p(*var_ptr);
      if (tmp___2 > 1U) {
        zval_delref_p(*var_ptr);
        while (1) {
          tmp___1 = _emalloc(sizeof(zval_gc_info ));
          new_zv = (zval *)tmp___1;
          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            new_zv->value = (*var_ptr)->value;
            new_zv->type = (*var_ptr)->type;
            break;
          }
          zval_set_refcount_p(new_zv, 1U);
          zval_unset_isref_p(new_zv);
          break;
        }
        *var_ptr = new_zv;
        _zval_copy_ctor(new_zv);
      } else {

      }
      break;
    }
  }
  tmp___5 = __builtin_expect((long )((int )(*var_ptr)->type == 5), 0L);
  if (tmp___5) {
    if (((*var_ptr)->value.obj.handlers)->get) {
      if (((*var_ptr)->value.obj.handlers)->set) {
        tmp___4 = (*(((*var_ptr)->value.obj.handlers)->get))(*var_ptr);
        val = tmp___4;
        zval_addref_p(val);
        fast_decrement_function(val);
        (*(((*var_ptr)->value.obj.handlers)->set))(var_ptr, val);
        i_zval_ptr_dtor(val);
      } else {
        fast_decrement_function(*var_ptr);
      }
    } else {
      fast_decrement_function(*var_ptr);
    }
  } else {
    fast_decrement_function(*var_ptr);
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ECHO_SPEC_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval z_copy ;
  zval *z ;
  int __attribute__((__visibility__("default")))  tmp ;
  long tmp___0 ;

  {
  opline = execute_data->opline;
  z = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 != 1) {
    tmp___0 = __builtin_expect((long )((int )z->type == 5), 0L);
    if (tmp___0) {
      if ((unsigned int )(z->value.obj.handlers)->get_method != (unsigned int )((void *)0)) {
        if (1 << 2 == 1 << 1) {
          z->refcount__gc = 1U;
          z->is_ref__gc = (unsigned char)0;
        } else {

        }
        tmp = zend_std_cast_object_tostring(z, & z_copy, 6);
        if (tmp == (int __attribute__((__visibility__("default")))  )0) {
          zend_print_variable(& z_copy);
          _zval_dtor(& z_copy);
        } else {
          zend_print_variable(z);
        }
      } else {
        zend_print_variable(z);
      }
    } else {
      zend_print_variable(z);
    }
  } else {
    zend_print_variable(z);
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_PRINT_SPEC_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *__z ;
  int tmp ;

  {
  opline = execute_data->opline;
  __z = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  __z->value.lval = 1L;
  __z->type = (unsigned char)1;
  tmp = ZEND_ECHO_SPEC_VAR_HANDLER(execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_JMPZ_SPEC_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *val ;
  int ret ;
  long tmp ;
  long tmp___0 ;

  {
  opline = execute_data->opline;
  val = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 1) {
    tmp___0 = __builtin_expect((long )((int )val->type == 3), 1L);
    if (tmp___0) {
      ret = (int )val->value.lval;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    ret = i_zend_is_true(val);
    if (free_op1.var) {
      i_zval_ptr_dtor(free_op1.var);
    } else {

    }
    tmp = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
    if (tmp) {
      return (0);
    } else {

    }
  }
  if (! ret) {
    execute_data->opline = opline->op2.jmp_addr;
    return (0);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_JMPNZ_SPEC_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *val ;
  int ret ;
  long tmp ;
  long tmp___0 ;

  {
  opline = execute_data->opline;
  val = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 1) {
    tmp___0 = __builtin_expect((long )((int )val->type == 3), 1L);
    if (tmp___0) {
      ret = (int )val->value.lval;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    ret = i_zend_is_true(val);
    if (free_op1.var) {
      i_zval_ptr_dtor(free_op1.var);
    } else {

    }
    tmp = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
    if (tmp) {
      return (0);
    } else {

    }
  }
  if (ret) {
    execute_data->opline = opline->op2.jmp_addr;
    return (0);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_JMPZNZ_SPEC_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *val ;
  int retval ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  opline = execute_data->opline;
  val = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 1) {
    tmp___0 = __builtin_expect((long )((int )val->type == 3), 1L);
    if (tmp___0) {
      retval = (int )val->value.lval;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    retval = i_zend_is_true(val);
    if (free_op1.var) {
      i_zval_ptr_dtor(free_op1.var);
    } else {

    }
    tmp = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
    if (tmp) {
      return (0);
    } else {

    }
  }
  tmp___1 = __builtin_expect((long )(retval != 0), 1L);
  if (tmp___1) {
    execute_data->opline = (execute_data->op_array)->opcodes + opline->extended_value;
    return (0);
  } else {
    execute_data->opline = (execute_data->op_array)->opcodes + opline->op2.opline_num;
    return (0);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_JMPZ_EX_SPEC_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *val ;
  int retval ;
  long tmp ;
  long tmp___0 ;

  {
  opline = execute_data->opline;
  val = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 1) {
    tmp___0 = __builtin_expect((long )((int )val->type == 3), 1L);
    if (tmp___0) {
      retval = (int )val->value.lval;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    retval = i_zend_is_true(val);
    if (free_op1.var) {
      i_zval_ptr_dtor(free_op1.var);
    } else {

    }
    tmp = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
    if (tmp) {
      return (0);
    } else {

    }
  }
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.lval = (long )retval;
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.type = (unsigned char)3;
  if (! retval) {
    execute_data->opline = opline->op2.jmp_addr;
    return (0);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_JMPNZ_EX_SPEC_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *val ;
  int retval ;
  long tmp ;
  long tmp___0 ;

  {
  opline = execute_data->opline;
  val = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 1) {
    tmp___0 = __builtin_expect((long )((int )val->type == 3), 1L);
    if (tmp___0) {
      retval = (int )val->value.lval;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    retval = i_zend_is_true(val);
    if (free_op1.var) {
      i_zval_ptr_dtor(free_op1.var);
    } else {

    }
    tmp = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
    if (tmp) {
      return (0);
    } else {

    }
  }
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.lval = (long )retval;
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.type = (unsigned char)3;
  if (retval) {
    execute_data->opline = opline->op2.jmp_addr;
    return (0);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FREE_SPEC_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;

  {
  opline = execute_data->opline;
  if (1 << 2 == 1 << 1) {
    _zval_dtor(& ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->tmp_var);
  } else {
    i_zval_ptr_dtor(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr);
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_RETURN_SPEC_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *retval_ptr ;
  zend_free_op free_op1 ;
  zval *ret ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zval *ret___0 ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_bool tmp___1 ;
  zend_uint tmp___2 ;
  zval *ret___1 ;
  void __attribute__((__visibility__("default")))  *tmp___3 ;
  int tmp___4 ;

  {
  opline = execute_data->opline;
  retval_ptr = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (! executor_globals.return_value_ptr_ptr) {
    if (1 << 2 == 1 << 1) {
      if (free_op1.var) {
        i_zval_ptr_dtor(free_op1.var);
      } else {

      }
    } else {

    }
  } else {
    if (1 << 2 == 1) {
      goto _L___0;
    } else {
      tmp___1 = zval_isref_p(retval_ptr);
      if (tmp___1) {
        tmp___2 = zval_refcount_p(retval_ptr);
        if (tmp___2 > 0U) {
          _L___0: /* CIL Label */ 
          while (1) {
            tmp = _emalloc(sizeof(zval_gc_info ));
            ret = (zval *)tmp;
            ((zval_gc_info *)ret)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              ret->value = retval_ptr->value;
              ret->type = retval_ptr->type;
              break;
            }
            zval_set_refcount_p(ret, 1U);
            zval_unset_isref_p(ret);
            break;
          }
          _zval_copy_ctor(ret);
          *(executor_globals.return_value_ptr_ptr) = ret;
        } else {
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
        if (1 << 2 == 1 << 4) {
          goto _L;
        } else {
          if (1 << 2 == 1 << 2) {
            _L: /* CIL Label */ 
            if ((unsigned int )retval_ptr == (unsigned int )(& executor_globals.uninitialized_zval)) {
              while (1) {
                tmp___0 = _emalloc(sizeof(zval_gc_info ));
                ret___0 = (zval *)tmp___0;
                ((zval_gc_info *)ret___0)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              *ret___0 = (struct _zval_struct )zval_used_for_init;
              *(executor_globals.return_value_ptr_ptr) = ret___0;
            } else {
              *(executor_globals.return_value_ptr_ptr) = retval_ptr;
              zval_addref_p(retval_ptr);
            }
          } else {
            *(executor_globals.return_value_ptr_ptr) = retval_ptr;
            zval_addref_p(retval_ptr);
          }
        }
      }
    }
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  tmp___4 = zend_leave_helper_SPEC(execute_data);
  return (tmp___4);
}
}
static int ( __attribute__((__fastcall__)) ZEND_RETURN_BY_REF_SPEC_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *retval_ptr ;
  zval **retval_ptr_ptr ;
  zend_free_op free_op1 ;
  zval *ret ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zval *ret___0 ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  long tmp___1 ;
  zend_bool tmp___2 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___3 ;
  zend_uint tmp___4 ;
  zend_bool tmp___5 ;
  int tmp___6 ;

  {
  opline = execute_data->opline;
  while (1) {
    if (1 << 2 == 1) {
      goto _L;
    } else {
      if (1 << 2 == 1 << 1) {
        _L: /* CIL Label */ 
        zend_error(1 << 3L, "Only variable references should be returned by reference");
        retval_ptr = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
        if (! executor_globals.return_value_ptr_ptr) {
          if (1 << 2 == 1 << 1) {
            if (free_op1.var) {
              i_zval_ptr_dtor(free_op1.var);
            } else {

            }
          } else {

          }
        } else {
          while (1) {
            tmp = _emalloc(sizeof(zval_gc_info ));
            ret = (zval *)tmp;
            ((zval_gc_info *)ret)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              ret->value = retval_ptr->value;
              ret->type = retval_ptr->type;
              break;
            }
            zval_set_refcount_p(ret, 1U);
            zval_unset_isref_p(ret);
            break;
          }
          _zval_copy_ctor(ret);
          *(executor_globals.return_value_ptr_ptr) = ret;
        }
        break;
      } else {

      }
    }
    retval_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    if (1 << 2 == 1 << 2) {
      tmp___1 = __builtin_expect((long )((unsigned int )retval_ptr_ptr == (unsigned int )((void *)0)), 0L);
      if (tmp___1) {
        zend_error_noreturn(1, "Cannot return string offsets by reference");
      } else {

      }
    } else {

    }
    if (1 << 2 == 1 << 2) {
      tmp___2 = zval_isref_p(*retval_ptr_ptr);
      if (tmp___2) {

      } else {
        if (opline->extended_value == 1UL) {
          if (((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.fcall_returned_reference) {

          } else {
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
          if ((unsigned int )((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr == (unsigned int )(& ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr)) {
            zend_error(1 << 3L, "Only variable references should be returned by reference");
            if (executor_globals.return_value_ptr_ptr) {
              retval_ptr = *retval_ptr_ptr;
              *(executor_globals.return_value_ptr_ptr) = retval_ptr;
              zval_addref_p(retval_ptr);
            } else {

            }
            break;
          } else {

          }
        }
      }
    } else {

    }
    if (executor_globals.return_value_ptr_ptr) {
      tmp___5 = zval_isref_p(*retval_ptr_ptr);
      if (tmp___5) {

      } else {
        while (1) {
          tmp___4 = zval_refcount_p(*retval_ptr_ptr);
          if (tmp___4 > 1U) {
            zval_delref_p(*retval_ptr_ptr);
            while (1) {
              tmp___3 = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp___3;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*retval_ptr_ptr)->value;
                new_zv->type = (*retval_ptr_ptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *retval_ptr_ptr = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
        zval_set_isref_p(*retval_ptr_ptr);
      }
      zval_addref_p(*retval_ptr_ptr);
      *(executor_globals.return_value_ptr_ptr) = *retval_ptr_ptr;
    } else {

    }
    break;
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  tmp___6 = zend_leave_helper_SPEC(execute_data);
  return (tmp___6);
}
}
static int ( __attribute__((__fastcall__)) ZEND_THROW_SPEC_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *value ;
  zval *exception ;
  zend_free_op free_op1 ;
  long tmp ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;

  {
  opline = execute_data->opline;
  value = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1) {
    zend_error_noreturn(1, "Can only throw objects");
  } else {
    tmp = __builtin_expect((long )((int )value->type != 5), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Can only throw objects");
    } else {

    }
  }
  zend_exception_save();
  while (1) {
    tmp___0 = _emalloc(sizeof(zval_gc_info ));
    exception = (zval *)tmp___0;
    ((zval_gc_info *)exception)->u.buffered = (gc_root_buffer *)((void *)0);
    break;
  }
  while (1) {
    while (1) {
      exception->value = value->value;
      exception->type = value->type;
      break;
    }
    zval_set_refcount_p(exception, 1U);
    zval_unset_isref_p(exception);
    break;
  }
  _zval_copy_ctor(exception);
  zend_throw_exception_object(exception);
  zend_exception_restore();
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_send_by_var_helper_SPEC_VAR)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *varptr ;
  zend_free_op free_op1 ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zval *original_var ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_bool tmp___1 ;

  {
  opline = execute_data->opline;
  varptr = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if ((unsigned int )varptr == (unsigned int )(& executor_globals.uninitialized_zval)) {
    while (1) {
      tmp = _emalloc(sizeof(zval_gc_info ));
      varptr = (zval *)tmp;
      ((zval_gc_info *)varptr)->u.buffered = (gc_root_buffer *)((void *)0);
      break;
    }
    *varptr = (struct _zval_struct )zval_used_for_init;
    zval_set_refcount_p(varptr, 0U);
  } else {
    tmp___1 = zval_isref_p(varptr);
    if (tmp___1) {
      original_var = varptr;
      while (1) {
        tmp___0 = _emalloc(sizeof(zval_gc_info ));
        varptr = (zval *)tmp___0;
        ((zval_gc_info *)varptr)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      while (1) {
        varptr->value = original_var->value;
        varptr->type = original_var->type;
        break;
      }
      zval_unset_isref_p(varptr);
      zval_set_refcount_p(varptr, 0U);
      _zval_copy_ctor(varptr);
    } else {

    }
  }
  zval_addref_p(varptr);
  zend_vm_stack_push((void *)varptr);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SEND_VAR_NO_REF_SPEC_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *varptr ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  zval *valptr ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  zend_bool tmp___6 ;
  zend_uint tmp___7 ;

  {
  opline = execute_data->opline;
  if (opline->extended_value & (unsigned long )(1 << 1)) {
    if (! (opline->extended_value & 1UL)) {
      tmp = zend_send_by_var_helper_SPEC_VAR(execute_data);
      return (tmp);
    } else {

    }
  } else {
    if (execute_data->fbc) {
      if ((execute_data->fbc)->common.arg_info) {
        if (opline->op2.opline_num <= (execute_data->fbc)->common.num_args) {
          tmp___1 = (unsigned int )((int )((execute_data->fbc)->common.arg_info + (opline->op2.opline_num - 1U))->pass_by_reference & 3);
        } else {
          tmp___1 = (execute_data->fbc)->common.fn_flags & 50331648U;
        }
      } else {
        tmp___1 = (execute_data->fbc)->common.fn_flags & 50331648U;
      }
      if (tmp___1) {

      } else {
        tmp___0 = zend_send_by_var_helper_SPEC_VAR(execute_data);
        return (tmp___0);
      }
    } else {
      tmp___0 = zend_send_by_var_helper_SPEC_VAR(execute_data);
      return (tmp___0);
    }
  }
  if (1 << 2 == 1 << 2) {
    if (opline->extended_value & (unsigned long )(1 << 2)) {
      if (((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.fcall_returned_reference) {
        if (((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr) {
          varptr = ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr;
          zend_pzval_unlock_func(varptr, & free_op1, 0);
        } else {
          varptr = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
        }
      } else {
        varptr = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
      }
    } else {
      varptr = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    }
  } else {
    varptr = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  }
  if (! (opline->extended_value & (unsigned long )(1 << 2))) {
    goto _L___1;
  } else {
    if (((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.fcall_returned_reference) {
      _L___1: /* CIL Label */ 
      if ((unsigned int )varptr != (unsigned int )(& executor_globals.uninitialized_zval)) {
        tmp___6 = zval_isref_p(varptr);
        if (tmp___6) {
          zval_set_isref_p(varptr);
          zval_addref_p(varptr);
          zend_vm_stack_push((void *)varptr);
        } else {
          tmp___7 = zval_refcount_p(varptr);
          if (tmp___7 == 1U) {
            if (1 << 2 == 1 << 4) {
              zval_set_isref_p(varptr);
              zval_addref_p(varptr);
              zend_vm_stack_push((void *)varptr);
            } else {
              if (free_op1.var) {
                zval_set_isref_p(varptr);
                zval_addref_p(varptr);
                zend_vm_stack_push((void *)varptr);
              } else {
                goto _L___0;
              }
            }
          } else {
            goto _L___0;
          }
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      _L: /* CIL Label */ 
      if (opline->extended_value & (unsigned long )(1 << 1)) {
        tmp___4 = ! (opline->extended_value & (unsigned long )(1 << 3));
      } else {
        if (execute_data->fbc) {
          if ((execute_data->fbc)->common.arg_info) {
            if (opline->op2.opline_num <= (execute_data->fbc)->common.num_args) {
              tmp___2 = (unsigned int )((int )((execute_data->fbc)->common.arg_info + (opline->op2.opline_num - 1U))->pass_by_reference & 2);
            } else {
              tmp___2 = (execute_data->fbc)->common.fn_flags & 33554432U;
            }
          } else {
            tmp___2 = (execute_data->fbc)->common.fn_flags & 33554432U;
          }
          if (tmp___2) {
            tmp___3 = 0;
          } else {
            tmp___3 = 1;
          }
        } else {
          tmp___3 = 1;
        }
        tmp___4 = tmp___3;
      }
      if (tmp___4) {
        zend_error(1 << 11L, "Only variables should be passed by reference");
      } else {

      }
      while (1) {
        tmp___5 = _emalloc(sizeof(zval_gc_info ));
        valptr = (zval *)tmp___5;
        ((zval_gc_info *)valptr)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      while (1) {
        while (1) {
          valptr->value = varptr->value;
          valptr->type = varptr->type;
          break;
        }
        zval_set_refcount_p(valptr, 1U);
        zval_unset_isref_p(valptr);
        break;
      }
      _zval_copy_ctor(valptr);
      zend_vm_stack_push((void *)valptr);
    }
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SEND_REF_SPEC_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **varptr_ptr ;
  zval *varptr ;
  long tmp ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_uint tmp___5 ;
  zend_bool tmp___6 ;

  {
  opline = execute_data->opline;
  varptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )varptr_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Only variables can be passed by reference");
    } else {

    }
  } else {

  }
  if (1 << 2 == 1 << 2) {
    tmp___1 = __builtin_expect((long )((unsigned int )*varptr_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
    if (tmp___1) {
      while (1) {
        tmp___0 = _emalloc(sizeof(zval_gc_info ));
        varptr = (zval *)tmp___0;
        ((zval_gc_info *)varptr)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      *varptr = (struct _zval_struct )zval_used_for_init;
      zend_vm_stack_push((void *)varptr);
      (execute_data->opline) ++;
      return (0);
    } else {

    }
  } else {

  }
  if ((int )(execute_data->function_state.function)->type == 1) {
    if (execute_data->fbc) {
      if ((execute_data->fbc)->common.arg_info) {
        if (opline->op2.opline_num <= (execute_data->fbc)->common.num_args) {
          tmp___3 = (unsigned int )((int )((execute_data->fbc)->common.arg_info + (opline->op2.opline_num - 1U))->pass_by_reference & 3);
        } else {
          tmp___3 = (execute_data->fbc)->common.fn_flags & 50331648U;
        }
      } else {
        tmp___3 = (execute_data->fbc)->common.fn_flags & 50331648U;
      }
      if (tmp___3) {

      } else {
        tmp___2 = zend_send_by_var_helper_SPEC_VAR(execute_data);
        return (tmp___2);
      }
    } else {
      tmp___2 = zend_send_by_var_helper_SPEC_VAR(execute_data);
      return (tmp___2);
    }
  } else {

  }
  tmp___6 = zval_isref_p(*varptr_ptr);
  if (tmp___6) {

  } else {
    while (1) {
      tmp___5 = zval_refcount_p(*varptr_ptr);
      if (tmp___5 > 1U) {
        zval_delref_p(*varptr_ptr);
        while (1) {
          tmp___4 = _emalloc(sizeof(zval_gc_info ));
          new_zv = (zval *)tmp___4;
          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            new_zv->value = (*varptr_ptr)->value;
            new_zv->type = (*varptr_ptr)->type;
            break;
          }
          zval_set_refcount_p(new_zv, 1U);
          zval_unset_isref_p(new_zv);
          break;
        }
        *varptr_ptr = new_zv;
        _zval_copy_ctor(new_zv);
      } else {

      }
      break;
    }
    zval_set_isref_p(*varptr_ptr);
  }
  varptr = *varptr_ptr;
  zval_addref_p(varptr);
  zend_vm_stack_push((void *)varptr);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SEND_VAR_SPEC_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  if (opline->extended_value == 61UL) {
    if (execute_data->fbc) {
      if ((execute_data->fbc)->common.arg_info) {
        if (opline->op2.opline_num <= (execute_data->fbc)->common.num_args) {
          tmp___0 = (unsigned int )((int )((execute_data->fbc)->common.arg_info + (opline->op2.opline_num - 1U))->pass_by_reference & 3);
        } else {
          tmp___0 = (execute_data->fbc)->common.fn_flags & 50331648U;
        }
      } else {
        tmp___0 = (execute_data->fbc)->common.fn_flags & 50331648U;
      }
      if (tmp___0) {
        tmp = ZEND_SEND_REF_SPEC_VAR_HANDLER(execute_data);
        return (tmp);
      } else {

      }
    } else {

    }
  } else {

  }
  tmp___1 = zend_send_by_var_helper_SPEC_VAR(execute_data);
  return (tmp___1);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BOOL_SPEC_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *retval ;
  zval *__z ;
  zval *tmp ;
  int tmp___0 ;

  {
  opline = execute_data->opline;
  retval = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = retval;
    tmp = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    tmp___0 = i_zend_is_true(tmp);
    __z->value.lval = (long )(tmp___0 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SWITCH_FREE_SPEC_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;

  {
  opline = execute_data->opline;
  i_zval_ptr_dtor(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_CLONE_SPEC_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *obj ;
  zend_class_entry *ce ;
  zend_function *clone ;
  zend_object_value (*clone_call)(zval *object ) ;
  long tmp ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  long tmp___1 ;
  char const   *tmp___2 ;
  long tmp___3 ;
  char const   *tmp___4 ;
  int __attribute__((__visibility__("default")))  tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  zval *retval ;
  void __attribute__((__visibility__("default")))  *tmp___8 ;
  temp_variable *__t ;
  long tmp___9 ;
  long tmp___10 ;

  {
  opline = execute_data->opline;
  obj = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1) {
    zend_error_noreturn(1, "__clone method called on non-object");
  } else {
    tmp = __builtin_expect((long )((int )obj->type != 5), 0L);
    if (tmp) {
      zend_error_noreturn(1, "__clone method called on non-object");
    } else {

    }
  }
  tmp___0 = zend_get_class_entry((zval const   *)obj);
  ce = (zend_class_entry *)tmp___0;
  if (ce) {
    clone = ce->clone;
  } else {
    clone = (zend_function *)((void *)0);
  }
  clone_call = (zend_object_value (*)(zval *object ))(obj->value.obj.handlers)->clone_obj;
  tmp___1 = __builtin_expect((long )((unsigned int )clone_call == (unsigned int )((void *)0)), 0L);
  if (tmp___1) {
    if (ce) {
      zend_error_noreturn(1, "Trying to clone an uncloneable object of class %s", ce->name);
    } else {
      zend_error_noreturn(1, "Trying to clone an uncloneable object");
    }
  } else {

  }
  if (ce) {
    if (clone) {
      if (clone->op_array.fn_flags & 1024U) {
        tmp___3 = __builtin_expect((long )((unsigned int )ce != (unsigned int )executor_globals.scope), 0L);
        if (tmp___3) {
          if (executor_globals.scope) {
            tmp___2 = (executor_globals.scope)->name;
          } else {
            tmp___2 = "";
          }
          zend_error_noreturn(1, "Call to private %s::__clone() from context \'%s\'", ce->name, tmp___2);
        } else {

        }
      } else {
        if (clone->common.fn_flags & 512U) {
          tmp___5 = zend_check_protected(clone->common.scope, executor_globals.scope);
          if (tmp___5) {
            tmp___6 = 0;
          } else {
            tmp___6 = 1;
          }
          tmp___7 = __builtin_expect((long )tmp___6, 0L);
          if (tmp___7) {
            if (executor_globals.scope) {
              tmp___4 = (executor_globals.scope)->name;
            } else {
              tmp___4 = "";
            }
            zend_error_noreturn(1, "Call to protected %s::__clone() from context \'%s\'", ce->name, tmp___4);
          } else {

          }
        } else {

        }
      }
    } else {

    }
  } else {

  }
  tmp___10 = __builtin_expect((long )((unsigned int )executor_globals.exception == (unsigned int )((void *)0)), 1L);
  if (tmp___10) {
    while (1) {
      tmp___8 = _emalloc(sizeof(zval_gc_info ));
      retval = (zval *)tmp___8;
      ((zval_gc_info *)retval)->u.buffered = (gc_root_buffer *)((void *)0);
      break;
    }
    retval->value.obj = (*clone_call)(obj);
    retval->type = (unsigned char)5;
    zval_set_refcount_p(retval, 1U);
    zval_set_isref_p(retval);
    if (! (! ((int )opline->result_type & (1 << 5)))) {
      i_zval_ptr_dtor(retval);
    } else {
      tmp___9 = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
      if (tmp___9) {
        i_zval_ptr_dtor(retval);
      } else {
        while (1) {
          __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
          __t->var.ptr = retval;
          __t->var.ptr_ptr = & __t->var.ptr;
          break;
        }
      }
    }
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_CAST_SPEC_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *expr ;
  zval *result ;
  zval var_copy ;
  int use_copy ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  expr = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (opline->extended_value != 6UL) {
    while (1) {
      result->value = expr->value;
      result->type = expr->type;
      break;
    }
    _zval_copy_ctor(result);
  } else {

  }
  switch ((int )opline->extended_value) {
  case 0: 
  convert_to_null(result);
  break;
  case 3: 
  convert_to_boolean(result);
  break;
  case 1: 
  convert_to_long(result);
  break;
  case 2: 
  convert_to_double(result);
  break;
  case 6: 
  zend_make_printable_zval(expr, & var_copy, & use_copy);
  if (use_copy) {
    while (1) {
      result->value = var_copy.value;
      result->type = var_copy.type;
      break;
    }
  } else {
    while (1) {
      result->value = expr->value;
      result->type = expr->type;
      break;
    }
    _zval_copy_ctor(result);
  }
  break;
  case 4: 
  convert_to_array(result);
  break;
  case 5: 
  convert_to_object(result);
  break;
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INCLUDE_OR_EVAL_SPEC_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_op_array *new_op_array ;
  zend_free_op free_op1 ;
  zval *inc_filename ;
  zval tmp_inc_filename ;
  zend_bool failure_retval ;
  zend_file_handle file_handle ;
  char *resolved_path ;
  char __attribute__((__visibility__("default")))  *tmp ;
  size_t tmp___0 ;
  int __attribute__((__visibility__("default")))  tmp___1 ;
  char __attribute__((__visibility__("default")))  *tmp___2 ;
  int tmp___3 ;
  zend_op_array __attribute__((__visibility__("default")))  *tmp___4 ;
  size_t tmp___5 ;
  int __attribute__((__visibility__("default")))  tmp___6 ;
  int __attribute__((__visibility__("default")))  tmp___7 ;
  zend_op_array __attribute__((__visibility__("default")))  *tmp___8 ;
  char *eval_desc ;
  char __attribute__((__visibility__("default")))  *tmp___9 ;
  zend_op_array __attribute__((__visibility__("default")))  *tmp___10 ;
  size_t tmp___11 ;
  long tmp___12 ;
  zval *retval ;
  void __attribute__((__visibility__("default")))  *tmp___13 ;
  zval *__z ;
  long tmp___14 ;
  zval *retval___0 ;
  void __attribute__((__visibility__("default")))  *tmp___15 ;
  zval *__z___0 ;
  temp_variable *__t ;
  long tmp___16 ;
  long tmp___17 ;

  {
  opline = execute_data->opline;
  new_op_array = (zend_op_array *)((void *)0);
  failure_retval = (zend_bool )0;
  inc_filename = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if ((int )inc_filename->type != 6) {
    while (1) {
      tmp_inc_filename.value = inc_filename->value;
      tmp_inc_filename.type = inc_filename->type;
      break;
    }
    _zval_copy_ctor(& tmp_inc_filename);
    if ((int )tmp_inc_filename.type != 6) {
      _convert_to_string(& tmp_inc_filename);
    } else {

    }
    inc_filename = & tmp_inc_filename;
  } else {

  }
  if (opline->extended_value != 1UL) {
    tmp___11 = strlen((char const   *)inc_filename->value.str.val);
    if (tmp___11 != (size_t )inc_filename->value.str.len) {
      if (opline->extended_value == (ulong )(1 << 2)) {
        zend_message_dispatcher(1L, (void const   *)inc_filename->value.str.val);
      } else {
        if (opline->extended_value == (ulong )(1 << 1)) {
          zend_message_dispatcher(1L, (void const   *)inc_filename->value.str.val);
        } else {
          zend_message_dispatcher(2L, (void const   *)inc_filename->value.str.val);
        }
      }
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    switch ((int )opline->extended_value) {
    case 1 << 2: 
    case 1 << 4: 
    tmp = (*zend_resolve_path)((char const   *)inc_filename->value.str.val, inc_filename->value.str.len);
    resolved_path = (char *)tmp;
    if (resolved_path) {
      tmp___0 = strlen((char const   *)resolved_path);
      tmp___1 = zend_hash_exists((HashTable const   *)(& executor_globals.included_files), (char const   *)resolved_path, tmp___0 + 1U);
      failure_retval = (unsigned char )tmp___1;
    } else {
      resolved_path = inc_filename->value.str.val;
    }
    if (failure_retval) {

    } else {
      tmp___7 = zend_stream_open((char const   *)resolved_path, & file_handle);
      if (0 == (int )tmp___7) {
        if (! file_handle.opened_path) {
          tmp___2 = _estrdup((char const   *)resolved_path);
          file_handle.opened_path = (char *)tmp___2;
        } else {

        }
        tmp___5 = strlen((char const   *)file_handle.opened_path);
        tmp___6 = zend_hash_add_empty_element(& executor_globals.included_files, (char const   *)file_handle.opened_path, tmp___5 + 1U);
        if (tmp___6 == (int __attribute__((__visibility__("default")))  )0) {
          if (opline->extended_value == (ulong )(1 << 2)) {
            tmp___3 = 1 << 1;
          } else {
            tmp___3 = 1 << 3;
          }
          tmp___4 = (*zend_compile_file)(& file_handle, tmp___3);
          new_op_array = (zend_op_array *)tmp___4;
          zend_destroy_file_handle(& file_handle);
        } else {
          zend_file_handle_dtor(& file_handle);
          failure_retval = (unsigned char)1;
        }
      } else {
        if (opline->extended_value == (ulong )(1 << 2)) {
          zend_message_dispatcher(1L, (void const   *)inc_filename->value.str.val);
        } else {
          zend_message_dispatcher(2L, (void const   *)inc_filename->value.str.val);
        }
      }
    }
    if ((unsigned int )resolved_path != (unsigned int )inc_filename->value.str.val) {
      _efree((void *)resolved_path);
    } else {

    }
    break;
    case 1 << 1: 
    case 1 << 3: 
    tmp___8 = compile_filename((int )opline->extended_value, inc_filename);
    new_op_array = (zend_op_array *)tmp___8;
    break;
    case 1: 
    tmp___9 = zend_make_compiled_string_description("eval()\'d code");
    eval_desc = (char *)tmp___9;
    tmp___10 = (*zend_compile_string)(inc_filename, eval_desc);
    new_op_array = (zend_op_array *)tmp___10;
    _efree((void *)eval_desc);
    break;
    }
  }
  if ((unsigned int )inc_filename == (unsigned int )(& tmp_inc_filename)) {
    _zval_dtor(& tmp_inc_filename);
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  tmp___17 = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
  if (tmp___17) {
    return (0);
  } else {
    tmp___16 = __builtin_expect((long )((unsigned int )new_op_array != (unsigned int )((void *)0)), 1L);
    if (tmp___16) {
      execute_data->original_return_value = executor_globals.return_value_ptr_ptr;
      executor_globals.active_op_array = new_op_array;
      if (! ((int )opline->result_type & (1 << 5))) {
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = (zval *)((void *)0);
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
        executor_globals.return_value_ptr_ptr = ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr;
      } else {
        executor_globals.return_value_ptr_ptr = (zval **)((void *)0);
      }
      execute_data->current_object = execute_data->object;
      execute_data->function_state.function = (zend_function *)new_op_array;
      execute_data->object = (zval *)((void *)0);
      if (! executor_globals.active_symbol_table) {
        zend_rebuild_symbol_table();
      } else {

      }
      tmp___12 = __builtin_expect((long )((unsigned int )zend_execute == (unsigned int )(& execute)), 1L);
      if (tmp___12) {
        return (2);
      } else {
        (*zend_execute)(new_op_array);
      }
      execute_data->function_state.function = (zend_function *)execute_data->op_array;
      execute_data->object = execute_data->current_object;
      executor_globals.opline_ptr = & execute_data->opline;
      executor_globals.active_op_array = execute_data->op_array;
      executor_globals.return_value_ptr_ptr = execute_data->original_return_value;
      destroy_op_array(new_op_array);
      _efree((void *)new_op_array);
      tmp___14 = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
      if (tmp___14) {
        zend_throw_exception_internal((zval *)((void *)0));
        return (0);
      } else {
        if (! ((int )opline->result_type & (1 << 5))) {
          if (! ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr) {
            while (1) {
              tmp___13 = _emalloc(sizeof(zval_gc_info ));
              retval = (zval *)tmp___13;
              ((zval_gc_info *)retval)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              __z = retval;
              __z->value.lval = 1L;
              __z->type = (unsigned char)3;
              break;
            }
            retval->refcount__gc = 1U;
            retval->is_ref__gc = (unsigned char)0;
            ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = retval;
          } else {

          }
        } else {

        }
      }
    } else {
      if (! ((int )opline->result_type & (1 << 5))) {
        while (1) {
          tmp___15 = _emalloc(sizeof(zval_gc_info ));
          retval___0 = (zval *)tmp___15;
          ((zval_gc_info *)retval___0)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          __z___0 = retval___0;
          __z___0->value.lval = (long )((int )failure_retval != 0);
          __z___0->type = (unsigned char)3;
          break;
        }
        retval___0->refcount__gc = 1U;
        retval___0->is_ref__gc = (unsigned char)0;
        while (1) {
          __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
          __t->var.ptr = retval___0;
          __t->var.ptr_ptr = & __t->var.ptr;
          break;
        }
      } else {

      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FE_RESET_SPEC_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *array_ptr ;
  zval **array_ptr_ptr ;
  HashTable *fe_ht ;
  zend_object_iterator *iter ;
  zend_class_entry *ce ;
  zend_bool is_empty ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___1 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_uint tmp___3 ;
  zend_bool tmp___4 ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  zend_uint tmp___6 ;
  zend_bool tmp___7 ;
  zval *tmp___8 ;
  void __attribute__((__visibility__("default")))  *tmp___9 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___10 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___11 ;
  zval *tmp___12 ;
  void __attribute__((__visibility__("default")))  *tmp___13 ;
  zend_bool tmp___14 ;
  zend_uint tmp___15 ;
  zval __attribute__((__visibility__("default")))  *tmp___16 ;
  long tmp___17 ;
  long tmp___18 ;
  int tmp___19 ;
  long tmp___20 ;
  zend_object *zobj ;
  zend_object __attribute__((__visibility__("default")))  *tmp___21 ;
  char *str_key ;
  uint str_key_len ;
  ulong int_key ;
  zend_uchar key_type ;
  int __attribute__((__visibility__("default")))  tmp___22 ;
  int __attribute__((__visibility__("default")))  tmp___23 ;
  int __attribute__((__visibility__("default")))  tmp___24 ;
  int tmp___25 ;
  int __attribute__((__visibility__("default")))  tmp___26 ;
  int __attribute__((__visibility__("default")))  tmp___27 ;
  int tmp___28 ;
  int __attribute__((__visibility__("default")))  tmp___29 ;
  HashTable *tmp___30 ;
  HashTable *tmp___31 ;
  long tmp___32 ;

  {
  opline = execute_data->opline;
  iter = (zend_object_iterator *)((void *)0);
  ce = (zend_class_entry *)((void *)0);
  is_empty = (zend_bool )0;
  if (1 << 2 == 1 << 4) {
    goto _L___4;
  } else {
    if (1 << 2 == 1 << 2) {
      _L___4: /* CIL Label */ 
      if (opline->extended_value & 1UL) {
        array_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
        if ((unsigned int )array_ptr_ptr == (unsigned int )((void *)0)) {
          goto _L___0;
        } else {
          if ((unsigned int )array_ptr_ptr == (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
            _L___0: /* CIL Label */ 
            while (1) {
              tmp = _emalloc(sizeof(zval_gc_info ));
              array_ptr = (zval *)tmp;
              ((zval_gc_info *)array_ptr)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            array_ptr->refcount__gc = 1U;
            array_ptr->is_ref__gc = (unsigned char)0;
            array_ptr->type = (unsigned char)0;
          } else {
            if ((int )(*array_ptr_ptr)->type == 5) {
              if ((unsigned int )((*array_ptr_ptr)->value.obj.handlers)->get_class_entry == (unsigned int )((void *)0)) {
                zend_error(1 << 1L, "foreach() cannot iterate over objects without PHP class");
                tmp___0 = __builtin_expect((long )(! executor_globals.exception), 1L);
                if (tmp___0) {
                  execute_data->opline = (execute_data->op_array)->opcodes + opline->op2.opline_num;
                } else {

                }
                return (0);
              } else {

              }
              tmp___1 = zend_get_class_entry((zval const   *)*array_ptr_ptr);
              ce = (zend_class_entry *)tmp___1;
              if (! ce) {
                goto _L;
              } else {
                if ((unsigned int )ce->get_iterator == (unsigned int )((void *)0)) {
                  _L: /* CIL Label */ 
                  tmp___4 = zval_isref_p(*array_ptr_ptr);
                  if (tmp___4) {

                  } else {
                    while (1) {
                      tmp___3 = zval_refcount_p(*array_ptr_ptr);
                      if (tmp___3 > 1U) {
                        zval_delref_p(*array_ptr_ptr);
                        while (1) {
                          tmp___2 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___2;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*array_ptr_ptr)->value;
                            new_zv->type = (*array_ptr_ptr)->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *array_ptr_ptr = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  }
                  zval_addref_p(*array_ptr_ptr);
                } else {

                }
              }
              array_ptr = *array_ptr_ptr;
            } else {
              if ((int )(*array_ptr_ptr)->type == 4) {
                tmp___7 = zval_isref_p(*array_ptr_ptr);
                if (tmp___7) {

                } else {
                  while (1) {
                    tmp___6 = zval_refcount_p(*array_ptr_ptr);
                    if (tmp___6 > 1U) {
                      zval_delref_p(*array_ptr_ptr);
                      while (1) {
                        tmp___5 = _emalloc(sizeof(zval_gc_info ));
                        new_zv___0 = (zval *)tmp___5;
                        ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                        break;
                      }
                      while (1) {
                        while (1) {
                          new_zv___0->value = (*array_ptr_ptr)->value;
                          new_zv___0->type = (*array_ptr_ptr)->type;
                          break;
                        }
                        zval_set_refcount_p(new_zv___0, 1U);
                        zval_unset_isref_p(new_zv___0);
                        break;
                      }
                      *array_ptr_ptr = new_zv___0;
                      _zval_copy_ctor(new_zv___0);
                    } else {

                    }
                    break;
                  }
                }
                if (opline->extended_value & 1UL) {
                  zval_set_isref_p(*array_ptr_ptr);
                } else {

                }
              } else {

              }
              array_ptr = *array_ptr_ptr;
              zval_addref_p(array_ptr);
            }
          }
        }
      } else {
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ 
      array_ptr = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
      if ((int )array_ptr->type == 5) {
        tmp___11 = zend_get_class_entry((zval const   *)array_ptr);
        ce = (zend_class_entry *)tmp___11;
        if (! ce) {
          zval_addref_p(array_ptr);
        } else {
          if (! ce->get_iterator) {
            zval_addref_p(array_ptr);
          } else {

          }
        }
      } else {
        if (1 << 2 == 1) {
          goto _L___1;
        } else {
          if (1 << 2 == 1 << 4) {
            goto _L___2;
          } else {
            if (1 << 2 == 1 << 2) {
              _L___2: /* CIL Label */ 
              tmp___14 = zval_isref_p(array_ptr);
              if (tmp___14) {
                zval_addref_p(array_ptr);
              } else {
                tmp___15 = zval_refcount_p(array_ptr);
                if (tmp___15 > 1U) {
                  _L___1: /* CIL Label */ 
                  while (1) {
                    tmp___13 = _emalloc(sizeof(zval_gc_info ));
                    tmp___12 = (zval *)tmp___13;
                    ((zval_gc_info *)tmp___12)->u.buffered = (gc_root_buffer *)((void *)0);
                    break;
                  }
                  while (1) {
                    while (1) {
                      tmp___12->value = array_ptr->value;
                      tmp___12->type = array_ptr->type;
                      break;
                    }
                    zval_set_refcount_p(tmp___12, 1U);
                    zval_unset_isref_p(tmp___12);
                    break;
                  }
                  _zval_copy_ctor(tmp___12);
                  array_ptr = tmp___12;
                } else {
                  zval_addref_p(array_ptr);
                }
              }
            } else {
              zval_addref_p(array_ptr);
            }
          }
        }
      }
    }
  }
  if (ce) {
    if (ce->get_iterator) {
      iter = (*(ce->get_iterator))(ce, array_ptr, (int )(opline->extended_value & (unsigned long )(1 << 1)));
      if (iter) {
        tmp___17 = __builtin_expect((long )((unsigned int )executor_globals.exception == (unsigned int )((void *)0)), 1L);
        if (tmp___17) {
          tmp___16 = zend_iterator_wrap(iter);
          array_ptr = (zval *)tmp___16;
        } else {
          goto _L___5;
        }
      } else {
        _L___5: /* CIL Label */ 
        if (free_op1.var) {
          i_zval_ptr_dtor(free_op1.var);
        } else {

        }
        if (! executor_globals.exception) {
          zend_throw_exception_ex((zend_class_entry *)((void *)0), 0L, (char *)"Object of type %s did not create an Iterator", ce->name);
        } else {

        }
        zend_throw_exception_internal((zval *)((void *)0));
        return (0);
      }
    } else {

    }
  } else {

  }
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->fe.ptr = array_ptr;
  if (iter) {
    iter->index = 0UL;
    if ((iter->funcs)->rewind) {
      (*((iter->funcs)->rewind))(iter);
      tmp___18 = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
      if (tmp___18) {
        i_zval_ptr_dtor(array_ptr);
        if (free_op1.var) {
          i_zval_ptr_dtor(free_op1.var);
        } else {

        }
        return (0);
      } else {

      }
    } else {

    }
    tmp___19 = (*((iter->funcs)->valid))(iter);
    is_empty = (unsigned char )(tmp___19 != 0);
    tmp___20 = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
    if (tmp___20) {
      i_zval_ptr_dtor(array_ptr);
      if (free_op1.var) {
        i_zval_ptr_dtor(free_op1.var);
      } else {

      }
      return (0);
    } else {

    }
    iter->index = 4294967295UL;
  } else {
    if ((int )array_ptr->type == 4) {
      fe_ht = array_ptr->value.ht;
    } else {
      if ((int )array_ptr->type == 5) {
        tmp___30 = (*((array_ptr->value.obj.handlers)->get_properties))(array_ptr);
        tmp___31 = tmp___30;
      } else {
        tmp___31 = (HashTable *)((void *)0);
      }
      fe_ht = tmp___31;
    }
    if ((unsigned int )fe_ht != (unsigned int )((void *)0)) {
      zend_hash_internal_pointer_reset_ex(fe_ht, (HashPosition *)((void *)0));
      if (ce) {
        tmp___21 = zend_objects_get_address((zval const   *)array_ptr);
        zobj = (zend_object *)tmp___21;
        while (1) {
          tmp___26 = zend_hash_get_current_key_type_ex(fe_ht, (HashPosition *)((void *)0));
          if (tmp___26 == (int __attribute__((__visibility__("default")))  )3) {
            tmp___25 = -1;
          } else {
            tmp___25 = 0;
          }
          if (tmp___25 == 0) {

          } else {
            break;
          }
          tmp___22 = zend_hash_get_current_key_ex((HashTable const   *)fe_ht, & str_key, & str_key_len, & int_key, (unsigned char)0, (HashPosition *)((void *)0));
          key_type = (unsigned char )tmp___22;
          if ((int )key_type != 3) {
            if ((int )key_type == 2) {
              break;
            } else {
              tmp___23 = zend_check_property_access(zobj, (char const   *)str_key, (int )(str_key_len - 1U));
              if (tmp___23 == (int __attribute__((__visibility__("default")))  )0) {
                break;
              } else {

              }
            }
          } else {

          }
          zend_hash_move_forward_ex(fe_ht, (HashPosition *)((void *)0));
        }
      } else {

      }
      tmp___29 = zend_hash_get_current_key_type_ex(fe_ht, (HashPosition *)((void *)0));
      if (tmp___29 == (int __attribute__((__visibility__("default")))  )3) {
        tmp___28 = -1;
      } else {
        tmp___28 = 0;
      }
      is_empty = (unsigned char )(tmp___28 != 0);
      zend_hash_get_pointer((HashTable const   *)fe_ht, & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->fe.fe_pos);
    } else {
      zend_error(1 << 1L, "Invalid argument supplied for foreach()");
      is_empty = (unsigned char)1;
    }
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  if (is_empty) {
    tmp___32 = __builtin_expect((long )(! executor_globals.exception), 1L);
    if (tmp___32) {
      execute_data->opline = (execute_data->op_array)->opcodes + opline->op2.opline_num;
    } else {

    }
    return (0);
  } else {
    (execute_data->opline) ++;
    return (0);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_FE_FETCH_SPEC_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *array ;
  zval **value ;
  char *str_key ;
  uint str_key_len ;
  ulong int_key ;
  HashTable *fe_ht ;
  zend_object_iterator *iter ;
  int key_type ;
  zend_bool use_key ;
  enum zend_object_iterator_kind  __attribute__((__visibility__("default"))) tmp ;
  long tmp___0 ;
  char const   *class_name ;
  char const   *prop_name ;
  zend_object *zobj ;
  zend_object __attribute__((__visibility__("default")))  *tmp___1 ;
  long tmp___2 ;
  int __attribute__((__visibility__("default")))  tmp___3 ;
  int __attribute__((__visibility__("default")))  tmp___4 ;
  int __attribute__((__visibility__("default")))  tmp___5 ;
  char __attribute__((__visibility__("default")))  *tmp___6 ;
  long tmp___7 ;
  int __attribute__((__visibility__("default")))  tmp___8 ;
  int __attribute__((__visibility__("default")))  tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  int tmp___13 ;
  long tmp___14 ;
  long tmp___15 ;
  long tmp___16 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___17 ;
  zend_uint tmp___18 ;
  zend_bool tmp___19 ;
  temp_variable *__t ;
  zval *key ;

  {
  opline = execute_data->opline;
  array = ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->fe.ptr;
  iter = (zend_object_iterator *)((void *)0);
  key_type = 0;
  use_key = (unsigned char )(opline->extended_value & 2UL);
  tmp = zend_iterator_unwrap(array, & iter);
  switch ((int )tmp) {
  default: ;
  case 0: 
  zend_error(1 << 1L, "Invalid argument supplied for foreach()");
  tmp___0 = __builtin_expect((long )(! executor_globals.exception), 1L);
  if (tmp___0) {
    execute_data->opline = (execute_data->op_array)->opcodes + opline->op2.opline_num;
  } else {

  }
  return (0);
  case 2: 
  tmp___1 = zend_objects_get_address((zval const   *)array);
  zobj = (zend_object *)tmp___1;
  fe_ht = (*((array->value.obj.handlers)->get_properties))(array);
  zend_hash_set_pointer(fe_ht, (HashPointer const   *)(& ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->fe.fe_pos));
  while (1) {
    tmp___3 = zend_hash_get_current_data_ex(fe_ht, (void **)(& value), (HashPosition *)((void *)0));
    if (tmp___3 == (int __attribute__((__visibility__("default")))  )-1) {
      tmp___2 = __builtin_expect((long )(! executor_globals.exception), 1L);
      if (tmp___2) {
        execute_data->opline = (execute_data->op_array)->opcodes + opline->op2.opline_num;
      } else {

      }
      return (0);
    } else {

    }
    tmp___4 = zend_hash_get_current_key_ex((HashTable const   *)fe_ht, & str_key, & str_key_len, & int_key, (unsigned char)0, (HashPosition *)((void *)0));
    key_type = (int )tmp___4;
    zend_hash_move_forward_ex(fe_ht, (HashPosition *)((void *)0));
    if (key_type == 3) {

    } else {
      if (key_type != 2) {
        tmp___5 = zend_check_property_access(zobj, (char const   *)str_key, (int )(str_key_len - 1U));
        if (tmp___5 != (int __attribute__((__visibility__("default")))  )0) {

        } else {
          break;
        }
      } else {
        break;
      }
    }
  }
  zend_hash_get_pointer((HashTable const   *)fe_ht, & ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->fe.fe_pos);
  if (use_key) {
    if (key_type != 2) {
      zend_unmangle_property_name((char const   *)str_key, (int )(str_key_len - 1U), & class_name, & prop_name);
      str_key_len = strlen(prop_name);
      tmp___6 = _estrndup(prop_name, str_key_len);
      str_key = (char *)tmp___6;
      str_key_len ++;
    } else {

    }
  } else {

  }
  break;
  case 1: 
  fe_ht = array->value.ht;
  zend_hash_set_pointer(fe_ht, (HashPointer const   *)(& ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->fe.fe_pos));
  tmp___8 = zend_hash_get_current_data_ex(fe_ht, (void **)(& value), (HashPosition *)((void *)0));
  if (tmp___8 == (int __attribute__((__visibility__("default")))  )-1) {
    tmp___7 = __builtin_expect((long )(! executor_globals.exception), 1L);
    if (tmp___7) {
      execute_data->opline = (execute_data->op_array)->opcodes + opline->op2.opline_num;
    } else {

    }
    return (0);
  } else {

  }
  if (use_key) {
    tmp___9 = zend_hash_get_current_key_ex((HashTable const   *)fe_ht, & str_key, & str_key_len, & int_key, (unsigned char)1, (HashPosition *)((void *)0));
    key_type = (int )tmp___9;
  } else {

  }
  zend_hash_move_forward_ex(fe_ht, (HashPosition *)((void *)0));
  zend_hash_get_pointer((HashTable const   *)fe_ht, & ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->fe.fe_pos);
  break;
  case 3: 
  if (iter) {
    (iter->index) ++;
    if (iter->index > 0UL) {
      (*((iter->funcs)->move_forward))(iter);
      tmp___10 = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
      if (tmp___10) {
        i_zval_ptr_dtor(array);
        return (0);
      } else {

      }
    } else {

    }
  } else {

  }
  if (! iter) {
    goto _L;
  } else {
    if (iter->index > 0UL) {
      tmp___13 = (*((iter->funcs)->valid))(iter);
      if (tmp___13 == -1) {
        _L: /* CIL Label */ 
        tmp___11 = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
        if (tmp___11) {
          i_zval_ptr_dtor(array);
          return (0);
        } else {

        }
        tmp___12 = __builtin_expect((long )(! executor_globals.exception), 1L);
        if (tmp___12) {
          execute_data->opline = (execute_data->op_array)->opcodes + opline->op2.opline_num;
        } else {

        }
        return (0);
      } else {

      }
    } else {

    }
  }
  (*((iter->funcs)->get_current_data))(iter, & value);
  tmp___14 = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
  if (tmp___14) {
    i_zval_ptr_dtor(array);
    return (0);
  } else {

  }
  if (! value) {
    tmp___15 = __builtin_expect((long )(! executor_globals.exception), 1L);
    if (tmp___15) {
      execute_data->opline = (execute_data->op_array)->opcodes + opline->op2.opline_num;
    } else {

    }
    return (0);
  } else {

  }
  if (use_key) {
    if ((iter->funcs)->get_current_key) {
      key_type = (*((iter->funcs)->get_current_key))(iter, & str_key, & str_key_len, & int_key);
      tmp___16 = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
      if (tmp___16) {
        i_zval_ptr_dtor(array);
        return (0);
      } else {

      }
    } else {
      key_type = 2;
      int_key = iter->index;
    }
  } else {

  }
  break;
  }
  if (opline->extended_value & 1UL) {
    tmp___19 = zval_isref_p(*value);
    if (tmp___19) {

    } else {
      while (1) {
        tmp___18 = zval_refcount_p(*value);
        if (tmp___18 > 1U) {
          zval_delref_p(*value);
          while (1) {
            tmp___17 = _emalloc(sizeof(zval_gc_info ));
            new_zv = (zval *)tmp___17;
            ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv->value = (*value)->value;
              new_zv->type = (*value)->type;
              break;
            }
            zval_set_refcount_p(new_zv, 1U);
            zval_unset_isref_p(new_zv);
            break;
          }
          *value = new_zv;
          _zval_copy_ctor(new_zv);
        } else {

        }
        break;
      }
    }
    zval_set_isref_p(*value);
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = value;
    zval_addref_p(*value);
  } else {
    zval_addref_p(*value);
    while (1) {
      __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
      __t->var.ptr = *value;
      __t->var.ptr_ptr = & __t->var.ptr;
      break;
    }
  }
  if (use_key) {
    key = & ((temp_variable *)((char *)execute_data->Ts + (opline + 1)->result.var))->tmp_var;
    switch (key_type) {
    case 1: 
    key->value.str.val = str_key;
    key->value.str.len = (int )(str_key_len - 1U);
    key->type = (unsigned char)6;
    break;
    case 2: 
    key->value.lval = (long )int_key;
    key->type = (unsigned char)1;
    break;
    default: ;
    case 3: 
    key->type = (unsigned char)0;
    break;
    }
  } else {

  }
  (execute_data->opline) ++;
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_EXIT_SPEC_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *ptr ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  if (1 << 2 != 1 << 3) {
    tmp = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    ptr = tmp;
    if ((int )ptr->type == 1) {
      executor_globals.exit_status = (int )ptr->value.lval;
    } else {
      zend_print_variable(ptr);
    }
    if (free_op1.var) {
      i_zval_ptr_dtor(free_op1.var);
    } else {

    }
  } else {

  }
  _zend_bailout((char *)"/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-12-18-beda5efd41-622412d8e6/php/Zend/zend_vm_execute.h", 11654U);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_JMP_SET_SPEC_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *value ;
  long tmp ;
  int tmp___0 ;

  {
  opline = execute_data->opline;
  value = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  tmp___0 = i_zend_is_true(value);
  if (tmp___0) {
    while (1) {
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value = value->value;
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.type = value->type;
      break;
    }
    _zval_copy_ctor(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var);
    if (free_op1.var) {
      i_zval_ptr_dtor(free_op1.var);
    } else {

    }
    tmp = __builtin_expect((long )(! executor_globals.exception), 1L);
    if (tmp) {
      execute_data->opline = opline->op2.jmp_addr;
    } else {

    }
    return (0);
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_JMP_SET_VAR_SPEC_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *value ;
  zval *ret ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  value = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  tmp___1 = i_zend_is_true(value);
  if (tmp___1) {
    if (1 << 2 == 1 << 2) {
      zval_addref_p(value);
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = value;
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
    } else {
      if (1 << 2 == 1 << 4) {
        zval_addref_p(value);
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = value;
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
      } else {
        while (1) {
          tmp = _emalloc(sizeof(zval_gc_info ));
          ret = (zval *)tmp;
          ((zval_gc_info *)ret)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            ret->value = value->value;
            ret->type = value->type;
            break;
          }
          zval_set_refcount_p(ret, 1U);
          zval_unset_isref_p(ret);
          break;
        }
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = ret;
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
        _zval_copy_ctor(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr);
      }
    }
    if (free_op1.var) {
      i_zval_ptr_dtor(free_op1.var);
    } else {

    }
    tmp___0 = __builtin_expect((long )(! executor_globals.exception), 1L);
    if (tmp___0) {
      execute_data->opline = opline->op2.jmp_addr;
    } else {

    }
    return (0);
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_QM_ASSIGN_SPEC_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *value ;

  {
  opline = execute_data->opline;
  value = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  while (1) {
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value = value->value;
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.type = value->type;
    break;
  }
  _zval_copy_ctor(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_QM_ASSIGN_VAR_SPEC_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *value ;
  zval *ret ;
  void __attribute__((__visibility__("default")))  *tmp ;

  {
  opline = execute_data->opline;
  value = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 2) {
    zval_addref_p(value);
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = value;
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
  } else {
    if (1 << 2 == 1 << 4) {
      zval_addref_p(value);
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = value;
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
    } else {
      while (1) {
        tmp = _emalloc(sizeof(zval_gc_info ));
        ret = (zval *)tmp;
        ((zval_gc_info *)ret)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      while (1) {
        while (1) {
          ret->value = value->value;
          ret->type = value->type;
          break;
        }
        zval_set_refcount_p(ret, 1U);
        zval_unset_isref_p(ret);
        break;
      }
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = ret;
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
      _zval_copy_ctor(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr);
    }
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INSTANCEOF_SPEC_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *expr ;
  zend_bool result ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp ;
  zend_bool __attribute__((__visibility__("default")))  tmp___0 ;
  zval *__z ;

  {
  opline = execute_data->opline;
  expr = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if ((int )expr->type == 5) {
    if ((expr->value.obj.handlers)->get_class_entry) {
      tmp = zend_get_class_entry((zval const   *)expr);
      tmp___0 = instanceof_function((zend_class_entry const   *)tmp, (zend_class_entry const   *)((temp_variable *)((char *)execute_data->Ts + opline->op2.var))->class_entry);
      result = (unsigned char )tmp___0;
    } else {
      result = (unsigned char)0;
    }
  } else {
    result = (unsigned char)0;
  }
  while (1) {
    __z = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
    __z->value.lval = (long )((int )result != 0);
    __z->type = (unsigned char)3;
    break;
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  fast_add_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp, opline->op2.zv);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SUB_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  fast_sub_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp, opline->op2.zv);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_MUL_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  fast_mul_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp, opline->op2.zv);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_DIV_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  fast_div_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp, opline->op2.zv);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_MOD_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  fast_mod_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp, opline->op2.zv);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SL_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  shift_left_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp, opline->op2.zv);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SR_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  shift_right_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp, opline->op2.zv);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_CONCAT_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  concat_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp, opline->op2.zv);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_IDENTICAL_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  is_identical_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp, opline->op2.zv);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_NOT_IDENTICAL_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *result ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  tmp = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  is_identical_function(result, tmp, opline->op2.zv);
  result->value.lval = (long )(! result->value.lval);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_EQUAL_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  int tmp___0 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    tmp___0 = fast_equal_function(result, tmp, opline->op2.zv);
    __z->value.lval = (long )(tmp___0 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_NOT_EQUAL_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  int tmp___0 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    tmp___0 = fast_not_equal_function(result, tmp, opline->op2.zv);
    __z->value.lval = (long )(tmp___0 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_SMALLER_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  int tmp___0 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    tmp___0 = fast_is_smaller_function(result, tmp, opline->op2.zv);
    __z->value.lval = (long )(tmp___0 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_SMALLER_OR_EQUAL_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  int tmp___0 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    tmp___0 = fast_is_smaller_or_equal_function(result, tmp, opline->op2.zv);
    __z->value.lval = (long )(tmp___0 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_OR_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  bitwise_or_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp, opline->op2.zv);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_AND_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  bitwise_and_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp, opline->op2.zv);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_XOR_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  bitwise_xor_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp, opline->op2.zv);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BOOL_XOR_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  boolean_xor_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp, opline->op2.zv);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_binary_assign_op_obj_helper_SPEC_VAR_CONST)(int (*binary_op)(zval *result , zval *op1 , zval *op2 ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op_data1 ;
  zval **object_ptr ;
  zval **tmp ;
  zval *object ;
  zval *property ;
  zval *value ;
  zval *tmp___0 ;
  int have_get_ptr ;
  long tmp___1 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zval **zptr ;
  zval **tmp___3 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_uint tmp___5 ;
  zend_bool tmp___6 ;
  zval *z ;
  zval *value___0 ;
  zval *tmp___7 ;
  zend_uint tmp___8 ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___9 ;
  zend_uint tmp___10 ;
  zend_bool tmp___11 ;
  long tmp___12 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  object_ptr = tmp;
  property = opline->op2.zv;
  tmp___0 = _get_zval_ptr((int )(opline + 1)->op1_type, (znode_op const   *)(& (opline + 1)->op1), (temp_variable const   *)execute_data->Ts, & free_op_data1, 0);
  value = tmp___0;
  have_get_ptr = 0;
  if (1 << 2 == 1 << 2) {
    tmp___1 = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___1) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  make_real_object(object_ptr);
  object = *object_ptr;
  tmp___12 = __builtin_expect((long )((int )object->type != 5), 0L);
  if (tmp___12) {
    zend_error(1 << 1L, "Attempt to assign property of non-object");
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = & executor_globals.uninitialized_zval;
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
    } else {

    }
  } else {
    if (opline->extended_value == 136UL) {
      if ((object->value.obj.handlers)->get_property_ptr_ptr) {
        tmp___3 = (*((object->value.obj.handlers)->get_property_ptr_ptr))(object, property, (struct _zend_literal  const  *)opline->op2.literal);
        zptr = tmp___3;
        if ((unsigned int )zptr != (unsigned int )((void *)0)) {
          tmp___6 = zval_isref_p(*zptr);
          if (tmp___6) {

          } else {
            while (1) {
              tmp___5 = zval_refcount_p(*zptr);
              if (tmp___5 > 1U) {
                zval_delref_p(*zptr);
                while (1) {
                  tmp___4 = _emalloc(sizeof(zval_gc_info ));
                  new_zv = (zval *)tmp___4;
                  ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                  break;
                }
                while (1) {
                  while (1) {
                    new_zv->value = (*zptr)->value;
                    new_zv->type = (*zptr)->type;
                    break;
                  }
                  zval_set_refcount_p(new_zv, 1U);
                  zval_unset_isref_p(new_zv);
                  break;
                }
                *zptr = new_zv;
                _zval_copy_ctor(new_zv);
              } else {

              }
              break;
            }
          }
          have_get_ptr = 1;
          (*binary_op)(*zptr, *zptr, value);
          if (! ((int )opline->result_type & (1 << 5))) {
            zval_addref_p(*zptr);
            ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = *zptr;
            ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
          } else {

          }
        } else {

        }
      } else {

      }
    } else {

    }
    if (! have_get_ptr) {
      z = (zval *)((void *)0);
      if (opline->extended_value == 136UL) {
        if ((object->value.obj.handlers)->read_property) {
          z = (*((object->value.obj.handlers)->read_property))(object, property, 0, (struct _zend_literal  const  *)opline->op2.literal);
        } else {

        }
      } else {
        if ((object->value.obj.handlers)->read_dimension) {
          z = (*((object->value.obj.handlers)->read_dimension))(object, property, 0);
        } else {

        }
      }
      if (z) {
        if ((int )z->type == 5) {
          if ((z->value.obj.handlers)->get) {
            tmp___7 = (*((z->value.obj.handlers)->get))(z);
            value___0 = tmp___7;
            tmp___8 = zval_refcount_p(z);
            if (tmp___8 == 0U) {
              if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                gc_remove_zval_from_buffer(z);
              } else {

              }
              _zval_dtor(z);
              while (1) {
                if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                  gc_remove_zval_from_buffer(z);
                } else {

                }
                _efree((void *)z);
                break;
              }
            } else {

            }
            z = value___0;
          } else {

          }
        } else {

        }
        zval_addref_p(z);
        tmp___11 = zval_isref_p(z);
        if (tmp___11) {

        } else {
          while (1) {
            tmp___10 = zval_refcount_p(z);
            if (tmp___10 > 1U) {
              zval_delref_p(z);
              while (1) {
                tmp___9 = _emalloc(sizeof(zval_gc_info ));
                new_zv___0 = (zval *)tmp___9;
                ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv___0->value = z->value;
                  new_zv___0->type = z->type;
                  break;
                }
                zval_set_refcount_p(new_zv___0, 1U);
                zval_unset_isref_p(new_zv___0);
                break;
              }
              z = new_zv___0;
              _zval_copy_ctor(new_zv___0);
            } else {

            }
            break;
          }
        }
        (*binary_op)(z, z, value);
        if (opline->extended_value == 136UL) {
          (*((object->value.obj.handlers)->write_property))(object, property, z, (struct _zend_literal  const  *)opline->op2.literal);
        } else {
          (*((object->value.obj.handlers)->write_dimension))(object, property, z);
        }
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(z);
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = z;
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
        } else {

        }
        i_zval_ptr_dtor(z);
      } else {
        zend_error(1 << 1L, "Attempt to assign property of non-object");
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = & executor_globals.uninitialized_zval;
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
        } else {

        }
      }
    } else {

    }
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_binary_assign_op_helper_SPEC_VAR_CONST)(int (*binary_op)(zval *result , zval *op1 , zval *op2 ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op_data2 ;
  zend_free_op free_op_data1 ;
  zval **var_ptr ;
  zval *value ;
  int tmp ;
  zval **container ;
  zval **tmp___0 ;
  int tmp___1 ;
  zval *dim ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  temp_variable *__t ;
  long tmp___5 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;
  zend_uint tmp___7 ;
  zend_bool tmp___8 ;
  zval *objval ;
  zval *tmp___9 ;
  long tmp___10 ;
  temp_variable *__t___0 ;

  {
  opline = execute_data->opline;
  switch ((int )opline->extended_value) {
  case 136: 
  tmp = zend_binary_assign_op_obj_helper_SPEC_VAR_CONST(binary_op, execute_data);
  return (tmp);
  break;
  case 147: 
  tmp___0 = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  container = tmp___0;
  if (1 << 2 == 1 << 2) {
    tmp___3 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___3) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    tmp___2 = __builtin_expect((long )((int )(*container)->type == 5), 0L);
    if (tmp___2) {
      if (1 << 2 == 1 << 2) {
        if (! ((unsigned int )free_op1.var != (unsigned int )((void *)0))) {
          zval_addref_p(*container);
        } else {

        }
      } else {

      }
      tmp___1 = zend_binary_assign_op_obj_helper_SPEC_VAR_CONST(binary_op, execute_data);
      return (tmp___1);
    } else {
      dim = opline->op2.zv;
      zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var), container, dim, 1, 2);
      value = _get_zval_ptr((int )(opline + 1)->op1_type, (znode_op const   *)(& (opline + 1)->op1), (temp_variable const   *)execute_data->Ts, & free_op_data1, 0);
      var_ptr = _get_zval_ptr_ptr_var((opline + 1)->op2.var, (temp_variable const   *)execute_data->Ts, & free_op_data2);
    }
  }
  break;
  default: 
  value = opline->op2.zv;
  var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  break;
  }
  tmp___4 = __builtin_expect((long )((unsigned int )var_ptr == (unsigned int )((void *)0)), 0L);
  if (tmp___4) {
    zend_error_noreturn(1, "Cannot use assign-op operators with overloaded objects nor string offsets");
  } else {

  }
  tmp___5 = __builtin_expect((long )((unsigned int )*var_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
  if (tmp___5) {
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      while (1) {
        __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t->var.ptr = & executor_globals.uninitialized_zval;
        __t->var.ptr_ptr = & __t->var.ptr;
        break;
      }
    } else {

    }
    if (free_op1.var) {
      i_zval_ptr_dtor(free_op1.var);
    } else {

    }
    if (opline->extended_value == 147UL) {
      (execute_data->opline) ++;
    } else {

    }
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  tmp___8 = zval_isref_p(*var_ptr);
  if (tmp___8) {

  } else {
    while (1) {
      tmp___7 = zval_refcount_p(*var_ptr);
      if (tmp___7 > 1U) {
        zval_delref_p(*var_ptr);
        while (1) {
          tmp___6 = _emalloc(sizeof(zval_gc_info ));
          new_zv = (zval *)tmp___6;
          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            new_zv->value = (*var_ptr)->value;
            new_zv->type = (*var_ptr)->type;
            break;
          }
          zval_set_refcount_p(new_zv, 1U);
          zval_unset_isref_p(new_zv);
          break;
        }
        *var_ptr = new_zv;
        _zval_copy_ctor(new_zv);
      } else {

      }
      break;
    }
  }
  tmp___10 = __builtin_expect((long )((int )(*var_ptr)->type == 5), 0L);
  if (tmp___10) {
    if (((*var_ptr)->value.obj.handlers)->get) {
      if (((*var_ptr)->value.obj.handlers)->set) {
        tmp___9 = (*(((*var_ptr)->value.obj.handlers)->get))(*var_ptr);
        objval = tmp___9;
        zval_addref_p(objval);
        (*binary_op)(objval, objval, value);
        (*(((*var_ptr)->value.obj.handlers)->set))(var_ptr, objval);
        i_zval_ptr_dtor(objval);
      } else {
        (*binary_op)(*var_ptr, *var_ptr, value);
      }
    } else {
      (*binary_op)(*var_ptr, *var_ptr, value);
    }
  } else {
    (*binary_op)(*var_ptr, *var_ptr, value);
  }
  if (! ((int )opline->result_type & (1 << 5))) {
    zval_addref_p(*var_ptr);
    while (1) {
      __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
      __t___0->var.ptr = *var_ptr;
      __t___0->var.ptr_ptr = & __t___0->var.ptr;
      break;
    }
  } else {

  }
  if (opline->extended_value == 147UL) {
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
    if (free_op_data2.var) {
      i_zval_ptr_dtor(free_op_data2.var);
    } else {

    }
    if (free_op1.var) {
      i_zval_ptr_dtor(free_op1.var);
    } else {

    }
    (execute_data->opline) ++;
  } else {
    if (free_op1.var) {
      i_zval_ptr_dtor(free_op1.var);
    } else {

    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_ADD_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_CONST((int (*)(zval *result , zval *op1 , zval *op2 ))(& add_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SUB_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_CONST((int (*)(zval *result , zval *op1 , zval *op2 ))(& sub_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_MUL_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_CONST((int (*)(zval *result , zval *op1 , zval *op2 ))(& mul_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_DIV_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_CONST((int (*)(zval *result , zval *op1 , zval *op2 ))(& div_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_MOD_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_CONST((int (*)(zval *result , zval *op1 , zval *op2 ))(& mod_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SL_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_CONST((int (*)(zval *result , zval *op1 , zval *op2 ))(& shift_left_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SR_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_CONST((int (*)(zval *result , zval *op1 , zval *op2 ))(& shift_right_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_CONCAT_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_CONST((int (*)(zval *result , zval *op1 , zval *op2 ))(& concat_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_OR_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_CONST((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_or_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_AND_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_CONST((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_and_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_XOR_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_CONST((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_xor_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) zend_pre_incdec_property_helper_SPEC_VAR_CONST)(int (*incdec_op)(zval * ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **object_ptr ;
  zval *object ;
  zval *property ;
  zval **retval ;
  int have_get_ptr ;
  long tmp ;
  long tmp___0 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zval **zptr ;
  zval **tmp___2 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___3 ;
  zend_uint tmp___4 ;
  zend_bool tmp___5 ;
  zval *z ;
  zval *tmp___6 ;
  zval *value ;
  zval *tmp___7 ;
  zend_uint tmp___8 ;
  long tmp___9 ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___10 ;
  zend_uint tmp___11 ;
  zend_bool tmp___12 ;

  {
  opline = execute_data->opline;
  have_get_ptr = 0;
  object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  property = opline->op2.zv;
  retval = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
  if (1 << 2 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot increment/decrement overloaded objects nor string offsets");
    } else {

    }
  } else {

  }
  make_real_object(object_ptr);
  object = *object_ptr;
  tmp___0 = __builtin_expect((long )((int )object->type != 5), 0L);
  if (tmp___0) {
    zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      *retval = & executor_globals.uninitialized_zval;
    } else {

    }
    if (free_op1.var) {
      i_zval_ptr_dtor(free_op1.var);
    } else {

    }
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  if ((object->value.obj.handlers)->get_property_ptr_ptr) {
    tmp___2 = (*((object->value.obj.handlers)->get_property_ptr_ptr))(object, property, (struct _zend_literal  const  *)opline->op2.literal);
    zptr = tmp___2;
    if ((unsigned int )zptr != (unsigned int )((void *)0)) {
      tmp___5 = zval_isref_p(*zptr);
      if (tmp___5) {

      } else {
        while (1) {
          tmp___4 = zval_refcount_p(*zptr);
          if (tmp___4 > 1U) {
            zval_delref_p(*zptr);
            while (1) {
              tmp___3 = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp___3;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*zptr)->value;
                new_zv->type = (*zptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *zptr = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
      have_get_ptr = 1;
      (*incdec_op)(*zptr);
      if (! ((int )opline->result_type & (1 << 5))) {
        *retval = *zptr;
        zval_addref_p(*retval);
      } else {

      }
    } else {

    }
  } else {

  }
  if (! have_get_ptr) {
    if ((object->value.obj.handlers)->read_property) {
      if ((object->value.obj.handlers)->write_property) {
        tmp___6 = (*((object->value.obj.handlers)->read_property))(object, property, 0, (struct _zend_literal  const  *)opline->op2.literal);
        z = tmp___6;
        tmp___9 = __builtin_expect((long )((int )z->type == 5), 0L);
        if (tmp___9) {
          if ((z->value.obj.handlers)->get) {
            tmp___7 = (*((z->value.obj.handlers)->get))(z);
            value = tmp___7;
            tmp___8 = zval_refcount_p(z);
            if (tmp___8 == 0U) {
              if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                gc_remove_zval_from_buffer(z);
              } else {

              }
              _zval_dtor(z);
              while (1) {
                if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                  gc_remove_zval_from_buffer(z);
                } else {

                }
                _efree((void *)z);
                break;
              }
            } else {

            }
            z = value;
          } else {

          }
        } else {

        }
        zval_addref_p(z);
        tmp___12 = zval_isref_p(z);
        if (tmp___12) {

        } else {
          while (1) {
            tmp___11 = zval_refcount_p(z);
            if (tmp___11 > 1U) {
              zval_delref_p(z);
              while (1) {
                tmp___10 = _emalloc(sizeof(zval_gc_info ));
                new_zv___0 = (zval *)tmp___10;
                ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv___0->value = z->value;
                  new_zv___0->type = z->type;
                  break;
                }
                zval_set_refcount_p(new_zv___0, 1U);
                zval_unset_isref_p(new_zv___0);
                break;
              }
              z = new_zv___0;
              _zval_copy_ctor(new_zv___0);
            } else {

            }
            break;
          }
        }
        (*incdec_op)(z);
        *retval = z;
        (*((object->value.obj.handlers)->write_property))(object, property, z, (struct _zend_literal  const  *)opline->op2.literal);
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(*retval);
        } else {

        }
        i_zval_ptr_dtor(z);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
      if (! ((int )opline->result_type & (1 << 5))) {
        zval_addref_p(& executor_globals.uninitialized_zval);
        *retval = & executor_globals.uninitialized_zval;
      } else {

      }
    }
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_PRE_INC_OBJ_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_pre_incdec_property_helper_SPEC_VAR_CONST((int (*)(zval * ))(& increment_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_PRE_DEC_OBJ_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_pre_incdec_property_helper_SPEC_VAR_CONST((int (*)(zval * ))(& decrement_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) zend_post_incdec_property_helper_SPEC_VAR_CONST)(int (*incdec_op)(zval * ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **object_ptr ;
  zval *object ;
  zval *property ;
  zval *retval ;
  int have_get_ptr ;
  long tmp ;
  long tmp___0 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zval **zptr ;
  zval **tmp___2 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___3 ;
  zend_uint tmp___4 ;
  zend_bool tmp___5 ;
  zval *z ;
  zval *tmp___6 ;
  zval *z_copy ;
  zval *value ;
  zval *tmp___7 ;
  zend_uint tmp___8 ;
  long tmp___9 ;
  void __attribute__((__visibility__("default")))  *tmp___10 ;

  {
  opline = execute_data->opline;
  have_get_ptr = 0;
  object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  property = opline->op2.zv;
  retval = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  if (1 << 2 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot increment/decrement overloaded objects nor string offsets");
    } else {

    }
  } else {

  }
  make_real_object(object_ptr);
  object = *object_ptr;
  tmp___0 = __builtin_expect((long )((int )object->type != 5), 0L);
  if (tmp___0) {
    zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
    retval->type = (unsigned char)0;
    if (free_op1.var) {
      i_zval_ptr_dtor(free_op1.var);
    } else {

    }
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  if ((object->value.obj.handlers)->get_property_ptr_ptr) {
    tmp___2 = (*((object->value.obj.handlers)->get_property_ptr_ptr))(object, property, (struct _zend_literal  const  *)opline->op2.literal);
    zptr = tmp___2;
    if ((unsigned int )zptr != (unsigned int )((void *)0)) {
      have_get_ptr = 1;
      tmp___5 = zval_isref_p(*zptr);
      if (tmp___5) {

      } else {
        while (1) {
          tmp___4 = zval_refcount_p(*zptr);
          if (tmp___4 > 1U) {
            zval_delref_p(*zptr);
            while (1) {
              tmp___3 = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp___3;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*zptr)->value;
                new_zv->type = (*zptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *zptr = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
      while (1) {
        retval->value = (*zptr)->value;
        retval->type = (*zptr)->type;
        break;
      }
      _zval_copy_ctor(retval);
      (*incdec_op)(*zptr);
    } else {

    }
  } else {

  }
  if (! have_get_ptr) {
    if ((object->value.obj.handlers)->read_property) {
      if ((object->value.obj.handlers)->write_property) {
        tmp___6 = (*((object->value.obj.handlers)->read_property))(object, property, 0, (struct _zend_literal  const  *)opline->op2.literal);
        z = tmp___6;
        tmp___9 = __builtin_expect((long )((int )z->type == 5), 0L);
        if (tmp___9) {
          if ((z->value.obj.handlers)->get) {
            tmp___7 = (*((z->value.obj.handlers)->get))(z);
            value = tmp___7;
            tmp___8 = zval_refcount_p(z);
            if (tmp___8 == 0U) {
              if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                gc_remove_zval_from_buffer(z);
              } else {

              }
              _zval_dtor(z);
              while (1) {
                if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                  gc_remove_zval_from_buffer(z);
                } else {

                }
                _efree((void *)z);
                break;
              }
            } else {

            }
            z = value;
          } else {

          }
        } else {

        }
        while (1) {
          retval->value = z->value;
          retval->type = z->type;
          break;
        }
        _zval_copy_ctor(retval);
        while (1) {
          tmp___10 = _emalloc(sizeof(zval_gc_info ));
          z_copy = (zval *)tmp___10;
          ((zval_gc_info *)z_copy)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            z_copy->value = z->value;
            z_copy->type = z->type;
            break;
          }
          zval_set_refcount_p(z_copy, 1U);
          zval_unset_isref_p(z_copy);
          break;
        }
        _zval_copy_ctor(z_copy);
        (*incdec_op)(z_copy);
        zval_addref_p(z);
        (*((object->value.obj.handlers)->write_property))(object, property, z_copy, (struct _zend_literal  const  *)opline->op2.literal);
        i_zval_ptr_dtor(z_copy);
        i_zval_ptr_dtor(z);
      } else {
        zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
        retval->type = (unsigned char)0;
      }
    } else {
      zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
      retval->type = (unsigned char)0;
    }
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_POST_INC_OBJ_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_post_incdec_property_helper_SPEC_VAR_CONST((int (*)(zval * ))(& increment_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_POST_DEC_OBJ_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_post_incdec_property_helper_SPEC_VAR_CONST((int (*)(zval * ))(& decrement_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) zend_fetch_var_address_helper_SPEC_VAR_CONST)(int type , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *varname ;
  zval **retval ;
  zval tmp_varname ;
  HashTable *target_symbol_table ;
  ulong hash_value ;
  long tmp ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_literal *tmp___1 ;
  zval __attribute__((__visibility__("default")))  **tmp___2 ;
  ulong __attribute__((__visibility__("default")))  tmp___3 ;
  int __attribute__((__visibility__("default")))  tmp___4 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  zend_uint tmp___6 ;
  zend_bool tmp___7 ;
  temp_variable *__t ;
  zend_free_op free_res ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___8 ;
  zend_uint tmp___9 ;
  zend_bool tmp___10 ;

  {
  opline = execute_data->opline;
  varname = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 != 1) {
    tmp = __builtin_expect((long )((int )varname->type != 6), 0L);
    if (tmp) {
      while (1) {
        tmp_varname.value = varname->value;
        tmp_varname.type = varname->type;
        break;
      }
      _zval_copy_ctor(& tmp_varname);
      zval_set_refcount_p(& tmp_varname, 1U);
      zval_unset_isref_p(& tmp_varname);
      if ((int )tmp_varname.type != 6) {
        _convert_to_string(& tmp_varname);
      } else {

      }
      varname = & tmp_varname;
    } else {

    }
  } else {

  }
  if (1 != 1 << 3) {
    if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
      ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
    } else {
      tmp___0 = zend_fetch_class_by_name((char const   *)(opline->op2.zv)->value.str.val, (unsigned int )(opline->op2.zv)->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), 0);
      ce = (zend_class_entry *)tmp___0;
      while (1) {
        *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
        break;
      }
    }
    if (1 << 2 == 1) {
      tmp___1 = opline->op1.literal;
    } else {
      tmp___1 = (zend_literal *)((void *)0);
    }
    tmp___2 = zend_std_get_static_property(ce, (char const   *)varname->value.str.val, varname->value.str.len, (unsigned char)0, (struct _zend_literal  const  *)tmp___1);
    retval = (zval **)tmp___2;
    if (free_op1.var) {
      i_zval_ptr_dtor(free_op1.var);
    } else {

    }
  } else {
    target_symbol_table = zend_get_target_symbol_table((int )(opline->extended_value & 1879048192UL));
    if (1 << 2 == 1) {
      hash_value = ((zend_literal *)varname)->hash_value;
    } else {
      if ((unsigned int )varname->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
        if ((unsigned int )varname->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
          hash_value = ((Bucket *)(varname->value.str.val - sizeof(Bucket )))->h;
        } else {
          tmp___3 = zend_hash_func((char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1));
          hash_value = (unsigned long )tmp___3;
        }
      } else {
        tmp___3 = zend_hash_func((char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1));
        hash_value = (unsigned long )tmp___3;
      }
    }
    tmp___4 = zend_hash_quick_find((HashTable const   *)target_symbol_table, (char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1), hash_value, (void **)(& retval));
    if (tmp___4 == (int __attribute__((__visibility__("default")))  )-1) {
      switch (type) {
      case 0: 
      case 6: 
      zend_error(1 << 3L, "Undefined variable: %s", varname->value.str.val);
      case 3: 
      retval = & executor_globals.uninitialized_zval_ptr;
      break;
      case 2: 
      zend_error(1 << 3L, "Undefined variable: %s", varname->value.str.val);
      case 1: 
      zval_addref_p(& executor_globals.uninitialized_zval);
      _zend_hash_quick_add_or_update(target_symbol_table, (char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1), hash_value, (void *)(& executor_globals.uninitialized_zval_ptr), sizeof(zval *), (void **)(& retval), 1);
      break;
      }
    } else {

    }
    switch ((int )(opline->extended_value & 1879048192UL)) {
    case 0x00000000: 
    if (1 << 2 != 1 << 1) {
      if (free_op1.var) {
        i_zval_ptr_dtor(free_op1.var);
      } else {

      }
    } else {

    }
    break;
    case 0x10000000: 
    if (free_op1.var) {
      i_zval_ptr_dtor(free_op1.var);
    } else {

    }
    break;
    case 0x20000000: 
    zval_update_constant(retval, (void *)1);
    break;
    case 0x40000000: 
    if (1 << 2 == 1 << 2) {
      if (! free_op1.var) {
        zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr));
      } else {

      }
    } else {

    }
    break;
    }
  }
  if (1 << 2 != 1) {
    if ((unsigned int )varname == (unsigned int )(& tmp_varname)) {
      _zval_dtor(& tmp_varname);
    } else {

    }
  } else {

  }
  if (opline->extended_value & 67108864UL) {
    tmp___7 = zval_isref_p(*retval);
    if (tmp___7) {

    } else {
      while (1) {
        tmp___6 = zval_refcount_p(*retval);
        if (tmp___6 > 1U) {
          zval_delref_p(*retval);
          while (1) {
            tmp___5 = _emalloc(sizeof(zval_gc_info ));
            new_zv = (zval *)tmp___5;
            ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv->value = (*retval)->value;
              new_zv->type = (*retval)->type;
              break;
            }
            zval_set_refcount_p(new_zv, 1U);
            zval_unset_isref_p(new_zv);
            break;
          }
          *retval = new_zv;
          _zval_copy_ctor(new_zv);
        } else {

        }
        break;
      }
      zval_set_isref_p(*retval);
    }
  } else {

  }
  zval_addref_p(*retval);
  switch (type) {
  case 0: 
  case 3: 
  while (1) {
    __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
    __t->var.ptr = *retval;
    __t->var.ptr_ptr = & __t->var.ptr;
    break;
  }
  break;
  case 6: 
  zend_pzval_unlock_func(*retval, & free_res, 1);
  if ((unsigned int )retval != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
    tmp___10 = zval_isref_p(*retval);
    if (tmp___10) {

    } else {
      while (1) {
        tmp___9 = zval_refcount_p(*retval);
        if (tmp___9 > 1U) {
          zval_delref_p(*retval);
          while (1) {
            tmp___8 = _emalloc(sizeof(zval_gc_info ));
            new_zv___0 = (zval *)tmp___8;
            ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv___0->value = (*retval)->value;
              new_zv___0->type = (*retval)->type;
              break;
            }
            zval_set_refcount_p(new_zv___0, 1U);
            zval_unset_isref_p(new_zv___0);
            break;
          }
          *retval = new_zv___0;
          _zval_copy_ctor(new_zv___0);
        } else {

        }
        break;
      }
    }
  } else {

  }
  zval_addref_p(*retval);
  if (free_res.var) {
    i_zval_ptr_dtor(free_res.var);
  } else {

  }
  default: 
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = retval;
  break;
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_R_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_VAR_CONST(0, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_W_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_VAR_CONST(1, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_RW_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_VAR_CONST(2, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_FUNC_ARG_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  unsigned int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
  opline = execute_data->opline;
  if (execute_data->fbc) {
    if ((execute_data->fbc)->common.arg_info) {
      if ((opline->extended_value & 1048575UL) <= (unsigned long )(execute_data->fbc)->common.num_args) {
        tmp___1 = (unsigned int )((int )((execute_data->fbc)->common.arg_info + ((opline->extended_value & 1048575UL) - 1UL))->pass_by_reference & 3);
      } else {
        tmp___1 = (execute_data->fbc)->common.fn_flags & 50331648U;
      }
    } else {
      tmp___1 = (execute_data->fbc)->common.fn_flags & 50331648U;
    }
    if (tmp___1) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___2 = zend_fetch_var_address_helper_SPEC_VAR_CONST(tmp___0, execute_data);
  return (tmp___2);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_UNSET_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_VAR_CONST(6, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_IS_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_VAR_CONST(3, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_R_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **container ;

  {
  opline = execute_data->opline;
  if (opline->extended_value & 134217728UL) {
    if (1 << 2 != 1 << 4) {
      if (((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr) {
        zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr));
      } else {

      }
    } else {

    }
  } else {

  }
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  zend_fetch_dimension_address_read((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, opline->op2.zv, 1, 0);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_W_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **container ;
  long tmp ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_uint tmp___1 ;
  zend_bool tmp___2 ;
  zend_uint tmp___3 ;
  zend_uint tmp___4 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___5 ;
  zval **retval_ptr ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;
  zend_uint tmp___7 ;
  zend_bool tmp___8 ;
  long tmp___9 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, opline->op2.zv, 1, 1);
  if (1 << 2 == 1 << 2) {
    if ((unsigned int )free_op1.var != (unsigned int )((void *)0)) {
      tmp___4 = zval_refcount_p(free_op1.var);
      if (tmp___4 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___5 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___5 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___2 = zval_isref_p(__t->var.ptr);
                if (tmp___2) {

                } else {
                  tmp___3 = zval_refcount_p(__t->var.ptr);
                  if (tmp___3 > 2U) {
                    while (1) {
                      tmp___1 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___1 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___0 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___0;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  tmp___9 = __builtin_expect((long )(opline->extended_value != 0UL), 0L);
  if (tmp___9) {
    retval_ptr = ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr;
    if (retval_ptr) {
      zval_delref_p(*retval_ptr);
      tmp___8 = zval_isref_p(*retval_ptr);
      if (tmp___8) {

      } else {
        while (1) {
          tmp___7 = zval_refcount_p(*retval_ptr);
          if (tmp___7 > 1U) {
            zval_delref_p(*retval_ptr);
            while (1) {
              tmp___6 = _emalloc(sizeof(zval_gc_info ));
              new_zv___0 = (zval *)tmp___6;
              ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv___0->value = (*retval_ptr)->value;
                new_zv___0->type = (*retval_ptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv___0, 1U);
              zval_unset_isref_p(new_zv___0);
              break;
            }
            *retval_ptr = new_zv___0;
            _zval_copy_ctor(new_zv___0);
          } else {

          }
          break;
        }
        zval_set_isref_p(*retval_ptr);
      }
      zval_addref_p(*retval_ptr);
    } else {

    }
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_RW_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **container ;
  long tmp ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_uint tmp___1 ;
  zend_bool tmp___2 ;
  zend_uint tmp___3 ;
  zend_uint tmp___4 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___5 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, opline->op2.zv, 1, 2);
  if (1 << 2 == 1 << 2) {
    if ((unsigned int )free_op1.var != (unsigned int )((void *)0)) {
      tmp___4 = zval_refcount_p(free_op1.var);
      if (tmp___4 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___5 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___5 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___2 = zval_isref_p(__t->var.ptr);
                if (tmp___2) {

                } else {
                  tmp___3 = zval_refcount_p(__t->var.ptr);
                  if (tmp___3 > 2U) {
                    while (1) {
                      tmp___1 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___1 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___0 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___0;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_IS_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **container ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  zend_fetch_dimension_address_read((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, opline->op2.zv, 1, 3);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **container ;
  long tmp ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_uint tmp___1 ;
  zend_bool tmp___2 ;
  zend_uint tmp___3 ;
  zend_uint tmp___4 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___5 ;
  unsigned int tmp___6 ;

  {
  opline = execute_data->opline;
  if (execute_data->fbc) {
    if ((execute_data->fbc)->common.arg_info) {
      if ((opline->extended_value & 1048575UL) <= (unsigned long )(execute_data->fbc)->common.num_args) {
        tmp___6 = (unsigned int )((int )((execute_data->fbc)->common.arg_info + ((opline->extended_value & 1048575UL) - 1UL))->pass_by_reference & 3);
      } else {
        tmp___6 = (execute_data->fbc)->common.fn_flags & 50331648U;
      }
    } else {
      tmp___6 = (execute_data->fbc)->common.fn_flags & 50331648U;
    }
    if (tmp___6) {
      container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
      if (1 << 2 == 1 << 2) {
        tmp = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
        if (tmp) {
          zend_error_noreturn(1, "Cannot use string offset as an array");
        } else {

        }
      } else {

      }
      zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, opline->op2.zv, 1, 1);
      if (1 << 2 == 1 << 2) {
        if ((unsigned int )free_op1.var != (unsigned int )((void *)0)) {
          tmp___4 = zval_refcount_p(free_op1.var);
          if (tmp___4 == 1U) {
            if ((int )(free_op1.var)->type != 5) {
              goto _L;
            } else {
              tmp___5 = zend_objects_store_get_refcount(free_op1.var);
              if (tmp___5 == (zend_uint __attribute__((__visibility__("default")))  )1) {
                _L: /* CIL Label */ 
                while (1) {
                  __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
                  if (__t->var.ptr_ptr) {
                    __t->var.ptr = *(__t->var.ptr_ptr);
                    __t->var.ptr_ptr = & __t->var.ptr;
                    tmp___2 = zval_isref_p(__t->var.ptr);
                    if (tmp___2) {

                    } else {
                      tmp___3 = zval_refcount_p(__t->var.ptr);
                      if (tmp___3 > 2U) {
                        while (1) {
                          tmp___1 = zval_refcount_p(*(__t->var.ptr_ptr));
                          if (tmp___1 > 1U) {
                            zval_delref_p(*(__t->var.ptr_ptr));
                            while (1) {
                              tmp___0 = _emalloc(sizeof(zval_gc_info ));
                              new_zv = (zval *)tmp___0;
                              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                              break;
                            }
                            while (1) {
                              while (1) {
                                new_zv->value = (*(__t->var.ptr_ptr))->value;
                                new_zv->type = (*(__t->var.ptr_ptr))->type;
                                break;
                              }
                              zval_set_refcount_p(new_zv, 1U);
                              zval_unset_isref_p(new_zv);
                              break;
                            }
                            *(__t->var.ptr_ptr) = new_zv;
                            _zval_copy_ctor(new_zv);
                          } else {

                          }
                          break;
                        }
                      } else {

                      }
                    }
                  } else {

                  }
                  break;
                }
              } else {

              }
            }
          } else {

          }
        } else {

        }
      } else {

      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if (1 == 1 << 3) {
      zend_error_noreturn(1, "Cannot use [] for reading");
    } else {

    }
    container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    zend_fetch_dimension_address_read((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, opline->op2.zv, 1, 0);
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_UNSET_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **container ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  long tmp___2 ;
  temp_variable *__t ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___3 ;
  zend_uint tmp___4 ;
  zend_bool tmp___5 ;
  zend_uint tmp___6 ;
  zend_uint tmp___7 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___8 ;
  zend_free_op free_res ;
  zval **retval_ptr ;
  zval *new_zv___1 ;
  void __attribute__((__visibility__("default")))  *tmp___9 ;
  zend_uint tmp___10 ;
  zend_bool tmp___11 ;
  long tmp___12 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 4) {
    if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
      tmp___1 = zval_isref_p(*container);
      if (tmp___1) {

      } else {
        while (1) {
          tmp___0 = zval_refcount_p(*container);
          if (tmp___0 > 1U) {
            zval_delref_p(*container);
            while (1) {
              tmp = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*container)->value;
                new_zv->type = (*container)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *container = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
    } else {

    }
  } else {

  }
  if (1 << 2 == 1 << 2) {
    tmp___2 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___2) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, opline->op2.zv, 1, 6);
  if (1 << 2 == 1 << 2) {
    if ((unsigned int )free_op1.var != (unsigned int )((void *)0)) {
      tmp___7 = zval_refcount_p(free_op1.var);
      if (tmp___7 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___8 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___8 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___5 = zval_isref_p(__t->var.ptr);
                if (tmp___5) {

                } else {
                  tmp___6 = zval_refcount_p(__t->var.ptr);
                  if (tmp___6 > 2U) {
                    while (1) {
                      tmp___4 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___4 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___3 = _emalloc(sizeof(zval_gc_info ));
                          new_zv___0 = (zval *)tmp___3;
                          ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv___0->value = (*(__t->var.ptr_ptr))->value;
                            new_zv___0->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv___0, 1U);
                          zval_unset_isref_p(new_zv___0);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv___0;
                        _zval_copy_ctor(new_zv___0);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  tmp___12 = __builtin_expect((long )((unsigned int )((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr == (unsigned int )((void *)0)), 0L);
  if (tmp___12) {
    zend_error_noreturn(1, "Cannot unset string offsets");
  } else {
    retval_ptr = ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr;
    zend_pzval_unlock_func(*retval_ptr, & free_res, 1);
    if ((unsigned int )retval_ptr != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
      tmp___11 = zval_isref_p(*retval_ptr);
      if (tmp___11) {

      } else {
        while (1) {
          tmp___10 = zval_refcount_p(*retval_ptr);
          if (tmp___10 > 1U) {
            zval_delref_p(*retval_ptr);
            while (1) {
              tmp___9 = _emalloc(sizeof(zval_gc_info ));
              new_zv___1 = (zval *)tmp___9;
              ((zval_gc_info *)new_zv___1)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv___1->value = (*retval_ptr)->value;
                new_zv___1->type = (*retval_ptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv___1, 1U);
              zval_unset_isref_p(new_zv___1);
              break;
            }
            *retval_ptr = new_zv___1;
            _zval_copy_ctor(new_zv___1);
          } else {

          }
          break;
        }
      }
    } else {

    }
    zval_addref_p(*retval_ptr);
    if (free_res.var) {
      i_zval_ptr_dtor(free_res.var);
    } else {

    }
    (execute_data->opline) ++;
    return (0);
  }
}
}
static int ( __attribute__((__fastcall__)) zend_fetch_property_address_read_helper_SPEC_VAR_CONST)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *container ;
  zval *offset ;
  temp_variable *__t ;
  zval *retval ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  temp_variable *__t___0 ;
  long tmp___0 ;
  long tmp___1 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  offset = opline->op2.zv;
  tmp___0 = __builtin_expect((long )((int )container->type != 5), 0L);
  if (tmp___0) {
    goto _L;
  } else {
    tmp___1 = __builtin_expect((long )((unsigned int )(container->value.obj.handlers)->read_property == (unsigned int )((void *)0)), 0L);
    if (tmp___1) {
      _L: /* CIL Label */ 
      zend_error(1 << 3L, "Trying to get property of non-object");
      zval_addref_p(& executor_globals.uninitialized_zval);
      while (1) {
        __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t->var.ptr = & executor_globals.uninitialized_zval;
        __t->var.ptr_ptr = & __t->var.ptr;
        break;
      }
    } else {
      retval = (*((container->value.obj.handlers)->read_property))(container, offset, 0, (struct _zend_literal  const  *)opline->op2.literal);
      zval_addref_p(retval);
      while (1) {
        __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t___0->var.ptr = retval;
        __t___0->var.ptr_ptr = & __t___0->var.ptr;
        break;
      }
    }
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_R_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_property_address_read_helper_SPEC_VAR_CONST(execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_W_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *property ;
  zval **container ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zend_uint tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___6 ;
  zval **retval_ptr ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___7 ;
  zend_uint tmp___8 ;
  zend_bool tmp___9 ;

  {
  opline = execute_data->opline;
  property = opline->op2.zv;
  if (1 << 2 == 1 << 2) {
    if (opline->extended_value & 134217728UL) {
      zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr));
      ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr = *(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr);
    } else {

    }
  } else {

  }
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)opline->op2.literal, 1);
  if (1 << 2 == 1 << 2) {
    if ((unsigned int )free_op1.var != (unsigned int )((void *)0)) {
      tmp___5 = zval_refcount_p(free_op1.var);
      if (tmp___5 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___6 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___6 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___3 = zval_isref_p(__t->var.ptr);
                if (tmp___3) {

                } else {
                  tmp___4 = zval_refcount_p(__t->var.ptr);
                  if (tmp___4 > 2U) {
                    while (1) {
                      tmp___2 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___2 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___1 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___1;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  if (opline->extended_value & 67108864UL) {
    retval_ptr = ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr;
    zval_delref_p(*retval_ptr);
    tmp___9 = zval_isref_p(*retval_ptr);
    if (tmp___9) {

    } else {
      while (1) {
        tmp___8 = zval_refcount_p(*retval_ptr);
        if (tmp___8 > 1U) {
          zval_delref_p(*retval_ptr);
          while (1) {
            tmp___7 = _emalloc(sizeof(zval_gc_info ));
            new_zv___0 = (zval *)tmp___7;
            ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv___0->value = (*retval_ptr)->value;
              new_zv___0->type = (*retval_ptr)->type;
              break;
            }
            zval_set_refcount_p(new_zv___0, 1U);
            zval_unset_isref_p(new_zv___0);
            break;
          }
          *retval_ptr = new_zv___0;
          _zval_copy_ctor(new_zv___0);
        } else {

        }
        break;
      }
      zval_set_isref_p(*retval_ptr);
    }
    zval_addref_p(*retval_ptr);
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = *(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr);
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_RW_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *property ;
  zval **container ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zend_uint tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___6 ;

  {
  opline = execute_data->opline;
  property = opline->op2.zv;
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)opline->op2.literal, 2);
  if (1 << 2 == 1 << 2) {
    if ((unsigned int )free_op1.var != (unsigned int )((void *)0)) {
      tmp___5 = zval_refcount_p(free_op1.var);
      if (tmp___5 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___6 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___6 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___3 = zval_isref_p(__t->var.ptr);
                if (tmp___3) {

                } else {
                  tmp___4 = zval_refcount_p(__t->var.ptr);
                  if (tmp___4 > 2U) {
                    while (1) {
                      tmp___2 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___2 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___1 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___1;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_IS_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *container ;
  zval *offset ;
  temp_variable *__t ;
  zval *retval ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  temp_variable *__t___0 ;
  long tmp___0 ;
  long tmp___1 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  offset = opline->op2.zv;
  tmp___0 = __builtin_expect((long )((int )container->type != 5), 0L);
  if (tmp___0) {
    goto _L;
  } else {
    tmp___1 = __builtin_expect((long )((unsigned int )(container->value.obj.handlers)->read_property == (unsigned int )((void *)0)), 0L);
    if (tmp___1) {
      _L: /* CIL Label */ 
      zval_addref_p(& executor_globals.uninitialized_zval);
      while (1) {
        __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t->var.ptr = & executor_globals.uninitialized_zval;
        __t->var.ptr_ptr = & __t->var.ptr;
        break;
      }
    } else {
      retval = (*((container->value.obj.handlers)->read_property))(container, offset, 3, (struct _zend_literal  const  *)opline->op2.literal);
      zval_addref_p(retval);
      while (1) {
        __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t___0->var.ptr = retval;
        __t___0->var.ptr_ptr = & __t___0->var.ptr;
        break;
      }
    }
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *property ;
  zval **container ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zend_uint tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___6 ;
  int tmp___7 ;
  unsigned int tmp___8 ;

  {
  opline = execute_data->opline;
  if (execute_data->fbc) {
    if ((execute_data->fbc)->common.arg_info) {
      if ((opline->extended_value & 1048575UL) <= (unsigned long )(execute_data->fbc)->common.num_args) {
        tmp___8 = (unsigned int )((int )((execute_data->fbc)->common.arg_info + ((opline->extended_value & 1048575UL) - 1UL))->pass_by_reference & 3);
      } else {
        tmp___8 = (execute_data->fbc)->common.fn_flags & 50331648U;
      }
    } else {
      tmp___8 = (execute_data->fbc)->common.fn_flags & 50331648U;
    }
    if (tmp___8) {
      property = opline->op2.zv;
      container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
      if (1 << 2 == 1 << 2) {
        tmp___0 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
        if (tmp___0) {
          zend_error_noreturn(1, "Cannot use string offset as an object");
        } else {

        }
      } else {

      }
      zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)opline->op2.literal, 1);
      if (1 << 2 == 1 << 2) {
        if ((unsigned int )free_op1.var != (unsigned int )((void *)0)) {
          tmp___5 = zval_refcount_p(free_op1.var);
          if (tmp___5 == 1U) {
            if ((int )(free_op1.var)->type != 5) {
              goto _L;
            } else {
              tmp___6 = zend_objects_store_get_refcount(free_op1.var);
              if (tmp___6 == (zend_uint __attribute__((__visibility__("default")))  )1) {
                _L: /* CIL Label */ 
                while (1) {
                  __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
                  if (__t->var.ptr_ptr) {
                    __t->var.ptr = *(__t->var.ptr_ptr);
                    __t->var.ptr_ptr = & __t->var.ptr;
                    tmp___3 = zval_isref_p(__t->var.ptr);
                    if (tmp___3) {

                    } else {
                      tmp___4 = zval_refcount_p(__t->var.ptr);
                      if (tmp___4 > 2U) {
                        while (1) {
                          tmp___2 = zval_refcount_p(*(__t->var.ptr_ptr));
                          if (tmp___2 > 1U) {
                            zval_delref_p(*(__t->var.ptr_ptr));
                            while (1) {
                              tmp___1 = _emalloc(sizeof(zval_gc_info ));
                              new_zv = (zval *)tmp___1;
                              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                              break;
                            }
                            while (1) {
                              while (1) {
                                new_zv->value = (*(__t->var.ptr_ptr))->value;
                                new_zv->type = (*(__t->var.ptr_ptr))->type;
                                break;
                              }
                              zval_set_refcount_p(new_zv, 1U);
                              zval_unset_isref_p(new_zv);
                              break;
                            }
                            *(__t->var.ptr_ptr) = new_zv;
                            _zval_copy_ctor(new_zv);
                          } else {

                          }
                          break;
                        }
                      } else {

                      }
                    }
                  } else {

                  }
                  break;
                }
              } else {

              }
            }
          } else {

          }
        } else {

        }
      } else {

      }
      if (free_op1.var) {
        i_zval_ptr_dtor(free_op1.var);
      } else {

      }
      (execute_data->opline) ++;
      return (0);
    } else {
      tmp___7 = zend_fetch_property_address_read_helper_SPEC_VAR_CONST(execute_data);
      return (tmp___7);
    }
  } else {
    tmp___7 = zend_fetch_property_address_read_helper_SPEC_VAR_CONST(execute_data);
    return (tmp___7);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_UNSET_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_res ;
  zval **container ;
  zval *property ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  long tmp___3 ;
  temp_variable *__t ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_uint tmp___5 ;
  zend_bool tmp___6 ;
  zend_uint tmp___7 ;
  zend_uint tmp___8 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___9 ;
  zval *new_zv___1 ;
  void __attribute__((__visibility__("default")))  *tmp___10 ;
  zend_uint tmp___11 ;
  zend_bool tmp___12 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  property = opline->op2.zv;
  if (1 << 2 == 1 << 4) {
    if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
      tmp___1 = zval_isref_p(*container);
      if (tmp___1) {

      } else {
        while (1) {
          tmp___0 = zval_refcount_p(*container);
          if (tmp___0 > 1U) {
            zval_delref_p(*container);
            while (1) {
              tmp = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*container)->value;
                new_zv->type = (*container)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *container = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
    } else {

    }
  } else {

  }
  if (1 << 2 == 1 << 2) {
    tmp___3 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___3) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)opline->op2.literal, 6);
  if (1 << 2 == 1 << 2) {
    if ((unsigned int )free_op1.var != (unsigned int )((void *)0)) {
      tmp___8 = zval_refcount_p(free_op1.var);
      if (tmp___8 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___9 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___9 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___6 = zval_isref_p(__t->var.ptr);
                if (tmp___6) {

                } else {
                  tmp___7 = zval_refcount_p(__t->var.ptr);
                  if (tmp___7 > 2U) {
                    while (1) {
                      tmp___5 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___5 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___4 = _emalloc(sizeof(zval_gc_info ));
                          new_zv___0 = (zval *)tmp___4;
                          ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv___0->value = (*(__t->var.ptr_ptr))->value;
                            new_zv___0->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv___0, 1U);
                          zval_unset_isref_p(new_zv___0);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv___0;
                        _zval_copy_ctor(new_zv___0);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  zend_pzval_unlock_func(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr), & free_res, 1);
  if ((unsigned int )((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
    tmp___12 = zval_isref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
    if (tmp___12) {

    } else {
      while (1) {
        tmp___11 = zval_refcount_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
        if (tmp___11 > 1U) {
          zval_delref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
          while (1) {
            tmp___10 = _emalloc(sizeof(zval_gc_info ));
            new_zv___1 = (zval *)tmp___10;
            ((zval_gc_info *)new_zv___1)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv___1->value = (*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr))->value;
              new_zv___1->type = (*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr))->type;
              break;
            }
            zval_set_refcount_p(new_zv___1, 1U);
            zval_unset_isref_p(new_zv___1);
            break;
          }
          *(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr) = new_zv___1;
          _zval_copy_ctor(new_zv___1);
        } else {

        }
        break;
      }
    }
  } else {

  }
  zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
  if (free_res.var) {
    i_zval_ptr_dtor(free_res.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_OBJ_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **object_ptr ;
  zval *property_name ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zval **tmp___1 ;

  {
  opline = execute_data->opline;
  object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  property_name = opline->op2.zv;
  if (1 << 2 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  if (! ((int )opline->result_type & (1 << 5))) {
    tmp___1 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
  } else {
    tmp___1 = (zval **)((void *)0);
  }
  zend_assign_to_object(tmp___1, object_ptr, property_name, (int )(opline + 1)->op1_type, & (opline + 1)->op1, (temp_variable const   *)execute_data->Ts, 136, (zend_literal const   *)opline->op2.literal);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_DIM_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **object_ptr ;
  long tmp ;
  zval *property_name ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  zval **tmp___1 ;
  zend_free_op free_op_data1 ;
  zend_free_op free_op_data2 ;
  zval *value ;
  zval *dim ;
  zval **variable_ptr_ptr ;
  zval *retval ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  char const   *__s ;
  int __l ;
  zval *__z ;
  char __attribute__((__visibility__("default")))  *tmp___3 ;
  temp_variable *__t ;
  temp_variable *__t___0 ;
  int tmp___4 ;
  temp_variable *__t___1 ;
  temp_variable *__t___2 ;
  long tmp___5 ;
  long tmp___6 ;

  {
  opline = execute_data->opline;
  object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  if ((int )(*object_ptr)->type == 5) {
    property_name = opline->op2.zv;
    if (! ((int )opline->result_type & (1 << 5))) {
      tmp___1 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
    } else {
      tmp___1 = (zval **)((void *)0);
    }
    zend_assign_to_object(tmp___1, object_ptr, property_name, (int )(opline + 1)->op1_type, & (opline + 1)->op1, (temp_variable const   *)execute_data->Ts, 147, (zend_literal const   *)opline->op2.literal);
  } else {
    dim = opline->op2.zv;
    zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var), object_ptr, dim, 1, 1);
    value = _get_zval_ptr((int )(opline + 1)->op1_type, (znode_op const   *)(& (opline + 1)->op1), (temp_variable const   *)execute_data->Ts, & free_op_data1, 0);
    variable_ptr_ptr = _get_zval_ptr_ptr_var((opline + 1)->op2.var, (temp_variable const   *)execute_data->Ts, & free_op_data2);
    tmp___6 = __builtin_expect((long )((unsigned int )variable_ptr_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___6) {
      tmp___4 = zend_assign_to_string_offset((temp_variable const   *)((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var)), (zval const   *)value, (int )(opline + 1)->op1_type);
      if (tmp___4) {
        if (! ((int )opline->result_type & (1 << 5))) {
          while (1) {
            tmp___2 = _emalloc(sizeof(zval_gc_info ));
            retval = (zval *)tmp___2;
            ((zval_gc_info *)retval)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            __s = (char const   *)((((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var))->str_offset.str)->value.str.val + ((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var))->str_offset.offset);
            __l = 1;
            __z = retval;
            __z->value.str.len = __l;
            tmp___3 = _estrndup(__s, (unsigned int )__l);
            __z->value.str.val = (char *)tmp___3;
            __z->type = (unsigned char)6;
            break;
          }
          retval->refcount__gc = 1U;
          retval->is_ref__gc = (unsigned char)0;
          while (1) {
            __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t->var.ptr = retval;
            __t->var.ptr_ptr = & __t->var.ptr;
            break;
          }
        } else {

        }
      } else {
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          while (1) {
            __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___0->var.ptr = & executor_globals.uninitialized_zval;
            __t___0->var.ptr_ptr = & __t___0->var.ptr;
            break;
          }
        } else {

        }
      }
    } else {
      tmp___5 = __builtin_expect((long )((unsigned int )*variable_ptr_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
      if (tmp___5) {
        if ((unsigned long )free_op_data1.var & 1UL) {
          _zval_dtor(value);
        } else {

        }
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          while (1) {
            __t___1 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___1->var.ptr = & executor_globals.uninitialized_zval;
            __t___1->var.ptr_ptr = & __t___1->var.ptr;
            break;
          }
        } else {

        }
      } else {
        if ((int )(opline + 1)->op1_type == 1 << 1) {
          value = zend_assign_tmp_to_variable(variable_ptr_ptr, value);
        } else {
          if ((int )(opline + 1)->op1_type == 1) {
            value = zend_assign_const_to_variable(variable_ptr_ptr, value);
          } else {
            value = zend_assign_to_variable(variable_ptr_ptr, value);
          }
        }
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(value);
          while (1) {
            __t___2 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___2->var.ptr = value;
            __t___2->var.ptr_ptr = & __t___2->var.ptr;
            break;
          }
        } else {

        }
      }
    }
    if (free_op_data2.var) {
      i_zval_ptr_dtor(free_op_data2.var);
    } else {

    }
    if ((unsigned int )free_op_data1.var != (unsigned int )((void *)0)) {
      if (((unsigned long )free_op_data1.var & 1UL) == 0UL) {
        i_zval_ptr_dtor(free_op_data1.var);
      } else {

      }
    } else {

    }
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *value ;
  zval **variable_ptr_ptr ;
  zval *retval ;
  void __attribute__((__visibility__("default")))  *tmp ;
  char const   *__s ;
  int __l ;
  zval *__z ;
  char __attribute__((__visibility__("default")))  *tmp___0 ;
  temp_variable *__t ;
  temp_variable *__t___0 ;
  int tmp___1 ;
  temp_variable *__t___1 ;
  temp_variable *__t___2 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  opline = execute_data->opline;
  value = opline->op2.zv;
  variable_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 2) {
    tmp___3 = __builtin_expect((long )((unsigned int )variable_ptr_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___3) {
      tmp___1 = zend_assign_to_string_offset((temp_variable const   *)((temp_variable *)((char *)execute_data->Ts + opline->op1.var)), (zval const   *)value, 1);
      if (tmp___1) {
        if (! ((int )opline->result_type & (1 << 5))) {
          while (1) {
            tmp = _emalloc(sizeof(zval_gc_info ));
            retval = (zval *)tmp;
            ((zval_gc_info *)retval)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            __s = (char const   *)((((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->str_offset.str)->value.str.val + ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->str_offset.offset);
            __l = 1;
            __z = retval;
            __z->value.str.len = __l;
            tmp___0 = _estrndup(__s, (unsigned int )__l);
            __z->value.str.val = (char *)tmp___0;
            __z->type = (unsigned char)6;
            break;
          }
          retval->refcount__gc = 1U;
          retval->is_ref__gc = (unsigned char)0;
          while (1) {
            __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t->var.ptr = retval;
            __t->var.ptr_ptr = & __t->var.ptr;
            break;
          }
        } else {

        }
      } else {
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          while (1) {
            __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___0->var.ptr = & executor_globals.uninitialized_zval;
            __t___0->var.ptr_ptr = & __t___0->var.ptr;
            break;
          }
        } else {

        }
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if (1 << 2 == 1 << 2) {
      tmp___2 = __builtin_expect((long )((unsigned int )*variable_ptr_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
      if (tmp___2) {
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          while (1) {
            __t___1 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___1->var.ptr = & executor_globals.uninitialized_zval;
            __t___1->var.ptr_ptr = & __t___1->var.ptr;
            break;
          }
        } else {

        }
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      if (1 == 1 << 1) {
        value = zend_assign_tmp_to_variable(variable_ptr_ptr, value);
      } else {
        value = zend_assign_const_to_variable(variable_ptr_ptr, value);
      }
      if (! ((int )opline->result_type & (1 << 5))) {
        zval_addref_p(value);
        while (1) {
          __t___2 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
          __t___2->var.ptr = value;
          __t___2->var.ptr_ptr = & __t___2->var.ptr;
          break;
        }
      } else {

      }
    }
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_METHOD_CALL_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *function_name ;
  char *function_name_strval ;
  int function_name_strlen ;
  zend_free_op free_op1 ;
  long tmp ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  zval *object ;
  long tmp___1 ;
  zend_class_entry *tmp___2 ;
  zend_class_entry *tmp___3 ;
  char const   *tmp___4 ;
  zend_class_entry *tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  zend_function *tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  zval *this_ptr ;
  void __attribute__((__visibility__("default")))  *tmp___12 ;
  zend_bool tmp___13 ;

  {
  opline = execute_data->opline;
  zend_ptr_stack_3_push(& executor_globals.arg_types_stack, (void *)execute_data->fbc, (void *)execute_data->object, (void *)execute_data->called_scope);
  function_name = opline->op2.zv;
  function_name_strval = function_name->value.str.val;
  function_name_strlen = function_name->value.str.len;
  execute_data->object = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  tmp___10 = __builtin_expect((long )((unsigned int )execute_data->object != (unsigned int )((void *)0)), 1L);
  if (tmp___10) {
    tmp___11 = __builtin_expect((long )((int )(execute_data->object)->type == 5), 1L);
    if (tmp___11) {
      tmp___0 = zend_get_class_entry((zval const   *)execute_data->object);
      execute_data->called_scope = (zend_class_entry *)tmp___0;
      if ((unsigned int )*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) == (unsigned int )execute_data->called_scope) {
        tmp___9 = (zend_function *)*((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U));
      } else {
        tmp___9 = (zend_function *)((void *)0);
      }
      execute_data->fbc = tmp___9;
      if ((unsigned int )tmp___9 == (unsigned int )((void *)0)) {
        object = execute_data->object;
        tmp___1 = __builtin_expect((long )((unsigned int )((execute_data->object)->value.obj.handlers)->get_method == (unsigned int )((void *)0)), 0L);
        if (tmp___1) {
          zend_error_noreturn(1, "Object does not support method calls");
        } else {

        }
        execute_data->fbc = (*(((execute_data->object)->value.obj.handlers)->get_method))(& execute_data->object, function_name_strval, function_name_strlen, (struct _zend_literal  const  *)(opline->op2.literal + 1));
        tmp___6 = __builtin_expect((long )((unsigned int )execute_data->fbc == (unsigned int )((void *)0)), 0L);
        if (tmp___6) {
          if (execute_data->object) {
            if ((int )(execute_data->object)->type == 5) {
              if ((unsigned int )((execute_data->object)->value.obj.handlers)->get_class_entry != (unsigned int )((void *)0)) {
                tmp___5 = (*(((execute_data->object)->value.obj.handlers)->get_class_entry))((zval const   *)execute_data->object);
                if (tmp___5) {
                  tmp___3 = (*(((execute_data->object)->value.obj.handlers)->get_class_entry))((zval const   *)execute_data->object);
                  tmp___4 = tmp___3->name;
                } else {
                  tmp___4 = "";
                }
              } else {
                tmp___4 = "";
              }
            } else {
              tmp___4 = "";
            }
          } else {
            tmp___4 = "";
          }
          zend_error_noreturn(1, "Call to undefined method %s::%s()", tmp___4, function_name_strval);
        } else {

        }
        tmp___7 = __builtin_expect((long )(((execute_data->fbc)->common.fn_flags & 6291456U) == 0U), 1L);
        if (tmp___7) {
          tmp___8 = __builtin_expect((long )((unsigned int )execute_data->object == (unsigned int )object), 1L);
          if (tmp___8) {
            while (1) {
              *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)execute_data->called_scope;
              *((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U)) = (void *)execute_data->fbc;
              break;
            }
          } else {

          }
        } else {

        }
      } else {

      }
    } else {
      zend_error_noreturn(1, "Call to a member function %s() on a non-object", function_name_strval);
    }
  } else {
    zend_error_noreturn(1, "Call to a member function %s() on a non-object", function_name_strval);
  }
  if (((execute_data->fbc)->common.fn_flags & 1U) != 0U) {
    execute_data->object = (zval *)((void *)0);
  } else {
    tmp___13 = zval_isref_p(execute_data->object);
    if (tmp___13) {
      while (1) {
        tmp___12 = _emalloc(sizeof(zval_gc_info ));
        this_ptr = (zval *)tmp___12;
        ((zval_gc_info *)this_ptr)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      while (1) {
        while (1) {
          this_ptr->value = (execute_data->object)->value;
          this_ptr->type = (execute_data->object)->type;
          break;
        }
        zval_set_refcount_p(this_ptr, 1U);
        zval_unset_isref_p(this_ptr);
        break;
      }
      _zval_copy_ctor(this_ptr);
      execute_data->object = this_ptr;
    } else {
      zval_addref_p(execute_data->object);
    }
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *function_name ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  char *function_name_strval ;
  int function_name_strlen ;
  long tmp___1 ;
  union _zend_function  __attribute__((__visibility__("default"))) *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___6 ;
  zend_function *tmp___7 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___8 ;
  zend_bool __attribute__((__visibility__("default")))  tmp___9 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___10 ;
  zval *tmp___11 ;

  {
  opline = execute_data->opline;
  zend_ptr_stack_3_push(& executor_globals.arg_types_stack, (void *)execute_data->fbc, (void *)execute_data->object, (void *)execute_data->called_scope);
  if (1 << 2 == 1) {
    if (*((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot)) {
      ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot);
    } else {
      tmp = zend_fetch_class_by_name((char const   *)(opline->op1.zv)->value.str.val, (unsigned int )(opline->op1.zv)->value.str.len, (zend_literal const   *)(opline->op1.literal + 1), (int )opline->extended_value);
      ce = (zend_class_entry *)tmp;
      tmp___0 = __builtin_expect((long )((unsigned int )ce == (unsigned int )((void *)0)), 0L);
      if (tmp___0) {
        zend_error_noreturn(1, "Class \'%s\' not found", (opline->op1.zv)->value.str.val);
      } else {

      }
      while (1) {
        *((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot) = (void *)ce;
        break;
      }
    }
    execute_data->called_scope = ce;
  } else {
    ce = ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->class_entry;
    if (opline->extended_value == 2UL) {
      execute_data->called_scope = executor_globals.called_scope;
    } else {
      if (opline->extended_value == 1UL) {
        execute_data->called_scope = executor_globals.called_scope;
      } else {
        execute_data->called_scope = ce;
      }
    }
  }
  if (1 << 2 == 1) {
    if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
      execute_data->fbc = (zend_function *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
    } else {
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
    _L___1: /* CIL Label */ 
    if (1 << 2 != 1) {
      if ((unsigned int )*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) == (unsigned int )ce) {
        tmp___7 = (zend_function *)*((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U));
      } else {
        tmp___7 = (zend_function *)((void *)0);
      }
      execute_data->fbc = tmp___7;
      if (tmp___7) {

      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      _L: /* CIL Label */ 
      if (1 != 1 << 3) {
        function_name_strval = (char *)((void *)0);
        function_name_strlen = 0;
        function_name_strval = (opline->op2.zv)->value.str.val;
        function_name_strlen = (opline->op2.zv)->value.str.len;
        if (function_name_strval) {
          if (ce->get_static_method) {
            execute_data->fbc = (*(ce->get_static_method))(ce, function_name_strval, function_name_strlen);
          } else {
            tmp___2 = zend_std_get_static_method(ce, (char const   *)function_name_strval, function_name_strlen, (struct _zend_literal  const  *)(opline->op2.literal + 1));
            execute_data->fbc = (zend_function *)tmp___2;
          }
          tmp___3 = __builtin_expect((long )((unsigned int )execute_data->fbc == (unsigned int )((void *)0)), 0L);
          if (tmp___3) {
            zend_error_noreturn(1, "Call to undefined method %s::%s()", ce->name, function_name_strval);
          } else {

          }
          tmp___4 = __builtin_expect((long )(((execute_data->fbc)->common.fn_flags & 6291456U) == 0U), 1L);
          if (tmp___4) {
            if (1 << 2 == 1) {
              while (1) {
                *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)execute_data->fbc;
                break;
              }
            } else {
              while (1) {
                *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
                *((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U)) = (void *)execute_data->fbc;
                break;
              }
            }
          } else {

          }
        } else {

        }
      } else {
        tmp___5 = __builtin_expect((long )((unsigned int )ce->constructor == (unsigned int )((void *)0)), 0L);
        if (tmp___5) {
          zend_error_noreturn(1, "Cannot call constructor");
        } else {

        }
        if (executor_globals.This) {
          tmp___6 = zend_get_class_entry((zval const   *)executor_globals.This);
          if ((unsigned int )tmp___6 != (unsigned int )(ce->constructor)->common.scope) {
            if ((ce->constructor)->common.fn_flags & 1024U) {
              zend_error_noreturn(1, "Cannot call private %s::__construct()", ce->name);
            } else {

            }
          } else {

          }
        } else {

        }
        execute_data->fbc = ce->constructor;
      }
    }
  }
  if ((execute_data->fbc)->common.fn_flags & 1U) {
    execute_data->object = (zval *)((void *)0);
  } else {
    if (executor_globals.This) {
      if (((executor_globals.This)->value.obj.handlers)->get_class_entry) {
        tmp___8 = zend_get_class_entry((zval const   *)executor_globals.This);
        tmp___9 = instanceof_function((zend_class_entry const   *)tmp___8, (zend_class_entry const   *)ce);
        if (tmp___9) {

        } else {
          if ((execute_data->fbc)->common.fn_flags & 65536U) {
            zend_error(1 << 11L, "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", ((execute_data->fbc)->common.scope)->name, (execute_data->fbc)->common.function_name);
          } else {
            zend_error_noreturn(1, "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", ((execute_data->fbc)->common.scope)->name, (execute_data->fbc)->common.function_name);
          }
        }
      } else {

      }
    } else {

    }
    tmp___11 = executor_globals.This;
    execute_data->object = tmp___11;
    if (tmp___11) {
      zval_addref_p(execute_data->object);
      tmp___10 = zend_get_class_entry((zval const   *)execute_data->object);
      execute_data->called_scope = (zend_class_entry *)tmp___10;
    } else {

    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_CASE_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  if (1 << 2 == 1 << 2) {
    zval_addref_p(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr);
  } else {

  }
  tmp = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  is_equal_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp, opline->op2.zv);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_CONSTANT_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_constant *c ;
  zval *retval ;
  char *actual ;
  void const   *tmp ;
  char const   *__s ;
  int __l ;
  zval *__z ;
  char __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_class_entry *ce ;
  zval **value ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___1 ;
  long tmp___2 ;
  zend_class_entry *old_scope ;
  int __attribute__((__visibility__("default")))  tmp___3 ;
  long tmp___4 ;

  {
  opline = execute_data->opline;
  if (1 << 2 == 1 << 3) {
    if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
      c = (zend_constant *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
    } else {
      c = zend_quick_get_constant((zend_literal const   *)(opline->op2.literal + 1), opline->extended_value);
      if ((unsigned int )c == (unsigned int )((void *)0)) {
        if ((opline->extended_value & 16UL) != 0UL) {
          tmp = zend_memrchr((void const   *)(opline->op2.zv)->value.str.val, '\\', (unsigned int )(opline->op2.zv)->value.str.len);
          actual = (char *)tmp;
          if (! actual) {
            actual = (opline->op2.zv)->value.str.val;
          } else {
            actual ++;
          }
          zend_error(1 << 3L, "Use of undefined constant %s - assumed \'%s\'", actual, actual);
          while (1) {
            __s = (char const   *)actual;
            __l = (opline->op2.zv)->value.str.len - (actual - (opline->op2.zv)->value.str.val);
            __z = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
            __z->value.str.len = __l;
            tmp___0 = _estrndup(__s, (unsigned int )__l);
            __z->value.str.val = (char *)tmp___0;
            __z->type = (unsigned char)6;
            break;
          }
          (execute_data->opline) ++;
          return (0);
        } else {
          zend_error_noreturn(1, "Undefined constant \'%s\'", (opline->op2.zv)->value.str.val);
        }
      } else {
        while (1) {
          *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)c;
          break;
        }
      }
    }
    retval = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
    while (1) {
      retval->value = c->value.value;
      retval->type = c->value.type;
      break;
    }
    _zval_copy_ctor(retval);
    (execute_data->opline) ++;
    return (0);
  } else {
    if (1 << 2 == 1) {
      if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
        value = (zval **)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
        while (1) {
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value = (*value)->value;
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.type = (*value)->type;
          break;
        }
        _zval_copy_ctor(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var);
        (execute_data->opline) ++;
        return (0);
      } else {
        if (*((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot)) {
          ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot);
        } else {
          tmp___1 = zend_fetch_class_by_name((char const   *)(opline->op1.zv)->value.str.val, (unsigned int )(opline->op1.zv)->value.str.len, (zend_literal const   *)(opline->op1.literal + 1), (int )opline->extended_value);
          ce = (zend_class_entry *)tmp___1;
          tmp___2 = __builtin_expect((long )((unsigned int )ce == (unsigned int )((void *)0)), 0L);
          if (tmp___2) {
            zend_error_noreturn(1, "Undefined class constant \'%s\'", (opline->op2.zv)->value.str.val);
          } else {

          }
          while (1) {
            *((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot) = (void *)ce;
            break;
          }
        }
      }
    } else {
      ce = ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->class_entry;
      if ((unsigned int )*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) == (unsigned int )ce) {
        value = (zval **)*((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U));
      } else {
        value = (zval **)((void *)0);
      }
      if ((unsigned int )value != (unsigned int )((void *)0)) {
        while (1) {
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value = (*value)->value;
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.type = (*value)->type;
          break;
        }
        _zval_copy_ctor(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var);
        (execute_data->opline) ++;
        return (0);
      } else {

      }
    }
    tmp___3 = zend_hash_quick_find((HashTable const   *)(& ce->constants_table), (char const   *)(opline->op2.zv)->value.str.val, (unsigned int )((opline->op2.zv)->value.str.len + 1), ((zend_literal *)opline->op2.zv)->hash_value, (void **)(& value));
    tmp___4 = __builtin_expect((long )(tmp___3 == (int __attribute__((__visibility__("default")))  )0), 1L);
    if (tmp___4) {
      if ((int )(*value)->type == 9) {
        old_scope = executor_globals.scope;
        executor_globals.scope = ce;
        zval_update_constant(value, (void *)1);
        executor_globals.scope = old_scope;
      } else {
        if (((int )(*value)->type & 0x00f) == 8) {
          old_scope = executor_globals.scope;
          executor_globals.scope = ce;
          zval_update_constant(value, (void *)1);
          executor_globals.scope = old_scope;
        } else {

        }
      }
      if (1 << 2 == 1) {
        while (1) {
          *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)value;
          break;
        }
      } else {
        while (1) {
          *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
          *((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U)) = (void *)value;
          break;
        }
      }
      while (1) {
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value = (*value)->value;
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.type = (*value)->type;
        break;
      }
      _zval_copy_ctor(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var);
    } else {
      zend_error_noreturn(1, "Undefined class constant \'%s\'", (opline->op2.zv)->value.str.val);
    }
    (execute_data->opline) ++;
    return (0);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *expr_ptr ;
  zval **expr_ptr_ptr ;
  zval **tmp ;
  long tmp___0 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zval *new_expr ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zval *new_expr___0 ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  zend_bool tmp___6 ;
  zval *offset ;
  ulong hval ;
  long tmp___7 ;
  register char const   *tmp___8 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___9 ;

  {
  opline = execute_data->opline;
  if (1 << 2 == 1 << 2) {
    goto _L___1;
  } else {
    if (1 << 2 == 1 << 4) {
      _L___1: /* CIL Label */ 
      if (opline->extended_value) {
        tmp = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
        expr_ptr_ptr = tmp;
        if (1 << 2 == 1 << 2) {
          tmp___0 = __builtin_expect((long )((unsigned int )expr_ptr_ptr == (unsigned int )((void *)0)), 0L);
          if (tmp___0) {
            zend_error_noreturn(1, "Cannot create references to/from string offsets");
          } else {

          }
        } else {

        }
        tmp___3 = zval_isref_p(*expr_ptr_ptr);
        if (tmp___3) {

        } else {
          while (1) {
            tmp___2 = zval_refcount_p(*expr_ptr_ptr);
            if (tmp___2 > 1U) {
              zval_delref_p(*expr_ptr_ptr);
              while (1) {
                tmp___1 = _emalloc(sizeof(zval_gc_info ));
                new_zv = (zval *)tmp___1;
                ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv->value = (*expr_ptr_ptr)->value;
                  new_zv->type = (*expr_ptr_ptr)->type;
                  break;
                }
                zval_set_refcount_p(new_zv, 1U);
                zval_unset_isref_p(new_zv);
                break;
              }
              *expr_ptr_ptr = new_zv;
              _zval_copy_ctor(new_zv);
            } else {

            }
            break;
          }
          zval_set_isref_p(*expr_ptr_ptr);
        }
        expr_ptr = *expr_ptr_ptr;
        zval_addref_p(expr_ptr);
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      expr_ptr = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
      if (1 << 2 == 1) {
        goto _L;
      } else {
        tmp___6 = zval_isref_p(expr_ptr);
        if (tmp___6) {
          _L: /* CIL Label */ 
          while (1) {
            tmp___5 = _emalloc(sizeof(zval_gc_info ));
            new_expr___0 = (zval *)tmp___5;
            ((zval_gc_info *)new_expr___0)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_expr___0->value = expr_ptr->value;
              new_expr___0->type = expr_ptr->type;
              break;
            }
            zval_set_refcount_p(new_expr___0, 1U);
            zval_unset_isref_p(new_expr___0);
            break;
          }
          expr_ptr = new_expr___0;
          _zval_copy_ctor(expr_ptr);
        } else {
          zval_addref_p(expr_ptr);
        }
      }
    }
  }
  if (1 != 1 << 3) {
    offset = opline->op2.zv;
    switch ((int )offset->type) {
    case 2: 
    tmp___7 = zend_dval_to_lval(offset->value.dval);
    hval = (unsigned long )tmp___7;
    goto num_index;
    case 1: 
    case 3: 
    hval = (unsigned long )offset->value.lval;
    num_index: 
    _zend_hash_index_update_or_next_insert(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, hval, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    case 6: 
    if (1) {
      hval = ((zend_literal *)offset)->hash_value;
    } else {
      while (1) {
        tmp___8 = (char const   *)offset->value.str.val;
        if ((int const   )*tmp___8 == 45) {
          tmp___8 ++;
        } else {

        }
        if ((int const   )*tmp___8 >= 48) {
          if ((int const   )*tmp___8 <= 57) {
            end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
            if ((int const   )*end != 0) {
              break;
            } else {
              if ((int const   )*tmp___8 == 48) {
                if (offset->value.str.len + 1 > 2) {
                  break;
                } else {
                  goto _L___2;
                }
              } else {
                _L___2: /* CIL Label */ 
                if (end - tmp___8 > 10) {
                  break;
                } else {
                  if (end - tmp___8 == 10) {
                    if ((int const   )*tmp___8 > 50) {
                      break;
                    } else {

                    }
                  } else {

                  }
                }
              }
            }
            hval = (unsigned long )((int const   )*tmp___8 - 48);
            while (1) {
              tmp___8 ++;
              if ((unsigned int )tmp___8 != (unsigned int )end) {
                if ((int const   )*tmp___8 >= 48) {
                  if ((int const   )*tmp___8 <= 57) {

                  } else {
                    break;
                  }
                } else {
                  break;
                }
              } else {
                break;
              }
              hval = hval * 10UL + (ulong )((int const   )*tmp___8 - 48);
            }
            if ((unsigned int )tmp___8 == (unsigned int )end) {
              if ((int )*(offset->value.str.val) == 45) {
                if (hval - 1UL > 2147483647UL) {
                  break;
                } else {

                }
                hval = (unsigned long )(- ((long )hval));
              } else {
                if (hval > 2147483647UL) {
                  break;
                } else {

                }
              }
              goto num_index;
            } else {

            }
          } else {

          }
        } else {

        }
        break;
      }
      if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
        if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
          hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
        } else {
          tmp___9 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___9;
        }
      } else {
        tmp___9 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
        hval = (unsigned long )tmp___9;
      }
    }
    _zend_hash_quick_add_or_update(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    case 0: 
    _zend_hash_add_or_update(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, "", sizeof(""), (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    default: 
    zend_error(1 << 1L, "Illegal offset type");
    i_zval_ptr_dtor(expr_ptr);
    break;
    }
  } else {
    _zend_hash_index_update_or_next_insert(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, 0UL, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1 << 2);
  }
  if (1 << 2 == 1 << 2) {
    goto _L___4;
  } else {
    if (1 << 2 == 1 << 4) {
      _L___4: /* CIL Label */ 
      if (opline->extended_value) {
        if (free_op1.var) {
          i_zval_ptr_dtor(free_op1.var);
        } else {

        }
      } else {
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ 
      if (free_op1.var) {
        i_zval_ptr_dtor(free_op1.var);
      } else {

      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_ARRAY_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  int tmp ;

  {
  opline = execute_data->opline;
  _array_init(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, 0U);
  if (1 << 2 == 1 << 3) {
    (execute_data->opline) ++;
    return (0);
  } else {
    tmp = ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CONST_HANDLER(execute_data);
    return (tmp);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_UNSET_VAR_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval tmp ;
  zval *varname ;
  HashTable *target_symbol_table ;
  zend_free_op free_op1 ;
  zend_compiled_variable *cv ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_literal *tmp___1 ;
  ulong hash_value ;
  ulong tmp___2 ;

  {
  opline = execute_data->opline;
  if (1 << 2 == 1 << 4) {
    if (1 == 1 << 3) {
      if (opline->extended_value & 8388608UL) {
        if (executor_globals.active_symbol_table) {
          cv = (executor_globals.active_op_array)->vars + opline->op1.var;
          zend_delete_variable(execute_data->prev_execute_data, executor_globals.active_symbol_table, cv->name, cv->name_len + 1, cv->hash_value);
          *(execute_data->CVs + opline->op1.var) = (zval **)((void *)0);
        } else {
          if (*(execute_data->CVs + opline->op1.var)) {
            i_zval_ptr_dtor(*(*(execute_data->CVs + opline->op1.var)));
            *(execute_data->CVs + opline->op1.var) = (zval **)((void *)0);
          } else {

          }
        }
        (execute_data->opline) ++;
        return (0);
      } else {

      }
    } else {

    }
  } else {

  }
  varname = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 != 1) {
    if ((int )varname->type != 6) {
      while (1) {
        tmp.value = varname->value;
        tmp.type = varname->type;
        break;
      }
      _zval_copy_ctor(& tmp);
      if ((int )tmp.type != 6) {
        _convert_to_string(& tmp);
      } else {

      }
      varname = & tmp;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if (1 << 2 == 1 << 2) {
      zval_addref_p(varname);
    } else {
      if (1 << 2 == 1 << 4) {
        zval_addref_p(varname);
      } else {

      }
    }
  }
  if (1 != 1 << 3) {
    if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
      ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
    } else {
      tmp___0 = zend_fetch_class_by_name((char const   *)(opline->op2.zv)->value.str.val, (unsigned int )(opline->op2.zv)->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), 0);
      ce = (zend_class_entry *)tmp___0;
      while (1) {
        *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
        break;
      }
    }
    if (1 << 2 == 1) {
      tmp___1 = opline->op1.literal;
    } else {
      tmp___1 = (zend_literal *)((void *)0);
    }
    zend_std_unset_static_property(ce, (char const   *)varname->value.str.val, varname->value.str.len, (struct _zend_literal  const  *)tmp___1);
  } else {
    tmp___2 = zend_inline_hash_func((char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1));
    hash_value = tmp___2;
    target_symbol_table = zend_get_target_symbol_table((int )(opline->extended_value & 1879048192UL));
    zend_delete_variable(execute_data, target_symbol_table, (char const   *)varname->value.str.val, varname->value.str.len + 1, hash_value);
  }
  if (1 << 2 != 1) {
    if ((unsigned int )varname == (unsigned int )(& tmp)) {
      _zval_dtor(& tmp);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if (1 << 2 == 1 << 2) {
      i_zval_ptr_dtor(varname);
    } else {
      if (1 << 2 == 1 << 4) {
        i_zval_ptr_dtor(varname);
      } else {

      }
    }
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_UNSET_DIM_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **container ;
  zval *offset ;
  ulong hval ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  HashTable *ht ;
  long tmp___2 ;
  register char const   *tmp___3 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___4 ;
  long tmp___5 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 4) {
    if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
      tmp___1 = zval_isref_p(*container);
      if (tmp___1) {

      } else {
        while (1) {
          tmp___0 = zval_refcount_p(*container);
          if (tmp___0 > 1U) {
            zval_delref_p(*container);
            while (1) {
              tmp = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*container)->value;
                new_zv->type = (*container)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *container = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
    } else {

    }
  } else {

  }
  offset = opline->op2.zv;
  if (1 << 2 != 1 << 2) {
    goto _L___0;
  } else {
    if (container) {
      _L___0: /* CIL Label */ 
      switch ((int )(*container)->type) {
      case 4: 
      ht = (*container)->value.ht;
      switch ((int )offset->type) {
      case 2: 
      tmp___2 = zend_dval_to_lval(offset->value.dval);
      hval = (unsigned long )tmp___2;
      goto num_index_dim;
      case 7: 
      case 3: 
      case 1: 
      hval = (unsigned long )offset->value.lval;
      zend_hash_del_key_or_index(ht, (char const   *)((void *)0), 0U, hval, 1);
      break;
      case 6: 
      if (1 == 1 << 4) {
        zval_addref_p(offset);
      } else {
        if (1 == 1 << 2) {
          zval_addref_p(offset);
        } else {

        }
      }
      if (1) {
        hval = ((zend_literal *)offset)->hash_value;
      } else {
        while (1) {
          tmp___3 = (char const   *)offset->value.str.val;
          if ((int const   )*tmp___3 == 45) {
            tmp___3 ++;
          } else {

          }
          if ((int const   )*tmp___3 >= 48) {
            if ((int const   )*tmp___3 <= 57) {
              end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
              if ((int const   )*end != 0) {
                break;
              } else {
                if ((int const   )*tmp___3 == 48) {
                  if (offset->value.str.len + 1 > 2) {
                    break;
                  } else {
                    goto _L;
                  }
                } else {
                  _L: /* CIL Label */ 
                  if (end - tmp___3 > 10) {
                    break;
                  } else {
                    if (end - tmp___3 == 10) {
                      if ((int const   )*tmp___3 > 50) {
                        break;
                      } else {

                      }
                    } else {

                    }
                  }
                }
              }
              hval = (unsigned long )((int const   )*tmp___3 - 48);
              while (1) {
                tmp___3 ++;
                if ((unsigned int )tmp___3 != (unsigned int )end) {
                  if ((int const   )*tmp___3 >= 48) {
                    if ((int const   )*tmp___3 <= 57) {

                    } else {
                      break;
                    }
                  } else {
                    break;
                  }
                } else {
                  break;
                }
                hval = hval * 10UL + (ulong )((int const   )*tmp___3 - 48);
              }
              if ((unsigned int )tmp___3 == (unsigned int )end) {
                if ((int )*(offset->value.str.val) == 45) {
                  if (hval - 1UL > 2147483647UL) {
                    break;
                  } else {

                  }
                  hval = (unsigned long )(- ((long )hval));
                } else {
                  if (hval > 2147483647UL) {
                    break;
                  } else {

                  }
                }
                goto num_index_dim;
              } else {

              }
            } else {

            }
          } else {

          }
          break;
        }
        if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
          if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
            hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
          } else {
            tmp___4 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
            hval = (unsigned long )tmp___4;
          }
        } else {
          tmp___4 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___4;
        }
      }
      if ((unsigned int )ht == (unsigned int )(& executor_globals.symbol_table)) {
        zend_delete_global_variable_ex((char const   *)offset->value.str.val, offset->value.str.len, hval);
      } else {
        zend_hash_del_key_or_index(ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, 2);
      }
      if (1 == 1 << 4) {
        i_zval_ptr_dtor(offset);
      } else {
        if (1 == 1 << 2) {
          i_zval_ptr_dtor(offset);
        } else {

        }
      }
      break;
      num_index_dim: 
      zend_hash_del_key_or_index(ht, (char const   *)((void *)0), 0U, hval, 1);
      if (1 == 1 << 4) {
        i_zval_ptr_dtor(offset);
      } else {
        if (1 == 1 << 2) {
          i_zval_ptr_dtor(offset);
        } else {

        }
      }
      break;
      case 0: 
      zend_hash_del_key_or_index(ht, "", sizeof(""), 0UL, 0);
      break;
      default: 
      zend_error(1 << 1L, "Illegal offset type in unset");
      break;
      }
      break;
      case 5: 
      tmp___5 = __builtin_expect((long )((unsigned int )((*container)->value.obj.handlers)->unset_dimension == (unsigned int )((void *)0)), 0L);
      if (tmp___5) {
        zend_error_noreturn(1, "Cannot use object as array");
      } else {

      }
      (*(((*container)->value.obj.handlers)->unset_dimension))(*container, offset);
      break;
      case 6: 
      zend_error_noreturn(1, "Cannot unset string offsets");
      return (0);
      default: ;
      break;
      }
    } else {

    }
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_UNSET_OBJ_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **container ;
  zval *offset ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  offset = opline->op2.zv;
  if (1 << 2 != 1 << 2) {
    goto _L;
  } else {
    if (container) {
      _L: /* CIL Label */ 
      if (1 << 2 == 1 << 4) {
        if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
          tmp___1 = zval_isref_p(*container);
          if (tmp___1) {

          } else {
            while (1) {
              tmp___0 = zval_refcount_p(*container);
              if (tmp___0 > 1U) {
                zval_delref_p(*container);
                while (1) {
                  tmp = _emalloc(sizeof(zval_gc_info ));
                  new_zv = (zval *)tmp;
                  ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                  break;
                }
                while (1) {
                  while (1) {
                    new_zv->value = (*container)->value;
                    new_zv->type = (*container)->type;
                    break;
                  }
                  zval_set_refcount_p(new_zv, 1U);
                  zval_unset_isref_p(new_zv);
                  break;
                }
                *container = new_zv;
                _zval_copy_ctor(new_zv);
              } else {

              }
              break;
            }
          }
        } else {

        }
      } else {

      }
      if ((int )(*container)->type == 5) {
        if (((*container)->value.obj.handlers)->unset_property) {
          (*(((*container)->value.obj.handlers)->unset_property))(*container, offset, (struct _zend_literal  const  *)opline->op2.literal);
        } else {
          zend_error(1 << 3L, "Trying to unset property of non-object");
        }
      } else {

      }
    } else {

    }
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ISSET_ISEMPTY_VAR_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **value ;
  zend_bool isset ;
  zend_compiled_variable *cv ;
  int __attribute__((__visibility__("default")))  tmp ;
  HashTable *target_symbol_table ;
  zend_free_op free_op1 ;
  zval tmp___0 ;
  zval *varname ;
  zval *tmp___1 ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_literal *tmp___3 ;
  zval __attribute__((__visibility__("default")))  **tmp___4 ;
  int __attribute__((__visibility__("default")))  tmp___5 ;
  zval *__z ;
  zval *__z___0 ;
  zval *__z___1 ;
  zval *__z___2 ;
  int tmp___6 ;

  {
  opline = execute_data->opline;
  isset = (zend_bool )1;
  if (1 << 2 == 1 << 4) {
    if (1 == 1 << 3) {
      if (opline->extended_value & 8388608UL) {
        if (*(execute_data->CVs + opline->op1.var)) {
          value = *(execute_data->CVs + opline->op1.var);
        } else {
          if (executor_globals.active_symbol_table) {
            cv = (executor_globals.active_op_array)->vars + opline->op1.var;
            tmp = zend_hash_quick_find((HashTable const   *)executor_globals.active_symbol_table, cv->name, (unsigned int )(cv->name_len + 1), cv->hash_value, (void **)(& value));
            if (tmp == (int __attribute__((__visibility__("default")))  )-1) {
              isset = (unsigned char)0;
            } else {

            }
          } else {
            isset = (unsigned char)0;
          }
        }
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    _L: /* CIL Label */ 
    tmp___1 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    varname = tmp___1;
    if (1 << 2 != 1) {
      if ((int )varname->type != 6) {
        while (1) {
          tmp___0.value = varname->value;
          tmp___0.type = varname->type;
          break;
        }
        _zval_copy_ctor(& tmp___0);
        if ((int )tmp___0.type != 6) {
          _convert_to_string(& tmp___0);
        } else {

        }
        varname = & tmp___0;
      } else {

      }
    } else {

    }
    if (1 != 1 << 3) {
      if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
        ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
      } else {
        tmp___2 = zend_fetch_class_by_name((char const   *)(opline->op2.zv)->value.str.val, (unsigned int )(opline->op2.zv)->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), 0);
        ce = (zend_class_entry *)tmp___2;
        while (1) {
          *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
          break;
        }
      }
      if (1 << 2 == 1) {
        tmp___3 = opline->op1.literal;
      } else {
        tmp___3 = (zend_literal *)((void *)0);
      }
      tmp___4 = zend_std_get_static_property(ce, (char const   *)varname->value.str.val, varname->value.str.len, (unsigned char)1, (struct _zend_literal  const  *)tmp___3);
      value = (zval **)tmp___4;
      if (! value) {
        isset = (unsigned char)0;
      } else {

      }
    } else {
      target_symbol_table = zend_get_target_symbol_table((int )(opline->extended_value & 1879048192UL));
      tmp___5 = zend_hash_find((HashTable const   *)target_symbol_table, (char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1), (void **)(& value));
      if (tmp___5 == (int __attribute__((__visibility__("default")))  )-1) {
        isset = (unsigned char)0;
      } else {

      }
    }
    if (1 << 2 != 1) {
      if ((unsigned int )varname == (unsigned int )(& tmp___0)) {
        _zval_dtor(& tmp___0);
      } else {

      }
    } else {

    }
    if (free_op1.var) {
      i_zval_ptr_dtor(free_op1.var);
    } else {

    }
  }
  if (opline->extended_value & 33554432UL) {
    if (isset) {
      if ((int )(*value)->type != 0) {
        while (1) {
          __z = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
          __z->value.lval = 1L;
          __z->type = (unsigned char)3;
          break;
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      while (1) {
        __z___0 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
        __z___0->value.lval = 0L;
        __z___0->type = (unsigned char)3;
        break;
      }
    }
  } else {
    if (! isset) {
      goto _L___2;
    } else {
      tmp___6 = i_zend_is_true(*value);
      if (tmp___6) {
        while (1) {
          __z___2 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
          __z___2->value.lval = 0L;
          __z___2->type = (unsigned char)3;
          break;
        }
      } else {
        _L___2: /* CIL Label */ 
        while (1) {
          __z___1 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
          __z___1->value.lval = 1L;
          __z___1->type = (unsigned char)3;
          break;
        }
      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_CONST)(int prop_dim , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **container ;
  zval **value ;
  int result ;
  ulong hval ;
  zval *offset ;
  HashTable *ht ;
  int isset ;
  long tmp ;
  int __attribute__((__visibility__("default")))  tmp___0 ;
  register char const   *tmp___1 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___2 ;
  int __attribute__((__visibility__("default")))  tmp___3 ;
  int __attribute__((__visibility__("default")))  tmp___4 ;
  int tmp___5 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;
  zval tmp___7 ;

  {
  opline = execute_data->opline;
  value = (zval **)((void *)0);
  result = 0;
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  offset = opline->op2.zv;
  if ((int )(*container)->type == 4) {
    if (! prop_dim) {
      isset = 0;
      ht = (*container)->value.ht;
      switch ((int )offset->type) {
      case 2: 
      tmp = zend_dval_to_lval(offset->value.dval);
      hval = (unsigned long )tmp;
      goto num_index_prop;
      case 7: 
      case 3: 
      case 1: 
      hval = (unsigned long )offset->value.lval;
      num_index_prop: 
      tmp___0 = zend_hash_index_find((HashTable const   *)ht, hval, (void **)(& value));
      if (tmp___0 == (int __attribute__((__visibility__("default")))  )0) {
        isset = 1;
      } else {

      }
      break;
      case 6: 
      if (1) {
        hval = ((zend_literal *)offset)->hash_value;
      } else {
        if (! prop_dim) {
          while (1) {
            tmp___1 = (char const   *)offset->value.str.val;
            if ((int const   )*tmp___1 == 45) {
              tmp___1 ++;
            } else {

            }
            if ((int const   )*tmp___1 >= 48) {
              if ((int const   )*tmp___1 <= 57) {
                end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
                if ((int const   )*end != 0) {
                  break;
                } else {
                  if ((int const   )*tmp___1 == 48) {
                    if (offset->value.str.len + 1 > 2) {
                      break;
                    } else {
                      goto _L;
                    }
                  } else {
                    _L: /* CIL Label */ 
                    if (end - tmp___1 > 10) {
                      break;
                    } else {
                      if (end - tmp___1 == 10) {
                        if ((int const   )*tmp___1 > 50) {
                          break;
                        } else {

                        }
                      } else {

                      }
                    }
                  }
                }
                hval = (unsigned long )((int const   )*tmp___1 - 48);
                while (1) {
                  tmp___1 ++;
                  if ((unsigned int )tmp___1 != (unsigned int )end) {
                    if ((int const   )*tmp___1 >= 48) {
                      if ((int const   )*tmp___1 <= 57) {

                      } else {
                        break;
                      }
                    } else {
                      break;
                    }
                  } else {
                    break;
                  }
                  hval = hval * 10UL + (ulong )((int const   )*tmp___1 - 48);
                }
                if ((unsigned int )tmp___1 == (unsigned int )end) {
                  if ((int )*(offset->value.str.val) == 45) {
                    if (hval - 1UL > 2147483647UL) {
                      break;
                    } else {

                    }
                    hval = (unsigned long )(- ((long )hval));
                  } else {
                    if (hval > 2147483647UL) {
                      break;
                    } else {

                    }
                  }
                  goto num_index_prop;
                } else {

                }
              } else {

              }
            } else {

            }
            break;
          }
        } else {

        }
        if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
          if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
            hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
          } else {
            tmp___2 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
            hval = (unsigned long )tmp___2;
          }
        } else {
          tmp___2 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___2;
        }
      }
      tmp___3 = zend_hash_quick_find((HashTable const   *)ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, (void **)(& value));
      if (tmp___3 == (int __attribute__((__visibility__("default")))  )0) {
        isset = 1;
      } else {

      }
      break;
      case 0: 
      tmp___4 = zend_hash_find((HashTable const   *)ht, "", sizeof(""), (void **)(& value));
      if (tmp___4 == (int __attribute__((__visibility__("default")))  )0) {
        isset = 1;
      } else {

      }
      break;
      default: 
      zend_error(1 << 1L, "Illegal offset type in isset or empty");
      break;
      }
      if (opline->extended_value & 33554432UL) {
        if (isset) {
          if ((int )(*value)->type == 0) {
            result = 0;
          } else {
            result = isset;
          }
        } else {
          result = isset;
        }
      } else {
        if (! isset) {
          result = 0;
        } else {
          tmp___5 = i_zend_is_true(*value);
          if (tmp___5) {
            result = 1;
          } else {
            result = 0;
          }
        }
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if ((int )(*container)->type == 5) {
      if (prop_dim) {
        if (((*container)->value.obj.handlers)->has_property) {
          result = (*(((*container)->value.obj.handlers)->has_property))(*container, offset, (opline->extended_value & 16777216UL) != 0UL, (struct _zend_literal  const  *)opline->op2.literal);
        } else {
          zend_error(1 << 3L, "Trying to check property of non-object");
          result = 0;
        }
      } else {
        if (((*container)->value.obj.handlers)->has_dimension) {
          result = (*(((*container)->value.obj.handlers)->has_dimension))(*container, offset, (opline->extended_value & 16777216UL) != 0UL);
        } else {
          zend_error(1 << 3L, "Trying to check element of non-array");
          result = 0;
        }
      }
    } else {
      if ((int )(*container)->type == 6) {
        if (! prop_dim) {
          if ((int )offset->type != 1) {
            while (1) {
              tmp___7.value = offset->value;
              tmp___7.type = offset->type;
              break;
            }
            _zval_copy_ctor(& tmp___7);
            convert_to_long(& tmp___7);
            offset = & tmp___7;
          } else {

          }
          if ((int )offset->type == 1) {
            if (opline->extended_value & 33554432UL) {
              if (offset->value.lval >= 0L) {
                if (offset->value.lval < (long )(*container)->value.str.len) {
                  result = 1;
                } else {

                }
              } else {

              }
            } else {
              if (offset->value.lval >= 0L) {
                if (offset->value.lval < (long )(*container)->value.str.len) {
                  if ((int )*((*container)->value.str.val + offset->value.lval) != 48) {
                    result = 1;
                  } else {

                  }
                } else {

                }
              } else {

              }
            }
          } else {

          }
        } else {

        }
      } else {

      }
    }
  }
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.type = (unsigned char)3;
  if (opline->extended_value & 33554432UL) {
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.lval = (long )result;
  } else {
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.lval = (long )(! result);
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_CONST(0, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_VAR_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_CONST(1, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  fast_add_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SUB_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  fast_sub_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_MUL_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  fast_mul_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_DIV_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  fast_div_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_MOD_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  fast_mod_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SL_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  shift_left_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SR_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  shift_right_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_CONCAT_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  concat_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_IDENTICAL_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  is_identical_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_NOT_IDENTICAL_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *result ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  is_identical_function(result, tmp___0, tmp);
  result->value.lval = (long )(! result->value.lval);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_EQUAL_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  zval *tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    tmp___1 = fast_equal_function(result, tmp___0, tmp);
    __z->value.lval = (long )(tmp___1 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_NOT_EQUAL_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  zval *tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    tmp___1 = fast_not_equal_function(result, tmp___0, tmp);
    __z->value.lval = (long )(tmp___1 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_SMALLER_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  zval *tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    tmp___1 = fast_is_smaller_function(result, tmp___0, tmp);
    __z->value.lval = (long )(tmp___1 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_SMALLER_OR_EQUAL_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  zval *tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    tmp___1 = fast_is_smaller_or_equal_function(result, tmp___0, tmp);
    __z->value.lval = (long )(tmp___1 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_OR_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  bitwise_or_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_AND_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  bitwise_and_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_XOR_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  bitwise_xor_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BOOL_XOR_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  boolean_xor_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_binary_assign_op_obj_helper_SPEC_VAR_TMP)(int (*binary_op)(zval *result , zval *op1 , zval *op2 ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zend_free_op free_op_data1 ;
  zval **object_ptr ;
  zval **tmp ;
  zval *object ;
  zval *property ;
  zval *tmp___0 ;
  zval *value ;
  zval *tmp___1 ;
  int have_get_ptr ;
  long tmp___2 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___3 ;
  zval **zptr ;
  zend_literal *tmp___4 ;
  zval **tmp___5 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;
  zend_uint tmp___7 ;
  zend_bool tmp___8 ;
  zval *z ;
  zend_literal *tmp___9 ;
  zval *value___0 ;
  zval *tmp___10 ;
  zend_uint tmp___11 ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___12 ;
  zend_uint tmp___13 ;
  zend_bool tmp___14 ;
  zend_literal *tmp___15 ;
  long tmp___16 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  object_ptr = tmp;
  tmp___0 = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  property = tmp___0;
  tmp___1 = _get_zval_ptr((int )(opline + 1)->op1_type, (znode_op const   *)(& (opline + 1)->op1), (temp_variable const   *)execute_data->Ts, & free_op_data1, 0);
  value = tmp___1;
  have_get_ptr = 0;
  if (1 << 2 == 1 << 2) {
    tmp___2 = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___2) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  make_real_object(object_ptr);
  object = *object_ptr;
  tmp___16 = __builtin_expect((long )((int )object->type != 5), 0L);
  if (tmp___16) {
    zend_error(1 << 1L, "Attempt to assign property of non-object");
    _zval_dtor(free_op2.var);
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = & executor_globals.uninitialized_zval;
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
    } else {

    }
  } else {
    while (1) {
      while (1) {
        tmp___3 = _emalloc(sizeof(zval_gc_info ));
        _tmp = (zval *)tmp___3;
        ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      while (1) {
        while (1) {
          _tmp->value = property->value;
          _tmp->type = property->type;
          break;
        }
        zval_set_refcount_p(_tmp, 1U);
        zval_unset_isref_p(_tmp);
        break;
      }
      property = _tmp;
      break;
    }
    if (opline->extended_value == 136UL) {
      if ((object->value.obj.handlers)->get_property_ptr_ptr) {
        if (1 << 1 == 1) {
          tmp___4 = opline->op2.literal;
        } else {
          tmp___4 = (zend_literal *)((void *)0);
        }
        tmp___5 = (*((object->value.obj.handlers)->get_property_ptr_ptr))(object, property, (struct _zend_literal  const  *)tmp___4);
        zptr = tmp___5;
        if ((unsigned int )zptr != (unsigned int )((void *)0)) {
          tmp___8 = zval_isref_p(*zptr);
          if (tmp___8) {

          } else {
            while (1) {
              tmp___7 = zval_refcount_p(*zptr);
              if (tmp___7 > 1U) {
                zval_delref_p(*zptr);
                while (1) {
                  tmp___6 = _emalloc(sizeof(zval_gc_info ));
                  new_zv = (zval *)tmp___6;
                  ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                  break;
                }
                while (1) {
                  while (1) {
                    new_zv->value = (*zptr)->value;
                    new_zv->type = (*zptr)->type;
                    break;
                  }
                  zval_set_refcount_p(new_zv, 1U);
                  zval_unset_isref_p(new_zv);
                  break;
                }
                *zptr = new_zv;
                _zval_copy_ctor(new_zv);
              } else {

              }
              break;
            }
          }
          have_get_ptr = 1;
          (*binary_op)(*zptr, *zptr, value);
          if (! ((int )opline->result_type & (1 << 5))) {
            zval_addref_p(*zptr);
            ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = *zptr;
            ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
          } else {

          }
        } else {

        }
      } else {

      }
    } else {

    }
    if (! have_get_ptr) {
      z = (zval *)((void *)0);
      if (opline->extended_value == 136UL) {
        if ((object->value.obj.handlers)->read_property) {
          if (1 << 1 == 1) {
            tmp___9 = opline->op2.literal;
          } else {
            tmp___9 = (zend_literal *)((void *)0);
          }
          z = (*((object->value.obj.handlers)->read_property))(object, property, 0, (struct _zend_literal  const  *)tmp___9);
        } else {

        }
      } else {
        if ((object->value.obj.handlers)->read_dimension) {
          z = (*((object->value.obj.handlers)->read_dimension))(object, property, 0);
        } else {

        }
      }
      if (z) {
        if ((int )z->type == 5) {
          if ((z->value.obj.handlers)->get) {
            tmp___10 = (*((z->value.obj.handlers)->get))(z);
            value___0 = tmp___10;
            tmp___11 = zval_refcount_p(z);
            if (tmp___11 == 0U) {
              if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                gc_remove_zval_from_buffer(z);
              } else {

              }
              _zval_dtor(z);
              while (1) {
                if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                  gc_remove_zval_from_buffer(z);
                } else {

                }
                _efree((void *)z);
                break;
              }
            } else {

            }
            z = value___0;
          } else {

          }
        } else {

        }
        zval_addref_p(z);
        tmp___14 = zval_isref_p(z);
        if (tmp___14) {

        } else {
          while (1) {
            tmp___13 = zval_refcount_p(z);
            if (tmp___13 > 1U) {
              zval_delref_p(z);
              while (1) {
                tmp___12 = _emalloc(sizeof(zval_gc_info ));
                new_zv___0 = (zval *)tmp___12;
                ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv___0->value = z->value;
                  new_zv___0->type = z->type;
                  break;
                }
                zval_set_refcount_p(new_zv___0, 1U);
                zval_unset_isref_p(new_zv___0);
                break;
              }
              z = new_zv___0;
              _zval_copy_ctor(new_zv___0);
            } else {

            }
            break;
          }
        }
        (*binary_op)(z, z, value);
        if (opline->extended_value == 136UL) {
          if (1 << 1 == 1) {
            tmp___15 = opline->op2.literal;
          } else {
            tmp___15 = (zend_literal *)((void *)0);
          }
          (*((object->value.obj.handlers)->write_property))(object, property, z, (struct _zend_literal  const  *)tmp___15);
        } else {
          (*((object->value.obj.handlers)->write_dimension))(object, property, z);
        }
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(z);
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = z;
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
        } else {

        }
        i_zval_ptr_dtor(z);
      } else {
        zend_error(1 << 1L, "Attempt to assign property of non-object");
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = & executor_globals.uninitialized_zval;
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
        } else {

        }
      }
    } else {

    }
    i_zval_ptr_dtor(property);
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_binary_assign_op_helper_SPEC_VAR_TMP)(int (*binary_op)(zval *result , zval *op1 , zval *op2 ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zend_free_op free_op_data2 ;
  zend_free_op free_op_data1 ;
  zval **var_ptr ;
  zval *value ;
  int tmp ;
  zval **container ;
  zval **tmp___0 ;
  int tmp___1 ;
  zval *dim ;
  zval *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  temp_variable *__t ;
  long tmp___6 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___7 ;
  zend_uint tmp___8 ;
  zend_bool tmp___9 ;
  zval *objval ;
  zval *tmp___10 ;
  long tmp___11 ;
  temp_variable *__t___0 ;

  {
  opline = execute_data->opline;
  switch ((int )opline->extended_value) {
  case 136: 
  tmp = zend_binary_assign_op_obj_helper_SPEC_VAR_TMP(binary_op, execute_data);
  return (tmp);
  break;
  case 147: 
  tmp___0 = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  container = tmp___0;
  if (1 << 2 == 1 << 2) {
    tmp___4 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___4) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    tmp___3 = __builtin_expect((long )((int )(*container)->type == 5), 0L);
    if (tmp___3) {
      if (1 << 2 == 1 << 2) {
        if (! ((unsigned int )free_op1.var != (unsigned int )((void *)0))) {
          zval_addref_p(*container);
        } else {

        }
      } else {

      }
      tmp___1 = zend_binary_assign_op_obj_helper_SPEC_VAR_TMP(binary_op, execute_data);
      return (tmp___1);
    } else {
      tmp___2 = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
      dim = tmp___2;
      zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var), container, dim, 1 << 1, 2);
      value = _get_zval_ptr((int )(opline + 1)->op1_type, (znode_op const   *)(& (opline + 1)->op1), (temp_variable const   *)execute_data->Ts, & free_op_data1, 0);
      var_ptr = _get_zval_ptr_ptr_var((opline + 1)->op2.var, (temp_variable const   *)execute_data->Ts, & free_op_data2);
    }
  }
  break;
  default: 
  value = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  break;
  }
  tmp___5 = __builtin_expect((long )((unsigned int )var_ptr == (unsigned int )((void *)0)), 0L);
  if (tmp___5) {
    zend_error_noreturn(1, "Cannot use assign-op operators with overloaded objects nor string offsets");
  } else {

  }
  tmp___6 = __builtin_expect((long )((unsigned int )*var_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
  if (tmp___6) {
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      while (1) {
        __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t->var.ptr = & executor_globals.uninitialized_zval;
        __t->var.ptr_ptr = & __t->var.ptr;
        break;
      }
    } else {

    }
    _zval_dtor(free_op2.var);
    if (free_op1.var) {
      i_zval_ptr_dtor(free_op1.var);
    } else {

    }
    if (opline->extended_value == 147UL) {
      (execute_data->opline) ++;
    } else {

    }
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  tmp___9 = zval_isref_p(*var_ptr);
  if (tmp___9) {

  } else {
    while (1) {
      tmp___8 = zval_refcount_p(*var_ptr);
      if (tmp___8 > 1U) {
        zval_delref_p(*var_ptr);
        while (1) {
          tmp___7 = _emalloc(sizeof(zval_gc_info ));
          new_zv = (zval *)tmp___7;
          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            new_zv->value = (*var_ptr)->value;
            new_zv->type = (*var_ptr)->type;
            break;
          }
          zval_set_refcount_p(new_zv, 1U);
          zval_unset_isref_p(new_zv);
          break;
        }
        *var_ptr = new_zv;
        _zval_copy_ctor(new_zv);
      } else {

      }
      break;
    }
  }
  tmp___11 = __builtin_expect((long )((int )(*var_ptr)->type == 5), 0L);
  if (tmp___11) {
    if (((*var_ptr)->value.obj.handlers)->get) {
      if (((*var_ptr)->value.obj.handlers)->set) {
        tmp___10 = (*(((*var_ptr)->value.obj.handlers)->get))(*var_ptr);
        objval = tmp___10;
        zval_addref_p(objval);
        (*binary_op)(objval, objval, value);
        (*(((*var_ptr)->value.obj.handlers)->set))(var_ptr, objval);
        i_zval_ptr_dtor(objval);
      } else {
        (*binary_op)(*var_ptr, *var_ptr, value);
      }
    } else {
      (*binary_op)(*var_ptr, *var_ptr, value);
    }
  } else {
    (*binary_op)(*var_ptr, *var_ptr, value);
  }
  if (! ((int )opline->result_type & (1 << 5))) {
    zval_addref_p(*var_ptr);
    while (1) {
      __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
      __t___0->var.ptr = *var_ptr;
      __t___0->var.ptr_ptr = & __t___0->var.ptr;
      break;
    }
  } else {

  }
  _zval_dtor(free_op2.var);
  if (opline->extended_value == 147UL) {
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
    if (free_op_data2.var) {
      i_zval_ptr_dtor(free_op_data2.var);
    } else {

    }
    if (free_op1.var) {
      i_zval_ptr_dtor(free_op1.var);
    } else {

    }
    (execute_data->opline) ++;
  } else {
    if (free_op1.var) {
      i_zval_ptr_dtor(free_op1.var);
    } else {

    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_ADD_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_TMP((int (*)(zval *result , zval *op1 , zval *op2 ))(& add_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SUB_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_TMP((int (*)(zval *result , zval *op1 , zval *op2 ))(& sub_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_MUL_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_TMP((int (*)(zval *result , zval *op1 , zval *op2 ))(& mul_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_DIV_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_TMP((int (*)(zval *result , zval *op1 , zval *op2 ))(& div_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_MOD_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_TMP((int (*)(zval *result , zval *op1 , zval *op2 ))(& mod_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SL_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_TMP((int (*)(zval *result , zval *op1 , zval *op2 ))(& shift_left_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SR_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_TMP((int (*)(zval *result , zval *op1 , zval *op2 ))(& shift_right_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_CONCAT_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_TMP((int (*)(zval *result , zval *op1 , zval *op2 ))(& concat_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_OR_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_TMP((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_or_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_AND_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_TMP((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_and_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_XOR_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_TMP((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_xor_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) zend_pre_incdec_property_helper_SPEC_VAR_TMP)(int (*incdec_op)(zval * ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval **object_ptr ;
  zval *object ;
  zval *property ;
  zval **retval ;
  int have_get_ptr ;
  long tmp ;
  long tmp___0 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zval **zptr ;
  zend_literal *tmp___2 ;
  zval **tmp___3 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_uint tmp___5 ;
  zend_bool tmp___6 ;
  zval *z ;
  zend_literal *tmp___7 ;
  zval *tmp___8 ;
  zval *value ;
  zval *tmp___9 ;
  zend_uint tmp___10 ;
  long tmp___11 ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___12 ;
  zend_uint tmp___13 ;
  zend_bool tmp___14 ;
  zend_literal *tmp___15 ;

  {
  opline = execute_data->opline;
  have_get_ptr = 0;
  object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  property = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  retval = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
  if (1 << 2 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot increment/decrement overloaded objects nor string offsets");
    } else {

    }
  } else {

  }
  make_real_object(object_ptr);
  object = *object_ptr;
  tmp___0 = __builtin_expect((long )((int )object->type != 5), 0L);
  if (tmp___0) {
    zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
    _zval_dtor(free_op2.var);
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      *retval = & executor_globals.uninitialized_zval;
    } else {

    }
    if (free_op1.var) {
      i_zval_ptr_dtor(free_op1.var);
    } else {

    }
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  while (1) {
    while (1) {
      tmp___1 = _emalloc(sizeof(zval_gc_info ));
      _tmp = (zval *)tmp___1;
      ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
      break;
    }
    while (1) {
      while (1) {
        _tmp->value = property->value;
        _tmp->type = property->type;
        break;
      }
      zval_set_refcount_p(_tmp, 1U);
      zval_unset_isref_p(_tmp);
      break;
    }
    property = _tmp;
    break;
  }
  if ((object->value.obj.handlers)->get_property_ptr_ptr) {
    if (1 << 1 == 1) {
      tmp___2 = opline->op2.literal;
    } else {
      tmp___2 = (zend_literal *)((void *)0);
    }
    tmp___3 = (*((object->value.obj.handlers)->get_property_ptr_ptr))(object, property, (struct _zend_literal  const  *)tmp___2);
    zptr = tmp___3;
    if ((unsigned int )zptr != (unsigned int )((void *)0)) {
      tmp___6 = zval_isref_p(*zptr);
      if (tmp___6) {

      } else {
        while (1) {
          tmp___5 = zval_refcount_p(*zptr);
          if (tmp___5 > 1U) {
            zval_delref_p(*zptr);
            while (1) {
              tmp___4 = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp___4;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*zptr)->value;
                new_zv->type = (*zptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *zptr = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
      have_get_ptr = 1;
      (*incdec_op)(*zptr);
      if (! ((int )opline->result_type & (1 << 5))) {
        *retval = *zptr;
        zval_addref_p(*retval);
      } else {

      }
    } else {

    }
  } else {

  }
  if (! have_get_ptr) {
    if ((object->value.obj.handlers)->read_property) {
      if ((object->value.obj.handlers)->write_property) {
        if (1 << 1 == 1) {
          tmp___7 = opline->op2.literal;
        } else {
          tmp___7 = (zend_literal *)((void *)0);
        }
        tmp___8 = (*((object->value.obj.handlers)->read_property))(object, property, 0, (struct _zend_literal  const  *)tmp___7);
        z = tmp___8;
        tmp___11 = __builtin_expect((long )((int )z->type == 5), 0L);
        if (tmp___11) {
          if ((z->value.obj.handlers)->get) {
            tmp___9 = (*((z->value.obj.handlers)->get))(z);
            value = tmp___9;
            tmp___10 = zval_refcount_p(z);
            if (tmp___10 == 0U) {
              if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                gc_remove_zval_from_buffer(z);
              } else {

              }
              _zval_dtor(z);
              while (1) {
                if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                  gc_remove_zval_from_buffer(z);
                } else {

                }
                _efree((void *)z);
                break;
              }
            } else {

            }
            z = value;
          } else {

          }
        } else {

        }
        zval_addref_p(z);
        tmp___14 = zval_isref_p(z);
        if (tmp___14) {

        } else {
          while (1) {
            tmp___13 = zval_refcount_p(z);
            if (tmp___13 > 1U) {
              zval_delref_p(z);
              while (1) {
                tmp___12 = _emalloc(sizeof(zval_gc_info ));
                new_zv___0 = (zval *)tmp___12;
                ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv___0->value = z->value;
                  new_zv___0->type = z->type;
                  break;
                }
                zval_set_refcount_p(new_zv___0, 1U);
                zval_unset_isref_p(new_zv___0);
                break;
              }
              z = new_zv___0;
              _zval_copy_ctor(new_zv___0);
            } else {

            }
            break;
          }
        }
        (*incdec_op)(z);
        *retval = z;
        if (1 << 1 == 1) {
          tmp___15 = opline->op2.literal;
        } else {
          tmp___15 = (zend_literal *)((void *)0);
        }
        (*((object->value.obj.handlers)->write_property))(object, property, z, (struct _zend_literal  const  *)tmp___15);
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(*retval);
        } else {

        }
        i_zval_ptr_dtor(z);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
      if (! ((int )opline->result_type & (1 << 5))) {
        zval_addref_p(& executor_globals.uninitialized_zval);
        *retval = & executor_globals.uninitialized_zval;
      } else {

      }
    }
  } else {

  }
  i_zval_ptr_dtor(property);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_PRE_INC_OBJ_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_pre_incdec_property_helper_SPEC_VAR_TMP((int (*)(zval * ))(& increment_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_PRE_DEC_OBJ_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_pre_incdec_property_helper_SPEC_VAR_TMP((int (*)(zval * ))(& decrement_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) zend_post_incdec_property_helper_SPEC_VAR_TMP)(int (*incdec_op)(zval * ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval **object_ptr ;
  zval *object ;
  zval *property ;
  zval *retval ;
  int have_get_ptr ;
  long tmp ;
  long tmp___0 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zval **zptr ;
  zend_literal *tmp___2 ;
  zval **tmp___3 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_uint tmp___5 ;
  zend_bool tmp___6 ;
  zval *z ;
  zend_literal *tmp___7 ;
  zval *tmp___8 ;
  zval *z_copy ;
  zval *value ;
  zval *tmp___9 ;
  zend_uint tmp___10 ;
  long tmp___11 ;
  void __attribute__((__visibility__("default")))  *tmp___12 ;
  zend_literal *tmp___13 ;

  {
  opline = execute_data->opline;
  have_get_ptr = 0;
  object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  property = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  retval = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  if (1 << 2 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot increment/decrement overloaded objects nor string offsets");
    } else {

    }
  } else {

  }
  make_real_object(object_ptr);
  object = *object_ptr;
  tmp___0 = __builtin_expect((long )((int )object->type != 5), 0L);
  if (tmp___0) {
    zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
    _zval_dtor(free_op2.var);
    retval->type = (unsigned char)0;
    if (free_op1.var) {
      i_zval_ptr_dtor(free_op1.var);
    } else {

    }
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  while (1) {
    while (1) {
      tmp___1 = _emalloc(sizeof(zval_gc_info ));
      _tmp = (zval *)tmp___1;
      ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
      break;
    }
    while (1) {
      while (1) {
        _tmp->value = property->value;
        _tmp->type = property->type;
        break;
      }
      zval_set_refcount_p(_tmp, 1U);
      zval_unset_isref_p(_tmp);
      break;
    }
    property = _tmp;
    break;
  }
  if ((object->value.obj.handlers)->get_property_ptr_ptr) {
    if (1 << 1 == 1) {
      tmp___2 = opline->op2.literal;
    } else {
      tmp___2 = (zend_literal *)((void *)0);
    }
    tmp___3 = (*((object->value.obj.handlers)->get_property_ptr_ptr))(object, property, (struct _zend_literal  const  *)tmp___2);
    zptr = tmp___3;
    if ((unsigned int )zptr != (unsigned int )((void *)0)) {
      have_get_ptr = 1;
      tmp___6 = zval_isref_p(*zptr);
      if (tmp___6) {

      } else {
        while (1) {
          tmp___5 = zval_refcount_p(*zptr);
          if (tmp___5 > 1U) {
            zval_delref_p(*zptr);
            while (1) {
              tmp___4 = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp___4;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*zptr)->value;
                new_zv->type = (*zptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *zptr = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
      while (1) {
        retval->value = (*zptr)->value;
        retval->type = (*zptr)->type;
        break;
      }
      _zval_copy_ctor(retval);
      (*incdec_op)(*zptr);
    } else {

    }
  } else {

  }
  if (! have_get_ptr) {
    if ((object->value.obj.handlers)->read_property) {
      if ((object->value.obj.handlers)->write_property) {
        if (1 << 1 == 1) {
          tmp___7 = opline->op2.literal;
        } else {
          tmp___7 = (zend_literal *)((void *)0);
        }
        tmp___8 = (*((object->value.obj.handlers)->read_property))(object, property, 0, (struct _zend_literal  const  *)tmp___7);
        z = tmp___8;
        tmp___11 = __builtin_expect((long )((int )z->type == 5), 0L);
        if (tmp___11) {
          if ((z->value.obj.handlers)->get) {
            tmp___9 = (*((z->value.obj.handlers)->get))(z);
            value = tmp___9;
            tmp___10 = zval_refcount_p(z);
            if (tmp___10 == 0U) {
              if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                gc_remove_zval_from_buffer(z);
              } else {

              }
              _zval_dtor(z);
              while (1) {
                if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                  gc_remove_zval_from_buffer(z);
                } else {

                }
                _efree((void *)z);
                break;
              }
            } else {

            }
            z = value;
          } else {

          }
        } else {

        }
        while (1) {
          retval->value = z->value;
          retval->type = z->type;
          break;
        }
        _zval_copy_ctor(retval);
        while (1) {
          tmp___12 = _emalloc(sizeof(zval_gc_info ));
          z_copy = (zval *)tmp___12;
          ((zval_gc_info *)z_copy)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            z_copy->value = z->value;
            z_copy->type = z->type;
            break;
          }
          zval_set_refcount_p(z_copy, 1U);
          zval_unset_isref_p(z_copy);
          break;
        }
        _zval_copy_ctor(z_copy);
        (*incdec_op)(z_copy);
        zval_addref_p(z);
        if (1 << 1 == 1) {
          tmp___13 = opline->op2.literal;
        } else {
          tmp___13 = (zend_literal *)((void *)0);
        }
        (*((object->value.obj.handlers)->write_property))(object, property, z_copy, (struct _zend_literal  const  *)tmp___13);
        i_zval_ptr_dtor(z_copy);
        i_zval_ptr_dtor(z);
      } else {
        zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
        retval->type = (unsigned char)0;
      }
    } else {
      zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
      retval->type = (unsigned char)0;
    }
  } else {

  }
  i_zval_ptr_dtor(property);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_POST_INC_OBJ_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_post_incdec_property_helper_SPEC_VAR_TMP((int (*)(zval * ))(& increment_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_POST_DEC_OBJ_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_post_incdec_property_helper_SPEC_VAR_TMP((int (*)(zval * ))(& decrement_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_R_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval **container ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  if (opline->extended_value & 134217728UL) {
    if (1 << 2 != 1 << 4) {
      if (((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr) {
        zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr));
      } else {

      }
    } else {

    }
  } else {

  }
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  zend_fetch_dimension_address_read((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, tmp, 1 << 1, 0);
  _zval_dtor(free_op2.var);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_W_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval **container ;
  long tmp ;
  zval *tmp___0 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zend_uint tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___6 ;
  zval **retval_ptr ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___7 ;
  zend_uint tmp___8 ;
  zend_bool tmp___9 ;
  long tmp___10 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  tmp___0 = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, tmp___0, 1 << 1, 1);
  _zval_dtor(free_op2.var);
  if (1 << 2 == 1 << 2) {
    if ((unsigned int )free_op1.var != (unsigned int )((void *)0)) {
      tmp___5 = zval_refcount_p(free_op1.var);
      if (tmp___5 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___6 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___6 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___3 = zval_isref_p(__t->var.ptr);
                if (tmp___3) {

                } else {
                  tmp___4 = zval_refcount_p(__t->var.ptr);
                  if (tmp___4 > 2U) {
                    while (1) {
                      tmp___2 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___2 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___1 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___1;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  tmp___10 = __builtin_expect((long )(opline->extended_value != 0UL), 0L);
  if (tmp___10) {
    retval_ptr = ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr;
    if (retval_ptr) {
      zval_delref_p(*retval_ptr);
      tmp___9 = zval_isref_p(*retval_ptr);
      if (tmp___9) {

      } else {
        while (1) {
          tmp___8 = zval_refcount_p(*retval_ptr);
          if (tmp___8 > 1U) {
            zval_delref_p(*retval_ptr);
            while (1) {
              tmp___7 = _emalloc(sizeof(zval_gc_info ));
              new_zv___0 = (zval *)tmp___7;
              ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv___0->value = (*retval_ptr)->value;
                new_zv___0->type = (*retval_ptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv___0, 1U);
              zval_unset_isref_p(new_zv___0);
              break;
            }
            *retval_ptr = new_zv___0;
            _zval_copy_ctor(new_zv___0);
          } else {

          }
          break;
        }
        zval_set_isref_p(*retval_ptr);
      }
      zval_addref_p(*retval_ptr);
    } else {

    }
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_RW_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval **container ;
  long tmp ;
  zval *tmp___0 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zend_uint tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___6 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  tmp___0 = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, tmp___0, 1 << 1, 2);
  _zval_dtor(free_op2.var);
  if (1 << 2 == 1 << 2) {
    if ((unsigned int )free_op1.var != (unsigned int )((void *)0)) {
      tmp___5 = zval_refcount_p(free_op1.var);
      if (tmp___5 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___6 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___6 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___3 = zval_isref_p(__t->var.ptr);
                if (tmp___3) {

                } else {
                  tmp___4 = zval_refcount_p(__t->var.ptr);
                  if (tmp___4 > 2U) {
                    while (1) {
                      tmp___2 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___2 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___1 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___1;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_IS_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval **container ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  zend_fetch_dimension_address_read((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, tmp, 1 << 1, 3);
  _zval_dtor(free_op2.var);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval **container ;
  long tmp ;
  zval *tmp___0 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zend_uint tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___6 ;
  zval *tmp___7 ;
  unsigned int tmp___8 ;

  {
  opline = execute_data->opline;
  if (execute_data->fbc) {
    if ((execute_data->fbc)->common.arg_info) {
      if ((opline->extended_value & 1048575UL) <= (unsigned long )(execute_data->fbc)->common.num_args) {
        tmp___8 = (unsigned int )((int )((execute_data->fbc)->common.arg_info + ((opline->extended_value & 1048575UL) - 1UL))->pass_by_reference & 3);
      } else {
        tmp___8 = (execute_data->fbc)->common.fn_flags & 50331648U;
      }
    } else {
      tmp___8 = (execute_data->fbc)->common.fn_flags & 50331648U;
    }
    if (tmp___8) {
      container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
      if (1 << 2 == 1 << 2) {
        tmp = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
        if (tmp) {
          zend_error_noreturn(1, "Cannot use string offset as an array");
        } else {

        }
      } else {

      }
      tmp___0 = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
      zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, tmp___0, 1 << 1, 1);
      if (1 << 2 == 1 << 2) {
        if ((unsigned int )free_op1.var != (unsigned int )((void *)0)) {
          tmp___5 = zval_refcount_p(free_op1.var);
          if (tmp___5 == 1U) {
            if ((int )(free_op1.var)->type != 5) {
              goto _L;
            } else {
              tmp___6 = zend_objects_store_get_refcount(free_op1.var);
              if (tmp___6 == (zend_uint __attribute__((__visibility__("default")))  )1) {
                _L: /* CIL Label */ 
                while (1) {
                  __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
                  if (__t->var.ptr_ptr) {
                    __t->var.ptr = *(__t->var.ptr_ptr);
                    __t->var.ptr_ptr = & __t->var.ptr;
                    tmp___3 = zval_isref_p(__t->var.ptr);
                    if (tmp___3) {

                    } else {
                      tmp___4 = zval_refcount_p(__t->var.ptr);
                      if (tmp___4 > 2U) {
                        while (1) {
                          tmp___2 = zval_refcount_p(*(__t->var.ptr_ptr));
                          if (tmp___2 > 1U) {
                            zval_delref_p(*(__t->var.ptr_ptr));
                            while (1) {
                              tmp___1 = _emalloc(sizeof(zval_gc_info ));
                              new_zv = (zval *)tmp___1;
                              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                              break;
                            }
                            while (1) {
                              while (1) {
                                new_zv->value = (*(__t->var.ptr_ptr))->value;
                                new_zv->type = (*(__t->var.ptr_ptr))->type;
                                break;
                              }
                              zval_set_refcount_p(new_zv, 1U);
                              zval_unset_isref_p(new_zv);
                              break;
                            }
                            *(__t->var.ptr_ptr) = new_zv;
                            _zval_copy_ctor(new_zv);
                          } else {

                          }
                          break;
                        }
                      } else {

                      }
                    }
                  } else {

                  }
                  break;
                }
              } else {

              }
            }
          } else {

          }
        } else {

        }
      } else {

      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if (1 << 1 == 1 << 3) {
      zend_error_noreturn(1, "Cannot use [] for reading");
    } else {

    }
    container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    tmp___7 = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    zend_fetch_dimension_address_read((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, tmp___7, 1 << 1, 0);
  }
  _zval_dtor(free_op2.var);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_UNSET_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval **container ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  long tmp___2 ;
  zval *tmp___3 ;
  temp_variable *__t ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_uint tmp___5 ;
  zend_bool tmp___6 ;
  zend_uint tmp___7 ;
  zend_uint tmp___8 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___9 ;
  zend_free_op free_res ;
  zval **retval_ptr ;
  zval *new_zv___1 ;
  void __attribute__((__visibility__("default")))  *tmp___10 ;
  zend_uint tmp___11 ;
  zend_bool tmp___12 ;
  long tmp___13 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 4) {
    if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
      tmp___1 = zval_isref_p(*container);
      if (tmp___1) {

      } else {
        while (1) {
          tmp___0 = zval_refcount_p(*container);
          if (tmp___0 > 1U) {
            zval_delref_p(*container);
            while (1) {
              tmp = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*container)->value;
                new_zv->type = (*container)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *container = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
    } else {

    }
  } else {

  }
  if (1 << 2 == 1 << 2) {
    tmp___2 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___2) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  tmp___3 = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, tmp___3, 1 << 1, 6);
  _zval_dtor(free_op2.var);
  if (1 << 2 == 1 << 2) {
    if ((unsigned int )free_op1.var != (unsigned int )((void *)0)) {
      tmp___8 = zval_refcount_p(free_op1.var);
      if (tmp___8 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___9 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___9 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___6 = zval_isref_p(__t->var.ptr);
                if (tmp___6) {

                } else {
                  tmp___7 = zval_refcount_p(__t->var.ptr);
                  if (tmp___7 > 2U) {
                    while (1) {
                      tmp___5 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___5 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___4 = _emalloc(sizeof(zval_gc_info ));
                          new_zv___0 = (zval *)tmp___4;
                          ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv___0->value = (*(__t->var.ptr_ptr))->value;
                            new_zv___0->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv___0, 1U);
                          zval_unset_isref_p(new_zv___0);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv___0;
                        _zval_copy_ctor(new_zv___0);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  tmp___13 = __builtin_expect((long )((unsigned int )((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr == (unsigned int )((void *)0)), 0L);
  if (tmp___13) {
    zend_error_noreturn(1, "Cannot unset string offsets");
  } else {
    retval_ptr = ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr;
    zend_pzval_unlock_func(*retval_ptr, & free_res, 1);
    if ((unsigned int )retval_ptr != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
      tmp___12 = zval_isref_p(*retval_ptr);
      if (tmp___12) {

      } else {
        while (1) {
          tmp___11 = zval_refcount_p(*retval_ptr);
          if (tmp___11 > 1U) {
            zval_delref_p(*retval_ptr);
            while (1) {
              tmp___10 = _emalloc(sizeof(zval_gc_info ));
              new_zv___1 = (zval *)tmp___10;
              ((zval_gc_info *)new_zv___1)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv___1->value = (*retval_ptr)->value;
                new_zv___1->type = (*retval_ptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv___1, 1U);
              zval_unset_isref_p(new_zv___1);
              break;
            }
            *retval_ptr = new_zv___1;
            _zval_copy_ctor(new_zv___1);
          } else {

          }
          break;
        }
      }
    } else {

    }
    zval_addref_p(*retval_ptr);
    if (free_res.var) {
      i_zval_ptr_dtor(free_res.var);
    } else {

    }
    (execute_data->opline) ++;
    return (0);
  }
}
}
static int ( __attribute__((__fastcall__)) zend_fetch_property_address_read_helper_SPEC_VAR_TMP)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *container ;
  zend_free_op free_op2 ;
  zval *offset ;
  temp_variable *__t ;
  zval *retval ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_literal *tmp___0 ;
  temp_variable *__t___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  offset = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___1 = __builtin_expect((long )((int )container->type != 5), 0L);
  if (tmp___1) {
    goto _L;
  } else {
    tmp___2 = __builtin_expect((long )((unsigned int )(container->value.obj.handlers)->read_property == (unsigned int )((void *)0)), 0L);
    if (tmp___2) {
      _L: /* CIL Label */ 
      zend_error(1 << 3L, "Trying to get property of non-object");
      zval_addref_p(& executor_globals.uninitialized_zval);
      while (1) {
        __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t->var.ptr = & executor_globals.uninitialized_zval;
        __t->var.ptr_ptr = & __t->var.ptr;
        break;
      }
      _zval_dtor(free_op2.var);
    } else {
      while (1) {
        while (1) {
          tmp = _emalloc(sizeof(zval_gc_info ));
          _tmp = (zval *)tmp;
          ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            _tmp->value = offset->value;
            _tmp->type = offset->type;
            break;
          }
          zval_set_refcount_p(_tmp, 1U);
          zval_unset_isref_p(_tmp);
          break;
        }
        offset = _tmp;
        break;
      }
      if (1 << 1 == 1) {
        tmp___0 = opline->op2.literal;
      } else {
        tmp___0 = (zend_literal *)((void *)0);
      }
      retval = (*((container->value.obj.handlers)->read_property))(container, offset, 0, (struct _zend_literal  const  *)tmp___0);
      zval_addref_p(retval);
      while (1) {
        __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t___0->var.ptr = retval;
        __t___0->var.ptr_ptr = & __t___0->var.ptr;
        break;
      }
      i_zval_ptr_dtor(offset);
    }
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_R_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_property_address_read_helper_SPEC_VAR_TMP(execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_W_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *property ;
  zval **container ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zend_literal *tmp___1 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_uint tmp___3 ;
  zend_bool tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint tmp___6 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___7 ;
  zval **retval_ptr ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___8 ;
  zend_uint tmp___9 ;
  zend_bool tmp___10 ;

  {
  opline = execute_data->opline;
  property = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if (1 << 2 == 1 << 2) {
    if (opline->extended_value & 134217728UL) {
      zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr));
      ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr = *(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr);
    } else {

    }
  } else {

  }
  while (1) {
    while (1) {
      tmp = _emalloc(sizeof(zval_gc_info ));
      _tmp = (zval *)tmp;
      ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
      break;
    }
    while (1) {
      while (1) {
        _tmp->value = property->value;
        _tmp->type = property->type;
        break;
      }
      zval_set_refcount_p(_tmp, 1U);
      zval_unset_isref_p(_tmp);
      break;
    }
    property = _tmp;
    break;
  }
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  if (1 << 1 == 1) {
    tmp___1 = opline->op2.literal;
  } else {
    tmp___1 = (zend_literal *)((void *)0);
  }
  zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)tmp___1, 1);
  i_zval_ptr_dtor(property);
  if (1 << 2 == 1 << 2) {
    if ((unsigned int )free_op1.var != (unsigned int )((void *)0)) {
      tmp___6 = zval_refcount_p(free_op1.var);
      if (tmp___6 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___7 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___7 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___4 = zval_isref_p(__t->var.ptr);
                if (tmp___4) {

                } else {
                  tmp___5 = zval_refcount_p(__t->var.ptr);
                  if (tmp___5 > 2U) {
                    while (1) {
                      tmp___3 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___3 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___2 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___2;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  if (opline->extended_value & 67108864UL) {
    retval_ptr = ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr;
    zval_delref_p(*retval_ptr);
    tmp___10 = zval_isref_p(*retval_ptr);
    if (tmp___10) {

    } else {
      while (1) {
        tmp___9 = zval_refcount_p(*retval_ptr);
        if (tmp___9 > 1U) {
          zval_delref_p(*retval_ptr);
          while (1) {
            tmp___8 = _emalloc(sizeof(zval_gc_info ));
            new_zv___0 = (zval *)tmp___8;
            ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv___0->value = (*retval_ptr)->value;
              new_zv___0->type = (*retval_ptr)->type;
              break;
            }
            zval_set_refcount_p(new_zv___0, 1U);
            zval_unset_isref_p(new_zv___0);
            break;
          }
          *retval_ptr = new_zv___0;
          _zval_copy_ctor(new_zv___0);
        } else {

        }
        break;
      }
      zval_set_isref_p(*retval_ptr);
    }
    zval_addref_p(*retval_ptr);
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = *(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr);
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_RW_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *property ;
  zval **container ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zend_literal *tmp___1 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_uint tmp___3 ;
  zend_bool tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint tmp___6 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___7 ;

  {
  opline = execute_data->opline;
  property = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  while (1) {
    while (1) {
      tmp = _emalloc(sizeof(zval_gc_info ));
      _tmp = (zval *)tmp;
      ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
      break;
    }
    while (1) {
      while (1) {
        _tmp->value = property->value;
        _tmp->type = property->type;
        break;
      }
      zval_set_refcount_p(_tmp, 1U);
      zval_unset_isref_p(_tmp);
      break;
    }
    property = _tmp;
    break;
  }
  if (1 << 2 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  if (1 << 1 == 1) {
    tmp___1 = opline->op2.literal;
  } else {
    tmp___1 = (zend_literal *)((void *)0);
  }
  zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)tmp___1, 2);
  i_zval_ptr_dtor(property);
  if (1 << 2 == 1 << 2) {
    if ((unsigned int )free_op1.var != (unsigned int )((void *)0)) {
      tmp___6 = zval_refcount_p(free_op1.var);
      if (tmp___6 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___7 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___7 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___4 = zval_isref_p(__t->var.ptr);
                if (tmp___4) {

                } else {
                  tmp___5 = zval_refcount_p(__t->var.ptr);
                  if (tmp___5 > 2U) {
                    while (1) {
                      tmp___3 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___3 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___2 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___2;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_IS_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *container ;
  zend_free_op free_op2 ;
  zval *offset ;
  temp_variable *__t ;
  zval *retval ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_literal *tmp___0 ;
  temp_variable *__t___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  offset = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___1 = __builtin_expect((long )((int )container->type != 5), 0L);
  if (tmp___1) {
    goto _L;
  } else {
    tmp___2 = __builtin_expect((long )((unsigned int )(container->value.obj.handlers)->read_property == (unsigned int )((void *)0)), 0L);
    if (tmp___2) {
      _L: /* CIL Label */ 
      zval_addref_p(& executor_globals.uninitialized_zval);
      while (1) {
        __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t->var.ptr = & executor_globals.uninitialized_zval;
        __t->var.ptr_ptr = & __t->var.ptr;
        break;
      }
      _zval_dtor(free_op2.var);
    } else {
      while (1) {
        while (1) {
          tmp = _emalloc(sizeof(zval_gc_info ));
          _tmp = (zval *)tmp;
          ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            _tmp->value = offset->value;
            _tmp->type = offset->type;
            break;
          }
          zval_set_refcount_p(_tmp, 1U);
          zval_unset_isref_p(_tmp);
          break;
        }
        offset = _tmp;
        break;
      }
      if (1 << 1 == 1) {
        tmp___0 = opline->op2.literal;
      } else {
        tmp___0 = (zend_literal *)((void *)0);
      }
      retval = (*((container->value.obj.handlers)->read_property))(container, offset, 3, (struct _zend_literal  const  *)tmp___0);
      zval_addref_p(retval);
      while (1) {
        __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t___0->var.ptr = retval;
        __t___0->var.ptr_ptr = & __t___0->var.ptr;
        break;
      }
      i_zval_ptr_dtor(offset);
    }
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *property ;
  zval **container ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zend_literal *tmp___1 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_uint tmp___3 ;
  zend_bool tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint tmp___6 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;

  {
  opline = execute_data->opline;
  if (execute_data->fbc) {
    if ((execute_data->fbc)->common.arg_info) {
      if ((opline->extended_value & 1048575UL) <= (unsigned long )(execute_data->fbc)->common.num_args) {
        tmp___9 = (unsigned int )((int )((execute_data->fbc)->common.arg_info + ((opline->extended_value & 1048575UL) - 1UL))->pass_by_reference & 3);
      } else {
        tmp___9 = (execute_data->fbc)->common.fn_flags & 50331648U;
      }
    } else {
      tmp___9 = (execute_data->fbc)->common.fn_flags & 50331648U;
    }
    if (tmp___9) {
      property = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
      container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
      while (1) {
        while (1) {
          tmp = _emalloc(sizeof(zval_gc_info ));
          _tmp = (zval *)tmp;
          ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            _tmp->value = property->value;
            _tmp->type = property->type;
            break;
          }
          zval_set_refcount_p(_tmp, 1U);
          zval_unset_isref_p(_tmp);
          break;
        }
        property = _tmp;
        break;
      }
      if (1 << 2 == 1 << 2) {
        tmp___0 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
        if (tmp___0) {
          zend_error_noreturn(1, "Cannot use string offset as an object");
        } else {

        }
      } else {

      }
      if (1 << 1 == 1) {
        tmp___1 = opline->op2.literal;
      } else {
        tmp___1 = (zend_literal *)((void *)0);
      }
      zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)tmp___1, 1);
      i_zval_ptr_dtor(property);
      if (1 << 2 == 1 << 2) {
        if ((unsigned int )free_op1.var != (unsigned int )((void *)0)) {
          tmp___6 = zval_refcount_p(free_op1.var);
          if (tmp___6 == 1U) {
            if ((int )(free_op1.var)->type != 5) {
              goto _L;
            } else {
              tmp___7 = zend_objects_store_get_refcount(free_op1.var);
              if (tmp___7 == (zend_uint __attribute__((__visibility__("default")))  )1) {
                _L: /* CIL Label */ 
                while (1) {
                  __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
                  if (__t->var.ptr_ptr) {
                    __t->var.ptr = *(__t->var.ptr_ptr);
                    __t->var.ptr_ptr = & __t->var.ptr;
                    tmp___4 = zval_isref_p(__t->var.ptr);
                    if (tmp___4) {

                    } else {
                      tmp___5 = zval_refcount_p(__t->var.ptr);
                      if (tmp___5 > 2U) {
                        while (1) {
                          tmp___3 = zval_refcount_p(*(__t->var.ptr_ptr));
                          if (tmp___3 > 1U) {
                            zval_delref_p(*(__t->var.ptr_ptr));
                            while (1) {
                              tmp___2 = _emalloc(sizeof(zval_gc_info ));
                              new_zv = (zval *)tmp___2;
                              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                              break;
                            }
                            while (1) {
                              while (1) {
                                new_zv->value = (*(__t->var.ptr_ptr))->value;
                                new_zv->type = (*(__t->var.ptr_ptr))->type;
                                break;
                              }
                              zval_set_refcount_p(new_zv, 1U);
                              zval_unset_isref_p(new_zv);
                              break;
                            }
                            *(__t->var.ptr_ptr) = new_zv;
                            _zval_copy_ctor(new_zv);
                          } else {

                          }
                          break;
                        }
                      } else {

                      }
                    }
                  } else {

                  }
                  break;
                }
              } else {

              }
            }
          } else {

          }
        } else {

        }
      } else {

      }
      if (free_op1.var) {
        i_zval_ptr_dtor(free_op1.var);
      } else {

      }
      (execute_data->opline) ++;
      return (0);
    } else {
      tmp___8 = zend_fetch_property_address_read_helper_SPEC_VAR_TMP(execute_data);
      return (tmp___8);
    }
  } else {
    tmp___8 = zend_fetch_property_address_read_helper_SPEC_VAR_TMP(execute_data);
    return (tmp___8);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_UNSET_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zend_free_op free_res ;
  zval **container ;
  zval *property ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  long tmp___3 ;
  zend_literal *tmp___4 ;
  temp_variable *__t ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  zend_uint tmp___6 ;
  zend_bool tmp___7 ;
  zend_uint tmp___8 ;
  zend_uint tmp___9 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___10 ;
  zval *new_zv___1 ;
  void __attribute__((__visibility__("default")))  *tmp___11 ;
  zend_uint tmp___12 ;
  zend_bool tmp___13 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  property = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if (1 << 2 == 1 << 4) {
    if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
      tmp___1 = zval_isref_p(*container);
      if (tmp___1) {

      } else {
        while (1) {
          tmp___0 = zval_refcount_p(*container);
          if (tmp___0 > 1U) {
            zval_delref_p(*container);
            while (1) {
              tmp = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*container)->value;
                new_zv->type = (*container)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *container = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
    } else {

    }
  } else {

  }
  while (1) {
    while (1) {
      tmp___2 = _emalloc(sizeof(zval_gc_info ));
      _tmp = (zval *)tmp___2;
      ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
      break;
    }
    while (1) {
      while (1) {
        _tmp->value = property->value;
        _tmp->type = property->type;
        break;
      }
      zval_set_refcount_p(_tmp, 1U);
      zval_unset_isref_p(_tmp);
      break;
    }
    property = _tmp;
    break;
  }
  if (1 << 2 == 1 << 2) {
    tmp___3 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___3) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  if (1 << 1 == 1) {
    tmp___4 = opline->op2.literal;
  } else {
    tmp___4 = (zend_literal *)((void *)0);
  }
  zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)tmp___4, 6);
  i_zval_ptr_dtor(property);
  if (1 << 2 == 1 << 2) {
    if ((unsigned int )free_op1.var != (unsigned int )((void *)0)) {
      tmp___9 = zval_refcount_p(free_op1.var);
      if (tmp___9 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___10 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___10 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___7 = zval_isref_p(__t->var.ptr);
                if (tmp___7) {

                } else {
                  tmp___8 = zval_refcount_p(__t->var.ptr);
                  if (tmp___8 > 2U) {
                    while (1) {
                      tmp___6 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___6 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___5 = _emalloc(sizeof(zval_gc_info ));
                          new_zv___0 = (zval *)tmp___5;
                          ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv___0->value = (*(__t->var.ptr_ptr))->value;
                            new_zv___0->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv___0, 1U);
                          zval_unset_isref_p(new_zv___0);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv___0;
                        _zval_copy_ctor(new_zv___0);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  zend_pzval_unlock_func(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr), & free_res, 1);
  if ((unsigned int )((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
    tmp___13 = zval_isref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
    if (tmp___13) {

    } else {
      while (1) {
        tmp___12 = zval_refcount_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
        if (tmp___12 > 1U) {
          zval_delref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
          while (1) {
            tmp___11 = _emalloc(sizeof(zval_gc_info ));
            new_zv___1 = (zval *)tmp___11;
            ((zval_gc_info *)new_zv___1)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv___1->value = (*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr))->value;
              new_zv___1->type = (*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr))->type;
              break;
            }
            zval_set_refcount_p(new_zv___1, 1U);
            zval_unset_isref_p(new_zv___1);
            break;
          }
          *(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr) = new_zv___1;
          _zval_copy_ctor(new_zv___1);
        } else {

        }
        break;
      }
    }
  } else {

  }
  zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
  if (free_res.var) {
    i_zval_ptr_dtor(free_res.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_OBJ_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval **object_ptr ;
  zval *property_name ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zend_literal *tmp___1 ;
  zval **tmp___2 ;

  {
  opline = execute_data->opline;
  object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  property_name = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  while (1) {
    while (1) {
      tmp = _emalloc(sizeof(zval_gc_info ));
      _tmp = (zval *)tmp;
      ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
      break;
    }
    while (1) {
      while (1) {
        _tmp->value = property_name->value;
        _tmp->type = property_name->type;
        break;
      }
      zval_set_refcount_p(_tmp, 1U);
      zval_unset_isref_p(_tmp);
      break;
    }
    property_name = _tmp;
    break;
  }
  if (1 << 2 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  if (1 << 1 == 1) {
    tmp___1 = opline->op2.literal;
  } else {
    tmp___1 = (zend_literal *)((void *)0);
  }
  if (! ((int )opline->result_type & (1 << 5))) {
    tmp___2 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
  } else {
    tmp___2 = (zval **)((void *)0);
  }
  zend_assign_to_object(tmp___2, object_ptr, property_name, (int )(opline + 1)->op1_type, & (opline + 1)->op1, (temp_variable const   *)execute_data->Ts, 136, (zend_literal const   *)tmp___1);
  i_zval_ptr_dtor(property_name);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_DIM_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **object_ptr ;
  long tmp ;
  zend_free_op free_op2 ;
  zval *property_name ;
  zval *tmp___0 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_literal *tmp___2 ;
  zval **tmp___3 ;
  zend_free_op free_op2___0 ;
  zend_free_op free_op_data1 ;
  zend_free_op free_op_data2 ;
  zval *value ;
  zval *dim ;
  zval *tmp___4 ;
  zval **variable_ptr_ptr ;
  zval *retval ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  char const   *__s ;
  int __l ;
  zval *__z ;
  char __attribute__((__visibility__("default")))  *tmp___6 ;
  temp_variable *__t ;
  temp_variable *__t___0 ;
  int tmp___7 ;
  temp_variable *__t___1 ;
  temp_variable *__t___2 ;
  long tmp___8 ;
  long tmp___9 ;

  {
  opline = execute_data->opline;
  object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  if ((int )(*object_ptr)->type == 5) {
    tmp___0 = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    property_name = tmp___0;
    while (1) {
      while (1) {
        tmp___1 = _emalloc(sizeof(zval_gc_info ));
        _tmp = (zval *)tmp___1;
        ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      while (1) {
        while (1) {
          _tmp->value = property_name->value;
          _tmp->type = property_name->type;
          break;
        }
        zval_set_refcount_p(_tmp, 1U);
        zval_unset_isref_p(_tmp);
        break;
      }
      property_name = _tmp;
      break;
    }
    if (1 << 1 == 1) {
      tmp___2 = opline->op2.literal;
    } else {
      tmp___2 = (zend_literal *)((void *)0);
    }
    if (! ((int )opline->result_type & (1 << 5))) {
      tmp___3 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
    } else {
      tmp___3 = (zval **)((void *)0);
    }
    zend_assign_to_object(tmp___3, object_ptr, property_name, (int )(opline + 1)->op1_type, & (opline + 1)->op1, (temp_variable const   *)execute_data->Ts, 147, (zend_literal const   *)tmp___2);
    i_zval_ptr_dtor(property_name);
  } else {
    tmp___4 = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2___0);
    dim = tmp___4;
    zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var), object_ptr, dim, 1 << 1, 1);
    _zval_dtor(free_op2___0.var);
    value = _get_zval_ptr((int )(opline + 1)->op1_type, (znode_op const   *)(& (opline + 1)->op1), (temp_variable const   *)execute_data->Ts, & free_op_data1, 0);
    variable_ptr_ptr = _get_zval_ptr_ptr_var((opline + 1)->op2.var, (temp_variable const   *)execute_data->Ts, & free_op_data2);
    tmp___9 = __builtin_expect((long )((unsigned int )variable_ptr_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___9) {
      tmp___7 = zend_assign_to_string_offset((temp_variable const   *)((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var)), (zval const   *)value, (int )(opline + 1)->op1_type);
      if (tmp___7) {
        if (! ((int )opline->result_type & (1 << 5))) {
          while (1) {
            tmp___5 = _emalloc(sizeof(zval_gc_info ));
            retval = (zval *)tmp___5;
            ((zval_gc_info *)retval)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            __s = (char const   *)((((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var))->str_offset.str)->value.str.val + ((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var))->str_offset.offset);
            __l = 1;
            __z = retval;
            __z->value.str.len = __l;
            tmp___6 = _estrndup(__s, (unsigned int )__l);
            __z->value.str.val = (char *)tmp___6;
            __z->type = (unsigned char)6;
            break;
          }
          retval->refcount__gc = 1U;
          retval->is_ref__gc = (unsigned char)0;
          while (1) {
            __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t->var.ptr = retval;
            __t->var.ptr_ptr = & __t->var.ptr;
            break;
          }
        } else {

        }
      } else {
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          while (1) {
            __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___0->var.ptr = & executor_globals.uninitialized_zval;
            __t___0->var.ptr_ptr = & __t___0->var.ptr;
            break;
          }
        } else {

        }
      }
    } else {
      tmp___8 = __builtin_expect((long )((unsigned int )*variable_ptr_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
      if (tmp___8) {
        if ((unsigned long )free_op_data1.var & 1UL) {
          _zval_dtor(value);
        } else {

        }
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          while (1) {
            __t___1 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___1->var.ptr = & executor_globals.uninitialized_zval;
            __t___1->var.ptr_ptr = & __t___1->var.ptr;
            break;
          }
        } else {

        }
      } else {
        if ((int )(opline + 1)->op1_type == 1 << 1) {
          value = zend_assign_tmp_to_variable(variable_ptr_ptr, value);
        } else {
          if ((int )(opline + 1)->op1_type == 1) {
            value = zend_assign_const_to_variable(variable_ptr_ptr, value);
          } else {
            value = zend_assign_to_variable(variable_ptr_ptr, value);
          }
        }
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(value);
          while (1) {
            __t___2 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___2->var.ptr = value;
            __t___2->var.ptr_ptr = & __t___2->var.ptr;
            break;
          }
        } else {

        }
      }
    }
    if (free_op_data2.var) {
      i_zval_ptr_dtor(free_op_data2.var);
    } else {

    }
    if ((unsigned int )free_op_data1.var != (unsigned int )((void *)0)) {
      if (((unsigned long )free_op_data1.var & 1UL) == 0UL) {
        i_zval_ptr_dtor(free_op_data1.var);
      } else {

      }
    } else {

    }
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *value ;
  zval **variable_ptr_ptr ;
  zval *retval ;
  void __attribute__((__visibility__("default")))  *tmp ;
  char const   *__s ;
  int __l ;
  zval *__z ;
  char __attribute__((__visibility__("default")))  *tmp___0 ;
  temp_variable *__t ;
  temp_variable *__t___0 ;
  int tmp___1 ;
  temp_variable *__t___1 ;
  temp_variable *__t___2 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  opline = execute_data->opline;
  value = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  variable_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 2) {
    tmp___3 = __builtin_expect((long )((unsigned int )variable_ptr_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___3) {
      tmp___1 = zend_assign_to_string_offset((temp_variable const   *)((temp_variable *)((char *)execute_data->Ts + opline->op1.var)), (zval const   *)value, 1 << 1);
      if (tmp___1) {
        if (! ((int )opline->result_type & (1 << 5))) {
          while (1) {
            tmp = _emalloc(sizeof(zval_gc_info ));
            retval = (zval *)tmp;
            ((zval_gc_info *)retval)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            __s = (char const   *)((((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->str_offset.str)->value.str.val + ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->str_offset.offset);
            __l = 1;
            __z = retval;
            __z->value.str.len = __l;
            tmp___0 = _estrndup(__s, (unsigned int )__l);
            __z->value.str.val = (char *)tmp___0;
            __z->type = (unsigned char)6;
            break;
          }
          retval->refcount__gc = 1U;
          retval->is_ref__gc = (unsigned char)0;
          while (1) {
            __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t->var.ptr = retval;
            __t->var.ptr_ptr = & __t->var.ptr;
            break;
          }
        } else {

        }
      } else {
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          while (1) {
            __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___0->var.ptr = & executor_globals.uninitialized_zval;
            __t___0->var.ptr_ptr = & __t___0->var.ptr;
            break;
          }
        } else {

        }
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if (1 << 2 == 1 << 2) {
      tmp___2 = __builtin_expect((long )((unsigned int )*variable_ptr_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
      if (tmp___2) {
        _zval_dtor(value);
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          while (1) {
            __t___1 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___1->var.ptr = & executor_globals.uninitialized_zval;
            __t___1->var.ptr_ptr = & __t___1->var.ptr;
            break;
          }
        } else {

        }
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      if (1 << 1 == 1 << 1) {
        value = zend_assign_tmp_to_variable(variable_ptr_ptr, value);
      } else {
        if (1 << 1 == 1) {
          value = zend_assign_const_to_variable(variable_ptr_ptr, value);
        } else {
          value = zend_assign_to_variable(variable_ptr_ptr, value);
        }
      }
      if (! ((int )opline->result_type & (1 << 5))) {
        zval_addref_p(value);
        while (1) {
          __t___2 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
          __t___2->var.ptr = value;
          __t___2->var.ptr_ptr = & __t___2->var.ptr;
          break;
        }
      } else {

      }
    }
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_METHOD_CALL_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *function_name ;
  char *function_name_strval ;
  int function_name_strlen ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  long tmp ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  zval *object ;
  long tmp___1 ;
  zend_literal *tmp___2 ;
  zend_class_entry *tmp___3 ;
  zend_class_entry *tmp___4 ;
  char const   *tmp___5 ;
  zend_class_entry *tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  zend_function *tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  zval *this_ptr ;
  void __attribute__((__visibility__("default")))  *tmp___13 ;
  zend_bool tmp___14 ;

  {
  opline = execute_data->opline;
  zend_ptr_stack_3_push(& executor_globals.arg_types_stack, (void *)execute_data->fbc, (void *)execute_data->object, (void *)execute_data->called_scope);
  function_name = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if (1 << 1 != 1) {
    tmp = __builtin_expect((long )((int )function_name->type != 6), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Method name must be a string");
    } else {

    }
  } else {

  }
  function_name_strval = function_name->value.str.val;
  function_name_strlen = function_name->value.str.len;
  execute_data->object = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  tmp___11 = __builtin_expect((long )((unsigned int )execute_data->object != (unsigned int )((void *)0)), 1L);
  if (tmp___11) {
    tmp___12 = __builtin_expect((long )((int )(execute_data->object)->type == 5), 1L);
    if (tmp___12) {
      tmp___0 = zend_get_class_entry((zval const   *)execute_data->object);
      execute_data->called_scope = (zend_class_entry *)tmp___0;
      if (1 << 1 != 1) {
        goto _L;
      } else {
        if ((unsigned int )*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) == (unsigned int )execute_data->called_scope) {
          tmp___10 = (zend_function *)*((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U));
        } else {
          tmp___10 = (zend_function *)((void *)0);
        }
        execute_data->fbc = tmp___10;
        if ((unsigned int )tmp___10 == (unsigned int )((void *)0)) {
          _L: /* CIL Label */ 
          object = execute_data->object;
          tmp___1 = __builtin_expect((long )((unsigned int )((execute_data->object)->value.obj.handlers)->get_method == (unsigned int )((void *)0)), 0L);
          if (tmp___1) {
            zend_error_noreturn(1, "Object does not support method calls");
          } else {

          }
          if (1 << 1 == 1) {
            tmp___2 = opline->op2.literal + 1;
          } else {
            tmp___2 = (zend_literal *)((void *)0);
          }
          execute_data->fbc = (*(((execute_data->object)->value.obj.handlers)->get_method))(& execute_data->object, function_name_strval, function_name_strlen, (struct _zend_literal  const  *)tmp___2);
          tmp___7 = __builtin_expect((long )((unsigned int )execute_data->fbc == (unsigned int )((void *)0)), 0L);
          if (tmp___7) {
            if (execute_data->object) {
              if ((int )(execute_data->object)->type == 5) {
                if ((unsigned int )((execute_data->object)->value.obj.handlers)->get_class_entry != (unsigned int )((void *)0)) {
                  tmp___6 = (*(((execute_data->object)->value.obj.handlers)->get_class_entry))((zval const   *)execute_data->object);
                  if (tmp___6) {
                    tmp___4 = (*(((execute_data->object)->value.obj.handlers)->get_class_entry))((zval const   *)execute_data->object);
                    tmp___5 = tmp___4->name;
                  } else {
                    tmp___5 = "";
                  }
                } else {
                  tmp___5 = "";
                }
              } else {
                tmp___5 = "";
              }
            } else {
              tmp___5 = "";
            }
            zend_error_noreturn(1, "Call to undefined method %s::%s()", tmp___5, function_name_strval);
          } else {

          }
          if (1 << 1 == 1) {
            tmp___8 = __builtin_expect((long )(((execute_data->fbc)->common.fn_flags & 6291456U) == 0U), 1L);
            if (tmp___8) {
              tmp___9 = __builtin_expect((long )((unsigned int )execute_data->object == (unsigned int )object), 1L);
              if (tmp___9) {
                while (1) {
                  *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)execute_data->called_scope;
                  *((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U)) = (void *)execute_data->fbc;
                  break;
                }
              } else {

              }
            } else {

            }
          } else {

          }
        } else {

        }
      }
    } else {
      zend_error_noreturn(1, "Call to a member function %s() on a non-object", function_name_strval);
    }
  } else {
    zend_error_noreturn(1, "Call to a member function %s() on a non-object", function_name_strval);
  }
  if (((execute_data->fbc)->common.fn_flags & 1U) != 0U) {
    execute_data->object = (zval *)((void *)0);
  } else {
    tmp___14 = zval_isref_p(execute_data->object);
    if (tmp___14) {
      while (1) {
        tmp___13 = _emalloc(sizeof(zval_gc_info ));
        this_ptr = (zval *)tmp___13;
        ((zval_gc_info *)this_ptr)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      while (1) {
        while (1) {
          this_ptr->value = (execute_data->object)->value;
          this_ptr->type = (execute_data->object)->type;
          break;
        }
        zval_set_refcount_p(this_ptr, 1U);
        zval_unset_isref_p(this_ptr);
        break;
      }
      _zval_copy_ctor(this_ptr);
      execute_data->object = this_ptr;
    } else {
      zval_addref_p(execute_data->object);
    }
  }
  _zval_dtor(free_op2.var);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *function_name ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  char *function_name_strval ;
  int function_name_strlen ;
  zend_free_op free_op2 ;
  long tmp___1 ;
  zend_literal *tmp___2 ;
  union _zend_function  __attribute__((__visibility__("default"))) *tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___7 ;
  zend_function *tmp___8 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___9 ;
  zend_bool __attribute__((__visibility__("default")))  tmp___10 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___11 ;
  zval *tmp___12 ;

  {
  opline = execute_data->opline;
  zend_ptr_stack_3_push(& executor_globals.arg_types_stack, (void *)execute_data->fbc, (void *)execute_data->object, (void *)execute_data->called_scope);
  if (1 << 2 == 1) {
    if (*((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot)) {
      ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot);
    } else {
      tmp = zend_fetch_class_by_name((char const   *)(opline->op1.zv)->value.str.val, (unsigned int )(opline->op1.zv)->value.str.len, (zend_literal const   *)(opline->op1.literal + 1), (int )opline->extended_value);
      ce = (zend_class_entry *)tmp;
      tmp___0 = __builtin_expect((long )((unsigned int )ce == (unsigned int )((void *)0)), 0L);
      if (tmp___0) {
        zend_error_noreturn(1, "Class \'%s\' not found", (opline->op1.zv)->value.str.val);
      } else {

      }
      while (1) {
        *((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot) = (void *)ce;
        break;
      }
    }
    execute_data->called_scope = ce;
  } else {
    ce = ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->class_entry;
    if (opline->extended_value == 2UL) {
      execute_data->called_scope = executor_globals.called_scope;
    } else {
      if (opline->extended_value == 1UL) {
        execute_data->called_scope = executor_globals.called_scope;
      } else {
        execute_data->called_scope = ce;
      }
    }
  }
  if (1 << 2 == 1) {
    if (1 << 1 == 1) {
      if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
        execute_data->fbc = (zend_function *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
      } else {
        goto _L___2;
      }
    } else {
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
    _L___1: /* CIL Label */ 
    if (1 << 2 != 1) {
      if (1 << 1 == 1) {
        if ((unsigned int )*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) == (unsigned int )ce) {
          tmp___8 = (zend_function *)*((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U));
        } else {
          tmp___8 = (zend_function *)((void *)0);
        }
        execute_data->fbc = tmp___8;
        if (tmp___8) {

        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      _L: /* CIL Label */ 
      if (1 << 1 != 1 << 3) {
        function_name_strval = (char *)((void *)0);
        function_name_strlen = 0;
        if (1 << 1 == 1) {
          function_name_strval = (opline->op2.zv)->value.str.val;
          function_name_strlen = (opline->op2.zv)->value.str.len;
        } else {
          function_name = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
          tmp___1 = __builtin_expect((long )((int )function_name->type != 6), 0L);
          if (tmp___1) {
            zend_error_noreturn(1, "Function name must be a string");
          } else {
            function_name_strval = function_name->value.str.val;
            function_name_strlen = function_name->value.str.len;
          }
        }
        if (function_name_strval) {
          if (ce->get_static_method) {
            execute_data->fbc = (*(ce->get_static_method))(ce, function_name_strval, function_name_strlen);
          } else {
            if (1 << 1 == 1) {
              tmp___2 = opline->op2.literal + 1;
            } else {
              tmp___2 = (zend_literal *)((void *)0);
            }
            tmp___3 = zend_std_get_static_method(ce, (char const   *)function_name_strval, function_name_strlen, (struct _zend_literal  const  *)tmp___2);
            execute_data->fbc = (zend_function *)tmp___3;
          }
          tmp___4 = __builtin_expect((long )((unsigned int )execute_data->fbc == (unsigned int )((void *)0)), 0L);
          if (tmp___4) {
            zend_error_noreturn(1, "Call to undefined method %s::%s()", ce->name, function_name_strval);
          } else {

          }
          if (1 << 1 == 1) {
            tmp___5 = __builtin_expect((long )(((execute_data->fbc)->common.fn_flags & 6291456U) == 0U), 1L);
            if (tmp___5) {
              if (1 << 2 == 1) {
                while (1) {
                  *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)execute_data->fbc;
                  break;
                }
              } else {
                while (1) {
                  *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
                  *((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U)) = (void *)execute_data->fbc;
                  break;
                }
              }
            } else {

            }
          } else {

          }
        } else {

        }
        if (1 << 1 != 1) {
          _zval_dtor(free_op2.var);
        } else {

        }
      } else {
        tmp___6 = __builtin_expect((long )((unsigned int )ce->constructor == (unsigned int )((void *)0)), 0L);
        if (tmp___6) {
          zend_error_noreturn(1, "Cannot call constructor");
        } else {

        }
        if (executor_globals.This) {
          tmp___7 = zend_get_class_entry((zval const   *)executor_globals.This);
          if ((unsigned int )tmp___7 != (unsigned int )(ce->constructor)->common.scope) {
            if ((ce->constructor)->common.fn_flags & 1024U) {
              zend_error_noreturn(1, "Cannot call private %s::__construct()", ce->name);
            } else {

            }
          } else {

          }
        } else {

        }
        execute_data->fbc = ce->constructor;
      }
    }
  }
  if ((execute_data->fbc)->common.fn_flags & 1U) {
    execute_data->object = (zval *)((void *)0);
  } else {
    if (executor_globals.This) {
      if (((executor_globals.This)->value.obj.handlers)->get_class_entry) {
        tmp___9 = zend_get_class_entry((zval const   *)executor_globals.This);
        tmp___10 = instanceof_function((zend_class_entry const   *)tmp___9, (zend_class_entry const   *)ce);
        if (tmp___10) {

        } else {
          if ((execute_data->fbc)->common.fn_flags & 65536U) {
            zend_error(1 << 11L, "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", ((execute_data->fbc)->common.scope)->name, (execute_data->fbc)->common.function_name);
          } else {
            zend_error_noreturn(1, "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", ((execute_data->fbc)->common.scope)->name, (execute_data->fbc)->common.function_name);
          }
        }
      } else {

      }
    } else {

    }
    tmp___12 = executor_globals.This;
    execute_data->object = tmp___12;
    if (tmp___12) {
      zval_addref_p(execute_data->object);
      tmp___11 = zend_get_class_entry((zval const   *)execute_data->object);
      execute_data->called_scope = (zend_class_entry *)tmp___11;
    } else {

    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_CASE_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  if (1 << 2 == 1 << 2) {
    zval_addref_p(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr);
  } else {

  }
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  is_equal_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *expr_ptr ;
  zval **expr_ptr_ptr ;
  zval **tmp ;
  long tmp___0 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zval *new_expr ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zval *new_expr___0 ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  zend_bool tmp___6 ;
  zend_free_op free_op2 ;
  zval *offset ;
  zval *tmp___7 ;
  ulong hval ;
  long tmp___8 ;
  register char const   *tmp___9 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___10 ;

  {
  opline = execute_data->opline;
  if (1 << 2 == 1 << 2) {
    goto _L___1;
  } else {
    if (1 << 2 == 1 << 4) {
      _L___1: /* CIL Label */ 
      if (opline->extended_value) {
        tmp = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
        expr_ptr_ptr = tmp;
        if (1 << 2 == 1 << 2) {
          tmp___0 = __builtin_expect((long )((unsigned int )expr_ptr_ptr == (unsigned int )((void *)0)), 0L);
          if (tmp___0) {
            zend_error_noreturn(1, "Cannot create references to/from string offsets");
          } else {

          }
        } else {

        }
        tmp___3 = zval_isref_p(*expr_ptr_ptr);
        if (tmp___3) {

        } else {
          while (1) {
            tmp___2 = zval_refcount_p(*expr_ptr_ptr);
            if (tmp___2 > 1U) {
              zval_delref_p(*expr_ptr_ptr);
              while (1) {
                tmp___1 = _emalloc(sizeof(zval_gc_info ));
                new_zv = (zval *)tmp___1;
                ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv->value = (*expr_ptr_ptr)->value;
                  new_zv->type = (*expr_ptr_ptr)->type;
                  break;
                }
                zval_set_refcount_p(new_zv, 1U);
                zval_unset_isref_p(new_zv);
                break;
              }
              *expr_ptr_ptr = new_zv;
              _zval_copy_ctor(new_zv);
            } else {

            }
            break;
          }
          zval_set_isref_p(*expr_ptr_ptr);
        }
        expr_ptr = *expr_ptr_ptr;
        zval_addref_p(expr_ptr);
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      expr_ptr = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
      if (1 << 2 == 1) {
        goto _L;
      } else {
        tmp___6 = zval_isref_p(expr_ptr);
        if (tmp___6) {
          _L: /* CIL Label */ 
          while (1) {
            tmp___5 = _emalloc(sizeof(zval_gc_info ));
            new_expr___0 = (zval *)tmp___5;
            ((zval_gc_info *)new_expr___0)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_expr___0->value = expr_ptr->value;
              new_expr___0->type = expr_ptr->type;
              break;
            }
            zval_set_refcount_p(new_expr___0, 1U);
            zval_unset_isref_p(new_expr___0);
            break;
          }
          expr_ptr = new_expr___0;
          _zval_copy_ctor(expr_ptr);
        } else {
          zval_addref_p(expr_ptr);
        }
      }
    }
  }
  if (1 << 1 != 1 << 3) {
    tmp___7 = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    offset = tmp___7;
    switch ((int )offset->type) {
    case 2: 
    tmp___8 = zend_dval_to_lval(offset->value.dval);
    hval = (unsigned long )tmp___8;
    goto num_index;
    case 1: 
    case 3: 
    hval = (unsigned long )offset->value.lval;
    num_index: 
    _zend_hash_index_update_or_next_insert(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, hval, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    case 6: 
    if (1 << 1 == 1) {
      hval = ((zend_literal *)offset)->hash_value;
    } else {
      while (1) {
        tmp___9 = (char const   *)offset->value.str.val;
        if ((int const   )*tmp___9 == 45) {
          tmp___9 ++;
        } else {

        }
        if ((int const   )*tmp___9 >= 48) {
          if ((int const   )*tmp___9 <= 57) {
            end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
            if ((int const   )*end != 0) {
              break;
            } else {
              if ((int const   )*tmp___9 == 48) {
                if (offset->value.str.len + 1 > 2) {
                  break;
                } else {
                  goto _L___2;
                }
              } else {
                _L___2: /* CIL Label */ 
                if (end - tmp___9 > 10) {
                  break;
                } else {
                  if (end - tmp___9 == 10) {
                    if ((int const   )*tmp___9 > 50) {
                      break;
                    } else {

                    }
                  } else {

                  }
                }
              }
            }
            hval = (unsigned long )((int const   )*tmp___9 - 48);
            while (1) {
              tmp___9 ++;
              if ((unsigned int )tmp___9 != (unsigned int )end) {
                if ((int const   )*tmp___9 >= 48) {
                  if ((int const   )*tmp___9 <= 57) {

                  } else {
                    break;
                  }
                } else {
                  break;
                }
              } else {
                break;
              }
              hval = hval * 10UL + (ulong )((int const   )*tmp___9 - 48);
            }
            if ((unsigned int )tmp___9 == (unsigned int )end) {
              if ((int )*(offset->value.str.val) == 45) {
                if (hval - 1UL > 2147483647UL) {
                  break;
                } else {

                }
                hval = (unsigned long )(- ((long )hval));
              } else {
                if (hval > 2147483647UL) {
                  break;
                } else {

                }
              }
              goto num_index;
            } else {

            }
          } else {

          }
        } else {

        }
        break;
      }
      if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
        if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
          hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
        } else {
          tmp___10 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___10;
        }
      } else {
        tmp___10 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
        hval = (unsigned long )tmp___10;
      }
    }
    _zend_hash_quick_add_or_update(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    case 0: 
    _zend_hash_add_or_update(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, "", sizeof(""), (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    default: 
    zend_error(1 << 1L, "Illegal offset type");
    i_zval_ptr_dtor(expr_ptr);
    break;
    }
    _zval_dtor(free_op2.var);
  } else {
    _zend_hash_index_update_or_next_insert(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, 0UL, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1 << 2);
  }
  if (1 << 2 == 1 << 2) {
    goto _L___4;
  } else {
    if (1 << 2 == 1 << 4) {
      _L___4: /* CIL Label */ 
      if (opline->extended_value) {
        if (free_op1.var) {
          i_zval_ptr_dtor(free_op1.var);
        } else {

        }
      } else {
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ 
      if (free_op1.var) {
        i_zval_ptr_dtor(free_op1.var);
      } else {

      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_ARRAY_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  int tmp ;

  {
  opline = execute_data->opline;
  _array_init(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, 0U);
  if (1 << 2 == 1 << 3) {
    (execute_data->opline) ++;
    return (0);
  } else {
    tmp = ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_TMP_HANDLER(execute_data);
    return (tmp);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_UNSET_DIM_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval **container ;
  zval *offset ;
  ulong hval ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  HashTable *ht ;
  long tmp___2 ;
  register char const   *tmp___3 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___4 ;
  long tmp___5 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 4) {
    if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
      tmp___1 = zval_isref_p(*container);
      if (tmp___1) {

      } else {
        while (1) {
          tmp___0 = zval_refcount_p(*container);
          if (tmp___0 > 1U) {
            zval_delref_p(*container);
            while (1) {
              tmp = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*container)->value;
                new_zv->type = (*container)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *container = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
    } else {

    }
  } else {

  }
  offset = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if (1 << 2 != 1 << 2) {
    goto _L___0;
  } else {
    if (container) {
      _L___0: /* CIL Label */ 
      switch ((int )(*container)->type) {
      case 4: 
      ht = (*container)->value.ht;
      switch ((int )offset->type) {
      case 2: 
      tmp___2 = zend_dval_to_lval(offset->value.dval);
      hval = (unsigned long )tmp___2;
      goto num_index_dim;
      case 7: 
      case 3: 
      case 1: 
      hval = (unsigned long )offset->value.lval;
      zend_hash_del_key_or_index(ht, (char const   *)((void *)0), 0U, hval, 1);
      break;
      case 6: 
      if (1 << 1 == 1 << 4) {
        zval_addref_p(offset);
      } else {
        if (1 << 1 == 1 << 2) {
          zval_addref_p(offset);
        } else {

        }
      }
      if (1 << 1 == 1) {
        hval = ((zend_literal *)offset)->hash_value;
      } else {
        while (1) {
          tmp___3 = (char const   *)offset->value.str.val;
          if ((int const   )*tmp___3 == 45) {
            tmp___3 ++;
          } else {

          }
          if ((int const   )*tmp___3 >= 48) {
            if ((int const   )*tmp___3 <= 57) {
              end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
              if ((int const   )*end != 0) {
                break;
              } else {
                if ((int const   )*tmp___3 == 48) {
                  if (offset->value.str.len + 1 > 2) {
                    break;
                  } else {
                    goto _L;
                  }
                } else {
                  _L: /* CIL Label */ 
                  if (end - tmp___3 > 10) {
                    break;
                  } else {
                    if (end - tmp___3 == 10) {
                      if ((int const   )*tmp___3 > 50) {
                        break;
                      } else {

                      }
                    } else {

                    }
                  }
                }
              }
              hval = (unsigned long )((int const   )*tmp___3 - 48);
              while (1) {
                tmp___3 ++;
                if ((unsigned int )tmp___3 != (unsigned int )end) {
                  if ((int const   )*tmp___3 >= 48) {
                    if ((int const   )*tmp___3 <= 57) {

                    } else {
                      break;
                    }
                  } else {
                    break;
                  }
                } else {
                  break;
                }
                hval = hval * 10UL + (ulong )((int const   )*tmp___3 - 48);
              }
              if ((unsigned int )tmp___3 == (unsigned int )end) {
                if ((int )*(offset->value.str.val) == 45) {
                  if (hval - 1UL > 2147483647UL) {
                    break;
                  } else {

                  }
                  hval = (unsigned long )(- ((long )hval));
                } else {
                  if (hval > 2147483647UL) {
                    break;
                  } else {

                  }
                }
                goto num_index_dim;
              } else {

              }
            } else {

            }
          } else {

          }
          break;
        }
        if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
          if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
            hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
          } else {
            tmp___4 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
            hval = (unsigned long )tmp___4;
          }
        } else {
          tmp___4 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___4;
        }
      }
      if ((unsigned int )ht == (unsigned int )(& executor_globals.symbol_table)) {
        zend_delete_global_variable_ex((char const   *)offset->value.str.val, offset->value.str.len, hval);
      } else {
        zend_hash_del_key_or_index(ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, 2);
      }
      if (1 << 1 == 1 << 4) {
        i_zval_ptr_dtor(offset);
      } else {
        if (1 << 1 == 1 << 2) {
          i_zval_ptr_dtor(offset);
        } else {

        }
      }
      break;
      num_index_dim: 
      zend_hash_del_key_or_index(ht, (char const   *)((void *)0), 0U, hval, 1);
      if (1 << 1 == 1 << 4) {
        i_zval_ptr_dtor(offset);
      } else {
        if (1 << 1 == 1 << 2) {
          i_zval_ptr_dtor(offset);
        } else {

        }
      }
      break;
      case 0: 
      zend_hash_del_key_or_index(ht, "", sizeof(""), 0UL, 0);
      break;
      default: 
      zend_error(1 << 1L, "Illegal offset type in unset");
      break;
      }
      _zval_dtor(free_op2.var);
      break;
      case 5: 
      tmp___5 = __builtin_expect((long )((unsigned int )((*container)->value.obj.handlers)->unset_dimension == (unsigned int )((void *)0)), 0L);
      if (tmp___5) {
        zend_error_noreturn(1, "Cannot use object as array");
      } else {

      }
      while (1) {
        while (1) {
          tmp___6 = _emalloc(sizeof(zval_gc_info ));
          _tmp = (zval *)tmp___6;
          ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            _tmp->value = offset->value;
            _tmp->type = offset->type;
            break;
          }
          zval_set_refcount_p(_tmp, 1U);
          zval_unset_isref_p(_tmp);
          break;
        }
        offset = _tmp;
        break;
      }
      (*(((*container)->value.obj.handlers)->unset_dimension))(*container, offset);
      i_zval_ptr_dtor(offset);
      break;
      case 6: 
      zend_error_noreturn(1, "Cannot unset string offsets");
      return (0);
      default: 
      _zval_dtor(free_op2.var);
      break;
      }
    } else {
      _zval_dtor(free_op2.var);
    }
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_UNSET_OBJ_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval **container ;
  zval *offset ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_literal *tmp___3 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  offset = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if (1 << 2 != 1 << 2) {
    goto _L;
  } else {
    if (container) {
      _L: /* CIL Label */ 
      if (1 << 2 == 1 << 4) {
        if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
          tmp___1 = zval_isref_p(*container);
          if (tmp___1) {

          } else {
            while (1) {
              tmp___0 = zval_refcount_p(*container);
              if (tmp___0 > 1U) {
                zval_delref_p(*container);
                while (1) {
                  tmp = _emalloc(sizeof(zval_gc_info ));
                  new_zv = (zval *)tmp;
                  ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                  break;
                }
                while (1) {
                  while (1) {
                    new_zv->value = (*container)->value;
                    new_zv->type = (*container)->type;
                    break;
                  }
                  zval_set_refcount_p(new_zv, 1U);
                  zval_unset_isref_p(new_zv);
                  break;
                }
                *container = new_zv;
                _zval_copy_ctor(new_zv);
              } else {

              }
              break;
            }
          }
        } else {

        }
      } else {

      }
      if ((int )(*container)->type == 5) {
        while (1) {
          while (1) {
            tmp___2 = _emalloc(sizeof(zval_gc_info ));
            _tmp = (zval *)tmp___2;
            ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              _tmp->value = offset->value;
              _tmp->type = offset->type;
              break;
            }
            zval_set_refcount_p(_tmp, 1U);
            zval_unset_isref_p(_tmp);
            break;
          }
          offset = _tmp;
          break;
        }
        if (((*container)->value.obj.handlers)->unset_property) {
          if (1 << 1 == 1) {
            tmp___3 = opline->op2.literal;
          } else {
            tmp___3 = (zend_literal *)((void *)0);
          }
          (*(((*container)->value.obj.handlers)->unset_property))(*container, offset, (struct _zend_literal  const  *)tmp___3);
        } else {
          zend_error(1 << 3L, "Trying to unset property of non-object");
        }
        i_zval_ptr_dtor(offset);
      } else {
        _zval_dtor(free_op2.var);
      }
    } else {
      _zval_dtor(free_op2.var);
    }
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_TMP)(int prop_dim , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval **container ;
  zval **value ;
  int result ;
  ulong hval ;
  zval *offset ;
  HashTable *ht ;
  int isset ;
  long tmp ;
  int __attribute__((__visibility__("default")))  tmp___0 ;
  register char const   *tmp___1 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___2 ;
  int __attribute__((__visibility__("default")))  tmp___3 ;
  int __attribute__((__visibility__("default")))  tmp___4 ;
  int tmp___5 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;
  zend_literal *tmp___7 ;
  zval tmp___8 ;

  {
  opline = execute_data->opline;
  value = (zval **)((void *)0);
  result = 0;
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  offset = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if ((int )(*container)->type == 4) {
    if (! prop_dim) {
      isset = 0;
      ht = (*container)->value.ht;
      switch ((int )offset->type) {
      case 2: 
      tmp = zend_dval_to_lval(offset->value.dval);
      hval = (unsigned long )tmp;
      goto num_index_prop;
      case 7: 
      case 3: 
      case 1: 
      hval = (unsigned long )offset->value.lval;
      num_index_prop: 
      tmp___0 = zend_hash_index_find((HashTable const   *)ht, hval, (void **)(& value));
      if (tmp___0 == (int __attribute__((__visibility__("default")))  )0) {
        isset = 1;
      } else {

      }
      break;
      case 6: 
      if (1 << 1 == 1) {
        hval = ((zend_literal *)offset)->hash_value;
      } else {
        if (! prop_dim) {
          while (1) {
            tmp___1 = (char const   *)offset->value.str.val;
            if ((int const   )*tmp___1 == 45) {
              tmp___1 ++;
            } else {

            }
            if ((int const   )*tmp___1 >= 48) {
              if ((int const   )*tmp___1 <= 57) {
                end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
                if ((int const   )*end != 0) {
                  break;
                } else {
                  if ((int const   )*tmp___1 == 48) {
                    if (offset->value.str.len + 1 > 2) {
                      break;
                    } else {
                      goto _L;
                    }
                  } else {
                    _L: /* CIL Label */ 
                    if (end - tmp___1 > 10) {
                      break;
                    } else {
                      if (end - tmp___1 == 10) {
                        if ((int const   )*tmp___1 > 50) {
                          break;
                        } else {

                        }
                      } else {

                      }
                    }
                  }
                }
                hval = (unsigned long )((int const   )*tmp___1 - 48);
                while (1) {
                  tmp___1 ++;
                  if ((unsigned int )tmp___1 != (unsigned int )end) {
                    if ((int const   )*tmp___1 >= 48) {
                      if ((int const   )*tmp___1 <= 57) {

                      } else {
                        break;
                      }
                    } else {
                      break;
                    }
                  } else {
                    break;
                  }
                  hval = hval * 10UL + (ulong )((int const   )*tmp___1 - 48);
                }
                if ((unsigned int )tmp___1 == (unsigned int )end) {
                  if ((int )*(offset->value.str.val) == 45) {
                    if (hval - 1UL > 2147483647UL) {
                      break;
                    } else {

                    }
                    hval = (unsigned long )(- ((long )hval));
                  } else {
                    if (hval > 2147483647UL) {
                      break;
                    } else {

                    }
                  }
                  goto num_index_prop;
                } else {

                }
              } else {

              }
            } else {

            }
            break;
          }
        } else {

        }
        if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
          if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
            hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
          } else {
            tmp___2 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
            hval = (unsigned long )tmp___2;
          }
        } else {
          tmp___2 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___2;
        }
      }
      tmp___3 = zend_hash_quick_find((HashTable const   *)ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, (void **)(& value));
      if (tmp___3 == (int __attribute__((__visibility__("default")))  )0) {
        isset = 1;
      } else {

      }
      break;
      case 0: 
      tmp___4 = zend_hash_find((HashTable const   *)ht, "", sizeof(""), (void **)(& value));
      if (tmp___4 == (int __attribute__((__visibility__("default")))  )0) {
        isset = 1;
      } else {

      }
      break;
      default: 
      zend_error(1 << 1L, "Illegal offset type in isset or empty");
      break;
      }
      if (opline->extended_value & 33554432UL) {
        if (isset) {
          if ((int )(*value)->type == 0) {
            result = 0;
          } else {
            result = isset;
          }
        } else {
          result = isset;
        }
      } else {
        if (! isset) {
          result = 0;
        } else {
          tmp___5 = i_zend_is_true(*value);
          if (tmp___5) {
            result = 1;
          } else {
            result = 0;
          }
        }
      }
      _zval_dtor(free_op2.var);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if ((int )(*container)->type == 5) {
      while (1) {
        while (1) {
          tmp___6 = _emalloc(sizeof(zval_gc_info ));
          _tmp = (zval *)tmp___6;
          ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            _tmp->value = offset->value;
            _tmp->type = offset->type;
            break;
          }
          zval_set_refcount_p(_tmp, 1U);
          zval_unset_isref_p(_tmp);
          break;
        }
        offset = _tmp;
        break;
      }
      if (prop_dim) {
        if (((*container)->value.obj.handlers)->has_property) {
          if (1 << 1 == 1) {
            tmp___7 = opline->op2.literal;
          } else {
            tmp___7 = (zend_literal *)((void *)0);
          }
          result = (*(((*container)->value.obj.handlers)->has_property))(*container, offset, (opline->extended_value & 16777216UL) != 0UL, (struct _zend_literal  const  *)tmp___7);
        } else {
          zend_error(1 << 3L, "Trying to check property of non-object");
          result = 0;
        }
      } else {
        if (((*container)->value.obj.handlers)->has_dimension) {
          result = (*(((*container)->value.obj.handlers)->has_dimension))(*container, offset, (opline->extended_value & 16777216UL) != 0UL);
        } else {
          zend_error(1 << 3L, "Trying to check element of non-array");
          result = 0;
        }
      }
      i_zval_ptr_dtor(offset);
    } else {
      if ((int )(*container)->type == 6) {
        if (! prop_dim) {
          if ((int )offset->type != 1) {
            while (1) {
              tmp___8.value = offset->value;
              tmp___8.type = offset->type;
              break;
            }
            _zval_copy_ctor(& tmp___8);
            convert_to_long(& tmp___8);
            offset = & tmp___8;
          } else {

          }
          if ((int )offset->type == 1) {
            if (opline->extended_value & 33554432UL) {
              if (offset->value.lval >= 0L) {
                if (offset->value.lval < (long )(*container)->value.str.len) {
                  result = 1;
                } else {

                }
              } else {

              }
            } else {
              if (offset->value.lval >= 0L) {
                if (offset->value.lval < (long )(*container)->value.str.len) {
                  if ((int )*((*container)->value.str.val + offset->value.lval) != 48) {
                    result = 1;
                  } else {

                  }
                } else {

                }
              } else {

              }
            }
          } else {

          }
          _zval_dtor(free_op2.var);
        } else {
          _zval_dtor(free_op2.var);
        }
      } else {
        _zval_dtor(free_op2.var);
      }
    }
  }
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.type = (unsigned char)3;
  if (opline->extended_value & 33554432UL) {
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.lval = (long )result;
  } else {
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.lval = (long )(! result);
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_TMP(0, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_VAR_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_TMP(1, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  fast_add_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SUB_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  fast_sub_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_MUL_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  fast_mul_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_DIV_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  fast_div_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_MOD_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  fast_mod_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SL_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  shift_left_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SR_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  shift_right_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_CONCAT_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  concat_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_IDENTICAL_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  is_identical_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_NOT_IDENTICAL_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *result ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  is_identical_function(result, tmp___0, tmp);
  result->value.lval = (long )(! result->value.lval);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_EQUAL_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  zval *tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    tmp___1 = fast_equal_function(result, tmp___0, tmp);
    __z->value.lval = (long )(tmp___1 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_NOT_EQUAL_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  zval *tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    tmp___1 = fast_not_equal_function(result, tmp___0, tmp);
    __z->value.lval = (long )(tmp___1 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_SMALLER_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  zval *tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    tmp___1 = fast_is_smaller_function(result, tmp___0, tmp);
    __z->value.lval = (long )(tmp___1 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_SMALLER_OR_EQUAL_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  zval *tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    tmp___1 = fast_is_smaller_or_equal_function(result, tmp___0, tmp);
    __z->value.lval = (long )(tmp___1 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_OR_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  bitwise_or_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_AND_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  bitwise_and_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_XOR_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  bitwise_xor_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BOOL_XOR_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  boolean_xor_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_binary_assign_op_obj_helper_SPEC_VAR_VAR)(int (*binary_op)(zval *result , zval *op1 , zval *op2 ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zend_free_op free_op_data1 ;
  zval **object_ptr ;
  zval **tmp ;
  zval *object ;
  zval *property ;
  zval *tmp___0 ;
  zval *value ;
  zval *tmp___1 ;
  int have_get_ptr ;
  long tmp___2 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___3 ;
  zval **zptr ;
  zend_literal *tmp___4 ;
  zval **tmp___5 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;
  zend_uint tmp___7 ;
  zend_bool tmp___8 ;
  zval *z ;
  zend_literal *tmp___9 ;
  zval *value___0 ;
  zval *tmp___10 ;
  zend_uint tmp___11 ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___12 ;
  zend_uint tmp___13 ;
  zend_bool tmp___14 ;
  zend_literal *tmp___15 ;
  long tmp___16 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  object_ptr = tmp;
  tmp___0 = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  property = tmp___0;
  tmp___1 = _get_zval_ptr((int )(opline + 1)->op1_type, (znode_op const   *)(& (opline + 1)->op1), (temp_variable const   *)execute_data->Ts, & free_op_data1, 0);
  value = tmp___1;
  have_get_ptr = 0;
  if (1 << 2 == 1 << 2) {
    tmp___2 = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___2) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  make_real_object(object_ptr);
  object = *object_ptr;
  tmp___16 = __builtin_expect((long )((int )object->type != 5), 0L);
  if (tmp___16) {
    zend_error(1 << 1L, "Attempt to assign property of non-object");
    if (free_op2.var) {
      i_zval_ptr_dtor(free_op2.var);
    } else {

    }
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = & executor_globals.uninitialized_zval;
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
    } else {

    }
  } else {
    if (opline->extended_value == 136UL) {
      if ((object->value.obj.handlers)->get_property_ptr_ptr) {
        if (1 << 2 == 1) {
          tmp___4 = opline->op2.literal;
        } else {
          tmp___4 = (zend_literal *)((void *)0);
        }
        tmp___5 = (*((object->value.obj.handlers)->get_property_ptr_ptr))(object, property, (struct _zend_literal  const  *)tmp___4);
        zptr = tmp___5;
        if ((unsigned int )zptr != (unsigned int )((void *)0)) {
          tmp___8 = zval_isref_p(*zptr);
          if (tmp___8) {

          } else {
            while (1) {
              tmp___7 = zval_refcount_p(*zptr);
              if (tmp___7 > 1U) {
                zval_delref_p(*zptr);
                while (1) {
                  tmp___6 = _emalloc(sizeof(zval_gc_info ));
                  new_zv = (zval *)tmp___6;
                  ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                  break;
                }
                while (1) {
                  while (1) {
                    new_zv->value = (*zptr)->value;
                    new_zv->type = (*zptr)->type;
                    break;
                  }
                  zval_set_refcount_p(new_zv, 1U);
                  zval_unset_isref_p(new_zv);
                  break;
                }
                *zptr = new_zv;
                _zval_copy_ctor(new_zv);
              } else {

              }
              break;
            }
          }
          have_get_ptr = 1;
          (*binary_op)(*zptr, *zptr, value);
          if (! ((int )opline->result_type & (1 << 5))) {
            zval_addref_p(*zptr);
            ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = *zptr;
            ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
          } else {

          }
        } else {

        }
      } else {

      }
    } else {

    }
    if (! have_get_ptr) {
      z = (zval *)((void *)0);
      if (opline->extended_value == 136UL) {
        if ((object->value.obj.handlers)->read_property) {
          if (1 << 2 == 1) {
            tmp___9 = opline->op2.literal;
          } else {
            tmp___9 = (zend_literal *)((void *)0);
          }
          z = (*((object->value.obj.handlers)->read_property))(object, property, 0, (struct _zend_literal  const  *)tmp___9);
        } else {

        }
      } else {
        if ((object->value.obj.handlers)->read_dimension) {
          z = (*((object->value.obj.handlers)->read_dimension))(object, property, 0);
        } else {

        }
      }
      if (z) {
        if ((int )z->type == 5) {
          if ((z->value.obj.handlers)->get) {
            tmp___10 = (*((z->value.obj.handlers)->get))(z);
            value___0 = tmp___10;
            tmp___11 = zval_refcount_p(z);
            if (tmp___11 == 0U) {
              if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                gc_remove_zval_from_buffer(z);
              } else {

              }
              _zval_dtor(z);
              while (1) {
                if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                  gc_remove_zval_from_buffer(z);
                } else {

                }
                _efree((void *)z);
                break;
              }
            } else {

            }
            z = value___0;
          } else {

          }
        } else {

        }
        zval_addref_p(z);
        tmp___14 = zval_isref_p(z);
        if (tmp___14) {

        } else {
          while (1) {
            tmp___13 = zval_refcount_p(z);
            if (tmp___13 > 1U) {
              zval_delref_p(z);
              while (1) {
                tmp___12 = _emalloc(sizeof(zval_gc_info ));
                new_zv___0 = (zval *)tmp___12;
                ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv___0->value = z->value;
                  new_zv___0->type = z->type;
                  break;
                }
                zval_set_refcount_p(new_zv___0, 1U);
                zval_unset_isref_p(new_zv___0);
                break;
              }
              z = new_zv___0;
              _zval_copy_ctor(new_zv___0);
            } else {

            }
            break;
          }
        }
        (*binary_op)(z, z, value);
        if (opline->extended_value == 136UL) {
          if (1 << 2 == 1) {
            tmp___15 = opline->op2.literal;
          } else {
            tmp___15 = (zend_literal *)((void *)0);
          }
          (*((object->value.obj.handlers)->write_property))(object, property, z, (struct _zend_literal  const  *)tmp___15);
        } else {
          (*((object->value.obj.handlers)->write_dimension))(object, property, z);
        }
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(z);
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = z;
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
        } else {

        }
        i_zval_ptr_dtor(z);
      } else {
        zend_error(1 << 1L, "Attempt to assign property of non-object");
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = & executor_globals.uninitialized_zval;
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
        } else {

        }
      }
    } else {

    }
    if (free_op2.var) {
      i_zval_ptr_dtor(free_op2.var);
    } else {

    }
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_binary_assign_op_helper_SPEC_VAR_VAR)(int (*binary_op)(zval *result , zval *op1 , zval *op2 ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zend_free_op free_op_data2 ;
  zend_free_op free_op_data1 ;
  zval **var_ptr ;
  zval *value ;
  int tmp ;
  zval **container ;
  zval **tmp___0 ;
  int tmp___1 ;
  zval *dim ;
  zval *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  temp_variable *__t ;
  long tmp___6 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___7 ;
  zend_uint tmp___8 ;
  zend_bool tmp___9 ;
  zval *objval ;
  zval *tmp___10 ;
  long tmp___11 ;
  temp_variable *__t___0 ;

  {
  opline = execute_data->opline;
  switch ((int )opline->extended_value) {
  case 136: 
  tmp = zend_binary_assign_op_obj_helper_SPEC_VAR_VAR(binary_op, execute_data);
  return (tmp);
  break;
  case 147: 
  tmp___0 = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  container = tmp___0;
  if (1 << 2 == 1 << 2) {
    tmp___4 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___4) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    tmp___3 = __builtin_expect((long )((int )(*container)->type == 5), 0L);
    if (tmp___3) {
      if (1 << 2 == 1 << 2) {
        if (! ((unsigned int )free_op1.var != (unsigned int )((void *)0))) {
          zval_addref_p(*container);
        } else {

        }
      } else {

      }
      tmp___1 = zend_binary_assign_op_obj_helper_SPEC_VAR_VAR(binary_op, execute_data);
      return (tmp___1);
    } else {
      tmp___2 = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
      dim = tmp___2;
      zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var), container, dim, 1 << 2, 2);
      value = _get_zval_ptr((int )(opline + 1)->op1_type, (znode_op const   *)(& (opline + 1)->op1), (temp_variable const   *)execute_data->Ts, & free_op_data1, 0);
      var_ptr = _get_zval_ptr_ptr_var((opline + 1)->op2.var, (temp_variable const   *)execute_data->Ts, & free_op_data2);
    }
  }
  break;
  default: 
  value = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  break;
  }
  tmp___5 = __builtin_expect((long )((unsigned int )var_ptr == (unsigned int )((void *)0)), 0L);
  if (tmp___5) {
    zend_error_noreturn(1, "Cannot use assign-op operators with overloaded objects nor string offsets");
  } else {

  }
  tmp___6 = __builtin_expect((long )((unsigned int )*var_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
  if (tmp___6) {
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      while (1) {
        __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t->var.ptr = & executor_globals.uninitialized_zval;
        __t->var.ptr_ptr = & __t->var.ptr;
        break;
      }
    } else {

    }
    if (free_op2.var) {
      i_zval_ptr_dtor(free_op2.var);
    } else {

    }
    if (free_op1.var) {
      i_zval_ptr_dtor(free_op1.var);
    } else {

    }
    if (opline->extended_value == 147UL) {
      (execute_data->opline) ++;
    } else {

    }
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  tmp___9 = zval_isref_p(*var_ptr);
  if (tmp___9) {

  } else {
    while (1) {
      tmp___8 = zval_refcount_p(*var_ptr);
      if (tmp___8 > 1U) {
        zval_delref_p(*var_ptr);
        while (1) {
          tmp___7 = _emalloc(sizeof(zval_gc_info ));
          new_zv = (zval *)tmp___7;
          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            new_zv->value = (*var_ptr)->value;
            new_zv->type = (*var_ptr)->type;
            break;
          }
          zval_set_refcount_p(new_zv, 1U);
          zval_unset_isref_p(new_zv);
          break;
        }
        *var_ptr = new_zv;
        _zval_copy_ctor(new_zv);
      } else {

      }
      break;
    }
  }
  tmp___11 = __builtin_expect((long )((int )(*var_ptr)->type == 5), 0L);
  if (tmp___11) {
    if (((*var_ptr)->value.obj.handlers)->get) {
      if (((*var_ptr)->value.obj.handlers)->set) {
        tmp___10 = (*(((*var_ptr)->value.obj.handlers)->get))(*var_ptr);
        objval = tmp___10;
        zval_addref_p(objval);
        (*binary_op)(objval, objval, value);
        (*(((*var_ptr)->value.obj.handlers)->set))(var_ptr, objval);
        i_zval_ptr_dtor(objval);
      } else {
        (*binary_op)(*var_ptr, *var_ptr, value);
      }
    } else {
      (*binary_op)(*var_ptr, *var_ptr, value);
    }
  } else {
    (*binary_op)(*var_ptr, *var_ptr, value);
  }
  if (! ((int )opline->result_type & (1 << 5))) {
    zval_addref_p(*var_ptr);
    while (1) {
      __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
      __t___0->var.ptr = *var_ptr;
      __t___0->var.ptr_ptr = & __t___0->var.ptr;
      break;
    }
  } else {

  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  if (opline->extended_value == 147UL) {
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
    if (free_op_data2.var) {
      i_zval_ptr_dtor(free_op_data2.var);
    } else {

    }
    if (free_op1.var) {
      i_zval_ptr_dtor(free_op1.var);
    } else {

    }
    (execute_data->opline) ++;
  } else {
    if (free_op1.var) {
      i_zval_ptr_dtor(free_op1.var);
    } else {

    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_ADD_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_VAR((int (*)(zval *result , zval *op1 , zval *op2 ))(& add_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SUB_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_VAR((int (*)(zval *result , zval *op1 , zval *op2 ))(& sub_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_MUL_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_VAR((int (*)(zval *result , zval *op1 , zval *op2 ))(& mul_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_DIV_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_VAR((int (*)(zval *result , zval *op1 , zval *op2 ))(& div_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_MOD_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_VAR((int (*)(zval *result , zval *op1 , zval *op2 ))(& mod_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SL_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_VAR((int (*)(zval *result , zval *op1 , zval *op2 ))(& shift_left_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SR_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_VAR((int (*)(zval *result , zval *op1 , zval *op2 ))(& shift_right_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_CONCAT_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_VAR((int (*)(zval *result , zval *op1 , zval *op2 ))(& concat_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_OR_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_VAR((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_or_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_AND_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_VAR((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_and_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_XOR_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_VAR((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_xor_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) zend_pre_incdec_property_helper_SPEC_VAR_VAR)(int (*incdec_op)(zval * ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval **object_ptr ;
  zval *object ;
  zval *property ;
  zval **retval ;
  int have_get_ptr ;
  long tmp ;
  long tmp___0 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zval **zptr ;
  zend_literal *tmp___2 ;
  zval **tmp___3 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_uint tmp___5 ;
  zend_bool tmp___6 ;
  zval *z ;
  zend_literal *tmp___7 ;
  zval *tmp___8 ;
  zval *value ;
  zval *tmp___9 ;
  zend_uint tmp___10 ;
  long tmp___11 ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___12 ;
  zend_uint tmp___13 ;
  zend_bool tmp___14 ;
  zend_literal *tmp___15 ;

  {
  opline = execute_data->opline;
  have_get_ptr = 0;
  object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  property = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  retval = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
  if (1 << 2 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot increment/decrement overloaded objects nor string offsets");
    } else {

    }
  } else {

  }
  make_real_object(object_ptr);
  object = *object_ptr;
  tmp___0 = __builtin_expect((long )((int )object->type != 5), 0L);
  if (tmp___0) {
    zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
    if (free_op2.var) {
      i_zval_ptr_dtor(free_op2.var);
    } else {

    }
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      *retval = & executor_globals.uninitialized_zval;
    } else {

    }
    if (free_op1.var) {
      i_zval_ptr_dtor(free_op1.var);
    } else {

    }
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  if ((object->value.obj.handlers)->get_property_ptr_ptr) {
    if (1 << 2 == 1) {
      tmp___2 = opline->op2.literal;
    } else {
      tmp___2 = (zend_literal *)((void *)0);
    }
    tmp___3 = (*((object->value.obj.handlers)->get_property_ptr_ptr))(object, property, (struct _zend_literal  const  *)tmp___2);
    zptr = tmp___3;
    if ((unsigned int )zptr != (unsigned int )((void *)0)) {
      tmp___6 = zval_isref_p(*zptr);
      if (tmp___6) {

      } else {
        while (1) {
          tmp___5 = zval_refcount_p(*zptr);
          if (tmp___5 > 1U) {
            zval_delref_p(*zptr);
            while (1) {
              tmp___4 = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp___4;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*zptr)->value;
                new_zv->type = (*zptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *zptr = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
      have_get_ptr = 1;
      (*incdec_op)(*zptr);
      if (! ((int )opline->result_type & (1 << 5))) {
        *retval = *zptr;
        zval_addref_p(*retval);
      } else {

      }
    } else {

    }
  } else {

  }
  if (! have_get_ptr) {
    if ((object->value.obj.handlers)->read_property) {
      if ((object->value.obj.handlers)->write_property) {
        if (1 << 2 == 1) {
          tmp___7 = opline->op2.literal;
        } else {
          tmp___7 = (zend_literal *)((void *)0);
        }
        tmp___8 = (*((object->value.obj.handlers)->read_property))(object, property, 0, (struct _zend_literal  const  *)tmp___7);
        z = tmp___8;
        tmp___11 = __builtin_expect((long )((int )z->type == 5), 0L);
        if (tmp___11) {
          if ((z->value.obj.handlers)->get) {
            tmp___9 = (*((z->value.obj.handlers)->get))(z);
            value = tmp___9;
            tmp___10 = zval_refcount_p(z);
            if (tmp___10 == 0U) {
              if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                gc_remove_zval_from_buffer(z);
              } else {

              }
              _zval_dtor(z);
              while (1) {
                if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                  gc_remove_zval_from_buffer(z);
                } else {

                }
                _efree((void *)z);
                break;
              }
            } else {

            }
            z = value;
          } else {

          }
        } else {

        }
        zval_addref_p(z);
        tmp___14 = zval_isref_p(z);
        if (tmp___14) {

        } else {
          while (1) {
            tmp___13 = zval_refcount_p(z);
            if (tmp___13 > 1U) {
              zval_delref_p(z);
              while (1) {
                tmp___12 = _emalloc(sizeof(zval_gc_info ));
                new_zv___0 = (zval *)tmp___12;
                ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv___0->value = z->value;
                  new_zv___0->type = z->type;
                  break;
                }
                zval_set_refcount_p(new_zv___0, 1U);
                zval_unset_isref_p(new_zv___0);
                break;
              }
              z = new_zv___0;
              _zval_copy_ctor(new_zv___0);
            } else {

            }
            break;
          }
        }
        (*incdec_op)(z);
        *retval = z;
        if (1 << 2 == 1) {
          tmp___15 = opline->op2.literal;
        } else {
          tmp___15 = (zend_literal *)((void *)0);
        }
        (*((object->value.obj.handlers)->write_property))(object, property, z, (struct _zend_literal  const  *)tmp___15);
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(*retval);
        } else {

        }
        i_zval_ptr_dtor(z);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
      if (! ((int )opline->result_type & (1 << 5))) {
        zval_addref_p(& executor_globals.uninitialized_zval);
        *retval = & executor_globals.uninitialized_zval;
      } else {

      }
    }
  } else {

  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_PRE_INC_OBJ_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_pre_incdec_property_helper_SPEC_VAR_VAR((int (*)(zval * ))(& increment_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_PRE_DEC_OBJ_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_pre_incdec_property_helper_SPEC_VAR_VAR((int (*)(zval * ))(& decrement_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) zend_post_incdec_property_helper_SPEC_VAR_VAR)(int (*incdec_op)(zval * ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval **object_ptr ;
  zval *object ;
  zval *property ;
  zval *retval ;
  int have_get_ptr ;
  long tmp ;
  long tmp___0 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zval **zptr ;
  zend_literal *tmp___2 ;
  zval **tmp___3 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_uint tmp___5 ;
  zend_bool tmp___6 ;
  zval *z ;
  zend_literal *tmp___7 ;
  zval *tmp___8 ;
  zval *z_copy ;
  zval *value ;
  zval *tmp___9 ;
  zend_uint tmp___10 ;
  long tmp___11 ;
  void __attribute__((__visibility__("default")))  *tmp___12 ;
  zend_literal *tmp___13 ;

  {
  opline = execute_data->opline;
  have_get_ptr = 0;
  object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  property = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  retval = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  if (1 << 2 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot increment/decrement overloaded objects nor string offsets");
    } else {

    }
  } else {

  }
  make_real_object(object_ptr);
  object = *object_ptr;
  tmp___0 = __builtin_expect((long )((int )object->type != 5), 0L);
  if (tmp___0) {
    zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
    if (free_op2.var) {
      i_zval_ptr_dtor(free_op2.var);
    } else {

    }
    retval->type = (unsigned char)0;
    if (free_op1.var) {
      i_zval_ptr_dtor(free_op1.var);
    } else {

    }
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  if ((object->value.obj.handlers)->get_property_ptr_ptr) {
    if (1 << 2 == 1) {
      tmp___2 = opline->op2.literal;
    } else {
      tmp___2 = (zend_literal *)((void *)0);
    }
    tmp___3 = (*((object->value.obj.handlers)->get_property_ptr_ptr))(object, property, (struct _zend_literal  const  *)tmp___2);
    zptr = tmp___3;
    if ((unsigned int )zptr != (unsigned int )((void *)0)) {
      have_get_ptr = 1;
      tmp___6 = zval_isref_p(*zptr);
      if (tmp___6) {

      } else {
        while (1) {
          tmp___5 = zval_refcount_p(*zptr);
          if (tmp___5 > 1U) {
            zval_delref_p(*zptr);
            while (1) {
              tmp___4 = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp___4;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*zptr)->value;
                new_zv->type = (*zptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *zptr = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
      while (1) {
        retval->value = (*zptr)->value;
        retval->type = (*zptr)->type;
        break;
      }
      _zval_copy_ctor(retval);
      (*incdec_op)(*zptr);
    } else {

    }
  } else {

  }
  if (! have_get_ptr) {
    if ((object->value.obj.handlers)->read_property) {
      if ((object->value.obj.handlers)->write_property) {
        if (1 << 2 == 1) {
          tmp___7 = opline->op2.literal;
        } else {
          tmp___7 = (zend_literal *)((void *)0);
        }
        tmp___8 = (*((object->value.obj.handlers)->read_property))(object, property, 0, (struct _zend_literal  const  *)tmp___7);
        z = tmp___8;
        tmp___11 = __builtin_expect((long )((int )z->type == 5), 0L);
        if (tmp___11) {
          if ((z->value.obj.handlers)->get) {
            tmp___9 = (*((z->value.obj.handlers)->get))(z);
            value = tmp___9;
            tmp___10 = zval_refcount_p(z);
            if (tmp___10 == 0U) {
              if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                gc_remove_zval_from_buffer(z);
              } else {

              }
              _zval_dtor(z);
              while (1) {
                if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                  gc_remove_zval_from_buffer(z);
                } else {

                }
                _efree((void *)z);
                break;
              }
            } else {

            }
            z = value;
          } else {

          }
        } else {

        }
        while (1) {
          retval->value = z->value;
          retval->type = z->type;
          break;
        }
        _zval_copy_ctor(retval);
        while (1) {
          tmp___12 = _emalloc(sizeof(zval_gc_info ));
          z_copy = (zval *)tmp___12;
          ((zval_gc_info *)z_copy)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            z_copy->value = z->value;
            z_copy->type = z->type;
            break;
          }
          zval_set_refcount_p(z_copy, 1U);
          zval_unset_isref_p(z_copy);
          break;
        }
        _zval_copy_ctor(z_copy);
        (*incdec_op)(z_copy);
        zval_addref_p(z);
        if (1 << 2 == 1) {
          tmp___13 = opline->op2.literal;
        } else {
          tmp___13 = (zend_literal *)((void *)0);
        }
        (*((object->value.obj.handlers)->write_property))(object, property, z_copy, (struct _zend_literal  const  *)tmp___13);
        i_zval_ptr_dtor(z_copy);
        i_zval_ptr_dtor(z);
      } else {
        zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
        retval->type = (unsigned char)0;
      }
    } else {
      zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
      retval->type = (unsigned char)0;
    }
  } else {

  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_POST_INC_OBJ_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_post_incdec_property_helper_SPEC_VAR_VAR((int (*)(zval * ))(& increment_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_POST_DEC_OBJ_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_post_incdec_property_helper_SPEC_VAR_VAR((int (*)(zval * ))(& decrement_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) zend_fetch_var_address_helper_SPEC_VAR_VAR)(int type , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *varname ;
  zval **retval ;
  zval tmp_varname ;
  HashTable *target_symbol_table ;
  ulong hash_value ;
  long tmp ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_literal *tmp___1 ;
  zval __attribute__((__visibility__("default")))  **tmp___2 ;
  ulong __attribute__((__visibility__("default")))  tmp___3 ;
  int __attribute__((__visibility__("default")))  tmp___4 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  zend_uint tmp___6 ;
  zend_bool tmp___7 ;
  temp_variable *__t ;
  zend_free_op free_res ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___8 ;
  zend_uint tmp___9 ;
  zend_bool tmp___10 ;

  {
  opline = execute_data->opline;
  varname = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 != 1) {
    tmp = __builtin_expect((long )((int )varname->type != 6), 0L);
    if (tmp) {
      while (1) {
        tmp_varname.value = varname->value;
        tmp_varname.type = varname->type;
        break;
      }
      _zval_copy_ctor(& tmp_varname);
      zval_set_refcount_p(& tmp_varname, 1U);
      zval_unset_isref_p(& tmp_varname);
      if ((int )tmp_varname.type != 6) {
        _convert_to_string(& tmp_varname);
      } else {

      }
      varname = & tmp_varname;
    } else {

    }
  } else {

  }
  if (1 << 2 != 1 << 3) {
    if (1 << 2 == 1) {
      if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
        ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
      } else {
        tmp___0 = zend_fetch_class_by_name((char const   *)(opline->op2.zv)->value.str.val, (unsigned int )(opline->op2.zv)->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), 0);
        ce = (zend_class_entry *)tmp___0;
        while (1) {
          *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
          break;
        }
      }
    } else {
      ce = ((temp_variable *)((char *)execute_data->Ts + opline->op2.var))->class_entry;
    }
    if (1 << 2 == 1) {
      tmp___1 = opline->op1.literal;
    } else {
      tmp___1 = (zend_literal *)((void *)0);
    }
    tmp___2 = zend_std_get_static_property(ce, (char const   *)varname->value.str.val, varname->value.str.len, (unsigned char)0, (struct _zend_literal  const  *)tmp___1);
    retval = (zval **)tmp___2;
    if (free_op1.var) {
      i_zval_ptr_dtor(free_op1.var);
    } else {

    }
  } else {
    target_symbol_table = zend_get_target_symbol_table((int )(opline->extended_value & 1879048192UL));
    if (1 << 2 == 1) {
      hash_value = ((zend_literal *)varname)->hash_value;
    } else {
      if ((unsigned int )varname->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
        if ((unsigned int )varname->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
          hash_value = ((Bucket *)(varname->value.str.val - sizeof(Bucket )))->h;
        } else {
          tmp___3 = zend_hash_func((char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1));
          hash_value = (unsigned long )tmp___3;
        }
      } else {
        tmp___3 = zend_hash_func((char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1));
        hash_value = (unsigned long )tmp___3;
      }
    }
    tmp___4 = zend_hash_quick_find((HashTable const   *)target_symbol_table, (char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1), hash_value, (void **)(& retval));
    if (tmp___4 == (int __attribute__((__visibility__("default")))  )-1) {
      switch (type) {
      case 0: 
      case 6: 
      zend_error(1 << 3L, "Undefined variable: %s", varname->value.str.val);
      case 3: 
      retval = & executor_globals.uninitialized_zval_ptr;
      break;
      case 2: 
      zend_error(1 << 3L, "Undefined variable: %s", varname->value.str.val);
      case 1: 
      zval_addref_p(& executor_globals.uninitialized_zval);
      _zend_hash_quick_add_or_update(target_symbol_table, (char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1), hash_value, (void *)(& executor_globals.uninitialized_zval_ptr), sizeof(zval *), (void **)(& retval), 1);
      break;
      }
    } else {

    }
    switch ((int )(opline->extended_value & 1879048192UL)) {
    case 0x00000000: 
    if (1 << 2 != 1 << 1) {
      if (free_op1.var) {
        i_zval_ptr_dtor(free_op1.var);
      } else {

      }
    } else {

    }
    break;
    case 0x10000000: 
    if (free_op1.var) {
      i_zval_ptr_dtor(free_op1.var);
    } else {

    }
    break;
    case 0x20000000: 
    zval_update_constant(retval, (void *)1);
    break;
    case 0x40000000: 
    if (1 << 2 == 1 << 2) {
      if (! free_op1.var) {
        zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr));
      } else {

      }
    } else {

    }
    break;
    }
  }
  if (1 << 2 != 1) {
    if ((unsigned int )varname == (unsigned int )(& tmp_varname)) {
      _zval_dtor(& tmp_varname);
    } else {

    }
  } else {

  }
  if (opline->extended_value & 67108864UL) {
    tmp___7 = zval_isref_p(*retval);
    if (tmp___7) {

    } else {
      while (1) {
        tmp___6 = zval_refcount_p(*retval);
        if (tmp___6 > 1U) {
          zval_delref_p(*retval);
          while (1) {
            tmp___5 = _emalloc(sizeof(zval_gc_info ));
            new_zv = (zval *)tmp___5;
            ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv->value = (*retval)->value;
              new_zv->type = (*retval)->type;
              break;
            }
            zval_set_refcount_p(new_zv, 1U);
            zval_unset_isref_p(new_zv);
            break;
          }
          *retval = new_zv;
          _zval_copy_ctor(new_zv);
        } else {

        }
        break;
      }
      zval_set_isref_p(*retval);
    }
  } else {

  }
  zval_addref_p(*retval);
  switch (type) {
  case 0: 
  case 3: 
  while (1) {
    __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
    __t->var.ptr = *retval;
    __t->var.ptr_ptr = & __t->var.ptr;
    break;
  }
  break;
  case 6: 
  zend_pzval_unlock_func(*retval, & free_res, 1);
  if ((unsigned int )retval != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
    tmp___10 = zval_isref_p(*retval);
    if (tmp___10) {

    } else {
      while (1) {
        tmp___9 = zval_refcount_p(*retval);
        if (tmp___9 > 1U) {
          zval_delref_p(*retval);
          while (1) {
            tmp___8 = _emalloc(sizeof(zval_gc_info ));
            new_zv___0 = (zval *)tmp___8;
            ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv___0->value = (*retval)->value;
              new_zv___0->type = (*retval)->type;
              break;
            }
            zval_set_refcount_p(new_zv___0, 1U);
            zval_unset_isref_p(new_zv___0);
            break;
          }
          *retval = new_zv___0;
          _zval_copy_ctor(new_zv___0);
        } else {

        }
        break;
      }
    }
  } else {

  }
  zval_addref_p(*retval);
  if (free_res.var) {
    i_zval_ptr_dtor(free_res.var);
  } else {

  }
  default: 
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = retval;
  break;
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_R_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_VAR_VAR(0, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_W_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_VAR_VAR(1, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_RW_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_VAR_VAR(2, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_FUNC_ARG_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  unsigned int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
  opline = execute_data->opline;
  if (execute_data->fbc) {
    if ((execute_data->fbc)->common.arg_info) {
      if ((opline->extended_value & 1048575UL) <= (unsigned long )(execute_data->fbc)->common.num_args) {
        tmp___1 = (unsigned int )((int )((execute_data->fbc)->common.arg_info + ((opline->extended_value & 1048575UL) - 1UL))->pass_by_reference & 3);
      } else {
        tmp___1 = (execute_data->fbc)->common.fn_flags & 50331648U;
      }
    } else {
      tmp___1 = (execute_data->fbc)->common.fn_flags & 50331648U;
    }
    if (tmp___1) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___2 = zend_fetch_var_address_helper_SPEC_VAR_VAR(tmp___0, execute_data);
  return (tmp___2);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_UNSET_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_VAR_VAR(6, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_IS_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_VAR_VAR(3, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_R_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval **container ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  if (opline->extended_value & 134217728UL) {
    if (1 << 2 != 1 << 4) {
      if (((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr) {
        zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr));
      } else {

      }
    } else {

    }
  } else {

  }
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  zend_fetch_dimension_address_read((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, tmp, 1 << 2, 0);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_W_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval **container ;
  long tmp ;
  zval *tmp___0 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zend_uint tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___6 ;
  zval **retval_ptr ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___7 ;
  zend_uint tmp___8 ;
  zend_bool tmp___9 ;
  long tmp___10 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  tmp___0 = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, tmp___0, 1 << 2, 1);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  if (1 << 2 == 1 << 2) {
    if ((unsigned int )free_op1.var != (unsigned int )((void *)0)) {
      tmp___5 = zval_refcount_p(free_op1.var);
      if (tmp___5 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___6 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___6 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___3 = zval_isref_p(__t->var.ptr);
                if (tmp___3) {

                } else {
                  tmp___4 = zval_refcount_p(__t->var.ptr);
                  if (tmp___4 > 2U) {
                    while (1) {
                      tmp___2 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___2 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___1 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___1;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  tmp___10 = __builtin_expect((long )(opline->extended_value != 0UL), 0L);
  if (tmp___10) {
    retval_ptr = ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr;
    if (retval_ptr) {
      zval_delref_p(*retval_ptr);
      tmp___9 = zval_isref_p(*retval_ptr);
      if (tmp___9) {

      } else {
        while (1) {
          tmp___8 = zval_refcount_p(*retval_ptr);
          if (tmp___8 > 1U) {
            zval_delref_p(*retval_ptr);
            while (1) {
              tmp___7 = _emalloc(sizeof(zval_gc_info ));
              new_zv___0 = (zval *)tmp___7;
              ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv___0->value = (*retval_ptr)->value;
                new_zv___0->type = (*retval_ptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv___0, 1U);
              zval_unset_isref_p(new_zv___0);
              break;
            }
            *retval_ptr = new_zv___0;
            _zval_copy_ctor(new_zv___0);
          } else {

          }
          break;
        }
        zval_set_isref_p(*retval_ptr);
      }
      zval_addref_p(*retval_ptr);
    } else {

    }
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_RW_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval **container ;
  long tmp ;
  zval *tmp___0 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zend_uint tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___6 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  tmp___0 = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, tmp___0, 1 << 2, 2);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  if (1 << 2 == 1 << 2) {
    if ((unsigned int )free_op1.var != (unsigned int )((void *)0)) {
      tmp___5 = zval_refcount_p(free_op1.var);
      if (tmp___5 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___6 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___6 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___3 = zval_isref_p(__t->var.ptr);
                if (tmp___3) {

                } else {
                  tmp___4 = zval_refcount_p(__t->var.ptr);
                  if (tmp___4 > 2U) {
                    while (1) {
                      tmp___2 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___2 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___1 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___1;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_IS_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval **container ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  zend_fetch_dimension_address_read((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, tmp, 1 << 2, 3);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval **container ;
  long tmp ;
  zval *tmp___0 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zend_uint tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___6 ;
  zval *tmp___7 ;
  unsigned int tmp___8 ;

  {
  opline = execute_data->opline;
  if (execute_data->fbc) {
    if ((execute_data->fbc)->common.arg_info) {
      if ((opline->extended_value & 1048575UL) <= (unsigned long )(execute_data->fbc)->common.num_args) {
        tmp___8 = (unsigned int )((int )((execute_data->fbc)->common.arg_info + ((opline->extended_value & 1048575UL) - 1UL))->pass_by_reference & 3);
      } else {
        tmp___8 = (execute_data->fbc)->common.fn_flags & 50331648U;
      }
    } else {
      tmp___8 = (execute_data->fbc)->common.fn_flags & 50331648U;
    }
    if (tmp___8) {
      container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
      if (1 << 2 == 1 << 2) {
        tmp = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
        if (tmp) {
          zend_error_noreturn(1, "Cannot use string offset as an array");
        } else {

        }
      } else {

      }
      tmp___0 = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
      zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, tmp___0, 1 << 2, 1);
      if (1 << 2 == 1 << 2) {
        if ((unsigned int )free_op1.var != (unsigned int )((void *)0)) {
          tmp___5 = zval_refcount_p(free_op1.var);
          if (tmp___5 == 1U) {
            if ((int )(free_op1.var)->type != 5) {
              goto _L;
            } else {
              tmp___6 = zend_objects_store_get_refcount(free_op1.var);
              if (tmp___6 == (zend_uint __attribute__((__visibility__("default")))  )1) {
                _L: /* CIL Label */ 
                while (1) {
                  __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
                  if (__t->var.ptr_ptr) {
                    __t->var.ptr = *(__t->var.ptr_ptr);
                    __t->var.ptr_ptr = & __t->var.ptr;
                    tmp___3 = zval_isref_p(__t->var.ptr);
                    if (tmp___3) {

                    } else {
                      tmp___4 = zval_refcount_p(__t->var.ptr);
                      if (tmp___4 > 2U) {
                        while (1) {
                          tmp___2 = zval_refcount_p(*(__t->var.ptr_ptr));
                          if (tmp___2 > 1U) {
                            zval_delref_p(*(__t->var.ptr_ptr));
                            while (1) {
                              tmp___1 = _emalloc(sizeof(zval_gc_info ));
                              new_zv = (zval *)tmp___1;
                              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                              break;
                            }
                            while (1) {
                              while (1) {
                                new_zv->value = (*(__t->var.ptr_ptr))->value;
                                new_zv->type = (*(__t->var.ptr_ptr))->type;
                                break;
                              }
                              zval_set_refcount_p(new_zv, 1U);
                              zval_unset_isref_p(new_zv);
                              break;
                            }
                            *(__t->var.ptr_ptr) = new_zv;
                            _zval_copy_ctor(new_zv);
                          } else {

                          }
                          break;
                        }
                      } else {

                      }
                    }
                  } else {

                  }
                  break;
                }
              } else {

              }
            }
          } else {

          }
        } else {

        }
      } else {

      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if (1 << 2 == 1 << 3) {
      zend_error_noreturn(1, "Cannot use [] for reading");
    } else {

    }
    container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    tmp___7 = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    zend_fetch_dimension_address_read((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, tmp___7, 1 << 2, 0);
  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_UNSET_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval **container ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  long tmp___2 ;
  zval *tmp___3 ;
  temp_variable *__t ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_uint tmp___5 ;
  zend_bool tmp___6 ;
  zend_uint tmp___7 ;
  zend_uint tmp___8 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___9 ;
  zend_free_op free_res ;
  zval **retval_ptr ;
  zval *new_zv___1 ;
  void __attribute__((__visibility__("default")))  *tmp___10 ;
  zend_uint tmp___11 ;
  zend_bool tmp___12 ;
  long tmp___13 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 4) {
    if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
      tmp___1 = zval_isref_p(*container);
      if (tmp___1) {

      } else {
        while (1) {
          tmp___0 = zval_refcount_p(*container);
          if (tmp___0 > 1U) {
            zval_delref_p(*container);
            while (1) {
              tmp = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*container)->value;
                new_zv->type = (*container)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *container = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
    } else {

    }
  } else {

  }
  if (1 << 2 == 1 << 2) {
    tmp___2 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___2) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  tmp___3 = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, tmp___3, 1 << 2, 6);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  if (1 << 2 == 1 << 2) {
    if ((unsigned int )free_op1.var != (unsigned int )((void *)0)) {
      tmp___8 = zval_refcount_p(free_op1.var);
      if (tmp___8 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___9 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___9 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___6 = zval_isref_p(__t->var.ptr);
                if (tmp___6) {

                } else {
                  tmp___7 = zval_refcount_p(__t->var.ptr);
                  if (tmp___7 > 2U) {
                    while (1) {
                      tmp___5 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___5 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___4 = _emalloc(sizeof(zval_gc_info ));
                          new_zv___0 = (zval *)tmp___4;
                          ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv___0->value = (*(__t->var.ptr_ptr))->value;
                            new_zv___0->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv___0, 1U);
                          zval_unset_isref_p(new_zv___0);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv___0;
                        _zval_copy_ctor(new_zv___0);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  tmp___13 = __builtin_expect((long )((unsigned int )((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr == (unsigned int )((void *)0)), 0L);
  if (tmp___13) {
    zend_error_noreturn(1, "Cannot unset string offsets");
  } else {
    retval_ptr = ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr;
    zend_pzval_unlock_func(*retval_ptr, & free_res, 1);
    if ((unsigned int )retval_ptr != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
      tmp___12 = zval_isref_p(*retval_ptr);
      if (tmp___12) {

      } else {
        while (1) {
          tmp___11 = zval_refcount_p(*retval_ptr);
          if (tmp___11 > 1U) {
            zval_delref_p(*retval_ptr);
            while (1) {
              tmp___10 = _emalloc(sizeof(zval_gc_info ));
              new_zv___1 = (zval *)tmp___10;
              ((zval_gc_info *)new_zv___1)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv___1->value = (*retval_ptr)->value;
                new_zv___1->type = (*retval_ptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv___1, 1U);
              zval_unset_isref_p(new_zv___1);
              break;
            }
            *retval_ptr = new_zv___1;
            _zval_copy_ctor(new_zv___1);
          } else {

          }
          break;
        }
      }
    } else {

    }
    zval_addref_p(*retval_ptr);
    if (free_res.var) {
      i_zval_ptr_dtor(free_res.var);
    } else {

    }
    (execute_data->opline) ++;
    return (0);
  }
}
}
static int ( __attribute__((__fastcall__)) zend_fetch_property_address_read_helper_SPEC_VAR_VAR)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *container ;
  zend_free_op free_op2 ;
  zval *offset ;
  temp_variable *__t ;
  zval *retval ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_literal *tmp___0 ;
  temp_variable *__t___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  offset = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___1 = __builtin_expect((long )((int )container->type != 5), 0L);
  if (tmp___1) {
    goto _L;
  } else {
    tmp___2 = __builtin_expect((long )((unsigned int )(container->value.obj.handlers)->read_property == (unsigned int )((void *)0)), 0L);
    if (tmp___2) {
      _L: /* CIL Label */ 
      zend_error(1 << 3L, "Trying to get property of non-object");
      zval_addref_p(& executor_globals.uninitialized_zval);
      while (1) {
        __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t->var.ptr = & executor_globals.uninitialized_zval;
        __t->var.ptr_ptr = & __t->var.ptr;
        break;
      }
      if (free_op2.var) {
        i_zval_ptr_dtor(free_op2.var);
      } else {

      }
    } else {
      if (1 << 2 == 1) {
        tmp___0 = opline->op2.literal;
      } else {
        tmp___0 = (zend_literal *)((void *)0);
      }
      retval = (*((container->value.obj.handlers)->read_property))(container, offset, 0, (struct _zend_literal  const  *)tmp___0);
      zval_addref_p(retval);
      while (1) {
        __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t___0->var.ptr = retval;
        __t___0->var.ptr_ptr = & __t___0->var.ptr;
        break;
      }
      if (free_op2.var) {
        i_zval_ptr_dtor(free_op2.var);
      } else {

      }
    }
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_R_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_property_address_read_helper_SPEC_VAR_VAR(execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_W_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *property ;
  zval **container ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zend_literal *tmp___1 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_uint tmp___3 ;
  zend_bool tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint tmp___6 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___7 ;
  zval **retval_ptr ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___8 ;
  zend_uint tmp___9 ;
  zend_bool tmp___10 ;

  {
  opline = execute_data->opline;
  property = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if (1 << 2 == 1 << 2) {
    if (opline->extended_value & 134217728UL) {
      zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr));
      ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr = *(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr);
    } else {

    }
  } else {

  }
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  if (1 << 2 == 1) {
    tmp___1 = opline->op2.literal;
  } else {
    tmp___1 = (zend_literal *)((void *)0);
  }
  zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)tmp___1, 1);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  if (1 << 2 == 1 << 2) {
    if ((unsigned int )free_op1.var != (unsigned int )((void *)0)) {
      tmp___6 = zval_refcount_p(free_op1.var);
      if (tmp___6 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___7 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___7 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___4 = zval_isref_p(__t->var.ptr);
                if (tmp___4) {

                } else {
                  tmp___5 = zval_refcount_p(__t->var.ptr);
                  if (tmp___5 > 2U) {
                    while (1) {
                      tmp___3 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___3 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___2 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___2;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  if (opline->extended_value & 67108864UL) {
    retval_ptr = ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr;
    zval_delref_p(*retval_ptr);
    tmp___10 = zval_isref_p(*retval_ptr);
    if (tmp___10) {

    } else {
      while (1) {
        tmp___9 = zval_refcount_p(*retval_ptr);
        if (tmp___9 > 1U) {
          zval_delref_p(*retval_ptr);
          while (1) {
            tmp___8 = _emalloc(sizeof(zval_gc_info ));
            new_zv___0 = (zval *)tmp___8;
            ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv___0->value = (*retval_ptr)->value;
              new_zv___0->type = (*retval_ptr)->type;
              break;
            }
            zval_set_refcount_p(new_zv___0, 1U);
            zval_unset_isref_p(new_zv___0);
            break;
          }
          *retval_ptr = new_zv___0;
          _zval_copy_ctor(new_zv___0);
        } else {

        }
        break;
      }
      zval_set_isref_p(*retval_ptr);
    }
    zval_addref_p(*retval_ptr);
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = *(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr);
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_RW_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *property ;
  zval **container ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zend_literal *tmp___1 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_uint tmp___3 ;
  zend_bool tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint tmp___6 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___7 ;

  {
  opline = execute_data->opline;
  property = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  if (1 << 2 == 1) {
    tmp___1 = opline->op2.literal;
  } else {
    tmp___1 = (zend_literal *)((void *)0);
  }
  zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)tmp___1, 2);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  if (1 << 2 == 1 << 2) {
    if ((unsigned int )free_op1.var != (unsigned int )((void *)0)) {
      tmp___6 = zval_refcount_p(free_op1.var);
      if (tmp___6 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___7 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___7 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___4 = zval_isref_p(__t->var.ptr);
                if (tmp___4) {

                } else {
                  tmp___5 = zval_refcount_p(__t->var.ptr);
                  if (tmp___5 > 2U) {
                    while (1) {
                      tmp___3 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___3 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___2 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___2;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_IS_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *container ;
  zend_free_op free_op2 ;
  zval *offset ;
  temp_variable *__t ;
  zval *retval ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_literal *tmp___0 ;
  temp_variable *__t___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  offset = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___1 = __builtin_expect((long )((int )container->type != 5), 0L);
  if (tmp___1) {
    goto _L;
  } else {
    tmp___2 = __builtin_expect((long )((unsigned int )(container->value.obj.handlers)->read_property == (unsigned int )((void *)0)), 0L);
    if (tmp___2) {
      _L: /* CIL Label */ 
      zval_addref_p(& executor_globals.uninitialized_zval);
      while (1) {
        __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t->var.ptr = & executor_globals.uninitialized_zval;
        __t->var.ptr_ptr = & __t->var.ptr;
        break;
      }
      if (free_op2.var) {
        i_zval_ptr_dtor(free_op2.var);
      } else {

      }
    } else {
      if (1 << 2 == 1) {
        tmp___0 = opline->op2.literal;
      } else {
        tmp___0 = (zend_literal *)((void *)0);
      }
      retval = (*((container->value.obj.handlers)->read_property))(container, offset, 3, (struct _zend_literal  const  *)tmp___0);
      zval_addref_p(retval);
      while (1) {
        __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t___0->var.ptr = retval;
        __t___0->var.ptr_ptr = & __t___0->var.ptr;
        break;
      }
      if (free_op2.var) {
        i_zval_ptr_dtor(free_op2.var);
      } else {

      }
    }
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *property ;
  zval **container ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zend_literal *tmp___1 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_uint tmp___3 ;
  zend_bool tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint tmp___6 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;

  {
  opline = execute_data->opline;
  if (execute_data->fbc) {
    if ((execute_data->fbc)->common.arg_info) {
      if ((opline->extended_value & 1048575UL) <= (unsigned long )(execute_data->fbc)->common.num_args) {
        tmp___9 = (unsigned int )((int )((execute_data->fbc)->common.arg_info + ((opline->extended_value & 1048575UL) - 1UL))->pass_by_reference & 3);
      } else {
        tmp___9 = (execute_data->fbc)->common.fn_flags & 50331648U;
      }
    } else {
      tmp___9 = (execute_data->fbc)->common.fn_flags & 50331648U;
    }
    if (tmp___9) {
      property = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
      container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
      if (1 << 2 == 1 << 2) {
        tmp___0 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
        if (tmp___0) {
          zend_error_noreturn(1, "Cannot use string offset as an object");
        } else {

        }
      } else {

      }
      if (1 << 2 == 1) {
        tmp___1 = opline->op2.literal;
      } else {
        tmp___1 = (zend_literal *)((void *)0);
      }
      zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)tmp___1, 1);
      if (free_op2.var) {
        i_zval_ptr_dtor(free_op2.var);
      } else {

      }
      if (1 << 2 == 1 << 2) {
        if ((unsigned int )free_op1.var != (unsigned int )((void *)0)) {
          tmp___6 = zval_refcount_p(free_op1.var);
          if (tmp___6 == 1U) {
            if ((int )(free_op1.var)->type != 5) {
              goto _L;
            } else {
              tmp___7 = zend_objects_store_get_refcount(free_op1.var);
              if (tmp___7 == (zend_uint __attribute__((__visibility__("default")))  )1) {
                _L: /* CIL Label */ 
                while (1) {
                  __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
                  if (__t->var.ptr_ptr) {
                    __t->var.ptr = *(__t->var.ptr_ptr);
                    __t->var.ptr_ptr = & __t->var.ptr;
                    tmp___4 = zval_isref_p(__t->var.ptr);
                    if (tmp___4) {

                    } else {
                      tmp___5 = zval_refcount_p(__t->var.ptr);
                      if (tmp___5 > 2U) {
                        while (1) {
                          tmp___3 = zval_refcount_p(*(__t->var.ptr_ptr));
                          if (tmp___3 > 1U) {
                            zval_delref_p(*(__t->var.ptr_ptr));
                            while (1) {
                              tmp___2 = _emalloc(sizeof(zval_gc_info ));
                              new_zv = (zval *)tmp___2;
                              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                              break;
                            }
                            while (1) {
                              while (1) {
                                new_zv->value = (*(__t->var.ptr_ptr))->value;
                                new_zv->type = (*(__t->var.ptr_ptr))->type;
                                break;
                              }
                              zval_set_refcount_p(new_zv, 1U);
                              zval_unset_isref_p(new_zv);
                              break;
                            }
                            *(__t->var.ptr_ptr) = new_zv;
                            _zval_copy_ctor(new_zv);
                          } else {

                          }
                          break;
                        }
                      } else {

                      }
                    }
                  } else {

                  }
                  break;
                }
              } else {

              }
            }
          } else {

          }
        } else {

        }
      } else {

      }
      if (free_op1.var) {
        i_zval_ptr_dtor(free_op1.var);
      } else {

      }
      (execute_data->opline) ++;
      return (0);
    } else {
      tmp___8 = zend_fetch_property_address_read_helper_SPEC_VAR_VAR(execute_data);
      return (tmp___8);
    }
  } else {
    tmp___8 = zend_fetch_property_address_read_helper_SPEC_VAR_VAR(execute_data);
    return (tmp___8);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_UNSET_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zend_free_op free_res ;
  zval **container ;
  zval *property ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  long tmp___3 ;
  zend_literal *tmp___4 ;
  temp_variable *__t ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  zend_uint tmp___6 ;
  zend_bool tmp___7 ;
  zend_uint tmp___8 ;
  zend_uint tmp___9 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___10 ;
  zval *new_zv___1 ;
  void __attribute__((__visibility__("default")))  *tmp___11 ;
  zend_uint tmp___12 ;
  zend_bool tmp___13 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  property = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if (1 << 2 == 1 << 4) {
    if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
      tmp___1 = zval_isref_p(*container);
      if (tmp___1) {

      } else {
        while (1) {
          tmp___0 = zval_refcount_p(*container);
          if (tmp___0 > 1U) {
            zval_delref_p(*container);
            while (1) {
              tmp = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*container)->value;
                new_zv->type = (*container)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *container = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
    } else {

    }
  } else {

  }
  if (1 << 2 == 1 << 2) {
    tmp___3 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___3) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  if (1 << 2 == 1) {
    tmp___4 = opline->op2.literal;
  } else {
    tmp___4 = (zend_literal *)((void *)0);
  }
  zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)tmp___4, 6);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  if (1 << 2 == 1 << 2) {
    if ((unsigned int )free_op1.var != (unsigned int )((void *)0)) {
      tmp___9 = zval_refcount_p(free_op1.var);
      if (tmp___9 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___10 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___10 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___7 = zval_isref_p(__t->var.ptr);
                if (tmp___7) {

                } else {
                  tmp___8 = zval_refcount_p(__t->var.ptr);
                  if (tmp___8 > 2U) {
                    while (1) {
                      tmp___6 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___6 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___5 = _emalloc(sizeof(zval_gc_info ));
                          new_zv___0 = (zval *)tmp___5;
                          ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv___0->value = (*(__t->var.ptr_ptr))->value;
                            new_zv___0->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv___0, 1U);
                          zval_unset_isref_p(new_zv___0);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv___0;
                        _zval_copy_ctor(new_zv___0);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  zend_pzval_unlock_func(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr), & free_res, 1);
  if ((unsigned int )((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
    tmp___13 = zval_isref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
    if (tmp___13) {

    } else {
      while (1) {
        tmp___12 = zval_refcount_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
        if (tmp___12 > 1U) {
          zval_delref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
          while (1) {
            tmp___11 = _emalloc(sizeof(zval_gc_info ));
            new_zv___1 = (zval *)tmp___11;
            ((zval_gc_info *)new_zv___1)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv___1->value = (*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr))->value;
              new_zv___1->type = (*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr))->type;
              break;
            }
            zval_set_refcount_p(new_zv___1, 1U);
            zval_unset_isref_p(new_zv___1);
            break;
          }
          *(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr) = new_zv___1;
          _zval_copy_ctor(new_zv___1);
        } else {

        }
        break;
      }
    }
  } else {

  }
  zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
  if (free_res.var) {
    i_zval_ptr_dtor(free_res.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_OBJ_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval **object_ptr ;
  zval *property_name ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zend_literal *tmp___1 ;
  zval **tmp___2 ;

  {
  opline = execute_data->opline;
  object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  property_name = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if (1 << 2 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  if (1 << 2 == 1) {
    tmp___1 = opline->op2.literal;
  } else {
    tmp___1 = (zend_literal *)((void *)0);
  }
  if (! ((int )opline->result_type & (1 << 5))) {
    tmp___2 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
  } else {
    tmp___2 = (zval **)((void *)0);
  }
  zend_assign_to_object(tmp___2, object_ptr, property_name, (int )(opline + 1)->op1_type, & (opline + 1)->op1, (temp_variable const   *)execute_data->Ts, 136, (zend_literal const   *)tmp___1);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_DIM_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **object_ptr ;
  long tmp ;
  zend_free_op free_op2 ;
  zval *property_name ;
  zval *tmp___0 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_literal *tmp___2 ;
  zval **tmp___3 ;
  zend_free_op free_op2___0 ;
  zend_free_op free_op_data1 ;
  zend_free_op free_op_data2 ;
  zval *value ;
  zval *dim ;
  zval *tmp___4 ;
  zval **variable_ptr_ptr ;
  zval *retval ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  char const   *__s ;
  int __l ;
  zval *__z ;
  char __attribute__((__visibility__("default")))  *tmp___6 ;
  temp_variable *__t ;
  temp_variable *__t___0 ;
  int tmp___7 ;
  temp_variable *__t___1 ;
  temp_variable *__t___2 ;
  long tmp___8 ;
  long tmp___9 ;

  {
  opline = execute_data->opline;
  object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  if ((int )(*object_ptr)->type == 5) {
    tmp___0 = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    property_name = tmp___0;
    if (1 << 2 == 1) {
      tmp___2 = opline->op2.literal;
    } else {
      tmp___2 = (zend_literal *)((void *)0);
    }
    if (! ((int )opline->result_type & (1 << 5))) {
      tmp___3 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
    } else {
      tmp___3 = (zval **)((void *)0);
    }
    zend_assign_to_object(tmp___3, object_ptr, property_name, (int )(opline + 1)->op1_type, & (opline + 1)->op1, (temp_variable const   *)execute_data->Ts, 147, (zend_literal const   *)tmp___2);
    if (free_op2.var) {
      i_zval_ptr_dtor(free_op2.var);
    } else {

    }
  } else {
    tmp___4 = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2___0);
    dim = tmp___4;
    zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var), object_ptr, dim, 1 << 2, 1);
    if (free_op2___0.var) {
      i_zval_ptr_dtor(free_op2___0.var);
    } else {

    }
    value = _get_zval_ptr((int )(opline + 1)->op1_type, (znode_op const   *)(& (opline + 1)->op1), (temp_variable const   *)execute_data->Ts, & free_op_data1, 0);
    variable_ptr_ptr = _get_zval_ptr_ptr_var((opline + 1)->op2.var, (temp_variable const   *)execute_data->Ts, & free_op_data2);
    tmp___9 = __builtin_expect((long )((unsigned int )variable_ptr_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___9) {
      tmp___7 = zend_assign_to_string_offset((temp_variable const   *)((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var)), (zval const   *)value, (int )(opline + 1)->op1_type);
      if (tmp___7) {
        if (! ((int )opline->result_type & (1 << 5))) {
          while (1) {
            tmp___5 = _emalloc(sizeof(zval_gc_info ));
            retval = (zval *)tmp___5;
            ((zval_gc_info *)retval)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            __s = (char const   *)((((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var))->str_offset.str)->value.str.val + ((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var))->str_offset.offset);
            __l = 1;
            __z = retval;
            __z->value.str.len = __l;
            tmp___6 = _estrndup(__s, (unsigned int )__l);
            __z->value.str.val = (char *)tmp___6;
            __z->type = (unsigned char)6;
            break;
          }
          retval->refcount__gc = 1U;
          retval->is_ref__gc = (unsigned char)0;
          while (1) {
            __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t->var.ptr = retval;
            __t->var.ptr_ptr = & __t->var.ptr;
            break;
          }
        } else {

        }
      } else {
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          while (1) {
            __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___0->var.ptr = & executor_globals.uninitialized_zval;
            __t___0->var.ptr_ptr = & __t___0->var.ptr;
            break;
          }
        } else {

        }
      }
    } else {
      tmp___8 = __builtin_expect((long )((unsigned int )*variable_ptr_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
      if (tmp___8) {
        if ((unsigned long )free_op_data1.var & 1UL) {
          _zval_dtor(value);
        } else {

        }
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          while (1) {
            __t___1 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___1->var.ptr = & executor_globals.uninitialized_zval;
            __t___1->var.ptr_ptr = & __t___1->var.ptr;
            break;
          }
        } else {

        }
      } else {
        if ((int )(opline + 1)->op1_type == 1 << 1) {
          value = zend_assign_tmp_to_variable(variable_ptr_ptr, value);
        } else {
          if ((int )(opline + 1)->op1_type == 1) {
            value = zend_assign_const_to_variable(variable_ptr_ptr, value);
          } else {
            value = zend_assign_to_variable(variable_ptr_ptr, value);
          }
        }
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(value);
          while (1) {
            __t___2 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___2->var.ptr = value;
            __t___2->var.ptr_ptr = & __t___2->var.ptr;
            break;
          }
        } else {

        }
      }
    }
    if (free_op_data2.var) {
      i_zval_ptr_dtor(free_op_data2.var);
    } else {

    }
    if ((unsigned int )free_op_data1.var != (unsigned int )((void *)0)) {
      if (((unsigned long )free_op_data1.var & 1UL) == 0UL) {
        i_zval_ptr_dtor(free_op_data1.var);
      } else {

      }
    } else {

    }
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *value ;
  zval **variable_ptr_ptr ;
  zval *retval ;
  void __attribute__((__visibility__("default")))  *tmp ;
  char const   *__s ;
  int __l ;
  zval *__z ;
  char __attribute__((__visibility__("default")))  *tmp___0 ;
  temp_variable *__t ;
  temp_variable *__t___0 ;
  int tmp___1 ;
  temp_variable *__t___1 ;
  temp_variable *__t___2 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  opline = execute_data->opline;
  value = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  variable_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 2) {
    tmp___3 = __builtin_expect((long )((unsigned int )variable_ptr_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___3) {
      tmp___1 = zend_assign_to_string_offset((temp_variable const   *)((temp_variable *)((char *)execute_data->Ts + opline->op1.var)), (zval const   *)value, 1 << 2);
      if (tmp___1) {
        if (! ((int )opline->result_type & (1 << 5))) {
          while (1) {
            tmp = _emalloc(sizeof(zval_gc_info ));
            retval = (zval *)tmp;
            ((zval_gc_info *)retval)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            __s = (char const   *)((((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->str_offset.str)->value.str.val + ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->str_offset.offset);
            __l = 1;
            __z = retval;
            __z->value.str.len = __l;
            tmp___0 = _estrndup(__s, (unsigned int )__l);
            __z->value.str.val = (char *)tmp___0;
            __z->type = (unsigned char)6;
            break;
          }
          retval->refcount__gc = 1U;
          retval->is_ref__gc = (unsigned char)0;
          while (1) {
            __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t->var.ptr = retval;
            __t->var.ptr_ptr = & __t->var.ptr;
            break;
          }
        } else {

        }
      } else {
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          while (1) {
            __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___0->var.ptr = & executor_globals.uninitialized_zval;
            __t___0->var.ptr_ptr = & __t___0->var.ptr;
            break;
          }
        } else {

        }
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if (1 << 2 == 1 << 2) {
      tmp___2 = __builtin_expect((long )((unsigned int )*variable_ptr_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
      if (tmp___2) {
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          while (1) {
            __t___1 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___1->var.ptr = & executor_globals.uninitialized_zval;
            __t___1->var.ptr_ptr = & __t___1->var.ptr;
            break;
          }
        } else {

        }
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      if (1 << 2 == 1 << 1) {
        value = zend_assign_tmp_to_variable(variable_ptr_ptr, value);
      } else {
        if (1 << 2 == 1) {
          value = zend_assign_const_to_variable(variable_ptr_ptr, value);
        } else {
          value = zend_assign_to_variable(variable_ptr_ptr, value);
        }
      }
      if (! ((int )opline->result_type & (1 << 5))) {
        zval_addref_p(value);
        while (1) {
          __t___2 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
          __t___2->var.ptr = value;
          __t___2->var.ptr_ptr = & __t___2->var.ptr;
          break;
        }
      } else {

      }
    }
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_REF_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval **variable_ptr_ptr ;
  zval **value_ptr_ptr ;
  long tmp ;
  int tmp___0 ;
  zend_bool tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  temp_variable *__t ;

  {
  opline = execute_data->opline;
  value_ptr_ptr = _get_zval_ptr_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if (1 << 2 == 1 << 2) {
    if (value_ptr_ptr) {
      tmp___1 = zval_isref_p(*value_ptr_ptr);
      if (tmp___1) {
        goto _L___2;
      } else {
        if (opline->extended_value == 1UL) {
          if (! ((temp_variable *)((char *)execute_data->Ts + opline->op2.var))->var.fcall_returned_reference) {
            if ((unsigned int )free_op2.var == (unsigned int )((void *)0)) {
              zval_addref_p(*value_ptr_ptr);
            } else {

            }
            zend_error(1 << 11L, "Only variables should be assigned by reference");
            tmp = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
            if (tmp) {
              if (free_op2.var) {
                i_zval_ptr_dtor(free_op2.var);
              } else {

              }
              return (0);
            } else {

            }
            tmp___0 = ZEND_ASSIGN_SPEC_VAR_VAR_HANDLER(execute_data);
            return (tmp___0);
          } else {
            goto _L___2;
          }
        } else {
          goto _L___2;
        }
      }
    } else {
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
    _L___1: /* CIL Label */ 
    _L___0: /* CIL Label */ 
    _L: /* CIL Label */ 
    if (1 << 2 == 1 << 2) {
      if (opline->extended_value == (ulong )(1 << 1)) {
        zval_addref_p(*value_ptr_ptr);
      } else {

      }
    } else {

    }
  }
  if (1 << 2 == 1 << 2) {
    tmp___2 = __builtin_expect((long )((unsigned int )((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr == (unsigned int )(& ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr)), 0L);
    if (tmp___2) {
      zend_error_noreturn(1, "Cannot assign by reference to overloaded object");
    } else {

    }
  } else {

  }
  variable_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 2) {
    tmp___3 = __builtin_expect((long )((unsigned int )value_ptr_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___3) {
      zend_error_noreturn(1, "Cannot create references to/from string offsets nor overloaded objects");
    } else {
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    if (1 << 2 == 1 << 2) {
      tmp___4 = __builtin_expect((long )((unsigned int )variable_ptr_ptr == (unsigned int )((void *)0)), 0L);
      if (tmp___4) {
        zend_error_noreturn(1, "Cannot create references to/from string offsets nor overloaded objects");
      } else {

      }
    } else {

    }
  }
  zend_assign_to_variable_reference(variable_ptr_ptr, value_ptr_ptr);
  if (1 << 2 == 1 << 2) {
    if (opline->extended_value == (ulong )(1 << 1)) {
      zval_delref_p(*variable_ptr_ptr);
    } else {

    }
  } else {

  }
  if (! ((int )opline->result_type & (1 << 5))) {
    zval_addref_p(*variable_ptr_ptr);
    while (1) {
      __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
      __t->var.ptr = *variable_ptr_ptr;
      __t->var.ptr_ptr = & __t->var.ptr;
      break;
    }
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_METHOD_CALL_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *function_name ;
  char *function_name_strval ;
  int function_name_strlen ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  long tmp ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  zval *object ;
  long tmp___1 ;
  zend_literal *tmp___2 ;
  zend_class_entry *tmp___3 ;
  zend_class_entry *tmp___4 ;
  char const   *tmp___5 ;
  zend_class_entry *tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  zend_function *tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  zval *this_ptr ;
  void __attribute__((__visibility__("default")))  *tmp___13 ;
  zend_bool tmp___14 ;

  {
  opline = execute_data->opline;
  zend_ptr_stack_3_push(& executor_globals.arg_types_stack, (void *)execute_data->fbc, (void *)execute_data->object, (void *)execute_data->called_scope);
  function_name = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if (1 << 2 != 1) {
    tmp = __builtin_expect((long )((int )function_name->type != 6), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Method name must be a string");
    } else {

    }
  } else {

  }
  function_name_strval = function_name->value.str.val;
  function_name_strlen = function_name->value.str.len;
  execute_data->object = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  tmp___11 = __builtin_expect((long )((unsigned int )execute_data->object != (unsigned int )((void *)0)), 1L);
  if (tmp___11) {
    tmp___12 = __builtin_expect((long )((int )(execute_data->object)->type == 5), 1L);
    if (tmp___12) {
      tmp___0 = zend_get_class_entry((zval const   *)execute_data->object);
      execute_data->called_scope = (zend_class_entry *)tmp___0;
      if (1 << 2 != 1) {
        goto _L;
      } else {
        if ((unsigned int )*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) == (unsigned int )execute_data->called_scope) {
          tmp___10 = (zend_function *)*((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U));
        } else {
          tmp___10 = (zend_function *)((void *)0);
        }
        execute_data->fbc = tmp___10;
        if ((unsigned int )tmp___10 == (unsigned int )((void *)0)) {
          _L: /* CIL Label */ 
          object = execute_data->object;
          tmp___1 = __builtin_expect((long )((unsigned int )((execute_data->object)->value.obj.handlers)->get_method == (unsigned int )((void *)0)), 0L);
          if (tmp___1) {
            zend_error_noreturn(1, "Object does not support method calls");
          } else {

          }
          if (1 << 2 == 1) {
            tmp___2 = opline->op2.literal + 1;
          } else {
            tmp___2 = (zend_literal *)((void *)0);
          }
          execute_data->fbc = (*(((execute_data->object)->value.obj.handlers)->get_method))(& execute_data->object, function_name_strval, function_name_strlen, (struct _zend_literal  const  *)tmp___2);
          tmp___7 = __builtin_expect((long )((unsigned int )execute_data->fbc == (unsigned int )((void *)0)), 0L);
          if (tmp___7) {
            if (execute_data->object) {
              if ((int )(execute_data->object)->type == 5) {
                if ((unsigned int )((execute_data->object)->value.obj.handlers)->get_class_entry != (unsigned int )((void *)0)) {
                  tmp___6 = (*(((execute_data->object)->value.obj.handlers)->get_class_entry))((zval const   *)execute_data->object);
                  if (tmp___6) {
                    tmp___4 = (*(((execute_data->object)->value.obj.handlers)->get_class_entry))((zval const   *)execute_data->object);
                    tmp___5 = tmp___4->name;
                  } else {
                    tmp___5 = "";
                  }
                } else {
                  tmp___5 = "";
                }
              } else {
                tmp___5 = "";
              }
            } else {
              tmp___5 = "";
            }
            zend_error_noreturn(1, "Call to undefined method %s::%s()", tmp___5, function_name_strval);
          } else {

          }
          if (1 << 2 == 1) {
            tmp___8 = __builtin_expect((long )(((execute_data->fbc)->common.fn_flags & 6291456U) == 0U), 1L);
            if (tmp___8) {
              tmp___9 = __builtin_expect((long )((unsigned int )execute_data->object == (unsigned int )object), 1L);
              if (tmp___9) {
                while (1) {
                  *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)execute_data->called_scope;
                  *((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U)) = (void *)execute_data->fbc;
                  break;
                }
              } else {

              }
            } else {

            }
          } else {

          }
        } else {

        }
      }
    } else {
      zend_error_noreturn(1, "Call to a member function %s() on a non-object", function_name_strval);
    }
  } else {
    zend_error_noreturn(1, "Call to a member function %s() on a non-object", function_name_strval);
  }
  if (((execute_data->fbc)->common.fn_flags & 1U) != 0U) {
    execute_data->object = (zval *)((void *)0);
  } else {
    tmp___14 = zval_isref_p(execute_data->object);
    if (tmp___14) {
      while (1) {
        tmp___13 = _emalloc(sizeof(zval_gc_info ));
        this_ptr = (zval *)tmp___13;
        ((zval_gc_info *)this_ptr)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      while (1) {
        while (1) {
          this_ptr->value = (execute_data->object)->value;
          this_ptr->type = (execute_data->object)->type;
          break;
        }
        zval_set_refcount_p(this_ptr, 1U);
        zval_unset_isref_p(this_ptr);
        break;
      }
      _zval_copy_ctor(this_ptr);
      execute_data->object = this_ptr;
    } else {
      zval_addref_p(execute_data->object);
    }
  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *function_name ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  char *function_name_strval ;
  int function_name_strlen ;
  zend_free_op free_op2 ;
  long tmp___1 ;
  zend_literal *tmp___2 ;
  union _zend_function  __attribute__((__visibility__("default"))) *tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___7 ;
  zend_function *tmp___8 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___9 ;
  zend_bool __attribute__((__visibility__("default")))  tmp___10 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___11 ;
  zval *tmp___12 ;

  {
  opline = execute_data->opline;
  zend_ptr_stack_3_push(& executor_globals.arg_types_stack, (void *)execute_data->fbc, (void *)execute_data->object, (void *)execute_data->called_scope);
  if (1 << 2 == 1) {
    if (*((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot)) {
      ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot);
    } else {
      tmp = zend_fetch_class_by_name((char const   *)(opline->op1.zv)->value.str.val, (unsigned int )(opline->op1.zv)->value.str.len, (zend_literal const   *)(opline->op1.literal + 1), (int )opline->extended_value);
      ce = (zend_class_entry *)tmp;
      tmp___0 = __builtin_expect((long )((unsigned int )ce == (unsigned int )((void *)0)), 0L);
      if (tmp___0) {
        zend_error_noreturn(1, "Class \'%s\' not found", (opline->op1.zv)->value.str.val);
      } else {

      }
      while (1) {
        *((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot) = (void *)ce;
        break;
      }
    }
    execute_data->called_scope = ce;
  } else {
    ce = ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->class_entry;
    if (opline->extended_value == 2UL) {
      execute_data->called_scope = executor_globals.called_scope;
    } else {
      if (opline->extended_value == 1UL) {
        execute_data->called_scope = executor_globals.called_scope;
      } else {
        execute_data->called_scope = ce;
      }
    }
  }
  if (1 << 2 == 1) {
    if (1 << 2 == 1) {
      if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
        execute_data->fbc = (zend_function *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
      } else {
        goto _L___2;
      }
    } else {
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
    _L___1: /* CIL Label */ 
    if (1 << 2 != 1) {
      if (1 << 2 == 1) {
        if ((unsigned int )*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) == (unsigned int )ce) {
          tmp___8 = (zend_function *)*((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U));
        } else {
          tmp___8 = (zend_function *)((void *)0);
        }
        execute_data->fbc = tmp___8;
        if (tmp___8) {

        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      _L: /* CIL Label */ 
      if (1 << 2 != 1 << 3) {
        function_name_strval = (char *)((void *)0);
        function_name_strlen = 0;
        if (1 << 2 == 1) {
          function_name_strval = (opline->op2.zv)->value.str.val;
          function_name_strlen = (opline->op2.zv)->value.str.len;
        } else {
          function_name = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
          tmp___1 = __builtin_expect((long )((int )function_name->type != 6), 0L);
          if (tmp___1) {
            zend_error_noreturn(1, "Function name must be a string");
          } else {
            function_name_strval = function_name->value.str.val;
            function_name_strlen = function_name->value.str.len;
          }
        }
        if (function_name_strval) {
          if (ce->get_static_method) {
            execute_data->fbc = (*(ce->get_static_method))(ce, function_name_strval, function_name_strlen);
          } else {
            if (1 << 2 == 1) {
              tmp___2 = opline->op2.literal + 1;
            } else {
              tmp___2 = (zend_literal *)((void *)0);
            }
            tmp___3 = zend_std_get_static_method(ce, (char const   *)function_name_strval, function_name_strlen, (struct _zend_literal  const  *)tmp___2);
            execute_data->fbc = (zend_function *)tmp___3;
          }
          tmp___4 = __builtin_expect((long )((unsigned int )execute_data->fbc == (unsigned int )((void *)0)), 0L);
          if (tmp___4) {
            zend_error_noreturn(1, "Call to undefined method %s::%s()", ce->name, function_name_strval);
          } else {

          }
          if (1 << 2 == 1) {
            tmp___5 = __builtin_expect((long )(((execute_data->fbc)->common.fn_flags & 6291456U) == 0U), 1L);
            if (tmp___5) {
              if (1 << 2 == 1) {
                while (1) {
                  *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)execute_data->fbc;
                  break;
                }
              } else {
                while (1) {
                  *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
                  *((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U)) = (void *)execute_data->fbc;
                  break;
                }
              }
            } else {

            }
          } else {

          }
        } else {

        }
        if (1 << 2 != 1) {
          if (free_op2.var) {
            i_zval_ptr_dtor(free_op2.var);
          } else {

          }
        } else {

        }
      } else {
        tmp___6 = __builtin_expect((long )((unsigned int )ce->constructor == (unsigned int )((void *)0)), 0L);
        if (tmp___6) {
          zend_error_noreturn(1, "Cannot call constructor");
        } else {

        }
        if (executor_globals.This) {
          tmp___7 = zend_get_class_entry((zval const   *)executor_globals.This);
          if ((unsigned int )tmp___7 != (unsigned int )(ce->constructor)->common.scope) {
            if ((ce->constructor)->common.fn_flags & 1024U) {
              zend_error_noreturn(1, "Cannot call private %s::__construct()", ce->name);
            } else {

            }
          } else {

          }
        } else {

        }
        execute_data->fbc = ce->constructor;
      }
    }
  }
  if ((execute_data->fbc)->common.fn_flags & 1U) {
    execute_data->object = (zval *)((void *)0);
  } else {
    if (executor_globals.This) {
      if (((executor_globals.This)->value.obj.handlers)->get_class_entry) {
        tmp___9 = zend_get_class_entry((zval const   *)executor_globals.This);
        tmp___10 = instanceof_function((zend_class_entry const   *)tmp___9, (zend_class_entry const   *)ce);
        if (tmp___10) {

        } else {
          if ((execute_data->fbc)->common.fn_flags & 65536U) {
            zend_error(1 << 11L, "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", ((execute_data->fbc)->common.scope)->name, (execute_data->fbc)->common.function_name);
          } else {
            zend_error_noreturn(1, "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", ((execute_data->fbc)->common.scope)->name, (execute_data->fbc)->common.function_name);
          }
        }
      } else {

      }
    } else {

    }
    tmp___12 = executor_globals.This;
    execute_data->object = tmp___12;
    if (tmp___12) {
      zval_addref_p(execute_data->object);
      tmp___11 = zend_get_class_entry((zval const   *)execute_data->object);
      execute_data->called_scope = (zend_class_entry *)tmp___11;
    } else {

    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_CASE_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  if (1 << 2 == 1 << 2) {
    zval_addref_p(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr);
  } else {

  }
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  is_equal_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *expr_ptr ;
  zval **expr_ptr_ptr ;
  zval **tmp ;
  long tmp___0 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zval *new_expr ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zval *new_expr___0 ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  zend_bool tmp___6 ;
  zend_free_op free_op2 ;
  zval *offset ;
  zval *tmp___7 ;
  ulong hval ;
  long tmp___8 ;
  register char const   *tmp___9 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___10 ;

  {
  opline = execute_data->opline;
  if (1 << 2 == 1 << 2) {
    goto _L___1;
  } else {
    if (1 << 2 == 1 << 4) {
      _L___1: /* CIL Label */ 
      if (opline->extended_value) {
        tmp = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
        expr_ptr_ptr = tmp;
        if (1 << 2 == 1 << 2) {
          tmp___0 = __builtin_expect((long )((unsigned int )expr_ptr_ptr == (unsigned int )((void *)0)), 0L);
          if (tmp___0) {
            zend_error_noreturn(1, "Cannot create references to/from string offsets");
          } else {

          }
        } else {

        }
        tmp___3 = zval_isref_p(*expr_ptr_ptr);
        if (tmp___3) {

        } else {
          while (1) {
            tmp___2 = zval_refcount_p(*expr_ptr_ptr);
            if (tmp___2 > 1U) {
              zval_delref_p(*expr_ptr_ptr);
              while (1) {
                tmp___1 = _emalloc(sizeof(zval_gc_info ));
                new_zv = (zval *)tmp___1;
                ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv->value = (*expr_ptr_ptr)->value;
                  new_zv->type = (*expr_ptr_ptr)->type;
                  break;
                }
                zval_set_refcount_p(new_zv, 1U);
                zval_unset_isref_p(new_zv);
                break;
              }
              *expr_ptr_ptr = new_zv;
              _zval_copy_ctor(new_zv);
            } else {

            }
            break;
          }
          zval_set_isref_p(*expr_ptr_ptr);
        }
        expr_ptr = *expr_ptr_ptr;
        zval_addref_p(expr_ptr);
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      expr_ptr = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
      if (1 << 2 == 1) {
        goto _L;
      } else {
        tmp___6 = zval_isref_p(expr_ptr);
        if (tmp___6) {
          _L: /* CIL Label */ 
          while (1) {
            tmp___5 = _emalloc(sizeof(zval_gc_info ));
            new_expr___0 = (zval *)tmp___5;
            ((zval_gc_info *)new_expr___0)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_expr___0->value = expr_ptr->value;
              new_expr___0->type = expr_ptr->type;
              break;
            }
            zval_set_refcount_p(new_expr___0, 1U);
            zval_unset_isref_p(new_expr___0);
            break;
          }
          expr_ptr = new_expr___0;
          _zval_copy_ctor(expr_ptr);
        } else {
          zval_addref_p(expr_ptr);
        }
      }
    }
  }
  if (1 << 2 != 1 << 3) {
    tmp___7 = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    offset = tmp___7;
    switch ((int )offset->type) {
    case 2: 
    tmp___8 = zend_dval_to_lval(offset->value.dval);
    hval = (unsigned long )tmp___8;
    goto num_index;
    case 1: 
    case 3: 
    hval = (unsigned long )offset->value.lval;
    num_index: 
    _zend_hash_index_update_or_next_insert(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, hval, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    case 6: 
    if (1 << 2 == 1) {
      hval = ((zend_literal *)offset)->hash_value;
    } else {
      while (1) {
        tmp___9 = (char const   *)offset->value.str.val;
        if ((int const   )*tmp___9 == 45) {
          tmp___9 ++;
        } else {

        }
        if ((int const   )*tmp___9 >= 48) {
          if ((int const   )*tmp___9 <= 57) {
            end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
            if ((int const   )*end != 0) {
              break;
            } else {
              if ((int const   )*tmp___9 == 48) {
                if (offset->value.str.len + 1 > 2) {
                  break;
                } else {
                  goto _L___2;
                }
              } else {
                _L___2: /* CIL Label */ 
                if (end - tmp___9 > 10) {
                  break;
                } else {
                  if (end - tmp___9 == 10) {
                    if ((int const   )*tmp___9 > 50) {
                      break;
                    } else {

                    }
                  } else {

                  }
                }
              }
            }
            hval = (unsigned long )((int const   )*tmp___9 - 48);
            while (1) {
              tmp___9 ++;
              if ((unsigned int )tmp___9 != (unsigned int )end) {
                if ((int const   )*tmp___9 >= 48) {
                  if ((int const   )*tmp___9 <= 57) {

                  } else {
                    break;
                  }
                } else {
                  break;
                }
              } else {
                break;
              }
              hval = hval * 10UL + (ulong )((int const   )*tmp___9 - 48);
            }
            if ((unsigned int )tmp___9 == (unsigned int )end) {
              if ((int )*(offset->value.str.val) == 45) {
                if (hval - 1UL > 2147483647UL) {
                  break;
                } else {

                }
                hval = (unsigned long )(- ((long )hval));
              } else {
                if (hval > 2147483647UL) {
                  break;
                } else {

                }
              }
              goto num_index;
            } else {

            }
          } else {

          }
        } else {

        }
        break;
      }
      if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
        if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
          hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
        } else {
          tmp___10 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___10;
        }
      } else {
        tmp___10 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
        hval = (unsigned long )tmp___10;
      }
    }
    _zend_hash_quick_add_or_update(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    case 0: 
    _zend_hash_add_or_update(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, "", sizeof(""), (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    default: 
    zend_error(1 << 1L, "Illegal offset type");
    i_zval_ptr_dtor(expr_ptr);
    break;
    }
    if (free_op2.var) {
      i_zval_ptr_dtor(free_op2.var);
    } else {

    }
  } else {
    _zend_hash_index_update_or_next_insert(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, 0UL, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1 << 2);
  }
  if (1 << 2 == 1 << 2) {
    goto _L___4;
  } else {
    if (1 << 2 == 1 << 4) {
      _L___4: /* CIL Label */ 
      if (opline->extended_value) {
        if (free_op1.var) {
          i_zval_ptr_dtor(free_op1.var);
        } else {

        }
      } else {
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ 
      if (free_op1.var) {
        i_zval_ptr_dtor(free_op1.var);
      } else {

      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_ARRAY_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  int tmp ;

  {
  opline = execute_data->opline;
  _array_init(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, 0U);
  if (1 << 2 == 1 << 3) {
    (execute_data->opline) ++;
    return (0);
  } else {
    tmp = ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_VAR_HANDLER(execute_data);
    return (tmp);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_UNSET_VAR_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval tmp ;
  zval *varname ;
  HashTable *target_symbol_table ;
  zend_free_op free_op1 ;
  zend_compiled_variable *cv ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_literal *tmp___1 ;
  ulong hash_value ;
  ulong tmp___2 ;

  {
  opline = execute_data->opline;
  if (1 << 2 == 1 << 4) {
    if (1 << 2 == 1 << 3) {
      if (opline->extended_value & 8388608UL) {
        if (executor_globals.active_symbol_table) {
          cv = (executor_globals.active_op_array)->vars + opline->op1.var;
          zend_delete_variable(execute_data->prev_execute_data, executor_globals.active_symbol_table, cv->name, cv->name_len + 1, cv->hash_value);
          *(execute_data->CVs + opline->op1.var) = (zval **)((void *)0);
        } else {
          if (*(execute_data->CVs + opline->op1.var)) {
            i_zval_ptr_dtor(*(*(execute_data->CVs + opline->op1.var)));
            *(execute_data->CVs + opline->op1.var) = (zval **)((void *)0);
          } else {

          }
        }
        (execute_data->opline) ++;
        return (0);
      } else {

      }
    } else {

    }
  } else {

  }
  varname = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 != 1) {
    if ((int )varname->type != 6) {
      while (1) {
        tmp.value = varname->value;
        tmp.type = varname->type;
        break;
      }
      _zval_copy_ctor(& tmp);
      if ((int )tmp.type != 6) {
        _convert_to_string(& tmp);
      } else {

      }
      varname = & tmp;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if (1 << 2 == 1 << 2) {
      zval_addref_p(varname);
    } else {
      if (1 << 2 == 1 << 4) {
        zval_addref_p(varname);
      } else {

      }
    }
  }
  if (1 << 2 != 1 << 3) {
    if (1 << 2 == 1) {
      if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
        ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
      } else {
        tmp___0 = zend_fetch_class_by_name((char const   *)(opline->op2.zv)->value.str.val, (unsigned int )(opline->op2.zv)->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), 0);
        ce = (zend_class_entry *)tmp___0;
        while (1) {
          *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
          break;
        }
      }
    } else {
      ce = ((temp_variable *)((char *)execute_data->Ts + opline->op2.var))->class_entry;
    }
    if (1 << 2 == 1) {
      tmp___1 = opline->op1.literal;
    } else {
      tmp___1 = (zend_literal *)((void *)0);
    }
    zend_std_unset_static_property(ce, (char const   *)varname->value.str.val, varname->value.str.len, (struct _zend_literal  const  *)tmp___1);
  } else {
    tmp___2 = zend_inline_hash_func((char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1));
    hash_value = tmp___2;
    target_symbol_table = zend_get_target_symbol_table((int )(opline->extended_value & 1879048192UL));
    zend_delete_variable(execute_data, target_symbol_table, (char const   *)varname->value.str.val, varname->value.str.len + 1, hash_value);
  }
  if (1 << 2 != 1) {
    if ((unsigned int )varname == (unsigned int )(& tmp)) {
      _zval_dtor(& tmp);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if (1 << 2 == 1 << 2) {
      i_zval_ptr_dtor(varname);
    } else {
      if (1 << 2 == 1 << 4) {
        i_zval_ptr_dtor(varname);
      } else {

      }
    }
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_UNSET_DIM_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval **container ;
  zval *offset ;
  ulong hval ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  HashTable *ht ;
  long tmp___2 ;
  register char const   *tmp___3 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___4 ;
  long tmp___5 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 4) {
    if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
      tmp___1 = zval_isref_p(*container);
      if (tmp___1) {

      } else {
        while (1) {
          tmp___0 = zval_refcount_p(*container);
          if (tmp___0 > 1U) {
            zval_delref_p(*container);
            while (1) {
              tmp = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*container)->value;
                new_zv->type = (*container)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *container = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
    } else {

    }
  } else {

  }
  offset = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if (1 << 2 != 1 << 2) {
    goto _L___0;
  } else {
    if (container) {
      _L___0: /* CIL Label */ 
      switch ((int )(*container)->type) {
      case 4: 
      ht = (*container)->value.ht;
      switch ((int )offset->type) {
      case 2: 
      tmp___2 = zend_dval_to_lval(offset->value.dval);
      hval = (unsigned long )tmp___2;
      goto num_index_dim;
      case 7: 
      case 3: 
      case 1: 
      hval = (unsigned long )offset->value.lval;
      zend_hash_del_key_or_index(ht, (char const   *)((void *)0), 0U, hval, 1);
      break;
      case 6: 
      if (1 << 2 == 1 << 4) {
        zval_addref_p(offset);
      } else {
        if (1 << 2 == 1 << 2) {
          zval_addref_p(offset);
        } else {

        }
      }
      if (1 << 2 == 1) {
        hval = ((zend_literal *)offset)->hash_value;
      } else {
        while (1) {
          tmp___3 = (char const   *)offset->value.str.val;
          if ((int const   )*tmp___3 == 45) {
            tmp___3 ++;
          } else {

          }
          if ((int const   )*tmp___3 >= 48) {
            if ((int const   )*tmp___3 <= 57) {
              end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
              if ((int const   )*end != 0) {
                break;
              } else {
                if ((int const   )*tmp___3 == 48) {
                  if (offset->value.str.len + 1 > 2) {
                    break;
                  } else {
                    goto _L;
                  }
                } else {
                  _L: /* CIL Label */ 
                  if (end - tmp___3 > 10) {
                    break;
                  } else {
                    if (end - tmp___3 == 10) {
                      if ((int const   )*tmp___3 > 50) {
                        break;
                      } else {

                      }
                    } else {

                    }
                  }
                }
              }
              hval = (unsigned long )((int const   )*tmp___3 - 48);
              while (1) {
                tmp___3 ++;
                if ((unsigned int )tmp___3 != (unsigned int )end) {
                  if ((int const   )*tmp___3 >= 48) {
                    if ((int const   )*tmp___3 <= 57) {

                    } else {
                      break;
                    }
                  } else {
                    break;
                  }
                } else {
                  break;
                }
                hval = hval * 10UL + (ulong )((int const   )*tmp___3 - 48);
              }
              if ((unsigned int )tmp___3 == (unsigned int )end) {
                if ((int )*(offset->value.str.val) == 45) {
                  if (hval - 1UL > 2147483647UL) {
                    break;
                  } else {

                  }
                  hval = (unsigned long )(- ((long )hval));
                } else {
                  if (hval > 2147483647UL) {
                    break;
                  } else {

                  }
                }
                goto num_index_dim;
              } else {

              }
            } else {

            }
          } else {

          }
          break;
        }
        if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
          if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
            hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
          } else {
            tmp___4 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
            hval = (unsigned long )tmp___4;
          }
        } else {
          tmp___4 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___4;
        }
      }
      if ((unsigned int )ht == (unsigned int )(& executor_globals.symbol_table)) {
        zend_delete_global_variable_ex((char const   *)offset->value.str.val, offset->value.str.len, hval);
      } else {
        zend_hash_del_key_or_index(ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, 2);
      }
      if (1 << 2 == 1 << 4) {
        i_zval_ptr_dtor(offset);
      } else {
        if (1 << 2 == 1 << 2) {
          i_zval_ptr_dtor(offset);
        } else {

        }
      }
      break;
      num_index_dim: 
      zend_hash_del_key_or_index(ht, (char const   *)((void *)0), 0U, hval, 1);
      if (1 << 2 == 1 << 4) {
        i_zval_ptr_dtor(offset);
      } else {
        if (1 << 2 == 1 << 2) {
          i_zval_ptr_dtor(offset);
        } else {

        }
      }
      break;
      case 0: 
      zend_hash_del_key_or_index(ht, "", sizeof(""), 0UL, 0);
      break;
      default: 
      zend_error(1 << 1L, "Illegal offset type in unset");
      break;
      }
      if (free_op2.var) {
        i_zval_ptr_dtor(free_op2.var);
      } else {

      }
      break;
      case 5: 
      tmp___5 = __builtin_expect((long )((unsigned int )((*container)->value.obj.handlers)->unset_dimension == (unsigned int )((void *)0)), 0L);
      if (tmp___5) {
        zend_error_noreturn(1, "Cannot use object as array");
      } else {

      }
      (*(((*container)->value.obj.handlers)->unset_dimension))(*container, offset);
      if (free_op2.var) {
        i_zval_ptr_dtor(free_op2.var);
      } else {

      }
      break;
      case 6: 
      zend_error_noreturn(1, "Cannot unset string offsets");
      return (0);
      default: ;
      if (free_op2.var) {
        i_zval_ptr_dtor(free_op2.var);
      } else {

      }
      break;
      }
    } else {
      if (free_op2.var) {
        i_zval_ptr_dtor(free_op2.var);
      } else {

      }
    }
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_UNSET_OBJ_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval **container ;
  zval *offset ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_literal *tmp___3 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  offset = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if (1 << 2 != 1 << 2) {
    goto _L;
  } else {
    if (container) {
      _L: /* CIL Label */ 
      if (1 << 2 == 1 << 4) {
        if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
          tmp___1 = zval_isref_p(*container);
          if (tmp___1) {

          } else {
            while (1) {
              tmp___0 = zval_refcount_p(*container);
              if (tmp___0 > 1U) {
                zval_delref_p(*container);
                while (1) {
                  tmp = _emalloc(sizeof(zval_gc_info ));
                  new_zv = (zval *)tmp;
                  ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                  break;
                }
                while (1) {
                  while (1) {
                    new_zv->value = (*container)->value;
                    new_zv->type = (*container)->type;
                    break;
                  }
                  zval_set_refcount_p(new_zv, 1U);
                  zval_unset_isref_p(new_zv);
                  break;
                }
                *container = new_zv;
                _zval_copy_ctor(new_zv);
              } else {

              }
              break;
            }
          }
        } else {

        }
      } else {

      }
      if ((int )(*container)->type == 5) {
        if (((*container)->value.obj.handlers)->unset_property) {
          if (1 << 2 == 1) {
            tmp___3 = opline->op2.literal;
          } else {
            tmp___3 = (zend_literal *)((void *)0);
          }
          (*(((*container)->value.obj.handlers)->unset_property))(*container, offset, (struct _zend_literal  const  *)tmp___3);
        } else {
          zend_error(1 << 3L, "Trying to unset property of non-object");
        }
        if (free_op2.var) {
          i_zval_ptr_dtor(free_op2.var);
        } else {

        }
      } else {
        if (free_op2.var) {
          i_zval_ptr_dtor(free_op2.var);
        } else {

        }
      }
    } else {
      if (free_op2.var) {
        i_zval_ptr_dtor(free_op2.var);
      } else {

      }
    }
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ISSET_ISEMPTY_VAR_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **value ;
  zend_bool isset ;
  zend_compiled_variable *cv ;
  int __attribute__((__visibility__("default")))  tmp ;
  HashTable *target_symbol_table ;
  zend_free_op free_op1 ;
  zval tmp___0 ;
  zval *varname ;
  zval *tmp___1 ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_literal *tmp___3 ;
  zval __attribute__((__visibility__("default")))  **tmp___4 ;
  int __attribute__((__visibility__("default")))  tmp___5 ;
  zval *__z ;
  zval *__z___0 ;
  zval *__z___1 ;
  zval *__z___2 ;
  int tmp___6 ;

  {
  opline = execute_data->opline;
  isset = (zend_bool )1;
  if (1 << 2 == 1 << 4) {
    if (1 << 2 == 1 << 3) {
      if (opline->extended_value & 8388608UL) {
        if (*(execute_data->CVs + opline->op1.var)) {
          value = *(execute_data->CVs + opline->op1.var);
        } else {
          if (executor_globals.active_symbol_table) {
            cv = (executor_globals.active_op_array)->vars + opline->op1.var;
            tmp = zend_hash_quick_find((HashTable const   *)executor_globals.active_symbol_table, cv->name, (unsigned int )(cv->name_len + 1), cv->hash_value, (void **)(& value));
            if (tmp == (int __attribute__((__visibility__("default")))  )-1) {
              isset = (unsigned char)0;
            } else {

            }
          } else {
            isset = (unsigned char)0;
          }
        }
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    _L: /* CIL Label */ 
    tmp___1 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    varname = tmp___1;
    if (1 << 2 != 1) {
      if ((int )varname->type != 6) {
        while (1) {
          tmp___0.value = varname->value;
          tmp___0.type = varname->type;
          break;
        }
        _zval_copy_ctor(& tmp___0);
        if ((int )tmp___0.type != 6) {
          _convert_to_string(& tmp___0);
        } else {

        }
        varname = & tmp___0;
      } else {

      }
    } else {

    }
    if (1 << 2 != 1 << 3) {
      if (1 << 2 == 1) {
        if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
          ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
        } else {
          tmp___2 = zend_fetch_class_by_name((char const   *)(opline->op2.zv)->value.str.val, (unsigned int )(opline->op2.zv)->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), 0);
          ce = (zend_class_entry *)tmp___2;
          while (1) {
            *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
            break;
          }
        }
      } else {
        ce = ((temp_variable *)((char *)execute_data->Ts + opline->op2.var))->class_entry;
      }
      if (1 << 2 == 1) {
        tmp___3 = opline->op1.literal;
      } else {
        tmp___3 = (zend_literal *)((void *)0);
      }
      tmp___4 = zend_std_get_static_property(ce, (char const   *)varname->value.str.val, varname->value.str.len, (unsigned char)1, (struct _zend_literal  const  *)tmp___3);
      value = (zval **)tmp___4;
      if (! value) {
        isset = (unsigned char)0;
      } else {

      }
    } else {
      target_symbol_table = zend_get_target_symbol_table((int )(opline->extended_value & 1879048192UL));
      tmp___5 = zend_hash_find((HashTable const   *)target_symbol_table, (char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1), (void **)(& value));
      if (tmp___5 == (int __attribute__((__visibility__("default")))  )-1) {
        isset = (unsigned char)0;
      } else {

      }
    }
    if (1 << 2 != 1) {
      if ((unsigned int )varname == (unsigned int )(& tmp___0)) {
        _zval_dtor(& tmp___0);
      } else {

      }
    } else {

    }
    if (free_op1.var) {
      i_zval_ptr_dtor(free_op1.var);
    } else {

    }
  }
  if (opline->extended_value & 33554432UL) {
    if (isset) {
      if ((int )(*value)->type != 0) {
        while (1) {
          __z = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
          __z->value.lval = 1L;
          __z->type = (unsigned char)3;
          break;
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      while (1) {
        __z___0 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
        __z___0->value.lval = 0L;
        __z___0->type = (unsigned char)3;
        break;
      }
    }
  } else {
    if (! isset) {
      goto _L___2;
    } else {
      tmp___6 = i_zend_is_true(*value);
      if (tmp___6) {
        while (1) {
          __z___2 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
          __z___2->value.lval = 0L;
          __z___2->type = (unsigned char)3;
          break;
        }
      } else {
        _L___2: /* CIL Label */ 
        while (1) {
          __z___1 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
          __z___1->value.lval = 1L;
          __z___1->type = (unsigned char)3;
          break;
        }
      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_VAR)(int prop_dim , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval **container ;
  zval **value ;
  int result ;
  ulong hval ;
  zval *offset ;
  HashTable *ht ;
  int isset ;
  long tmp ;
  int __attribute__((__visibility__("default")))  tmp___0 ;
  register char const   *tmp___1 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___2 ;
  int __attribute__((__visibility__("default")))  tmp___3 ;
  int __attribute__((__visibility__("default")))  tmp___4 ;
  int tmp___5 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;
  zend_literal *tmp___7 ;
  zval tmp___8 ;

  {
  opline = execute_data->opline;
  value = (zval **)((void *)0);
  result = 0;
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  offset = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if ((int )(*container)->type == 4) {
    if (! prop_dim) {
      isset = 0;
      ht = (*container)->value.ht;
      switch ((int )offset->type) {
      case 2: 
      tmp = zend_dval_to_lval(offset->value.dval);
      hval = (unsigned long )tmp;
      goto num_index_prop;
      case 7: 
      case 3: 
      case 1: 
      hval = (unsigned long )offset->value.lval;
      num_index_prop: 
      tmp___0 = zend_hash_index_find((HashTable const   *)ht, hval, (void **)(& value));
      if (tmp___0 == (int __attribute__((__visibility__("default")))  )0) {
        isset = 1;
      } else {

      }
      break;
      case 6: 
      if (1 << 2 == 1) {
        hval = ((zend_literal *)offset)->hash_value;
      } else {
        if (! prop_dim) {
          while (1) {
            tmp___1 = (char const   *)offset->value.str.val;
            if ((int const   )*tmp___1 == 45) {
              tmp___1 ++;
            } else {

            }
            if ((int const   )*tmp___1 >= 48) {
              if ((int const   )*tmp___1 <= 57) {
                end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
                if ((int const   )*end != 0) {
                  break;
                } else {
                  if ((int const   )*tmp___1 == 48) {
                    if (offset->value.str.len + 1 > 2) {
                      break;
                    } else {
                      goto _L;
                    }
                  } else {
                    _L: /* CIL Label */ 
                    if (end - tmp___1 > 10) {
                      break;
                    } else {
                      if (end - tmp___1 == 10) {
                        if ((int const   )*tmp___1 > 50) {
                          break;
                        } else {

                        }
                      } else {

                      }
                    }
                  }
                }
                hval = (unsigned long )((int const   )*tmp___1 - 48);
                while (1) {
                  tmp___1 ++;
                  if ((unsigned int )tmp___1 != (unsigned int )end) {
                    if ((int const   )*tmp___1 >= 48) {
                      if ((int const   )*tmp___1 <= 57) {

                      } else {
                        break;
                      }
                    } else {
                      break;
                    }
                  } else {
                    break;
                  }
                  hval = hval * 10UL + (ulong )((int const   )*tmp___1 - 48);
                }
                if ((unsigned int )tmp___1 == (unsigned int )end) {
                  if ((int )*(offset->value.str.val) == 45) {
                    if (hval - 1UL > 2147483647UL) {
                      break;
                    } else {

                    }
                    hval = (unsigned long )(- ((long )hval));
                  } else {
                    if (hval > 2147483647UL) {
                      break;
                    } else {

                    }
                  }
                  goto num_index_prop;
                } else {

                }
              } else {

              }
            } else {

            }
            break;
          }
        } else {

        }
        if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
          if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
            hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
          } else {
            tmp___2 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
            hval = (unsigned long )tmp___2;
          }
        } else {
          tmp___2 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___2;
        }
      }
      tmp___3 = zend_hash_quick_find((HashTable const   *)ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, (void **)(& value));
      if (tmp___3 == (int __attribute__((__visibility__("default")))  )0) {
        isset = 1;
      } else {

      }
      break;
      case 0: 
      tmp___4 = zend_hash_find((HashTable const   *)ht, "", sizeof(""), (void **)(& value));
      if (tmp___4 == (int __attribute__((__visibility__("default")))  )0) {
        isset = 1;
      } else {

      }
      break;
      default: 
      zend_error(1 << 1L, "Illegal offset type in isset or empty");
      break;
      }
      if (opline->extended_value & 33554432UL) {
        if (isset) {
          if ((int )(*value)->type == 0) {
            result = 0;
          } else {
            result = isset;
          }
        } else {
          result = isset;
        }
      } else {
        if (! isset) {
          result = 0;
        } else {
          tmp___5 = i_zend_is_true(*value);
          if (tmp___5) {
            result = 1;
          } else {
            result = 0;
          }
        }
      }
      if (free_op2.var) {
        i_zval_ptr_dtor(free_op2.var);
      } else {

      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    if ((int )(*container)->type == 5) {
      if (prop_dim) {
        if (((*container)->value.obj.handlers)->has_property) {
          if (1 << 2 == 1) {
            tmp___7 = opline->op2.literal;
          } else {
            tmp___7 = (zend_literal *)((void *)0);
          }
          result = (*(((*container)->value.obj.handlers)->has_property))(*container, offset, (opline->extended_value & 16777216UL) != 0UL, (struct _zend_literal  const  *)tmp___7);
        } else {
          zend_error(1 << 3L, "Trying to check property of non-object");
          result = 0;
        }
      } else {
        if (((*container)->value.obj.handlers)->has_dimension) {
          result = (*(((*container)->value.obj.handlers)->has_dimension))(*container, offset, (opline->extended_value & 16777216UL) != 0UL);
        } else {
          zend_error(1 << 3L, "Trying to check element of non-array");
          result = 0;
        }
      }
      if (free_op2.var) {
        i_zval_ptr_dtor(free_op2.var);
      } else {

      }
    } else {
      if ((int )(*container)->type == 6) {
        if (! prop_dim) {
          if ((int )offset->type != 1) {
            while (1) {
              tmp___8.value = offset->value;
              tmp___8.type = offset->type;
              break;
            }
            _zval_copy_ctor(& tmp___8);
            convert_to_long(& tmp___8);
            offset = & tmp___8;
          } else {

          }
          if ((int )offset->type == 1) {
            if (opline->extended_value & 33554432UL) {
              if (offset->value.lval >= 0L) {
                if (offset->value.lval < (long )(*container)->value.str.len) {
                  result = 1;
                } else {

                }
              } else {

              }
            } else {
              if (offset->value.lval >= 0L) {
                if (offset->value.lval < (long )(*container)->value.str.len) {
                  if ((int )*((*container)->value.str.val + offset->value.lval) != 48) {
                    result = 1;
                  } else {

                  }
                } else {

                }
              } else {

              }
            }
          } else {

          }
          if (free_op2.var) {
            i_zval_ptr_dtor(free_op2.var);
          } else {

          }
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        if (free_op2.var) {
          i_zval_ptr_dtor(free_op2.var);
        } else {

        }
      }
    }
  }
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.type = (unsigned char)3;
  if (opline->extended_value & 33554432UL) {
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.lval = (long )result;
  } else {
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.lval = (long )(! result);
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_VAR(0, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_VAR_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_VAR(1, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) zend_binary_assign_op_obj_helper_SPEC_VAR_UNUSED)(int (*binary_op)(zval *result , zval *op1 , zval *op2 ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op_data1 ;
  zval **object_ptr ;
  zval **tmp ;
  zval *object ;
  zval *property ;
  zval *value ;
  zval *tmp___0 ;
  int have_get_ptr ;
  long tmp___1 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zval **zptr ;
  zend_literal *tmp___3 ;
  zval **tmp___4 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  zend_uint tmp___6 ;
  zend_bool tmp___7 ;
  zval *z ;
  zend_literal *tmp___8 ;
  zval *value___0 ;
  zval *tmp___9 ;
  zend_uint tmp___10 ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___11 ;
  zend_uint tmp___12 ;
  zend_bool tmp___13 ;
  zend_literal *tmp___14 ;
  long tmp___15 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  object_ptr = tmp;
  property = (zval *)((void *)0);
  tmp___0 = _get_zval_ptr((int )(opline + 1)->op1_type, (znode_op const   *)(& (opline + 1)->op1), (temp_variable const   *)execute_data->Ts, & free_op_data1, 0);
  value = tmp___0;
  have_get_ptr = 0;
  if (1 << 2 == 1 << 2) {
    tmp___1 = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___1) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  make_real_object(object_ptr);
  object = *object_ptr;
  tmp___15 = __builtin_expect((long )((int )object->type != 5), 0L);
  if (tmp___15) {
    zend_error(1 << 1L, "Attempt to assign property of non-object");
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = & executor_globals.uninitialized_zval;
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
    } else {

    }
  } else {
    if (opline->extended_value == 136UL) {
      if ((object->value.obj.handlers)->get_property_ptr_ptr) {
        if (1 << 3 == 1) {
          tmp___3 = opline->op2.literal;
        } else {
          tmp___3 = (zend_literal *)((void *)0);
        }
        tmp___4 = (*((object->value.obj.handlers)->get_property_ptr_ptr))(object, property, (struct _zend_literal  const  *)tmp___3);
        zptr = tmp___4;
        if ((unsigned int )zptr != (unsigned int )((void *)0)) {
          tmp___7 = zval_isref_p(*zptr);
          if (tmp___7) {

          } else {
            while (1) {
              tmp___6 = zval_refcount_p(*zptr);
              if (tmp___6 > 1U) {
                zval_delref_p(*zptr);
                while (1) {
                  tmp___5 = _emalloc(sizeof(zval_gc_info ));
                  new_zv = (zval *)tmp___5;
                  ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                  break;
                }
                while (1) {
                  while (1) {
                    new_zv->value = (*zptr)->value;
                    new_zv->type = (*zptr)->type;
                    break;
                  }
                  zval_set_refcount_p(new_zv, 1U);
                  zval_unset_isref_p(new_zv);
                  break;
                }
                *zptr = new_zv;
                _zval_copy_ctor(new_zv);
              } else {

              }
              break;
            }
          }
          have_get_ptr = 1;
          (*binary_op)(*zptr, *zptr, value);
          if (! ((int )opline->result_type & (1 << 5))) {
            zval_addref_p(*zptr);
            ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = *zptr;
            ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
          } else {

          }
        } else {

        }
      } else {

      }
    } else {

    }
    if (! have_get_ptr) {
      z = (zval *)((void *)0);
      if (opline->extended_value == 136UL) {
        if ((object->value.obj.handlers)->read_property) {
          if (1 << 3 == 1) {
            tmp___8 = opline->op2.literal;
          } else {
            tmp___8 = (zend_literal *)((void *)0);
          }
          z = (*((object->value.obj.handlers)->read_property))(object, property, 0, (struct _zend_literal  const  *)tmp___8);
        } else {

        }
      } else {
        if ((object->value.obj.handlers)->read_dimension) {
          z = (*((object->value.obj.handlers)->read_dimension))(object, property, 0);
        } else {

        }
      }
      if (z) {
        if ((int )z->type == 5) {
          if ((z->value.obj.handlers)->get) {
            tmp___9 = (*((z->value.obj.handlers)->get))(z);
            value___0 = tmp___9;
            tmp___10 = zval_refcount_p(z);
            if (tmp___10 == 0U) {
              if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                gc_remove_zval_from_buffer(z);
              } else {

              }
              _zval_dtor(z);
              while (1) {
                if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                  gc_remove_zval_from_buffer(z);
                } else {

                }
                _efree((void *)z);
                break;
              }
            } else {

            }
            z = value___0;
          } else {

          }
        } else {

        }
        zval_addref_p(z);
        tmp___13 = zval_isref_p(z);
        if (tmp___13) {

        } else {
          while (1) {
            tmp___12 = zval_refcount_p(z);
            if (tmp___12 > 1U) {
              zval_delref_p(z);
              while (1) {
                tmp___11 = _emalloc(sizeof(zval_gc_info ));
                new_zv___0 = (zval *)tmp___11;
                ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv___0->value = z->value;
                  new_zv___0->type = z->type;
                  break;
                }
                zval_set_refcount_p(new_zv___0, 1U);
                zval_unset_isref_p(new_zv___0);
                break;
              }
              z = new_zv___0;
              _zval_copy_ctor(new_zv___0);
            } else {

            }
            break;
          }
        }
        (*binary_op)(z, z, value);
        if (opline->extended_value == 136UL) {
          if (1 << 3 == 1) {
            tmp___14 = opline->op2.literal;
          } else {
            tmp___14 = (zend_literal *)((void *)0);
          }
          (*((object->value.obj.handlers)->write_property))(object, property, z, (struct _zend_literal  const  *)tmp___14);
        } else {
          (*((object->value.obj.handlers)->write_dimension))(object, property, z);
        }
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(z);
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = z;
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
        } else {

        }
        i_zval_ptr_dtor(z);
      } else {
        zend_error(1 << 1L, "Attempt to assign property of non-object");
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = & executor_globals.uninitialized_zval;
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
        } else {

        }
      }
    } else {

    }
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_binary_assign_op_helper_SPEC_VAR_UNUSED)(int (*binary_op)(zval *result , zval *op1 , zval *op2 ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op_data2 ;
  zend_free_op free_op_data1 ;
  zval **var_ptr ;
  zval *value ;
  int tmp ;
  zval **container ;
  zval **tmp___0 ;
  int tmp___1 ;
  zval *dim ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  temp_variable *__t ;
  long tmp___5 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;
  zend_uint tmp___7 ;
  zend_bool tmp___8 ;
  zval *objval ;
  zval *tmp___9 ;
  long tmp___10 ;
  temp_variable *__t___0 ;

  {
  opline = execute_data->opline;
  switch ((int )opline->extended_value) {
  case 136: 
  tmp = zend_binary_assign_op_obj_helper_SPEC_VAR_UNUSED(binary_op, execute_data);
  return (tmp);
  break;
  case 147: 
  tmp___0 = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  container = tmp___0;
  if (1 << 2 == 1 << 2) {
    tmp___3 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___3) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    tmp___2 = __builtin_expect((long )((int )(*container)->type == 5), 0L);
    if (tmp___2) {
      if (1 << 2 == 1 << 2) {
        if (! ((unsigned int )free_op1.var != (unsigned int )((void *)0))) {
          zval_addref_p(*container);
        } else {

        }
      } else {

      }
      tmp___1 = zend_binary_assign_op_obj_helper_SPEC_VAR_UNUSED(binary_op, execute_data);
      return (tmp___1);
    } else {
      dim = (zval *)((void *)0);
      zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var), container, dim, 1 << 3, 2);
      value = _get_zval_ptr((int )(opline + 1)->op1_type, (znode_op const   *)(& (opline + 1)->op1), (temp_variable const   *)execute_data->Ts, & free_op_data1, 0);
      var_ptr = _get_zval_ptr_ptr_var((opline + 1)->op2.var, (temp_variable const   *)execute_data->Ts, & free_op_data2);
    }
  }
  break;
  default: 
  value = (zval *)((void *)0);
  var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  break;
  }
  tmp___4 = __builtin_expect((long )((unsigned int )var_ptr == (unsigned int )((void *)0)), 0L);
  if (tmp___4) {
    zend_error_noreturn(1, "Cannot use assign-op operators with overloaded objects nor string offsets");
  } else {

  }
  tmp___5 = __builtin_expect((long )((unsigned int )*var_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
  if (tmp___5) {
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      while (1) {
        __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t->var.ptr = & executor_globals.uninitialized_zval;
        __t->var.ptr_ptr = & __t->var.ptr;
        break;
      }
    } else {

    }
    if (free_op1.var) {
      i_zval_ptr_dtor(free_op1.var);
    } else {

    }
    if (opline->extended_value == 147UL) {
      (execute_data->opline) ++;
    } else {

    }
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  tmp___8 = zval_isref_p(*var_ptr);
  if (tmp___8) {

  } else {
    while (1) {
      tmp___7 = zval_refcount_p(*var_ptr);
      if (tmp___7 > 1U) {
        zval_delref_p(*var_ptr);
        while (1) {
          tmp___6 = _emalloc(sizeof(zval_gc_info ));
          new_zv = (zval *)tmp___6;
          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            new_zv->value = (*var_ptr)->value;
            new_zv->type = (*var_ptr)->type;
            break;
          }
          zval_set_refcount_p(new_zv, 1U);
          zval_unset_isref_p(new_zv);
          break;
        }
        *var_ptr = new_zv;
        _zval_copy_ctor(new_zv);
      } else {

      }
      break;
    }
  }
  tmp___10 = __builtin_expect((long )((int )(*var_ptr)->type == 5), 0L);
  if (tmp___10) {
    if (((*var_ptr)->value.obj.handlers)->get) {
      if (((*var_ptr)->value.obj.handlers)->set) {
        tmp___9 = (*(((*var_ptr)->value.obj.handlers)->get))(*var_ptr);
        objval = tmp___9;
        zval_addref_p(objval);
        (*binary_op)(objval, objval, value);
        (*(((*var_ptr)->value.obj.handlers)->set))(var_ptr, objval);
        i_zval_ptr_dtor(objval);
      } else {
        (*binary_op)(*var_ptr, *var_ptr, value);
      }
    } else {
      (*binary_op)(*var_ptr, *var_ptr, value);
    }
  } else {
    (*binary_op)(*var_ptr, *var_ptr, value);
  }
  if (! ((int )opline->result_type & (1 << 5))) {
    zval_addref_p(*var_ptr);
    while (1) {
      __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
      __t___0->var.ptr = *var_ptr;
      __t___0->var.ptr_ptr = & __t___0->var.ptr;
      break;
    }
  } else {

  }
  if (opline->extended_value == 147UL) {
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
    if (free_op_data2.var) {
      i_zval_ptr_dtor(free_op_data2.var);
    } else {

    }
    if (free_op1.var) {
      i_zval_ptr_dtor(free_op1.var);
    } else {

    }
    (execute_data->opline) ++;
  } else {
    if (free_op1.var) {
      i_zval_ptr_dtor(free_op1.var);
    } else {

    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_ADD_SPEC_VAR_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_UNUSED((int (*)(zval *result , zval *op1 , zval *op2 ))(& add_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SUB_SPEC_VAR_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_UNUSED((int (*)(zval *result , zval *op1 , zval *op2 ))(& sub_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_MUL_SPEC_VAR_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_UNUSED((int (*)(zval *result , zval *op1 , zval *op2 ))(& mul_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_DIV_SPEC_VAR_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_UNUSED((int (*)(zval *result , zval *op1 , zval *op2 ))(& div_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_MOD_SPEC_VAR_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_UNUSED((int (*)(zval *result , zval *op1 , zval *op2 ))(& mod_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SL_SPEC_VAR_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_UNUSED((int (*)(zval *result , zval *op1 , zval *op2 ))(& shift_left_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SR_SPEC_VAR_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_UNUSED((int (*)(zval *result , zval *op1 , zval *op2 ))(& shift_right_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_CONCAT_SPEC_VAR_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_UNUSED((int (*)(zval *result , zval *op1 , zval *op2 ))(& concat_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_OR_SPEC_VAR_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_UNUSED((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_or_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_AND_SPEC_VAR_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_UNUSED((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_and_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_XOR_SPEC_VAR_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_UNUSED((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_xor_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) zend_fetch_var_address_helper_SPEC_VAR_UNUSED)(int type , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *varname ;
  zval **retval ;
  zval tmp_varname ;
  HashTable *target_symbol_table ;
  ulong hash_value ;
  long tmp ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_literal *tmp___1 ;
  zval __attribute__((__visibility__("default")))  **tmp___2 ;
  ulong __attribute__((__visibility__("default")))  tmp___3 ;
  int __attribute__((__visibility__("default")))  tmp___4 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  zend_uint tmp___6 ;
  zend_bool tmp___7 ;
  temp_variable *__t ;
  zend_free_op free_res ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___8 ;
  zend_uint tmp___9 ;
  zend_bool tmp___10 ;

  {
  opline = execute_data->opline;
  varname = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 != 1) {
    tmp = __builtin_expect((long )((int )varname->type != 6), 0L);
    if (tmp) {
      while (1) {
        tmp_varname.value = varname->value;
        tmp_varname.type = varname->type;
        break;
      }
      _zval_copy_ctor(& tmp_varname);
      zval_set_refcount_p(& tmp_varname, 1U);
      zval_unset_isref_p(& tmp_varname);
      if ((int )tmp_varname.type != 6) {
        _convert_to_string(& tmp_varname);
      } else {

      }
      varname = & tmp_varname;
    } else {

    }
  } else {

  }
  if (1 << 3 != 1 << 3) {
    if (1 << 3 == 1) {
      if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
        ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
      } else {
        tmp___0 = zend_fetch_class_by_name((char const   *)(opline->op2.zv)->value.str.val, (unsigned int )(opline->op2.zv)->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), 0);
        ce = (zend_class_entry *)tmp___0;
        while (1) {
          *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
          break;
        }
      }
    } else {
      ce = ((temp_variable *)((char *)execute_data->Ts + opline->op2.var))->class_entry;
    }
    if (1 << 2 == 1) {
      tmp___1 = opline->op1.literal;
    } else {
      tmp___1 = (zend_literal *)((void *)0);
    }
    tmp___2 = zend_std_get_static_property(ce, (char const   *)varname->value.str.val, varname->value.str.len, (unsigned char)0, (struct _zend_literal  const  *)tmp___1);
    retval = (zval **)tmp___2;
    if (free_op1.var) {
      i_zval_ptr_dtor(free_op1.var);
    } else {

    }
  } else {
    target_symbol_table = zend_get_target_symbol_table((int )(opline->extended_value & 1879048192UL));
    if (1 << 2 == 1) {
      hash_value = ((zend_literal *)varname)->hash_value;
    } else {
      if ((unsigned int )varname->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
        if ((unsigned int )varname->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
          hash_value = ((Bucket *)(varname->value.str.val - sizeof(Bucket )))->h;
        } else {
          tmp___3 = zend_hash_func((char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1));
          hash_value = (unsigned long )tmp___3;
        }
      } else {
        tmp___3 = zend_hash_func((char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1));
        hash_value = (unsigned long )tmp___3;
      }
    }
    tmp___4 = zend_hash_quick_find((HashTable const   *)target_symbol_table, (char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1), hash_value, (void **)(& retval));
    if (tmp___4 == (int __attribute__((__visibility__("default")))  )-1) {
      switch (type) {
      case 0: 
      case 6: 
      zend_error(1 << 3L, "Undefined variable: %s", varname->value.str.val);
      case 3: 
      retval = & executor_globals.uninitialized_zval_ptr;
      break;
      case 2: 
      zend_error(1 << 3L, "Undefined variable: %s", varname->value.str.val);
      case 1: 
      zval_addref_p(& executor_globals.uninitialized_zval);
      _zend_hash_quick_add_or_update(target_symbol_table, (char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1), hash_value, (void *)(& executor_globals.uninitialized_zval_ptr), sizeof(zval *), (void **)(& retval), 1);
      break;
      }
    } else {

    }
    switch ((int )(opline->extended_value & 1879048192UL)) {
    case 0x00000000: 
    if (1 << 2 != 1 << 1) {
      if (free_op1.var) {
        i_zval_ptr_dtor(free_op1.var);
      } else {

      }
    } else {

    }
    break;
    case 0x10000000: 
    if (free_op1.var) {
      i_zval_ptr_dtor(free_op1.var);
    } else {

    }
    break;
    case 0x20000000: 
    zval_update_constant(retval, (void *)1);
    break;
    case 0x40000000: 
    if (1 << 2 == 1 << 2) {
      if (! free_op1.var) {
        zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr));
      } else {

      }
    } else {

    }
    break;
    }
  }
  if (1 << 2 != 1) {
    if ((unsigned int )varname == (unsigned int )(& tmp_varname)) {
      _zval_dtor(& tmp_varname);
    } else {

    }
  } else {

  }
  if (opline->extended_value & 67108864UL) {
    tmp___7 = zval_isref_p(*retval);
    if (tmp___7) {

    } else {
      while (1) {
        tmp___6 = zval_refcount_p(*retval);
        if (tmp___6 > 1U) {
          zval_delref_p(*retval);
          while (1) {
            tmp___5 = _emalloc(sizeof(zval_gc_info ));
            new_zv = (zval *)tmp___5;
            ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv->value = (*retval)->value;
              new_zv->type = (*retval)->type;
              break;
            }
            zval_set_refcount_p(new_zv, 1U);
            zval_unset_isref_p(new_zv);
            break;
          }
          *retval = new_zv;
          _zval_copy_ctor(new_zv);
        } else {

        }
        break;
      }
      zval_set_isref_p(*retval);
    }
  } else {

  }
  zval_addref_p(*retval);
  switch (type) {
  case 0: 
  case 3: 
  while (1) {
    __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
    __t->var.ptr = *retval;
    __t->var.ptr_ptr = & __t->var.ptr;
    break;
  }
  break;
  case 6: 
  zend_pzval_unlock_func(*retval, & free_res, 1);
  if ((unsigned int )retval != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
    tmp___10 = zval_isref_p(*retval);
    if (tmp___10) {

    } else {
      while (1) {
        tmp___9 = zval_refcount_p(*retval);
        if (tmp___9 > 1U) {
          zval_delref_p(*retval);
          while (1) {
            tmp___8 = _emalloc(sizeof(zval_gc_info ));
            new_zv___0 = (zval *)tmp___8;
            ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv___0->value = (*retval)->value;
              new_zv___0->type = (*retval)->type;
              break;
            }
            zval_set_refcount_p(new_zv___0, 1U);
            zval_unset_isref_p(new_zv___0);
            break;
          }
          *retval = new_zv___0;
          _zval_copy_ctor(new_zv___0);
        } else {

        }
        break;
      }
    }
  } else {

  }
  zval_addref_p(*retval);
  if (free_res.var) {
    i_zval_ptr_dtor(free_res.var);
  } else {

  }
  default: 
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = retval;
  break;
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_R_SPEC_VAR_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_VAR_UNUSED(0, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_W_SPEC_VAR_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_VAR_UNUSED(1, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_RW_SPEC_VAR_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_VAR_UNUSED(2, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_FUNC_ARG_SPEC_VAR_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  unsigned int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
  opline = execute_data->opline;
  if (execute_data->fbc) {
    if ((execute_data->fbc)->common.arg_info) {
      if ((opline->extended_value & 1048575UL) <= (unsigned long )(execute_data->fbc)->common.num_args) {
        tmp___1 = (unsigned int )((int )((execute_data->fbc)->common.arg_info + ((opline->extended_value & 1048575UL) - 1UL))->pass_by_reference & 3);
      } else {
        tmp___1 = (execute_data->fbc)->common.fn_flags & 50331648U;
      }
    } else {
      tmp___1 = (execute_data->fbc)->common.fn_flags & 50331648U;
    }
    if (tmp___1) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___2 = zend_fetch_var_address_helper_SPEC_VAR_UNUSED(tmp___0, execute_data);
  return (tmp___2);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_UNSET_SPEC_VAR_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_VAR_UNUSED(6, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_IS_SPEC_VAR_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_VAR_UNUSED(3, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_W_SPEC_VAR_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **container ;
  long tmp ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_uint tmp___1 ;
  zend_bool tmp___2 ;
  zend_uint tmp___3 ;
  zend_uint tmp___4 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___5 ;
  zval **retval_ptr ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;
  zend_uint tmp___7 ;
  zend_bool tmp___8 ;
  long tmp___9 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, (zval *)((void *)0), 1 << 3, 1);
  if (1 << 2 == 1 << 2) {
    if ((unsigned int )free_op1.var != (unsigned int )((void *)0)) {
      tmp___4 = zval_refcount_p(free_op1.var);
      if (tmp___4 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___5 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___5 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___2 = zval_isref_p(__t->var.ptr);
                if (tmp___2) {

                } else {
                  tmp___3 = zval_refcount_p(__t->var.ptr);
                  if (tmp___3 > 2U) {
                    while (1) {
                      tmp___1 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___1 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___0 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___0;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  tmp___9 = __builtin_expect((long )(opline->extended_value != 0UL), 0L);
  if (tmp___9) {
    retval_ptr = ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr;
    if (retval_ptr) {
      zval_delref_p(*retval_ptr);
      tmp___8 = zval_isref_p(*retval_ptr);
      if (tmp___8) {

      } else {
        while (1) {
          tmp___7 = zval_refcount_p(*retval_ptr);
          if (tmp___7 > 1U) {
            zval_delref_p(*retval_ptr);
            while (1) {
              tmp___6 = _emalloc(sizeof(zval_gc_info ));
              new_zv___0 = (zval *)tmp___6;
              ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv___0->value = (*retval_ptr)->value;
                new_zv___0->type = (*retval_ptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv___0, 1U);
              zval_unset_isref_p(new_zv___0);
              break;
            }
            *retval_ptr = new_zv___0;
            _zval_copy_ctor(new_zv___0);
          } else {

          }
          break;
        }
        zval_set_isref_p(*retval_ptr);
      }
      zval_addref_p(*retval_ptr);
    } else {

    }
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_RW_SPEC_VAR_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **container ;
  long tmp ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_uint tmp___1 ;
  zend_bool tmp___2 ;
  zend_uint tmp___3 ;
  zend_uint tmp___4 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___5 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, (zval *)((void *)0), 1 << 3, 2);
  if (1 << 2 == 1 << 2) {
    if ((unsigned int )free_op1.var != (unsigned int )((void *)0)) {
      tmp___4 = zval_refcount_p(free_op1.var);
      if (tmp___4 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___5 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___5 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___2 = zval_isref_p(__t->var.ptr);
                if (tmp___2) {

                } else {
                  tmp___3 = zval_refcount_p(__t->var.ptr);
                  if (tmp___3 > 2U) {
                    while (1) {
                      tmp___1 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___1 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___0 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___0;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **container ;
  long tmp ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_uint tmp___1 ;
  zend_bool tmp___2 ;
  zend_uint tmp___3 ;
  zend_uint tmp___4 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___5 ;
  unsigned int tmp___6 ;

  {
  opline = execute_data->opline;
  if (execute_data->fbc) {
    if ((execute_data->fbc)->common.arg_info) {
      if ((opline->extended_value & 1048575UL) <= (unsigned long )(execute_data->fbc)->common.num_args) {
        tmp___6 = (unsigned int )((int )((execute_data->fbc)->common.arg_info + ((opline->extended_value & 1048575UL) - 1UL))->pass_by_reference & 3);
      } else {
        tmp___6 = (execute_data->fbc)->common.fn_flags & 50331648U;
      }
    } else {
      tmp___6 = (execute_data->fbc)->common.fn_flags & 50331648U;
    }
    if (tmp___6) {
      container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
      if (1 << 2 == 1 << 2) {
        tmp = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
        if (tmp) {
          zend_error_noreturn(1, "Cannot use string offset as an array");
        } else {

        }
      } else {

      }
      zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, (zval *)((void *)0), 1 << 3, 1);
      if (1 << 2 == 1 << 2) {
        if ((unsigned int )free_op1.var != (unsigned int )((void *)0)) {
          tmp___4 = zval_refcount_p(free_op1.var);
          if (tmp___4 == 1U) {
            if ((int )(free_op1.var)->type != 5) {
              goto _L;
            } else {
              tmp___5 = zend_objects_store_get_refcount(free_op1.var);
              if (tmp___5 == (zend_uint __attribute__((__visibility__("default")))  )1) {
                _L: /* CIL Label */ 
                while (1) {
                  __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
                  if (__t->var.ptr_ptr) {
                    __t->var.ptr = *(__t->var.ptr_ptr);
                    __t->var.ptr_ptr = & __t->var.ptr;
                    tmp___2 = zval_isref_p(__t->var.ptr);
                    if (tmp___2) {

                    } else {
                      tmp___3 = zval_refcount_p(__t->var.ptr);
                      if (tmp___3 > 2U) {
                        while (1) {
                          tmp___1 = zval_refcount_p(*(__t->var.ptr_ptr));
                          if (tmp___1 > 1U) {
                            zval_delref_p(*(__t->var.ptr_ptr));
                            while (1) {
                              tmp___0 = _emalloc(sizeof(zval_gc_info ));
                              new_zv = (zval *)tmp___0;
                              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                              break;
                            }
                            while (1) {
                              while (1) {
                                new_zv->value = (*(__t->var.ptr_ptr))->value;
                                new_zv->type = (*(__t->var.ptr_ptr))->type;
                                break;
                              }
                              zval_set_refcount_p(new_zv, 1U);
                              zval_unset_isref_p(new_zv);
                              break;
                            }
                            *(__t->var.ptr_ptr) = new_zv;
                            _zval_copy_ctor(new_zv);
                          } else {

                          }
                          break;
                        }
                      } else {

                      }
                    }
                  } else {

                  }
                  break;
                }
              } else {

              }
            }
          } else {

          }
        } else {

        }
      } else {

      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if (1 << 3 == 1 << 3) {
      zend_error_noreturn(1, "Cannot use [] for reading");
    } else {

    }
    container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    zend_fetch_dimension_address_read((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, (zval *)((void *)0), 1 << 3, 0);
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_DIM_SPEC_VAR_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **object_ptr ;
  long tmp ;
  zval *property_name ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_literal *tmp___1 ;
  zval **tmp___2 ;
  zend_free_op free_op_data1 ;
  zend_free_op free_op_data2 ;
  zval *value ;
  zval *dim ;
  zval **variable_ptr_ptr ;
  zval *retval ;
  void __attribute__((__visibility__("default")))  *tmp___3 ;
  char const   *__s ;
  int __l ;
  zval *__z ;
  char __attribute__((__visibility__("default")))  *tmp___4 ;
  temp_variable *__t ;
  temp_variable *__t___0 ;
  int tmp___5 ;
  temp_variable *__t___1 ;
  temp_variable *__t___2 ;
  long tmp___6 ;
  long tmp___7 ;

  {
  opline = execute_data->opline;
  object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  if ((int )(*object_ptr)->type == 5) {
    property_name = (zval *)((void *)0);
    if (1 << 3 == 1) {
      tmp___1 = opline->op2.literal;
    } else {
      tmp___1 = (zend_literal *)((void *)0);
    }
    if (! ((int )opline->result_type & (1 << 5))) {
      tmp___2 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
    } else {
      tmp___2 = (zval **)((void *)0);
    }
    zend_assign_to_object(tmp___2, object_ptr, property_name, (int )(opline + 1)->op1_type, & (opline + 1)->op1, (temp_variable const   *)execute_data->Ts, 147, (zend_literal const   *)tmp___1);
  } else {
    dim = (zval *)((void *)0);
    zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var), object_ptr, dim, 1 << 3, 1);
    value = _get_zval_ptr((int )(opline + 1)->op1_type, (znode_op const   *)(& (opline + 1)->op1), (temp_variable const   *)execute_data->Ts, & free_op_data1, 0);
    variable_ptr_ptr = _get_zval_ptr_ptr_var((opline + 1)->op2.var, (temp_variable const   *)execute_data->Ts, & free_op_data2);
    tmp___7 = __builtin_expect((long )((unsigned int )variable_ptr_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___7) {
      tmp___5 = zend_assign_to_string_offset((temp_variable const   *)((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var)), (zval const   *)value, (int )(opline + 1)->op1_type);
      if (tmp___5) {
        if (! ((int )opline->result_type & (1 << 5))) {
          while (1) {
            tmp___3 = _emalloc(sizeof(zval_gc_info ));
            retval = (zval *)tmp___3;
            ((zval_gc_info *)retval)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            __s = (char const   *)((((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var))->str_offset.str)->value.str.val + ((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var))->str_offset.offset);
            __l = 1;
            __z = retval;
            __z->value.str.len = __l;
            tmp___4 = _estrndup(__s, (unsigned int )__l);
            __z->value.str.val = (char *)tmp___4;
            __z->type = (unsigned char)6;
            break;
          }
          retval->refcount__gc = 1U;
          retval->is_ref__gc = (unsigned char)0;
          while (1) {
            __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t->var.ptr = retval;
            __t->var.ptr_ptr = & __t->var.ptr;
            break;
          }
        } else {

        }
      } else {
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          while (1) {
            __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___0->var.ptr = & executor_globals.uninitialized_zval;
            __t___0->var.ptr_ptr = & __t___0->var.ptr;
            break;
          }
        } else {

        }
      }
    } else {
      tmp___6 = __builtin_expect((long )((unsigned int )*variable_ptr_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
      if (tmp___6) {
        if ((unsigned long )free_op_data1.var & 1UL) {
          _zval_dtor(value);
        } else {

        }
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          while (1) {
            __t___1 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___1->var.ptr = & executor_globals.uninitialized_zval;
            __t___1->var.ptr_ptr = & __t___1->var.ptr;
            break;
          }
        } else {

        }
      } else {
        if ((int )(opline + 1)->op1_type == 1 << 1) {
          value = zend_assign_tmp_to_variable(variable_ptr_ptr, value);
        } else {
          if ((int )(opline + 1)->op1_type == 1) {
            value = zend_assign_const_to_variable(variable_ptr_ptr, value);
          } else {
            value = zend_assign_to_variable(variable_ptr_ptr, value);
          }
        }
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(value);
          while (1) {
            __t___2 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___2->var.ptr = value;
            __t___2->var.ptr_ptr = & __t___2->var.ptr;
            break;
          }
        } else {

        }
      }
    }
    if (free_op_data2.var) {
      i_zval_ptr_dtor(free_op_data2.var);
    } else {

    }
    if ((unsigned int )free_op_data1.var != (unsigned int )((void *)0)) {
      if (((unsigned long )free_op_data1.var & 1UL) == 0UL) {
        i_zval_ptr_dtor(free_op_data1.var);
      } else {

      }
    } else {

    }
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *function_name ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  char *function_name_strval ;
  int function_name_strlen ;
  long tmp___1 ;
  zend_literal *tmp___2 ;
  union _zend_function  __attribute__((__visibility__("default"))) *tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___7 ;
  zend_function *tmp___8 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___9 ;
  zend_bool __attribute__((__visibility__("default")))  tmp___10 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___11 ;
  zval *tmp___12 ;

  {
  opline = execute_data->opline;
  zend_ptr_stack_3_push(& executor_globals.arg_types_stack, (void *)execute_data->fbc, (void *)execute_data->object, (void *)execute_data->called_scope);
  if (1 << 2 == 1) {
    if (*((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot)) {
      ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot);
    } else {
      tmp = zend_fetch_class_by_name((char const   *)(opline->op1.zv)->value.str.val, (unsigned int )(opline->op1.zv)->value.str.len, (zend_literal const   *)(opline->op1.literal + 1), (int )opline->extended_value);
      ce = (zend_class_entry *)tmp;
      tmp___0 = __builtin_expect((long )((unsigned int )ce == (unsigned int )((void *)0)), 0L);
      if (tmp___0) {
        zend_error_noreturn(1, "Class \'%s\' not found", (opline->op1.zv)->value.str.val);
      } else {

      }
      while (1) {
        *((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot) = (void *)ce;
        break;
      }
    }
    execute_data->called_scope = ce;
  } else {
    ce = ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->class_entry;
    if (opline->extended_value == 2UL) {
      execute_data->called_scope = executor_globals.called_scope;
    } else {
      if (opline->extended_value == 1UL) {
        execute_data->called_scope = executor_globals.called_scope;
      } else {
        execute_data->called_scope = ce;
      }
    }
  }
  if (1 << 2 == 1) {
    if (1 << 3 == 1) {
      if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
        execute_data->fbc = (zend_function *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
      } else {
        goto _L___2;
      }
    } else {
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
    _L___1: /* CIL Label */ 
    if (1 << 2 != 1) {
      if (1 << 3 == 1) {
        if ((unsigned int )*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) == (unsigned int )ce) {
          tmp___8 = (zend_function *)*((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U));
        } else {
          tmp___8 = (zend_function *)((void *)0);
        }
        execute_data->fbc = tmp___8;
        if (tmp___8) {

        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      _L: /* CIL Label */ 
      if (1 << 3 != 1 << 3) {
        function_name_strval = (char *)((void *)0);
        function_name_strlen = 0;
        if (1 << 3 == 1) {
          function_name_strval = (opline->op2.zv)->value.str.val;
          function_name_strlen = (opline->op2.zv)->value.str.len;
        } else {
          function_name = (zval *)((void *)0);
          tmp___1 = __builtin_expect((long )((int )function_name->type != 6), 0L);
          if (tmp___1) {
            zend_error_noreturn(1, "Function name must be a string");
          } else {
            function_name_strval = function_name->value.str.val;
            function_name_strlen = function_name->value.str.len;
          }
        }
        if (function_name_strval) {
          if (ce->get_static_method) {
            execute_data->fbc = (*(ce->get_static_method))(ce, function_name_strval, function_name_strlen);
          } else {
            if (1 << 3 == 1) {
              tmp___2 = opline->op2.literal + 1;
            } else {
              tmp___2 = (zend_literal *)((void *)0);
            }
            tmp___3 = zend_std_get_static_method(ce, (char const   *)function_name_strval, function_name_strlen, (struct _zend_literal  const  *)tmp___2);
            execute_data->fbc = (zend_function *)tmp___3;
          }
          tmp___4 = __builtin_expect((long )((unsigned int )execute_data->fbc == (unsigned int )((void *)0)), 0L);
          if (tmp___4) {
            zend_error_noreturn(1, "Call to undefined method %s::%s()", ce->name, function_name_strval);
          } else {

          }
          if (1 << 3 == 1) {
            tmp___5 = __builtin_expect((long )(((execute_data->fbc)->common.fn_flags & 6291456U) == 0U), 1L);
            if (tmp___5) {
              if (1 << 2 == 1) {
                while (1) {
                  *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)execute_data->fbc;
                  break;
                }
              } else {
                while (1) {
                  *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
                  *((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U)) = (void *)execute_data->fbc;
                  break;
                }
              }
            } else {

            }
          } else {

          }
        } else {

        }
        if (1 << 3 != 1) {

        } else {

        }
      } else {
        tmp___6 = __builtin_expect((long )((unsigned int )ce->constructor == (unsigned int )((void *)0)), 0L);
        if (tmp___6) {
          zend_error_noreturn(1, "Cannot call constructor");
        } else {

        }
        if (executor_globals.This) {
          tmp___7 = zend_get_class_entry((zval const   *)executor_globals.This);
          if ((unsigned int )tmp___7 != (unsigned int )(ce->constructor)->common.scope) {
            if ((ce->constructor)->common.fn_flags & 1024U) {
              zend_error_noreturn(1, "Cannot call private %s::__construct()", ce->name);
            } else {

            }
          } else {

          }
        } else {

        }
        execute_data->fbc = ce->constructor;
      }
    }
  }
  if ((execute_data->fbc)->common.fn_flags & 1U) {
    execute_data->object = (zval *)((void *)0);
  } else {
    if (executor_globals.This) {
      if (((executor_globals.This)->value.obj.handlers)->get_class_entry) {
        tmp___9 = zend_get_class_entry((zval const   *)executor_globals.This);
        tmp___10 = instanceof_function((zend_class_entry const   *)tmp___9, (zend_class_entry const   *)ce);
        if (tmp___10) {

        } else {
          if ((execute_data->fbc)->common.fn_flags & 65536U) {
            zend_error(1 << 11L, "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", ((execute_data->fbc)->common.scope)->name, (execute_data->fbc)->common.function_name);
          } else {
            zend_error_noreturn(1, "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", ((execute_data->fbc)->common.scope)->name, (execute_data->fbc)->common.function_name);
          }
        }
      } else {

      }
    } else {

    }
    tmp___12 = executor_globals.This;
    execute_data->object = tmp___12;
    if (tmp___12) {
      zval_addref_p(execute_data->object);
      tmp___11 = zend_get_class_entry((zval const   *)execute_data->object);
      execute_data->called_scope = (zend_class_entry *)tmp___11;
    } else {

    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *expr_ptr ;
  zval **expr_ptr_ptr ;
  zval **tmp ;
  long tmp___0 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zval *new_expr ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zval *new_expr___0 ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  zend_bool tmp___6 ;
  zval *offset ;
  ulong hval ;
  long tmp___7 ;
  register char const   *tmp___8 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___9 ;

  {
  opline = execute_data->opline;
  if (1 << 2 == 1 << 2) {
    goto _L___1;
  } else {
    if (1 << 2 == 1 << 4) {
      _L___1: /* CIL Label */ 
      if (opline->extended_value) {
        tmp = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
        expr_ptr_ptr = tmp;
        if (1 << 2 == 1 << 2) {
          tmp___0 = __builtin_expect((long )((unsigned int )expr_ptr_ptr == (unsigned int )((void *)0)), 0L);
          if (tmp___0) {
            zend_error_noreturn(1, "Cannot create references to/from string offsets");
          } else {

          }
        } else {

        }
        tmp___3 = zval_isref_p(*expr_ptr_ptr);
        if (tmp___3) {

        } else {
          while (1) {
            tmp___2 = zval_refcount_p(*expr_ptr_ptr);
            if (tmp___2 > 1U) {
              zval_delref_p(*expr_ptr_ptr);
              while (1) {
                tmp___1 = _emalloc(sizeof(zval_gc_info ));
                new_zv = (zval *)tmp___1;
                ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv->value = (*expr_ptr_ptr)->value;
                  new_zv->type = (*expr_ptr_ptr)->type;
                  break;
                }
                zval_set_refcount_p(new_zv, 1U);
                zval_unset_isref_p(new_zv);
                break;
              }
              *expr_ptr_ptr = new_zv;
              _zval_copy_ctor(new_zv);
            } else {

            }
            break;
          }
          zval_set_isref_p(*expr_ptr_ptr);
        }
        expr_ptr = *expr_ptr_ptr;
        zval_addref_p(expr_ptr);
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      expr_ptr = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
      if (1 << 2 == 1) {
        goto _L;
      } else {
        tmp___6 = zval_isref_p(expr_ptr);
        if (tmp___6) {
          _L: /* CIL Label */ 
          while (1) {
            tmp___5 = _emalloc(sizeof(zval_gc_info ));
            new_expr___0 = (zval *)tmp___5;
            ((zval_gc_info *)new_expr___0)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_expr___0->value = expr_ptr->value;
              new_expr___0->type = expr_ptr->type;
              break;
            }
            zval_set_refcount_p(new_expr___0, 1U);
            zval_unset_isref_p(new_expr___0);
            break;
          }
          expr_ptr = new_expr___0;
          _zval_copy_ctor(expr_ptr);
        } else {
          zval_addref_p(expr_ptr);
        }
      }
    }
  }
  if (1 << 3 != 1 << 3) {
    offset = (zval *)((void *)0);
    switch ((int )offset->type) {
    case 2: 
    tmp___7 = zend_dval_to_lval(offset->value.dval);
    hval = (unsigned long )tmp___7;
    goto num_index;
    case 1: 
    case 3: 
    hval = (unsigned long )offset->value.lval;
    num_index: 
    _zend_hash_index_update_or_next_insert(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, hval, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    case 6: 
    if (1 << 3 == 1) {
      hval = ((zend_literal *)offset)->hash_value;
    } else {
      while (1) {
        tmp___8 = (char const   *)offset->value.str.val;
        if ((int const   )*tmp___8 == 45) {
          tmp___8 ++;
        } else {

        }
        if ((int const   )*tmp___8 >= 48) {
          if ((int const   )*tmp___8 <= 57) {
            end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
            if ((int const   )*end != 0) {
              break;
            } else {
              if ((int const   )*tmp___8 == 48) {
                if (offset->value.str.len + 1 > 2) {
                  break;
                } else {
                  goto _L___2;
                }
              } else {
                _L___2: /* CIL Label */ 
                if (end - tmp___8 > 10) {
                  break;
                } else {
                  if (end - tmp___8 == 10) {
                    if ((int const   )*tmp___8 > 50) {
                      break;
                    } else {

                    }
                  } else {

                  }
                }
              }
            }
            hval = (unsigned long )((int const   )*tmp___8 - 48);
            while (1) {
              tmp___8 ++;
              if ((unsigned int )tmp___8 != (unsigned int )end) {
                if ((int const   )*tmp___8 >= 48) {
                  if ((int const   )*tmp___8 <= 57) {

                  } else {
                    break;
                  }
                } else {
                  break;
                }
              } else {
                break;
              }
              hval = hval * 10UL + (ulong )((int const   )*tmp___8 - 48);
            }
            if ((unsigned int )tmp___8 == (unsigned int )end) {
              if ((int )*(offset->value.str.val) == 45) {
                if (hval - 1UL > 2147483647UL) {
                  break;
                } else {

                }
                hval = (unsigned long )(- ((long )hval));
              } else {
                if (hval > 2147483647UL) {
                  break;
                } else {

                }
              }
              goto num_index;
            } else {

            }
          } else {

          }
        } else {

        }
        break;
      }
      if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
        if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
          hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
        } else {
          tmp___9 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___9;
        }
      } else {
        tmp___9 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
        hval = (unsigned long )tmp___9;
      }
    }
    _zend_hash_quick_add_or_update(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    case 0: 
    _zend_hash_add_or_update(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, "", sizeof(""), (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    default: 
    zend_error(1 << 1L, "Illegal offset type");
    i_zval_ptr_dtor(expr_ptr);
    break;
    }
  } else {
    _zend_hash_index_update_or_next_insert(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, 0UL, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1 << 2);
  }
  if (1 << 2 == 1 << 2) {
    goto _L___4;
  } else {
    if (1 << 2 == 1 << 4) {
      _L___4: /* CIL Label */ 
      if (opline->extended_value) {
        if (free_op1.var) {
          i_zval_ptr_dtor(free_op1.var);
        } else {

        }
      } else {
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ 
      if (free_op1.var) {
        i_zval_ptr_dtor(free_op1.var);
      } else {

      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_ARRAY_SPEC_VAR_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  int tmp ;

  {
  opline = execute_data->opline;
  _array_init(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, 0U);
  if (1 << 2 == 1 << 3) {
    (execute_data->opline) ++;
    return (0);
  } else {
    tmp = ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_UNUSED_HANDLER(execute_data);
    return (tmp);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_UNSET_VAR_SPEC_VAR_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval tmp ;
  zval *varname ;
  HashTable *target_symbol_table ;
  zend_free_op free_op1 ;
  zend_compiled_variable *cv ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_literal *tmp___1 ;
  ulong hash_value ;
  ulong tmp___2 ;

  {
  opline = execute_data->opline;
  if (1 << 2 == 1 << 4) {
    if (1 << 3 == 1 << 3) {
      if (opline->extended_value & 8388608UL) {
        if (executor_globals.active_symbol_table) {
          cv = (executor_globals.active_op_array)->vars + opline->op1.var;
          zend_delete_variable(execute_data->prev_execute_data, executor_globals.active_symbol_table, cv->name, cv->name_len + 1, cv->hash_value);
          *(execute_data->CVs + opline->op1.var) = (zval **)((void *)0);
        } else {
          if (*(execute_data->CVs + opline->op1.var)) {
            i_zval_ptr_dtor(*(*(execute_data->CVs + opline->op1.var)));
            *(execute_data->CVs + opline->op1.var) = (zval **)((void *)0);
          } else {

          }
        }
        (execute_data->opline) ++;
        return (0);
      } else {

      }
    } else {

    }
  } else {

  }
  varname = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 != 1) {
    if ((int )varname->type != 6) {
      while (1) {
        tmp.value = varname->value;
        tmp.type = varname->type;
        break;
      }
      _zval_copy_ctor(& tmp);
      if ((int )tmp.type != 6) {
        _convert_to_string(& tmp);
      } else {

      }
      varname = & tmp;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if (1 << 2 == 1 << 2) {
      zval_addref_p(varname);
    } else {
      if (1 << 2 == 1 << 4) {
        zval_addref_p(varname);
      } else {

      }
    }
  }
  if (1 << 3 != 1 << 3) {
    if (1 << 3 == 1) {
      if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
        ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
      } else {
        tmp___0 = zend_fetch_class_by_name((char const   *)(opline->op2.zv)->value.str.val, (unsigned int )(opline->op2.zv)->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), 0);
        ce = (zend_class_entry *)tmp___0;
        while (1) {
          *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
          break;
        }
      }
    } else {
      ce = ((temp_variable *)((char *)execute_data->Ts + opline->op2.var))->class_entry;
    }
    if (1 << 2 == 1) {
      tmp___1 = opline->op1.literal;
    } else {
      tmp___1 = (zend_literal *)((void *)0);
    }
    zend_std_unset_static_property(ce, (char const   *)varname->value.str.val, varname->value.str.len, (struct _zend_literal  const  *)tmp___1);
  } else {
    tmp___2 = zend_inline_hash_func((char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1));
    hash_value = tmp___2;
    target_symbol_table = zend_get_target_symbol_table((int )(opline->extended_value & 1879048192UL));
    zend_delete_variable(execute_data, target_symbol_table, (char const   *)varname->value.str.val, varname->value.str.len + 1, hash_value);
  }
  if (1 << 2 != 1) {
    if ((unsigned int )varname == (unsigned int )(& tmp)) {
      _zval_dtor(& tmp);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if (1 << 2 == 1 << 2) {
      i_zval_ptr_dtor(varname);
    } else {
      if (1 << 2 == 1 << 4) {
        i_zval_ptr_dtor(varname);
      } else {

      }
    }
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ISSET_ISEMPTY_VAR_SPEC_VAR_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **value ;
  zend_bool isset ;
  zend_compiled_variable *cv ;
  int __attribute__((__visibility__("default")))  tmp ;
  HashTable *target_symbol_table ;
  zend_free_op free_op1 ;
  zval tmp___0 ;
  zval *varname ;
  zval *tmp___1 ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_literal *tmp___3 ;
  zval __attribute__((__visibility__("default")))  **tmp___4 ;
  int __attribute__((__visibility__("default")))  tmp___5 ;
  zval *__z ;
  zval *__z___0 ;
  zval *__z___1 ;
  zval *__z___2 ;
  int tmp___6 ;

  {
  opline = execute_data->opline;
  isset = (zend_bool )1;
  if (1 << 2 == 1 << 4) {
    if (1 << 3 == 1 << 3) {
      if (opline->extended_value & 8388608UL) {
        if (*(execute_data->CVs + opline->op1.var)) {
          value = *(execute_data->CVs + opline->op1.var);
        } else {
          if (executor_globals.active_symbol_table) {
            cv = (executor_globals.active_op_array)->vars + opline->op1.var;
            tmp = zend_hash_quick_find((HashTable const   *)executor_globals.active_symbol_table, cv->name, (unsigned int )(cv->name_len + 1), cv->hash_value, (void **)(& value));
            if (tmp == (int __attribute__((__visibility__("default")))  )-1) {
              isset = (unsigned char)0;
            } else {

            }
          } else {
            isset = (unsigned char)0;
          }
        }
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    _L: /* CIL Label */ 
    tmp___1 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    varname = tmp___1;
    if (1 << 2 != 1) {
      if ((int )varname->type != 6) {
        while (1) {
          tmp___0.value = varname->value;
          tmp___0.type = varname->type;
          break;
        }
        _zval_copy_ctor(& tmp___0);
        if ((int )tmp___0.type != 6) {
          _convert_to_string(& tmp___0);
        } else {

        }
        varname = & tmp___0;
      } else {

      }
    } else {

    }
    if (1 << 3 != 1 << 3) {
      if (1 << 3 == 1) {
        if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
          ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
        } else {
          tmp___2 = zend_fetch_class_by_name((char const   *)(opline->op2.zv)->value.str.val, (unsigned int )(opline->op2.zv)->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), 0);
          ce = (zend_class_entry *)tmp___2;
          while (1) {
            *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
            break;
          }
        }
      } else {
        ce = ((temp_variable *)((char *)execute_data->Ts + opline->op2.var))->class_entry;
      }
      if (1 << 2 == 1) {
        tmp___3 = opline->op1.literal;
      } else {
        tmp___3 = (zend_literal *)((void *)0);
      }
      tmp___4 = zend_std_get_static_property(ce, (char const   *)varname->value.str.val, varname->value.str.len, (unsigned char)1, (struct _zend_literal  const  *)tmp___3);
      value = (zval **)tmp___4;
      if (! value) {
        isset = (unsigned char)0;
      } else {

      }
    } else {
      target_symbol_table = zend_get_target_symbol_table((int )(opline->extended_value & 1879048192UL));
      tmp___5 = zend_hash_find((HashTable const   *)target_symbol_table, (char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1), (void **)(& value));
      if (tmp___5 == (int __attribute__((__visibility__("default")))  )-1) {
        isset = (unsigned char)0;
      } else {

      }
    }
    if (1 << 2 != 1) {
      if ((unsigned int )varname == (unsigned int )(& tmp___0)) {
        _zval_dtor(& tmp___0);
      } else {

      }
    } else {

    }
    if (free_op1.var) {
      i_zval_ptr_dtor(free_op1.var);
    } else {

    }
  }
  if (opline->extended_value & 33554432UL) {
    if (isset) {
      if ((int )(*value)->type != 0) {
        while (1) {
          __z = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
          __z->value.lval = 1L;
          __z->type = (unsigned char)3;
          break;
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      while (1) {
        __z___0 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
        __z___0->value.lval = 0L;
        __z___0->type = (unsigned char)3;
        break;
      }
    }
  } else {
    if (! isset) {
      goto _L___2;
    } else {
      tmp___6 = i_zend_is_true(*value);
      if (tmp___6) {
        while (1) {
          __z___2 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
          __z___2->value.lval = 0L;
          __z___2->type = (unsigned char)3;
          break;
        }
      } else {
        _L___2: /* CIL Label */ 
        while (1) {
          __z___1 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
          __z___1->value.lval = 1L;
          __z___1->type = (unsigned char)3;
          break;
        }
      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SEPARATE_SPEC_VAR_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *var_ptr ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_bool tmp___0 ;
  zend_uint tmp___1 ;

  {
  opline = execute_data->opline;
  var_ptr = ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr;
  if ((int )var_ptr->type != 5) {
    tmp___0 = zval_isref_p(var_ptr);
    if (tmp___0) {

    } else {
      tmp___1 = zval_refcount_p(var_ptr);
      if (tmp___1 > 1U) {
        zval_delref_p(var_ptr);
        while (1) {
          tmp = _emalloc(sizeof(zval_gc_info ));
          new_zv = (zval *)tmp;
          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            new_zv->value = var_ptr->value;
            new_zv->type = var_ptr->type;
            break;
          }
          zval_set_refcount_p(new_zv, 1U);
          zval_unset_isref_p(new_zv);
          break;
        }
        var_ptr = new_zv;
        _zval_copy_ctor(var_ptr);
        ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr = var_ptr;
      } else {

      }
    }
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  fast_add_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SUB_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  fast_sub_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_MUL_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  fast_mul_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_DIV_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  fast_div_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_MOD_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  fast_mod_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SL_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  shift_left_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SR_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  shift_right_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_CONCAT_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  concat_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_IDENTICAL_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  is_identical_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_NOT_IDENTICAL_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *result ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  is_identical_function(result, tmp___0, tmp);
  result->value.lval = (long )(! result->value.lval);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_EQUAL_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  zval *tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
    tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    tmp___1 = fast_equal_function(result, tmp___0, tmp);
    __z->value.lval = (long )(tmp___1 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_NOT_EQUAL_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  zval *tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
    tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    tmp___1 = fast_not_equal_function(result, tmp___0, tmp);
    __z->value.lval = (long )(tmp___1 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_SMALLER_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  zval *tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
    tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    tmp___1 = fast_is_smaller_function(result, tmp___0, tmp);
    __z->value.lval = (long )(tmp___1 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_SMALLER_OR_EQUAL_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  zval *tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
    tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    tmp___1 = fast_is_smaller_or_equal_function(result, tmp___0, tmp);
    __z->value.lval = (long )(tmp___1 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_OR_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  bitwise_or_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_AND_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  bitwise_and_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_XOR_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  bitwise_xor_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BOOL_XOR_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  boolean_xor_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_binary_assign_op_obj_helper_SPEC_VAR_CV)(int (*binary_op)(zval *result , zval *op1 , zval *op2 ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op_data1 ;
  zval **object_ptr ;
  zval **tmp ;
  zval *object ;
  zval *property ;
  zval *tmp___0 ;
  zval *value ;
  zval *tmp___1 ;
  int have_get_ptr ;
  long tmp___2 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___3 ;
  zval **zptr ;
  zend_literal *tmp___4 ;
  zval **tmp___5 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;
  zend_uint tmp___7 ;
  zend_bool tmp___8 ;
  zval *z ;
  zend_literal *tmp___9 ;
  zval *value___0 ;
  zval *tmp___10 ;
  zend_uint tmp___11 ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___12 ;
  zend_uint tmp___13 ;
  zend_bool tmp___14 ;
  zend_literal *tmp___15 ;
  long tmp___16 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  object_ptr = tmp;
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  property = tmp___0;
  tmp___1 = _get_zval_ptr((int )(opline + 1)->op1_type, (znode_op const   *)(& (opline + 1)->op1), (temp_variable const   *)execute_data->Ts, & free_op_data1, 0);
  value = tmp___1;
  have_get_ptr = 0;
  if (1 << 2 == 1 << 2) {
    tmp___2 = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___2) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  make_real_object(object_ptr);
  object = *object_ptr;
  tmp___16 = __builtin_expect((long )((int )object->type != 5), 0L);
  if (tmp___16) {
    zend_error(1 << 1L, "Attempt to assign property of non-object");
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = & executor_globals.uninitialized_zval;
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
    } else {

    }
  } else {
    if (opline->extended_value == 136UL) {
      if ((object->value.obj.handlers)->get_property_ptr_ptr) {
        if (1 << 4 == 1) {
          tmp___4 = opline->op2.literal;
        } else {
          tmp___4 = (zend_literal *)((void *)0);
        }
        tmp___5 = (*((object->value.obj.handlers)->get_property_ptr_ptr))(object, property, (struct _zend_literal  const  *)tmp___4);
        zptr = tmp___5;
        if ((unsigned int )zptr != (unsigned int )((void *)0)) {
          tmp___8 = zval_isref_p(*zptr);
          if (tmp___8) {

          } else {
            while (1) {
              tmp___7 = zval_refcount_p(*zptr);
              if (tmp___7 > 1U) {
                zval_delref_p(*zptr);
                while (1) {
                  tmp___6 = _emalloc(sizeof(zval_gc_info ));
                  new_zv = (zval *)tmp___6;
                  ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                  break;
                }
                while (1) {
                  while (1) {
                    new_zv->value = (*zptr)->value;
                    new_zv->type = (*zptr)->type;
                    break;
                  }
                  zval_set_refcount_p(new_zv, 1U);
                  zval_unset_isref_p(new_zv);
                  break;
                }
                *zptr = new_zv;
                _zval_copy_ctor(new_zv);
              } else {

              }
              break;
            }
          }
          have_get_ptr = 1;
          (*binary_op)(*zptr, *zptr, value);
          if (! ((int )opline->result_type & (1 << 5))) {
            zval_addref_p(*zptr);
            ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = *zptr;
            ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
          } else {

          }
        } else {

        }
      } else {

      }
    } else {

    }
    if (! have_get_ptr) {
      z = (zval *)((void *)0);
      if (opline->extended_value == 136UL) {
        if ((object->value.obj.handlers)->read_property) {
          if (1 << 4 == 1) {
            tmp___9 = opline->op2.literal;
          } else {
            tmp___9 = (zend_literal *)((void *)0);
          }
          z = (*((object->value.obj.handlers)->read_property))(object, property, 0, (struct _zend_literal  const  *)tmp___9);
        } else {

        }
      } else {
        if ((object->value.obj.handlers)->read_dimension) {
          z = (*((object->value.obj.handlers)->read_dimension))(object, property, 0);
        } else {

        }
      }
      if (z) {
        if ((int )z->type == 5) {
          if ((z->value.obj.handlers)->get) {
            tmp___10 = (*((z->value.obj.handlers)->get))(z);
            value___0 = tmp___10;
            tmp___11 = zval_refcount_p(z);
            if (tmp___11 == 0U) {
              if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                gc_remove_zval_from_buffer(z);
              } else {

              }
              _zval_dtor(z);
              while (1) {
                if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                  gc_remove_zval_from_buffer(z);
                } else {

                }
                _efree((void *)z);
                break;
              }
            } else {

            }
            z = value___0;
          } else {

          }
        } else {

        }
        zval_addref_p(z);
        tmp___14 = zval_isref_p(z);
        if (tmp___14) {

        } else {
          while (1) {
            tmp___13 = zval_refcount_p(z);
            if (tmp___13 > 1U) {
              zval_delref_p(z);
              while (1) {
                tmp___12 = _emalloc(sizeof(zval_gc_info ));
                new_zv___0 = (zval *)tmp___12;
                ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv___0->value = z->value;
                  new_zv___0->type = z->type;
                  break;
                }
                zval_set_refcount_p(new_zv___0, 1U);
                zval_unset_isref_p(new_zv___0);
                break;
              }
              z = new_zv___0;
              _zval_copy_ctor(new_zv___0);
            } else {

            }
            break;
          }
        }
        (*binary_op)(z, z, value);
        if (opline->extended_value == 136UL) {
          if (1 << 4 == 1) {
            tmp___15 = opline->op2.literal;
          } else {
            tmp___15 = (zend_literal *)((void *)0);
          }
          (*((object->value.obj.handlers)->write_property))(object, property, z, (struct _zend_literal  const  *)tmp___15);
        } else {
          (*((object->value.obj.handlers)->write_dimension))(object, property, z);
        }
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(z);
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = z;
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
        } else {

        }
        i_zval_ptr_dtor(z);
      } else {
        zend_error(1 << 1L, "Attempt to assign property of non-object");
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = & executor_globals.uninitialized_zval;
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
        } else {

        }
      }
    } else {

    }
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_binary_assign_op_helper_SPEC_VAR_CV)(int (*binary_op)(zval *result , zval *op1 , zval *op2 ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op_data2 ;
  zend_free_op free_op_data1 ;
  zval **var_ptr ;
  zval *value ;
  int tmp ;
  zval **container ;
  zval **tmp___0 ;
  int tmp___1 ;
  zval *dim ;
  zval *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  temp_variable *__t ;
  long tmp___6 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___7 ;
  zend_uint tmp___8 ;
  zend_bool tmp___9 ;
  zval *objval ;
  zval *tmp___10 ;
  long tmp___11 ;
  temp_variable *__t___0 ;

  {
  opline = execute_data->opline;
  switch ((int )opline->extended_value) {
  case 136: 
  tmp = zend_binary_assign_op_obj_helper_SPEC_VAR_CV(binary_op, execute_data);
  return (tmp);
  break;
  case 147: 
  tmp___0 = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  container = tmp___0;
  if (1 << 2 == 1 << 2) {
    tmp___4 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___4) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    tmp___3 = __builtin_expect((long )((int )(*container)->type == 5), 0L);
    if (tmp___3) {
      if (1 << 2 == 1 << 2) {
        if (! ((unsigned int )free_op1.var != (unsigned int )((void *)0))) {
          zval_addref_p(*container);
        } else {

        }
      } else {

      }
      tmp___1 = zend_binary_assign_op_obj_helper_SPEC_VAR_CV(binary_op, execute_data);
      return (tmp___1);
    } else {
      tmp___2 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
      dim = tmp___2;
      zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var), container, dim, 1 << 4, 2);
      value = _get_zval_ptr((int )(opline + 1)->op1_type, (znode_op const   *)(& (opline + 1)->op1), (temp_variable const   *)execute_data->Ts, & free_op_data1, 0);
      var_ptr = _get_zval_ptr_ptr_var((opline + 1)->op2.var, (temp_variable const   *)execute_data->Ts, & free_op_data2);
    }
  }
  break;
  default: 
  value = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  break;
  }
  tmp___5 = __builtin_expect((long )((unsigned int )var_ptr == (unsigned int )((void *)0)), 0L);
  if (tmp___5) {
    zend_error_noreturn(1, "Cannot use assign-op operators with overloaded objects nor string offsets");
  } else {

  }
  tmp___6 = __builtin_expect((long )((unsigned int )*var_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
  if (tmp___6) {
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      while (1) {
        __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t->var.ptr = & executor_globals.uninitialized_zval;
        __t->var.ptr_ptr = & __t->var.ptr;
        break;
      }
    } else {

    }
    if (free_op1.var) {
      i_zval_ptr_dtor(free_op1.var);
    } else {

    }
    if (opline->extended_value == 147UL) {
      (execute_data->opline) ++;
    } else {

    }
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  tmp___9 = zval_isref_p(*var_ptr);
  if (tmp___9) {

  } else {
    while (1) {
      tmp___8 = zval_refcount_p(*var_ptr);
      if (tmp___8 > 1U) {
        zval_delref_p(*var_ptr);
        while (1) {
          tmp___7 = _emalloc(sizeof(zval_gc_info ));
          new_zv = (zval *)tmp___7;
          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            new_zv->value = (*var_ptr)->value;
            new_zv->type = (*var_ptr)->type;
            break;
          }
          zval_set_refcount_p(new_zv, 1U);
          zval_unset_isref_p(new_zv);
          break;
        }
        *var_ptr = new_zv;
        _zval_copy_ctor(new_zv);
      } else {

      }
      break;
    }
  }
  tmp___11 = __builtin_expect((long )((int )(*var_ptr)->type == 5), 0L);
  if (tmp___11) {
    if (((*var_ptr)->value.obj.handlers)->get) {
      if (((*var_ptr)->value.obj.handlers)->set) {
        tmp___10 = (*(((*var_ptr)->value.obj.handlers)->get))(*var_ptr);
        objval = tmp___10;
        zval_addref_p(objval);
        (*binary_op)(objval, objval, value);
        (*(((*var_ptr)->value.obj.handlers)->set))(var_ptr, objval);
        i_zval_ptr_dtor(objval);
      } else {
        (*binary_op)(*var_ptr, *var_ptr, value);
      }
    } else {
      (*binary_op)(*var_ptr, *var_ptr, value);
    }
  } else {
    (*binary_op)(*var_ptr, *var_ptr, value);
  }
  if (! ((int )opline->result_type & (1 << 5))) {
    zval_addref_p(*var_ptr);
    while (1) {
      __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
      __t___0->var.ptr = *var_ptr;
      __t___0->var.ptr_ptr = & __t___0->var.ptr;
      break;
    }
  } else {

  }
  if (opline->extended_value == 147UL) {
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
    if (free_op_data2.var) {
      i_zval_ptr_dtor(free_op_data2.var);
    } else {

    }
    if (free_op1.var) {
      i_zval_ptr_dtor(free_op1.var);
    } else {

    }
    (execute_data->opline) ++;
  } else {
    if (free_op1.var) {
      i_zval_ptr_dtor(free_op1.var);
    } else {

    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_ADD_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_CV((int (*)(zval *result , zval *op1 , zval *op2 ))(& add_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SUB_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_CV((int (*)(zval *result , zval *op1 , zval *op2 ))(& sub_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_MUL_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_CV((int (*)(zval *result , zval *op1 , zval *op2 ))(& mul_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_DIV_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_CV((int (*)(zval *result , zval *op1 , zval *op2 ))(& div_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_MOD_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_CV((int (*)(zval *result , zval *op1 , zval *op2 ))(& mod_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SL_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_CV((int (*)(zval *result , zval *op1 , zval *op2 ))(& shift_left_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SR_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_CV((int (*)(zval *result , zval *op1 , zval *op2 ))(& shift_right_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_CONCAT_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_CV((int (*)(zval *result , zval *op1 , zval *op2 ))(& concat_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_OR_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_CV((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_or_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_AND_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_CV((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_and_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_XOR_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_VAR_CV((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_xor_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) zend_pre_incdec_property_helper_SPEC_VAR_CV)(int (*incdec_op)(zval * ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **object_ptr ;
  zval *object ;
  zval *property ;
  zval **retval ;
  int have_get_ptr ;
  long tmp ;
  long tmp___0 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zval **zptr ;
  zend_literal *tmp___2 ;
  zval **tmp___3 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_uint tmp___5 ;
  zend_bool tmp___6 ;
  zval *z ;
  zend_literal *tmp___7 ;
  zval *tmp___8 ;
  zval *value ;
  zval *tmp___9 ;
  zend_uint tmp___10 ;
  long tmp___11 ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___12 ;
  zend_uint tmp___13 ;
  zend_bool tmp___14 ;
  zend_literal *tmp___15 ;

  {
  opline = execute_data->opline;
  have_get_ptr = 0;
  object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  property = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  retval = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
  if (1 << 2 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot increment/decrement overloaded objects nor string offsets");
    } else {

    }
  } else {

  }
  make_real_object(object_ptr);
  object = *object_ptr;
  tmp___0 = __builtin_expect((long )((int )object->type != 5), 0L);
  if (tmp___0) {
    zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      *retval = & executor_globals.uninitialized_zval;
    } else {

    }
    if (free_op1.var) {
      i_zval_ptr_dtor(free_op1.var);
    } else {

    }
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  if ((object->value.obj.handlers)->get_property_ptr_ptr) {
    if (1 << 4 == 1) {
      tmp___2 = opline->op2.literal;
    } else {
      tmp___2 = (zend_literal *)((void *)0);
    }
    tmp___3 = (*((object->value.obj.handlers)->get_property_ptr_ptr))(object, property, (struct _zend_literal  const  *)tmp___2);
    zptr = tmp___3;
    if ((unsigned int )zptr != (unsigned int )((void *)0)) {
      tmp___6 = zval_isref_p(*zptr);
      if (tmp___6) {

      } else {
        while (1) {
          tmp___5 = zval_refcount_p(*zptr);
          if (tmp___5 > 1U) {
            zval_delref_p(*zptr);
            while (1) {
              tmp___4 = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp___4;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*zptr)->value;
                new_zv->type = (*zptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *zptr = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
      have_get_ptr = 1;
      (*incdec_op)(*zptr);
      if (! ((int )opline->result_type & (1 << 5))) {
        *retval = *zptr;
        zval_addref_p(*retval);
      } else {

      }
    } else {

    }
  } else {

  }
  if (! have_get_ptr) {
    if ((object->value.obj.handlers)->read_property) {
      if ((object->value.obj.handlers)->write_property) {
        if (1 << 4 == 1) {
          tmp___7 = opline->op2.literal;
        } else {
          tmp___7 = (zend_literal *)((void *)0);
        }
        tmp___8 = (*((object->value.obj.handlers)->read_property))(object, property, 0, (struct _zend_literal  const  *)tmp___7);
        z = tmp___8;
        tmp___11 = __builtin_expect((long )((int )z->type == 5), 0L);
        if (tmp___11) {
          if ((z->value.obj.handlers)->get) {
            tmp___9 = (*((z->value.obj.handlers)->get))(z);
            value = tmp___9;
            tmp___10 = zval_refcount_p(z);
            if (tmp___10 == 0U) {
              if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                gc_remove_zval_from_buffer(z);
              } else {

              }
              _zval_dtor(z);
              while (1) {
                if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                  gc_remove_zval_from_buffer(z);
                } else {

                }
                _efree((void *)z);
                break;
              }
            } else {

            }
            z = value;
          } else {

          }
        } else {

        }
        zval_addref_p(z);
        tmp___14 = zval_isref_p(z);
        if (tmp___14) {

        } else {
          while (1) {
            tmp___13 = zval_refcount_p(z);
            if (tmp___13 > 1U) {
              zval_delref_p(z);
              while (1) {
                tmp___12 = _emalloc(sizeof(zval_gc_info ));
                new_zv___0 = (zval *)tmp___12;
                ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv___0->value = z->value;
                  new_zv___0->type = z->type;
                  break;
                }
                zval_set_refcount_p(new_zv___0, 1U);
                zval_unset_isref_p(new_zv___0);
                break;
              }
              z = new_zv___0;
              _zval_copy_ctor(new_zv___0);
            } else {

            }
            break;
          }
        }
        (*incdec_op)(z);
        *retval = z;
        if (1 << 4 == 1) {
          tmp___15 = opline->op2.literal;
        } else {
          tmp___15 = (zend_literal *)((void *)0);
        }
        (*((object->value.obj.handlers)->write_property))(object, property, z, (struct _zend_literal  const  *)tmp___15);
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(*retval);
        } else {

        }
        i_zval_ptr_dtor(z);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
      if (! ((int )opline->result_type & (1 << 5))) {
        zval_addref_p(& executor_globals.uninitialized_zval);
        *retval = & executor_globals.uninitialized_zval;
      } else {

      }
    }
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_PRE_INC_OBJ_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_pre_incdec_property_helper_SPEC_VAR_CV((int (*)(zval * ))(& increment_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_PRE_DEC_OBJ_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_pre_incdec_property_helper_SPEC_VAR_CV((int (*)(zval * ))(& decrement_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) zend_post_incdec_property_helper_SPEC_VAR_CV)(int (*incdec_op)(zval * ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **object_ptr ;
  zval *object ;
  zval *property ;
  zval *retval ;
  int have_get_ptr ;
  long tmp ;
  long tmp___0 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zval **zptr ;
  zend_literal *tmp___2 ;
  zval **tmp___3 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_uint tmp___5 ;
  zend_bool tmp___6 ;
  zval *z ;
  zend_literal *tmp___7 ;
  zval *tmp___8 ;
  zval *z_copy ;
  zval *value ;
  zval *tmp___9 ;
  zend_uint tmp___10 ;
  long tmp___11 ;
  void __attribute__((__visibility__("default")))  *tmp___12 ;
  zend_literal *tmp___13 ;

  {
  opline = execute_data->opline;
  have_get_ptr = 0;
  object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  property = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  retval = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  if (1 << 2 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot increment/decrement overloaded objects nor string offsets");
    } else {

    }
  } else {

  }
  make_real_object(object_ptr);
  object = *object_ptr;
  tmp___0 = __builtin_expect((long )((int )object->type != 5), 0L);
  if (tmp___0) {
    zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
    retval->type = (unsigned char)0;
    if (free_op1.var) {
      i_zval_ptr_dtor(free_op1.var);
    } else {

    }
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  if ((object->value.obj.handlers)->get_property_ptr_ptr) {
    if (1 << 4 == 1) {
      tmp___2 = opline->op2.literal;
    } else {
      tmp___2 = (zend_literal *)((void *)0);
    }
    tmp___3 = (*((object->value.obj.handlers)->get_property_ptr_ptr))(object, property, (struct _zend_literal  const  *)tmp___2);
    zptr = tmp___3;
    if ((unsigned int )zptr != (unsigned int )((void *)0)) {
      have_get_ptr = 1;
      tmp___6 = zval_isref_p(*zptr);
      if (tmp___6) {

      } else {
        while (1) {
          tmp___5 = zval_refcount_p(*zptr);
          if (tmp___5 > 1U) {
            zval_delref_p(*zptr);
            while (1) {
              tmp___4 = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp___4;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*zptr)->value;
                new_zv->type = (*zptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *zptr = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
      while (1) {
        retval->value = (*zptr)->value;
        retval->type = (*zptr)->type;
        break;
      }
      _zval_copy_ctor(retval);
      (*incdec_op)(*zptr);
    } else {

    }
  } else {

  }
  if (! have_get_ptr) {
    if ((object->value.obj.handlers)->read_property) {
      if ((object->value.obj.handlers)->write_property) {
        if (1 << 4 == 1) {
          tmp___7 = opline->op2.literal;
        } else {
          tmp___7 = (zend_literal *)((void *)0);
        }
        tmp___8 = (*((object->value.obj.handlers)->read_property))(object, property, 0, (struct _zend_literal  const  *)tmp___7);
        z = tmp___8;
        tmp___11 = __builtin_expect((long )((int )z->type == 5), 0L);
        if (tmp___11) {
          if ((z->value.obj.handlers)->get) {
            tmp___9 = (*((z->value.obj.handlers)->get))(z);
            value = tmp___9;
            tmp___10 = zval_refcount_p(z);
            if (tmp___10 == 0U) {
              if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                gc_remove_zval_from_buffer(z);
              } else {

              }
              _zval_dtor(z);
              while (1) {
                if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                  gc_remove_zval_from_buffer(z);
                } else {

                }
                _efree((void *)z);
                break;
              }
            } else {

            }
            z = value;
          } else {

          }
        } else {

        }
        while (1) {
          retval->value = z->value;
          retval->type = z->type;
          break;
        }
        _zval_copy_ctor(retval);
        while (1) {
          tmp___12 = _emalloc(sizeof(zval_gc_info ));
          z_copy = (zval *)tmp___12;
          ((zval_gc_info *)z_copy)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            z_copy->value = z->value;
            z_copy->type = z->type;
            break;
          }
          zval_set_refcount_p(z_copy, 1U);
          zval_unset_isref_p(z_copy);
          break;
        }
        _zval_copy_ctor(z_copy);
        (*incdec_op)(z_copy);
        zval_addref_p(z);
        if (1 << 4 == 1) {
          tmp___13 = opline->op2.literal;
        } else {
          tmp___13 = (zend_literal *)((void *)0);
        }
        (*((object->value.obj.handlers)->write_property))(object, property, z_copy, (struct _zend_literal  const  *)tmp___13);
        i_zval_ptr_dtor(z_copy);
        i_zval_ptr_dtor(z);
      } else {
        zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
        retval->type = (unsigned char)0;
      }
    } else {
      zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
      retval->type = (unsigned char)0;
    }
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_POST_INC_OBJ_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_post_incdec_property_helper_SPEC_VAR_CV((int (*)(zval * ))(& increment_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_POST_DEC_OBJ_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_post_incdec_property_helper_SPEC_VAR_CV((int (*)(zval * ))(& decrement_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_R_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **container ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  if (opline->extended_value & 134217728UL) {
    if (1 << 2 != 1 << 4) {
      if (((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr) {
        zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr));
      } else {

      }
    } else {

    }
  } else {

  }
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  zend_fetch_dimension_address_read((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, tmp, 1 << 4, 0);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_W_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **container ;
  long tmp ;
  zval *tmp___0 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zend_uint tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___6 ;
  zval **retval_ptr ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___7 ;
  zend_uint tmp___8 ;
  zend_bool tmp___9 ;
  long tmp___10 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, tmp___0, 1 << 4, 1);
  if (1 << 2 == 1 << 2) {
    if ((unsigned int )free_op1.var != (unsigned int )((void *)0)) {
      tmp___5 = zval_refcount_p(free_op1.var);
      if (tmp___5 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___6 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___6 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___3 = zval_isref_p(__t->var.ptr);
                if (tmp___3) {

                } else {
                  tmp___4 = zval_refcount_p(__t->var.ptr);
                  if (tmp___4 > 2U) {
                    while (1) {
                      tmp___2 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___2 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___1 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___1;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  tmp___10 = __builtin_expect((long )(opline->extended_value != 0UL), 0L);
  if (tmp___10) {
    retval_ptr = ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr;
    if (retval_ptr) {
      zval_delref_p(*retval_ptr);
      tmp___9 = zval_isref_p(*retval_ptr);
      if (tmp___9) {

      } else {
        while (1) {
          tmp___8 = zval_refcount_p(*retval_ptr);
          if (tmp___8 > 1U) {
            zval_delref_p(*retval_ptr);
            while (1) {
              tmp___7 = _emalloc(sizeof(zval_gc_info ));
              new_zv___0 = (zval *)tmp___7;
              ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv___0->value = (*retval_ptr)->value;
                new_zv___0->type = (*retval_ptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv___0, 1U);
              zval_unset_isref_p(new_zv___0);
              break;
            }
            *retval_ptr = new_zv___0;
            _zval_copy_ctor(new_zv___0);
          } else {

          }
          break;
        }
        zval_set_isref_p(*retval_ptr);
      }
      zval_addref_p(*retval_ptr);
    } else {

    }
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_RW_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **container ;
  long tmp ;
  zval *tmp___0 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zend_uint tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___6 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, tmp___0, 1 << 4, 2);
  if (1 << 2 == 1 << 2) {
    if ((unsigned int )free_op1.var != (unsigned int )((void *)0)) {
      tmp___5 = zval_refcount_p(free_op1.var);
      if (tmp___5 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___6 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___6 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___3 = zval_isref_p(__t->var.ptr);
                if (tmp___3) {

                } else {
                  tmp___4 = zval_refcount_p(__t->var.ptr);
                  if (tmp___4 > 2U) {
                    while (1) {
                      tmp___2 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___2 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___1 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___1;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_IS_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **container ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  zend_fetch_dimension_address_read((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, tmp, 1 << 4, 3);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **container ;
  long tmp ;
  zval *tmp___0 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zend_uint tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___6 ;
  zval *tmp___7 ;
  unsigned int tmp___8 ;

  {
  opline = execute_data->opline;
  if (execute_data->fbc) {
    if ((execute_data->fbc)->common.arg_info) {
      if ((opline->extended_value & 1048575UL) <= (unsigned long )(execute_data->fbc)->common.num_args) {
        tmp___8 = (unsigned int )((int )((execute_data->fbc)->common.arg_info + ((opline->extended_value & 1048575UL) - 1UL))->pass_by_reference & 3);
      } else {
        tmp___8 = (execute_data->fbc)->common.fn_flags & 50331648U;
      }
    } else {
      tmp___8 = (execute_data->fbc)->common.fn_flags & 50331648U;
    }
    if (tmp___8) {
      container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
      if (1 << 2 == 1 << 2) {
        tmp = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
        if (tmp) {
          zend_error_noreturn(1, "Cannot use string offset as an array");
        } else {

        }
      } else {

      }
      tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
      zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, tmp___0, 1 << 4, 1);
      if (1 << 2 == 1 << 2) {
        if ((unsigned int )free_op1.var != (unsigned int )((void *)0)) {
          tmp___5 = zval_refcount_p(free_op1.var);
          if (tmp___5 == 1U) {
            if ((int )(free_op1.var)->type != 5) {
              goto _L;
            } else {
              tmp___6 = zend_objects_store_get_refcount(free_op1.var);
              if (tmp___6 == (zend_uint __attribute__((__visibility__("default")))  )1) {
                _L: /* CIL Label */ 
                while (1) {
                  __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
                  if (__t->var.ptr_ptr) {
                    __t->var.ptr = *(__t->var.ptr_ptr);
                    __t->var.ptr_ptr = & __t->var.ptr;
                    tmp___3 = zval_isref_p(__t->var.ptr);
                    if (tmp___3) {

                    } else {
                      tmp___4 = zval_refcount_p(__t->var.ptr);
                      if (tmp___4 > 2U) {
                        while (1) {
                          tmp___2 = zval_refcount_p(*(__t->var.ptr_ptr));
                          if (tmp___2 > 1U) {
                            zval_delref_p(*(__t->var.ptr_ptr));
                            while (1) {
                              tmp___1 = _emalloc(sizeof(zval_gc_info ));
                              new_zv = (zval *)tmp___1;
                              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                              break;
                            }
                            while (1) {
                              while (1) {
                                new_zv->value = (*(__t->var.ptr_ptr))->value;
                                new_zv->type = (*(__t->var.ptr_ptr))->type;
                                break;
                              }
                              zval_set_refcount_p(new_zv, 1U);
                              zval_unset_isref_p(new_zv);
                              break;
                            }
                            *(__t->var.ptr_ptr) = new_zv;
                            _zval_copy_ctor(new_zv);
                          } else {

                          }
                          break;
                        }
                      } else {

                      }
                    }
                  } else {

                  }
                  break;
                }
              } else {

              }
            }
          } else {

          }
        } else {

        }
      } else {

      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if (1 << 4 == 1 << 3) {
      zend_error_noreturn(1, "Cannot use [] for reading");
    } else {

    }
    container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
    tmp___7 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
    zend_fetch_dimension_address_read((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, tmp___7, 1 << 4, 0);
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_UNSET_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **container ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  long tmp___2 ;
  zval *tmp___3 ;
  temp_variable *__t ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_uint tmp___5 ;
  zend_bool tmp___6 ;
  zend_uint tmp___7 ;
  zend_uint tmp___8 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___9 ;
  zend_free_op free_res ;
  zval **retval_ptr ;
  zval *new_zv___1 ;
  void __attribute__((__visibility__("default")))  *tmp___10 ;
  zend_uint tmp___11 ;
  zend_bool tmp___12 ;
  long tmp___13 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 4) {
    if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
      tmp___1 = zval_isref_p(*container);
      if (tmp___1) {

      } else {
        while (1) {
          tmp___0 = zval_refcount_p(*container);
          if (tmp___0 > 1U) {
            zval_delref_p(*container);
            while (1) {
              tmp = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*container)->value;
                new_zv->type = (*container)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *container = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
    } else {

    }
  } else {

  }
  if (1 << 2 == 1 << 2) {
    tmp___2 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___2) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  tmp___3 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, tmp___3, 1 << 4, 6);
  if (1 << 2 == 1 << 2) {
    if ((unsigned int )free_op1.var != (unsigned int )((void *)0)) {
      tmp___8 = zval_refcount_p(free_op1.var);
      if (tmp___8 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___9 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___9 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___6 = zval_isref_p(__t->var.ptr);
                if (tmp___6) {

                } else {
                  tmp___7 = zval_refcount_p(__t->var.ptr);
                  if (tmp___7 > 2U) {
                    while (1) {
                      tmp___5 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___5 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___4 = _emalloc(sizeof(zval_gc_info ));
                          new_zv___0 = (zval *)tmp___4;
                          ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv___0->value = (*(__t->var.ptr_ptr))->value;
                            new_zv___0->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv___0, 1U);
                          zval_unset_isref_p(new_zv___0);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv___0;
                        _zval_copy_ctor(new_zv___0);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  tmp___13 = __builtin_expect((long )((unsigned int )((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr == (unsigned int )((void *)0)), 0L);
  if (tmp___13) {
    zend_error_noreturn(1, "Cannot unset string offsets");
  } else {
    retval_ptr = ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr;
    zend_pzval_unlock_func(*retval_ptr, & free_res, 1);
    if ((unsigned int )retval_ptr != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
      tmp___12 = zval_isref_p(*retval_ptr);
      if (tmp___12) {

      } else {
        while (1) {
          tmp___11 = zval_refcount_p(*retval_ptr);
          if (tmp___11 > 1U) {
            zval_delref_p(*retval_ptr);
            while (1) {
              tmp___10 = _emalloc(sizeof(zval_gc_info ));
              new_zv___1 = (zval *)tmp___10;
              ((zval_gc_info *)new_zv___1)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv___1->value = (*retval_ptr)->value;
                new_zv___1->type = (*retval_ptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv___1, 1U);
              zval_unset_isref_p(new_zv___1);
              break;
            }
            *retval_ptr = new_zv___1;
            _zval_copy_ctor(new_zv___1);
          } else {

          }
          break;
        }
      }
    } else {

    }
    zval_addref_p(*retval_ptr);
    if (free_res.var) {
      i_zval_ptr_dtor(free_res.var);
    } else {

    }
    (execute_data->opline) ++;
    return (0);
  }
}
}
static int ( __attribute__((__fastcall__)) zend_fetch_property_address_read_helper_SPEC_VAR_CV)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *container ;
  zval *offset ;
  temp_variable *__t ;
  zval *retval ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_literal *tmp___0 ;
  temp_variable *__t___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  offset = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___1 = __builtin_expect((long )((int )container->type != 5), 0L);
  if (tmp___1) {
    goto _L;
  } else {
    tmp___2 = __builtin_expect((long )((unsigned int )(container->value.obj.handlers)->read_property == (unsigned int )((void *)0)), 0L);
    if (tmp___2) {
      _L: /* CIL Label */ 
      zend_error(1 << 3L, "Trying to get property of non-object");
      zval_addref_p(& executor_globals.uninitialized_zval);
      while (1) {
        __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t->var.ptr = & executor_globals.uninitialized_zval;
        __t->var.ptr_ptr = & __t->var.ptr;
        break;
      }
    } else {
      if (1 << 4 == 1) {
        tmp___0 = opline->op2.literal;
      } else {
        tmp___0 = (zend_literal *)((void *)0);
      }
      retval = (*((container->value.obj.handlers)->read_property))(container, offset, 0, (struct _zend_literal  const  *)tmp___0);
      zval_addref_p(retval);
      while (1) {
        __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t___0->var.ptr = retval;
        __t___0->var.ptr_ptr = & __t___0->var.ptr;
        break;
      }
    }
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_R_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_property_address_read_helper_SPEC_VAR_CV(execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_W_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *property ;
  zval **container ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zend_literal *tmp___1 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_uint tmp___3 ;
  zend_bool tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint tmp___6 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___7 ;
  zval **retval_ptr ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___8 ;
  zend_uint tmp___9 ;
  zend_bool tmp___10 ;

  {
  opline = execute_data->opline;
  property = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  if (1 << 2 == 1 << 2) {
    if (opline->extended_value & 134217728UL) {
      zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr));
      ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr = *(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr);
    } else {

    }
  } else {

  }
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  if (1 << 4 == 1) {
    tmp___1 = opline->op2.literal;
  } else {
    tmp___1 = (zend_literal *)((void *)0);
  }
  zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)tmp___1, 1);
  if (1 << 2 == 1 << 2) {
    if ((unsigned int )free_op1.var != (unsigned int )((void *)0)) {
      tmp___6 = zval_refcount_p(free_op1.var);
      if (tmp___6 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___7 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___7 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___4 = zval_isref_p(__t->var.ptr);
                if (tmp___4) {

                } else {
                  tmp___5 = zval_refcount_p(__t->var.ptr);
                  if (tmp___5 > 2U) {
                    while (1) {
                      tmp___3 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___3 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___2 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___2;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  if (opline->extended_value & 67108864UL) {
    retval_ptr = ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr;
    zval_delref_p(*retval_ptr);
    tmp___10 = zval_isref_p(*retval_ptr);
    if (tmp___10) {

    } else {
      while (1) {
        tmp___9 = zval_refcount_p(*retval_ptr);
        if (tmp___9 > 1U) {
          zval_delref_p(*retval_ptr);
          while (1) {
            tmp___8 = _emalloc(sizeof(zval_gc_info ));
            new_zv___0 = (zval *)tmp___8;
            ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv___0->value = (*retval_ptr)->value;
              new_zv___0->type = (*retval_ptr)->type;
              break;
            }
            zval_set_refcount_p(new_zv___0, 1U);
            zval_unset_isref_p(new_zv___0);
            break;
          }
          *retval_ptr = new_zv___0;
          _zval_copy_ctor(new_zv___0);
        } else {

        }
        break;
      }
      zval_set_isref_p(*retval_ptr);
    }
    zval_addref_p(*retval_ptr);
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = *(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr);
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_RW_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *property ;
  zval **container ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zend_literal *tmp___1 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_uint tmp___3 ;
  zend_bool tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint tmp___6 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___7 ;

  {
  opline = execute_data->opline;
  property = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  if (1 << 4 == 1) {
    tmp___1 = opline->op2.literal;
  } else {
    tmp___1 = (zend_literal *)((void *)0);
  }
  zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)tmp___1, 2);
  if (1 << 2 == 1 << 2) {
    if ((unsigned int )free_op1.var != (unsigned int )((void *)0)) {
      tmp___6 = zval_refcount_p(free_op1.var);
      if (tmp___6 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___7 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___7 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___4 = zval_isref_p(__t->var.ptr);
                if (tmp___4) {

                } else {
                  tmp___5 = zval_refcount_p(__t->var.ptr);
                  if (tmp___5 > 2U) {
                    while (1) {
                      tmp___3 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___3 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___2 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___2;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_IS_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *container ;
  zval *offset ;
  temp_variable *__t ;
  zval *retval ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_literal *tmp___0 ;
  temp_variable *__t___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  offset = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___1 = __builtin_expect((long )((int )container->type != 5), 0L);
  if (tmp___1) {
    goto _L;
  } else {
    tmp___2 = __builtin_expect((long )((unsigned int )(container->value.obj.handlers)->read_property == (unsigned int )((void *)0)), 0L);
    if (tmp___2) {
      _L: /* CIL Label */ 
      zval_addref_p(& executor_globals.uninitialized_zval);
      while (1) {
        __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t->var.ptr = & executor_globals.uninitialized_zval;
        __t->var.ptr_ptr = & __t->var.ptr;
        break;
      }
    } else {
      if (1 << 4 == 1) {
        tmp___0 = opline->op2.literal;
      } else {
        tmp___0 = (zend_literal *)((void *)0);
      }
      retval = (*((container->value.obj.handlers)->read_property))(container, offset, 3, (struct _zend_literal  const  *)tmp___0);
      zval_addref_p(retval);
      while (1) {
        __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t___0->var.ptr = retval;
        __t___0->var.ptr_ptr = & __t___0->var.ptr;
        break;
      }
    }
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *property ;
  zval **container ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zend_literal *tmp___1 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_uint tmp___3 ;
  zend_bool tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint tmp___6 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;

  {
  opline = execute_data->opline;
  if (execute_data->fbc) {
    if ((execute_data->fbc)->common.arg_info) {
      if ((opline->extended_value & 1048575UL) <= (unsigned long )(execute_data->fbc)->common.num_args) {
        tmp___9 = (unsigned int )((int )((execute_data->fbc)->common.arg_info + ((opline->extended_value & 1048575UL) - 1UL))->pass_by_reference & 3);
      } else {
        tmp___9 = (execute_data->fbc)->common.fn_flags & 50331648U;
      }
    } else {
      tmp___9 = (execute_data->fbc)->common.fn_flags & 50331648U;
    }
    if (tmp___9) {
      property = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
      container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
      if (1 << 2 == 1 << 2) {
        tmp___0 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
        if (tmp___0) {
          zend_error_noreturn(1, "Cannot use string offset as an object");
        } else {

        }
      } else {

      }
      if (1 << 4 == 1) {
        tmp___1 = opline->op2.literal;
      } else {
        tmp___1 = (zend_literal *)((void *)0);
      }
      zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)tmp___1, 1);
      if (1 << 2 == 1 << 2) {
        if ((unsigned int )free_op1.var != (unsigned int )((void *)0)) {
          tmp___6 = zval_refcount_p(free_op1.var);
          if (tmp___6 == 1U) {
            if ((int )(free_op1.var)->type != 5) {
              goto _L;
            } else {
              tmp___7 = zend_objects_store_get_refcount(free_op1.var);
              if (tmp___7 == (zend_uint __attribute__((__visibility__("default")))  )1) {
                _L: /* CIL Label */ 
                while (1) {
                  __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
                  if (__t->var.ptr_ptr) {
                    __t->var.ptr = *(__t->var.ptr_ptr);
                    __t->var.ptr_ptr = & __t->var.ptr;
                    tmp___4 = zval_isref_p(__t->var.ptr);
                    if (tmp___4) {

                    } else {
                      tmp___5 = zval_refcount_p(__t->var.ptr);
                      if (tmp___5 > 2U) {
                        while (1) {
                          tmp___3 = zval_refcount_p(*(__t->var.ptr_ptr));
                          if (tmp___3 > 1U) {
                            zval_delref_p(*(__t->var.ptr_ptr));
                            while (1) {
                              tmp___2 = _emalloc(sizeof(zval_gc_info ));
                              new_zv = (zval *)tmp___2;
                              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                              break;
                            }
                            while (1) {
                              while (1) {
                                new_zv->value = (*(__t->var.ptr_ptr))->value;
                                new_zv->type = (*(__t->var.ptr_ptr))->type;
                                break;
                              }
                              zval_set_refcount_p(new_zv, 1U);
                              zval_unset_isref_p(new_zv);
                              break;
                            }
                            *(__t->var.ptr_ptr) = new_zv;
                            _zval_copy_ctor(new_zv);
                          } else {

                          }
                          break;
                        }
                      } else {

                      }
                    }
                  } else {

                  }
                  break;
                }
              } else {

              }
            }
          } else {

          }
        } else {

        }
      } else {

      }
      if (free_op1.var) {
        i_zval_ptr_dtor(free_op1.var);
      } else {

      }
      (execute_data->opline) ++;
      return (0);
    } else {
      tmp___8 = zend_fetch_property_address_read_helper_SPEC_VAR_CV(execute_data);
      return (tmp___8);
    }
  } else {
    tmp___8 = zend_fetch_property_address_read_helper_SPEC_VAR_CV(execute_data);
    return (tmp___8);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_UNSET_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_res ;
  zval **container ;
  zval *property ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  long tmp___3 ;
  zend_literal *tmp___4 ;
  temp_variable *__t ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  zend_uint tmp___6 ;
  zend_bool tmp___7 ;
  zend_uint tmp___8 ;
  zend_uint tmp___9 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___10 ;
  zval *new_zv___1 ;
  void __attribute__((__visibility__("default")))  *tmp___11 ;
  zend_uint tmp___12 ;
  zend_bool tmp___13 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  property = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  if (1 << 2 == 1 << 4) {
    if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
      tmp___1 = zval_isref_p(*container);
      if (tmp___1) {

      } else {
        while (1) {
          tmp___0 = zval_refcount_p(*container);
          if (tmp___0 > 1U) {
            zval_delref_p(*container);
            while (1) {
              tmp = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*container)->value;
                new_zv->type = (*container)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *container = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
    } else {

    }
  } else {

  }
  if (1 << 2 == 1 << 2) {
    tmp___3 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___3) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  if (1 << 4 == 1) {
    tmp___4 = opline->op2.literal;
  } else {
    tmp___4 = (zend_literal *)((void *)0);
  }
  zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)tmp___4, 6);
  if (1 << 2 == 1 << 2) {
    if ((unsigned int )free_op1.var != (unsigned int )((void *)0)) {
      tmp___9 = zval_refcount_p(free_op1.var);
      if (tmp___9 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___10 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___10 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___7 = zval_isref_p(__t->var.ptr);
                if (tmp___7) {

                } else {
                  tmp___8 = zval_refcount_p(__t->var.ptr);
                  if (tmp___8 > 2U) {
                    while (1) {
                      tmp___6 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___6 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___5 = _emalloc(sizeof(zval_gc_info ));
                          new_zv___0 = (zval *)tmp___5;
                          ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv___0->value = (*(__t->var.ptr_ptr))->value;
                            new_zv___0->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv___0, 1U);
                          zval_unset_isref_p(new_zv___0);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv___0;
                        _zval_copy_ctor(new_zv___0);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  zend_pzval_unlock_func(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr), & free_res, 1);
  if ((unsigned int )((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
    tmp___13 = zval_isref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
    if (tmp___13) {

    } else {
      while (1) {
        tmp___12 = zval_refcount_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
        if (tmp___12 > 1U) {
          zval_delref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
          while (1) {
            tmp___11 = _emalloc(sizeof(zval_gc_info ));
            new_zv___1 = (zval *)tmp___11;
            ((zval_gc_info *)new_zv___1)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv___1->value = (*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr))->value;
              new_zv___1->type = (*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr))->type;
              break;
            }
            zval_set_refcount_p(new_zv___1, 1U);
            zval_unset_isref_p(new_zv___1);
            break;
          }
          *(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr) = new_zv___1;
          _zval_copy_ctor(new_zv___1);
        } else {

        }
        break;
      }
    }
  } else {

  }
  zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
  if (free_res.var) {
    i_zval_ptr_dtor(free_res.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_OBJ_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **object_ptr ;
  zval *property_name ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zend_literal *tmp___1 ;
  zval **tmp___2 ;

  {
  opline = execute_data->opline;
  object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  property_name = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  if (1 << 2 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  if (1 << 4 == 1) {
    tmp___1 = opline->op2.literal;
  } else {
    tmp___1 = (zend_literal *)((void *)0);
  }
  if (! ((int )opline->result_type & (1 << 5))) {
    tmp___2 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
  } else {
    tmp___2 = (zval **)((void *)0);
  }
  zend_assign_to_object(tmp___2, object_ptr, property_name, (int )(opline + 1)->op1_type, & (opline + 1)->op1, (temp_variable const   *)execute_data->Ts, 136, (zend_literal const   *)tmp___1);
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_DIM_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **object_ptr ;
  long tmp ;
  zval *property_name ;
  zval *tmp___0 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_literal *tmp___2 ;
  zval **tmp___3 ;
  zend_free_op free_op_data1 ;
  zend_free_op free_op_data2 ;
  zval *value ;
  zval *dim ;
  zval *tmp___4 ;
  zval **variable_ptr_ptr ;
  zval *retval ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  char const   *__s ;
  int __l ;
  zval *__z ;
  char __attribute__((__visibility__("default")))  *tmp___6 ;
  temp_variable *__t ;
  temp_variable *__t___0 ;
  int tmp___7 ;
  temp_variable *__t___1 ;
  temp_variable *__t___2 ;
  long tmp___8 ;
  long tmp___9 ;

  {
  opline = execute_data->opline;
  object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  if ((int )(*object_ptr)->type == 5) {
    tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
    property_name = tmp___0;
    if (1 << 4 == 1) {
      tmp___2 = opline->op2.literal;
    } else {
      tmp___2 = (zend_literal *)((void *)0);
    }
    if (! ((int )opline->result_type & (1 << 5))) {
      tmp___3 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
    } else {
      tmp___3 = (zval **)((void *)0);
    }
    zend_assign_to_object(tmp___3, object_ptr, property_name, (int )(opline + 1)->op1_type, & (opline + 1)->op1, (temp_variable const   *)execute_data->Ts, 147, (zend_literal const   *)tmp___2);
  } else {
    tmp___4 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
    dim = tmp___4;
    zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var), object_ptr, dim, 1 << 4, 1);
    value = _get_zval_ptr((int )(opline + 1)->op1_type, (znode_op const   *)(& (opline + 1)->op1), (temp_variable const   *)execute_data->Ts, & free_op_data1, 0);
    variable_ptr_ptr = _get_zval_ptr_ptr_var((opline + 1)->op2.var, (temp_variable const   *)execute_data->Ts, & free_op_data2);
    tmp___9 = __builtin_expect((long )((unsigned int )variable_ptr_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___9) {
      tmp___7 = zend_assign_to_string_offset((temp_variable const   *)((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var)), (zval const   *)value, (int )(opline + 1)->op1_type);
      if (tmp___7) {
        if (! ((int )opline->result_type & (1 << 5))) {
          while (1) {
            tmp___5 = _emalloc(sizeof(zval_gc_info ));
            retval = (zval *)tmp___5;
            ((zval_gc_info *)retval)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            __s = (char const   *)((((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var))->str_offset.str)->value.str.val + ((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var))->str_offset.offset);
            __l = 1;
            __z = retval;
            __z->value.str.len = __l;
            tmp___6 = _estrndup(__s, (unsigned int )__l);
            __z->value.str.val = (char *)tmp___6;
            __z->type = (unsigned char)6;
            break;
          }
          retval->refcount__gc = 1U;
          retval->is_ref__gc = (unsigned char)0;
          while (1) {
            __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t->var.ptr = retval;
            __t->var.ptr_ptr = & __t->var.ptr;
            break;
          }
        } else {

        }
      } else {
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          while (1) {
            __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___0->var.ptr = & executor_globals.uninitialized_zval;
            __t___0->var.ptr_ptr = & __t___0->var.ptr;
            break;
          }
        } else {

        }
      }
    } else {
      tmp___8 = __builtin_expect((long )((unsigned int )*variable_ptr_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
      if (tmp___8) {
        if ((unsigned long )free_op_data1.var & 1UL) {
          _zval_dtor(value);
        } else {

        }
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          while (1) {
            __t___1 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___1->var.ptr = & executor_globals.uninitialized_zval;
            __t___1->var.ptr_ptr = & __t___1->var.ptr;
            break;
          }
        } else {

        }
      } else {
        if ((int )(opline + 1)->op1_type == 1 << 1) {
          value = zend_assign_tmp_to_variable(variable_ptr_ptr, value);
        } else {
          if ((int )(opline + 1)->op1_type == 1) {
            value = zend_assign_const_to_variable(variable_ptr_ptr, value);
          } else {
            value = zend_assign_to_variable(variable_ptr_ptr, value);
          }
        }
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(value);
          while (1) {
            __t___2 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___2->var.ptr = value;
            __t___2->var.ptr_ptr = & __t___2->var.ptr;
            break;
          }
        } else {

        }
      }
    }
    if (free_op_data2.var) {
      i_zval_ptr_dtor(free_op_data2.var);
    } else {

    }
    if ((unsigned int )free_op_data1.var != (unsigned int )((void *)0)) {
      if (((unsigned long )free_op_data1.var & 1UL) == 0UL) {
        i_zval_ptr_dtor(free_op_data1.var);
      } else {

      }
    } else {

    }
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *value ;
  zval **variable_ptr_ptr ;
  zval *retval ;
  void __attribute__((__visibility__("default")))  *tmp ;
  char const   *__s ;
  int __l ;
  zval *__z ;
  char __attribute__((__visibility__("default")))  *tmp___0 ;
  temp_variable *__t ;
  temp_variable *__t___0 ;
  int tmp___1 ;
  temp_variable *__t___1 ;
  temp_variable *__t___2 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  opline = execute_data->opline;
  value = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  variable_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 2) {
    tmp___3 = __builtin_expect((long )((unsigned int )variable_ptr_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___3) {
      tmp___1 = zend_assign_to_string_offset((temp_variable const   *)((temp_variable *)((char *)execute_data->Ts + opline->op1.var)), (zval const   *)value, 1 << 4);
      if (tmp___1) {
        if (! ((int )opline->result_type & (1 << 5))) {
          while (1) {
            tmp = _emalloc(sizeof(zval_gc_info ));
            retval = (zval *)tmp;
            ((zval_gc_info *)retval)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            __s = (char const   *)((((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->str_offset.str)->value.str.val + ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->str_offset.offset);
            __l = 1;
            __z = retval;
            __z->value.str.len = __l;
            tmp___0 = _estrndup(__s, (unsigned int )__l);
            __z->value.str.val = (char *)tmp___0;
            __z->type = (unsigned char)6;
            break;
          }
          retval->refcount__gc = 1U;
          retval->is_ref__gc = (unsigned char)0;
          while (1) {
            __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t->var.ptr = retval;
            __t->var.ptr_ptr = & __t->var.ptr;
            break;
          }
        } else {

        }
      } else {
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          while (1) {
            __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___0->var.ptr = & executor_globals.uninitialized_zval;
            __t___0->var.ptr_ptr = & __t___0->var.ptr;
            break;
          }
        } else {

        }
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if (1 << 2 == 1 << 2) {
      tmp___2 = __builtin_expect((long )((unsigned int )*variable_ptr_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
      if (tmp___2) {
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          while (1) {
            __t___1 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___1->var.ptr = & executor_globals.uninitialized_zval;
            __t___1->var.ptr_ptr = & __t___1->var.ptr;
            break;
          }
        } else {

        }
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      if (1 << 4 == 1 << 1) {
        value = zend_assign_tmp_to_variable(variable_ptr_ptr, value);
      } else {
        if (1 << 4 == 1) {
          value = zend_assign_const_to_variable(variable_ptr_ptr, value);
        } else {
          value = zend_assign_to_variable(variable_ptr_ptr, value);
        }
      }
      if (! ((int )opline->result_type & (1 << 5))) {
        zval_addref_p(value);
        while (1) {
          __t___2 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
          __t___2->var.ptr = value;
          __t___2->var.ptr_ptr = & __t___2->var.ptr;
          break;
        }
      } else {

      }
    }
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_REF_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval **variable_ptr_ptr ;
  zval **value_ptr_ptr ;
  long tmp ;
  int tmp___0 ;
  zend_bool tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  temp_variable *__t ;

  {
  opline = execute_data->opline;
  value_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op2.var);
  if (1 << 4 == 1 << 2) {
    if (value_ptr_ptr) {
      tmp___1 = zval_isref_p(*value_ptr_ptr);
      if (tmp___1) {
        goto _L___2;
      } else {
        if (opline->extended_value == 1UL) {
          if (! ((temp_variable *)((char *)execute_data->Ts + opline->op2.var))->var.fcall_returned_reference) {
            if ((unsigned int )free_op2.var == (unsigned int )((void *)0)) {
              zval_addref_p(*value_ptr_ptr);
            } else {

            }
            zend_error(1 << 11L, "Only variables should be assigned by reference");
            tmp = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
            if (tmp) {
              return (0);
            } else {

            }
            tmp___0 = ZEND_ASSIGN_SPEC_VAR_CV_HANDLER(execute_data);
            return (tmp___0);
          } else {
            goto _L___2;
          }
        } else {
          goto _L___2;
        }
      }
    } else {
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
    _L___1: /* CIL Label */ 
    _L___0: /* CIL Label */ 
    _L: /* CIL Label */ 
    if (1 << 4 == 1 << 2) {
      if (opline->extended_value == (ulong )(1 << 1)) {
        zval_addref_p(*value_ptr_ptr);
      } else {

      }
    } else {

    }
  }
  if (1 << 2 == 1 << 2) {
    tmp___2 = __builtin_expect((long )((unsigned int )((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr == (unsigned int )(& ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr)), 0L);
    if (tmp___2) {
      zend_error_noreturn(1, "Cannot assign by reference to overloaded object");
    } else {

    }
  } else {

  }
  variable_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 4 == 1 << 2) {
    tmp___3 = __builtin_expect((long )((unsigned int )value_ptr_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___3) {
      zend_error_noreturn(1, "Cannot create references to/from string offsets nor overloaded objects");
    } else {
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    if (1 << 2 == 1 << 2) {
      tmp___4 = __builtin_expect((long )((unsigned int )variable_ptr_ptr == (unsigned int )((void *)0)), 0L);
      if (tmp___4) {
        zend_error_noreturn(1, "Cannot create references to/from string offsets nor overloaded objects");
      } else {

      }
    } else {

    }
  }
  zend_assign_to_variable_reference(variable_ptr_ptr, value_ptr_ptr);
  if (1 << 4 == 1 << 2) {
    if (opline->extended_value == (ulong )(1 << 1)) {
      zval_delref_p(*variable_ptr_ptr);
    } else {

    }
  } else {

  }
  if (! ((int )opline->result_type & (1 << 5))) {
    zval_addref_p(*variable_ptr_ptr);
    while (1) {
      __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
      __t->var.ptr = *variable_ptr_ptr;
      __t->var.ptr_ptr = & __t->var.ptr;
      break;
    }
  } else {

  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_METHOD_CALL_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *function_name ;
  char *function_name_strval ;
  int function_name_strlen ;
  zend_free_op free_op1 ;
  long tmp ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  zval *object ;
  long tmp___1 ;
  zend_literal *tmp___2 ;
  zend_class_entry *tmp___3 ;
  zend_class_entry *tmp___4 ;
  char const   *tmp___5 ;
  zend_class_entry *tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  zend_function *tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  zval *this_ptr ;
  void __attribute__((__visibility__("default")))  *tmp___13 ;
  zend_bool tmp___14 ;

  {
  opline = execute_data->opline;
  zend_ptr_stack_3_push(& executor_globals.arg_types_stack, (void *)execute_data->fbc, (void *)execute_data->object, (void *)execute_data->called_scope);
  function_name = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  if (1 << 4 != 1) {
    tmp = __builtin_expect((long )((int )function_name->type != 6), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Method name must be a string");
    } else {

    }
  } else {

  }
  function_name_strval = function_name->value.str.val;
  function_name_strlen = function_name->value.str.len;
  execute_data->object = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  tmp___11 = __builtin_expect((long )((unsigned int )execute_data->object != (unsigned int )((void *)0)), 1L);
  if (tmp___11) {
    tmp___12 = __builtin_expect((long )((int )(execute_data->object)->type == 5), 1L);
    if (tmp___12) {
      tmp___0 = zend_get_class_entry((zval const   *)execute_data->object);
      execute_data->called_scope = (zend_class_entry *)tmp___0;
      if (1 << 4 != 1) {
        goto _L;
      } else {
        if ((unsigned int )*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) == (unsigned int )execute_data->called_scope) {
          tmp___10 = (zend_function *)*((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U));
        } else {
          tmp___10 = (zend_function *)((void *)0);
        }
        execute_data->fbc = tmp___10;
        if ((unsigned int )tmp___10 == (unsigned int )((void *)0)) {
          _L: /* CIL Label */ 
          object = execute_data->object;
          tmp___1 = __builtin_expect((long )((unsigned int )((execute_data->object)->value.obj.handlers)->get_method == (unsigned int )((void *)0)), 0L);
          if (tmp___1) {
            zend_error_noreturn(1, "Object does not support method calls");
          } else {

          }
          if (1 << 4 == 1) {
            tmp___2 = opline->op2.literal + 1;
          } else {
            tmp___2 = (zend_literal *)((void *)0);
          }
          execute_data->fbc = (*(((execute_data->object)->value.obj.handlers)->get_method))(& execute_data->object, function_name_strval, function_name_strlen, (struct _zend_literal  const  *)tmp___2);
          tmp___7 = __builtin_expect((long )((unsigned int )execute_data->fbc == (unsigned int )((void *)0)), 0L);
          if (tmp___7) {
            if (execute_data->object) {
              if ((int )(execute_data->object)->type == 5) {
                if ((unsigned int )((execute_data->object)->value.obj.handlers)->get_class_entry != (unsigned int )((void *)0)) {
                  tmp___6 = (*(((execute_data->object)->value.obj.handlers)->get_class_entry))((zval const   *)execute_data->object);
                  if (tmp___6) {
                    tmp___4 = (*(((execute_data->object)->value.obj.handlers)->get_class_entry))((zval const   *)execute_data->object);
                    tmp___5 = tmp___4->name;
                  } else {
                    tmp___5 = "";
                  }
                } else {
                  tmp___5 = "";
                }
              } else {
                tmp___5 = "";
              }
            } else {
              tmp___5 = "";
            }
            zend_error_noreturn(1, "Call to undefined method %s::%s()", tmp___5, function_name_strval);
          } else {

          }
          if (1 << 4 == 1) {
            tmp___8 = __builtin_expect((long )(((execute_data->fbc)->common.fn_flags & 6291456U) == 0U), 1L);
            if (tmp___8) {
              tmp___9 = __builtin_expect((long )((unsigned int )execute_data->object == (unsigned int )object), 1L);
              if (tmp___9) {
                while (1) {
                  *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)execute_data->called_scope;
                  *((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U)) = (void *)execute_data->fbc;
                  break;
                }
              } else {

              }
            } else {

            }
          } else {

          }
        } else {

        }
      }
    } else {
      zend_error_noreturn(1, "Call to a member function %s() on a non-object", function_name_strval);
    }
  } else {
    zend_error_noreturn(1, "Call to a member function %s() on a non-object", function_name_strval);
  }
  if (((execute_data->fbc)->common.fn_flags & 1U) != 0U) {
    execute_data->object = (zval *)((void *)0);
  } else {
    tmp___14 = zval_isref_p(execute_data->object);
    if (tmp___14) {
      while (1) {
        tmp___13 = _emalloc(sizeof(zval_gc_info ));
        this_ptr = (zval *)tmp___13;
        ((zval_gc_info *)this_ptr)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      while (1) {
        while (1) {
          this_ptr->value = (execute_data->object)->value;
          this_ptr->type = (execute_data->object)->type;
          break;
        }
        zval_set_refcount_p(this_ptr, 1U);
        zval_unset_isref_p(this_ptr);
        break;
      }
      _zval_copy_ctor(this_ptr);
      execute_data->object = this_ptr;
    } else {
      zval_addref_p(execute_data->object);
    }
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *function_name ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  char *function_name_strval ;
  int function_name_strlen ;
  long tmp___1 ;
  zend_literal *tmp___2 ;
  union _zend_function  __attribute__((__visibility__("default"))) *tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___7 ;
  zend_function *tmp___8 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___9 ;
  zend_bool __attribute__((__visibility__("default")))  tmp___10 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___11 ;
  zval *tmp___12 ;

  {
  opline = execute_data->opline;
  zend_ptr_stack_3_push(& executor_globals.arg_types_stack, (void *)execute_data->fbc, (void *)execute_data->object, (void *)execute_data->called_scope);
  if (1 << 2 == 1) {
    if (*((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot)) {
      ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot);
    } else {
      tmp = zend_fetch_class_by_name((char const   *)(opline->op1.zv)->value.str.val, (unsigned int )(opline->op1.zv)->value.str.len, (zend_literal const   *)(opline->op1.literal + 1), (int )opline->extended_value);
      ce = (zend_class_entry *)tmp;
      tmp___0 = __builtin_expect((long )((unsigned int )ce == (unsigned int )((void *)0)), 0L);
      if (tmp___0) {
        zend_error_noreturn(1, "Class \'%s\' not found", (opline->op1.zv)->value.str.val);
      } else {

      }
      while (1) {
        *((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot) = (void *)ce;
        break;
      }
    }
    execute_data->called_scope = ce;
  } else {
    ce = ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->class_entry;
    if (opline->extended_value == 2UL) {
      execute_data->called_scope = executor_globals.called_scope;
    } else {
      if (opline->extended_value == 1UL) {
        execute_data->called_scope = executor_globals.called_scope;
      } else {
        execute_data->called_scope = ce;
      }
    }
  }
  if (1 << 2 == 1) {
    if (1 << 4 == 1) {
      if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
        execute_data->fbc = (zend_function *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
      } else {
        goto _L___2;
      }
    } else {
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
    _L___1: /* CIL Label */ 
    if (1 << 2 != 1) {
      if (1 << 4 == 1) {
        if ((unsigned int )*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) == (unsigned int )ce) {
          tmp___8 = (zend_function *)*((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U));
        } else {
          tmp___8 = (zend_function *)((void *)0);
        }
        execute_data->fbc = tmp___8;
        if (tmp___8) {

        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      _L: /* CIL Label */ 
      if (1 << 4 != 1 << 3) {
        function_name_strval = (char *)((void *)0);
        function_name_strlen = 0;
        if (1 << 4 == 1) {
          function_name_strval = (opline->op2.zv)->value.str.val;
          function_name_strlen = (opline->op2.zv)->value.str.len;
        } else {
          function_name = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
          tmp___1 = __builtin_expect((long )((int )function_name->type != 6), 0L);
          if (tmp___1) {
            zend_error_noreturn(1, "Function name must be a string");
          } else {
            function_name_strval = function_name->value.str.val;
            function_name_strlen = function_name->value.str.len;
          }
        }
        if (function_name_strval) {
          if (ce->get_static_method) {
            execute_data->fbc = (*(ce->get_static_method))(ce, function_name_strval, function_name_strlen);
          } else {
            if (1 << 4 == 1) {
              tmp___2 = opline->op2.literal + 1;
            } else {
              tmp___2 = (zend_literal *)((void *)0);
            }
            tmp___3 = zend_std_get_static_method(ce, (char const   *)function_name_strval, function_name_strlen, (struct _zend_literal  const  *)tmp___2);
            execute_data->fbc = (zend_function *)tmp___3;
          }
          tmp___4 = __builtin_expect((long )((unsigned int )execute_data->fbc == (unsigned int )((void *)0)), 0L);
          if (tmp___4) {
            zend_error_noreturn(1, "Call to undefined method %s::%s()", ce->name, function_name_strval);
          } else {

          }
          if (1 << 4 == 1) {
            tmp___5 = __builtin_expect((long )(((execute_data->fbc)->common.fn_flags & 6291456U) == 0U), 1L);
            if (tmp___5) {
              if (1 << 2 == 1) {
                while (1) {
                  *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)execute_data->fbc;
                  break;
                }
              } else {
                while (1) {
                  *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
                  *((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U)) = (void *)execute_data->fbc;
                  break;
                }
              }
            } else {

            }
          } else {

          }
        } else {

        }
        if (1 << 4 != 1) {

        } else {

        }
      } else {
        tmp___6 = __builtin_expect((long )((unsigned int )ce->constructor == (unsigned int )((void *)0)), 0L);
        if (tmp___6) {
          zend_error_noreturn(1, "Cannot call constructor");
        } else {

        }
        if (executor_globals.This) {
          tmp___7 = zend_get_class_entry((zval const   *)executor_globals.This);
          if ((unsigned int )tmp___7 != (unsigned int )(ce->constructor)->common.scope) {
            if ((ce->constructor)->common.fn_flags & 1024U) {
              zend_error_noreturn(1, "Cannot call private %s::__construct()", ce->name);
            } else {

            }
          } else {

          }
        } else {

        }
        execute_data->fbc = ce->constructor;
      }
    }
  }
  if ((execute_data->fbc)->common.fn_flags & 1U) {
    execute_data->object = (zval *)((void *)0);
  } else {
    if (executor_globals.This) {
      if (((executor_globals.This)->value.obj.handlers)->get_class_entry) {
        tmp___9 = zend_get_class_entry((zval const   *)executor_globals.This);
        tmp___10 = instanceof_function((zend_class_entry const   *)tmp___9, (zend_class_entry const   *)ce);
        if (tmp___10) {

        } else {
          if ((execute_data->fbc)->common.fn_flags & 65536U) {
            zend_error(1 << 11L, "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", ((execute_data->fbc)->common.scope)->name, (execute_data->fbc)->common.function_name);
          } else {
            zend_error_noreturn(1, "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", ((execute_data->fbc)->common.scope)->name, (execute_data->fbc)->common.function_name);
          }
        }
      } else {

      }
    } else {

    }
    tmp___12 = executor_globals.This;
    execute_data->object = tmp___12;
    if (tmp___12) {
      zval_addref_p(execute_data->object);
      tmp___11 = zend_get_class_entry((zval const   *)execute_data->object);
      execute_data->called_scope = (zend_class_entry *)tmp___11;
    } else {

    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_CASE_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  if (1 << 2 == 1 << 2) {
    zval_addref_p(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr);
  } else {

  }
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  is_equal_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *expr_ptr ;
  zval **expr_ptr_ptr ;
  zval **tmp ;
  long tmp___0 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zval *new_expr ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zval *new_expr___0 ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  zend_bool tmp___6 ;
  zval *offset ;
  zval *tmp___7 ;
  ulong hval ;
  long tmp___8 ;
  register char const   *tmp___9 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___10 ;

  {
  opline = execute_data->opline;
  if (1 << 2 == 1 << 2) {
    goto _L___1;
  } else {
    if (1 << 2 == 1 << 4) {
      _L___1: /* CIL Label */ 
      if (opline->extended_value) {
        tmp = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
        expr_ptr_ptr = tmp;
        if (1 << 2 == 1 << 2) {
          tmp___0 = __builtin_expect((long )((unsigned int )expr_ptr_ptr == (unsigned int )((void *)0)), 0L);
          if (tmp___0) {
            zend_error_noreturn(1, "Cannot create references to/from string offsets");
          } else {

          }
        } else {

        }
        tmp___3 = zval_isref_p(*expr_ptr_ptr);
        if (tmp___3) {

        } else {
          while (1) {
            tmp___2 = zval_refcount_p(*expr_ptr_ptr);
            if (tmp___2 > 1U) {
              zval_delref_p(*expr_ptr_ptr);
              while (1) {
                tmp___1 = _emalloc(sizeof(zval_gc_info ));
                new_zv = (zval *)tmp___1;
                ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv->value = (*expr_ptr_ptr)->value;
                  new_zv->type = (*expr_ptr_ptr)->type;
                  break;
                }
                zval_set_refcount_p(new_zv, 1U);
                zval_unset_isref_p(new_zv);
                break;
              }
              *expr_ptr_ptr = new_zv;
              _zval_copy_ctor(new_zv);
            } else {

            }
            break;
          }
          zval_set_isref_p(*expr_ptr_ptr);
        }
        expr_ptr = *expr_ptr_ptr;
        zval_addref_p(expr_ptr);
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      expr_ptr = _get_zval_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
      if (1 << 2 == 1) {
        goto _L;
      } else {
        tmp___6 = zval_isref_p(expr_ptr);
        if (tmp___6) {
          _L: /* CIL Label */ 
          while (1) {
            tmp___5 = _emalloc(sizeof(zval_gc_info ));
            new_expr___0 = (zval *)tmp___5;
            ((zval_gc_info *)new_expr___0)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_expr___0->value = expr_ptr->value;
              new_expr___0->type = expr_ptr->type;
              break;
            }
            zval_set_refcount_p(new_expr___0, 1U);
            zval_unset_isref_p(new_expr___0);
            break;
          }
          expr_ptr = new_expr___0;
          _zval_copy_ctor(expr_ptr);
        } else {
          zval_addref_p(expr_ptr);
        }
      }
    }
  }
  if (1 << 4 != 1 << 3) {
    tmp___7 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
    offset = tmp___7;
    switch ((int )offset->type) {
    case 2: 
    tmp___8 = zend_dval_to_lval(offset->value.dval);
    hval = (unsigned long )tmp___8;
    goto num_index;
    case 1: 
    case 3: 
    hval = (unsigned long )offset->value.lval;
    num_index: 
    _zend_hash_index_update_or_next_insert(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, hval, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    case 6: 
    if (1 << 4 == 1) {
      hval = ((zend_literal *)offset)->hash_value;
    } else {
      while (1) {
        tmp___9 = (char const   *)offset->value.str.val;
        if ((int const   )*tmp___9 == 45) {
          tmp___9 ++;
        } else {

        }
        if ((int const   )*tmp___9 >= 48) {
          if ((int const   )*tmp___9 <= 57) {
            end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
            if ((int const   )*end != 0) {
              break;
            } else {
              if ((int const   )*tmp___9 == 48) {
                if (offset->value.str.len + 1 > 2) {
                  break;
                } else {
                  goto _L___2;
                }
              } else {
                _L___2: /* CIL Label */ 
                if (end - tmp___9 > 10) {
                  break;
                } else {
                  if (end - tmp___9 == 10) {
                    if ((int const   )*tmp___9 > 50) {
                      break;
                    } else {

                    }
                  } else {

                  }
                }
              }
            }
            hval = (unsigned long )((int const   )*tmp___9 - 48);
            while (1) {
              tmp___9 ++;
              if ((unsigned int )tmp___9 != (unsigned int )end) {
                if ((int const   )*tmp___9 >= 48) {
                  if ((int const   )*tmp___9 <= 57) {

                  } else {
                    break;
                  }
                } else {
                  break;
                }
              } else {
                break;
              }
              hval = hval * 10UL + (ulong )((int const   )*tmp___9 - 48);
            }
            if ((unsigned int )tmp___9 == (unsigned int )end) {
              if ((int )*(offset->value.str.val) == 45) {
                if (hval - 1UL > 2147483647UL) {
                  break;
                } else {

                }
                hval = (unsigned long )(- ((long )hval));
              } else {
                if (hval > 2147483647UL) {
                  break;
                } else {

                }
              }
              goto num_index;
            } else {

            }
          } else {

          }
        } else {

        }
        break;
      }
      if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
        if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
          hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
        } else {
          tmp___10 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___10;
        }
      } else {
        tmp___10 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
        hval = (unsigned long )tmp___10;
      }
    }
    _zend_hash_quick_add_or_update(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    case 0: 
    _zend_hash_add_or_update(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, "", sizeof(""), (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    default: 
    zend_error(1 << 1L, "Illegal offset type");
    i_zval_ptr_dtor(expr_ptr);
    break;
    }
  } else {
    _zend_hash_index_update_or_next_insert(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, 0UL, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1 << 2);
  }
  if (1 << 2 == 1 << 2) {
    goto _L___4;
  } else {
    if (1 << 2 == 1 << 4) {
      _L___4: /* CIL Label */ 
      if (opline->extended_value) {
        if (free_op1.var) {
          i_zval_ptr_dtor(free_op1.var);
        } else {

        }
      } else {
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ 
      if (free_op1.var) {
        i_zval_ptr_dtor(free_op1.var);
      } else {

      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_ARRAY_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  int tmp ;

  {
  opline = execute_data->opline;
  _array_init(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, 0U);
  if (1 << 2 == 1 << 3) {
    (execute_data->opline) ++;
    return (0);
  } else {
    tmp = ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CV_HANDLER(execute_data);
    return (tmp);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_UNSET_DIM_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **container ;
  zval *offset ;
  ulong hval ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  HashTable *ht ;
  long tmp___2 ;
  register char const   *tmp___3 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___4 ;
  long tmp___5 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  if (1 << 2 == 1 << 4) {
    if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
      tmp___1 = zval_isref_p(*container);
      if (tmp___1) {

      } else {
        while (1) {
          tmp___0 = zval_refcount_p(*container);
          if (tmp___0 > 1U) {
            zval_delref_p(*container);
            while (1) {
              tmp = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*container)->value;
                new_zv->type = (*container)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *container = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
    } else {

    }
  } else {

  }
  offset = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  if (1 << 2 != 1 << 2) {
    goto _L___0;
  } else {
    if (container) {
      _L___0: /* CIL Label */ 
      switch ((int )(*container)->type) {
      case 4: 
      ht = (*container)->value.ht;
      switch ((int )offset->type) {
      case 2: 
      tmp___2 = zend_dval_to_lval(offset->value.dval);
      hval = (unsigned long )tmp___2;
      goto num_index_dim;
      case 7: 
      case 3: 
      case 1: 
      hval = (unsigned long )offset->value.lval;
      zend_hash_del_key_or_index(ht, (char const   *)((void *)0), 0U, hval, 1);
      break;
      case 6: 
      if (1 << 4 == 1 << 4) {
        zval_addref_p(offset);
      } else {
        if (1 << 4 == 1 << 2) {
          zval_addref_p(offset);
        } else {

        }
      }
      if (1 << 4 == 1) {
        hval = ((zend_literal *)offset)->hash_value;
      } else {
        while (1) {
          tmp___3 = (char const   *)offset->value.str.val;
          if ((int const   )*tmp___3 == 45) {
            tmp___3 ++;
          } else {

          }
          if ((int const   )*tmp___3 >= 48) {
            if ((int const   )*tmp___3 <= 57) {
              end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
              if ((int const   )*end != 0) {
                break;
              } else {
                if ((int const   )*tmp___3 == 48) {
                  if (offset->value.str.len + 1 > 2) {
                    break;
                  } else {
                    goto _L;
                  }
                } else {
                  _L: /* CIL Label */ 
                  if (end - tmp___3 > 10) {
                    break;
                  } else {
                    if (end - tmp___3 == 10) {
                      if ((int const   )*tmp___3 > 50) {
                        break;
                      } else {

                      }
                    } else {

                    }
                  }
                }
              }
              hval = (unsigned long )((int const   )*tmp___3 - 48);
              while (1) {
                tmp___3 ++;
                if ((unsigned int )tmp___3 != (unsigned int )end) {
                  if ((int const   )*tmp___3 >= 48) {
                    if ((int const   )*tmp___3 <= 57) {

                    } else {
                      break;
                    }
                  } else {
                    break;
                  }
                } else {
                  break;
                }
                hval = hval * 10UL + (ulong )((int const   )*tmp___3 - 48);
              }
              if ((unsigned int )tmp___3 == (unsigned int )end) {
                if ((int )*(offset->value.str.val) == 45) {
                  if (hval - 1UL > 2147483647UL) {
                    break;
                  } else {

                  }
                  hval = (unsigned long )(- ((long )hval));
                } else {
                  if (hval > 2147483647UL) {
                    break;
                  } else {

                  }
                }
                goto num_index_dim;
              } else {

              }
            } else {

            }
          } else {

          }
          break;
        }
        if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
          if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
            hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
          } else {
            tmp___4 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
            hval = (unsigned long )tmp___4;
          }
        } else {
          tmp___4 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___4;
        }
      }
      if ((unsigned int )ht == (unsigned int )(& executor_globals.symbol_table)) {
        zend_delete_global_variable_ex((char const   *)offset->value.str.val, offset->value.str.len, hval);
      } else {
        zend_hash_del_key_or_index(ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, 2);
      }
      if (1 << 4 == 1 << 4) {
        i_zval_ptr_dtor(offset);
      } else {
        if (1 << 4 == 1 << 2) {
          i_zval_ptr_dtor(offset);
        } else {

        }
      }
      break;
      num_index_dim: 
      zend_hash_del_key_or_index(ht, (char const   *)((void *)0), 0U, hval, 1);
      if (1 << 4 == 1 << 4) {
        i_zval_ptr_dtor(offset);
      } else {
        if (1 << 4 == 1 << 2) {
          i_zval_ptr_dtor(offset);
        } else {

        }
      }
      break;
      case 0: 
      zend_hash_del_key_or_index(ht, "", sizeof(""), 0UL, 0);
      break;
      default: 
      zend_error(1 << 1L, "Illegal offset type in unset");
      break;
      }
      break;
      case 5: 
      tmp___5 = __builtin_expect((long )((unsigned int )((*container)->value.obj.handlers)->unset_dimension == (unsigned int )((void *)0)), 0L);
      if (tmp___5) {
        zend_error_noreturn(1, "Cannot use object as array");
      } else {

      }
      (*(((*container)->value.obj.handlers)->unset_dimension))(*container, offset);
      break;
      case 6: 
      zend_error_noreturn(1, "Cannot unset string offsets");
      return (0);
      default: ;
      break;
      }
    } else {

    }
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_UNSET_OBJ_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **container ;
  zval *offset ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_literal *tmp___3 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  offset = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  if (1 << 2 != 1 << 2) {
    goto _L;
  } else {
    if (container) {
      _L: /* CIL Label */ 
      if (1 << 2 == 1 << 4) {
        if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
          tmp___1 = zval_isref_p(*container);
          if (tmp___1) {

          } else {
            while (1) {
              tmp___0 = zval_refcount_p(*container);
              if (tmp___0 > 1U) {
                zval_delref_p(*container);
                while (1) {
                  tmp = _emalloc(sizeof(zval_gc_info ));
                  new_zv = (zval *)tmp;
                  ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                  break;
                }
                while (1) {
                  while (1) {
                    new_zv->value = (*container)->value;
                    new_zv->type = (*container)->type;
                    break;
                  }
                  zval_set_refcount_p(new_zv, 1U);
                  zval_unset_isref_p(new_zv);
                  break;
                }
                *container = new_zv;
                _zval_copy_ctor(new_zv);
              } else {

              }
              break;
            }
          }
        } else {

        }
      } else {

      }
      if ((int )(*container)->type == 5) {
        if (((*container)->value.obj.handlers)->unset_property) {
          if (1 << 4 == 1) {
            tmp___3 = opline->op2.literal;
          } else {
            tmp___3 = (zend_literal *)((void *)0);
          }
          (*(((*container)->value.obj.handlers)->unset_property))(*container, offset, (struct _zend_literal  const  *)tmp___3);
        } else {
          zend_error(1 << 3L, "Trying to unset property of non-object");
        }
      } else {

      }
    } else {

    }
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_CV)(int prop_dim , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **container ;
  zval **value ;
  int result ;
  ulong hval ;
  zval *offset ;
  HashTable *ht ;
  int isset ;
  long tmp ;
  int __attribute__((__visibility__("default")))  tmp___0 ;
  register char const   *tmp___1 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___2 ;
  int __attribute__((__visibility__("default")))  tmp___3 ;
  int __attribute__((__visibility__("default")))  tmp___4 ;
  int tmp___5 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;
  zend_literal *tmp___7 ;
  zval tmp___8 ;

  {
  opline = execute_data->opline;
  value = (zval **)((void *)0);
  result = 0;
  container = _get_zval_ptr_ptr_var(opline->op1.var, (temp_variable const   *)execute_data->Ts, & free_op1);
  offset = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  if ((int )(*container)->type == 4) {
    if (! prop_dim) {
      isset = 0;
      ht = (*container)->value.ht;
      switch ((int )offset->type) {
      case 2: 
      tmp = zend_dval_to_lval(offset->value.dval);
      hval = (unsigned long )tmp;
      goto num_index_prop;
      case 7: 
      case 3: 
      case 1: 
      hval = (unsigned long )offset->value.lval;
      num_index_prop: 
      tmp___0 = zend_hash_index_find((HashTable const   *)ht, hval, (void **)(& value));
      if (tmp___0 == (int __attribute__((__visibility__("default")))  )0) {
        isset = 1;
      } else {

      }
      break;
      case 6: 
      if (1 << 4 == 1) {
        hval = ((zend_literal *)offset)->hash_value;
      } else {
        if (! prop_dim) {
          while (1) {
            tmp___1 = (char const   *)offset->value.str.val;
            if ((int const   )*tmp___1 == 45) {
              tmp___1 ++;
            } else {

            }
            if ((int const   )*tmp___1 >= 48) {
              if ((int const   )*tmp___1 <= 57) {
                end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
                if ((int const   )*end != 0) {
                  break;
                } else {
                  if ((int const   )*tmp___1 == 48) {
                    if (offset->value.str.len + 1 > 2) {
                      break;
                    } else {
                      goto _L;
                    }
                  } else {
                    _L: /* CIL Label */ 
                    if (end - tmp___1 > 10) {
                      break;
                    } else {
                      if (end - tmp___1 == 10) {
                        if ((int const   )*tmp___1 > 50) {
                          break;
                        } else {

                        }
                      } else {

                      }
                    }
                  }
                }
                hval = (unsigned long )((int const   )*tmp___1 - 48);
                while (1) {
                  tmp___1 ++;
                  if ((unsigned int )tmp___1 != (unsigned int )end) {
                    if ((int const   )*tmp___1 >= 48) {
                      if ((int const   )*tmp___1 <= 57) {

                      } else {
                        break;
                      }
                    } else {
                      break;
                    }
                  } else {
                    break;
                  }
                  hval = hval * 10UL + (ulong )((int const   )*tmp___1 - 48);
                }
                if ((unsigned int )tmp___1 == (unsigned int )end) {
                  if ((int )*(offset->value.str.val) == 45) {
                    if (hval - 1UL > 2147483647UL) {
                      break;
                    } else {

                    }
                    hval = (unsigned long )(- ((long )hval));
                  } else {
                    if (hval > 2147483647UL) {
                      break;
                    } else {

                    }
                  }
                  goto num_index_prop;
                } else {

                }
              } else {

              }
            } else {

            }
            break;
          }
        } else {

        }
        if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
          if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
            hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
          } else {
            tmp___2 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
            hval = (unsigned long )tmp___2;
          }
        } else {
          tmp___2 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___2;
        }
      }
      tmp___3 = zend_hash_quick_find((HashTable const   *)ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, (void **)(& value));
      if (tmp___3 == (int __attribute__((__visibility__("default")))  )0) {
        isset = 1;
      } else {

      }
      break;
      case 0: 
      tmp___4 = zend_hash_find((HashTable const   *)ht, "", sizeof(""), (void **)(& value));
      if (tmp___4 == (int __attribute__((__visibility__("default")))  )0) {
        isset = 1;
      } else {

      }
      break;
      default: 
      zend_error(1 << 1L, "Illegal offset type in isset or empty");
      break;
      }
      if (opline->extended_value & 33554432UL) {
        if (isset) {
          if ((int )(*value)->type == 0) {
            result = 0;
          } else {
            result = isset;
          }
        } else {
          result = isset;
        }
      } else {
        if (! isset) {
          result = 0;
        } else {
          tmp___5 = i_zend_is_true(*value);
          if (tmp___5) {
            result = 1;
          } else {
            result = 0;
          }
        }
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if ((int )(*container)->type == 5) {
      if (prop_dim) {
        if (((*container)->value.obj.handlers)->has_property) {
          if (1 << 4 == 1) {
            tmp___7 = opline->op2.literal;
          } else {
            tmp___7 = (zend_literal *)((void *)0);
          }
          result = (*(((*container)->value.obj.handlers)->has_property))(*container, offset, (opline->extended_value & 16777216UL) != 0UL, (struct _zend_literal  const  *)tmp___7);
        } else {
          zend_error(1 << 3L, "Trying to check property of non-object");
          result = 0;
        }
      } else {
        if (((*container)->value.obj.handlers)->has_dimension) {
          result = (*(((*container)->value.obj.handlers)->has_dimension))(*container, offset, (opline->extended_value & 16777216UL) != 0UL);
        } else {
          zend_error(1 << 3L, "Trying to check element of non-array");
          result = 0;
        }
      }
    } else {
      if ((int )(*container)->type == 6) {
        if (! prop_dim) {
          if ((int )offset->type != 1) {
            while (1) {
              tmp___8.value = offset->value;
              tmp___8.type = offset->type;
              break;
            }
            _zval_copy_ctor(& tmp___8);
            convert_to_long(& tmp___8);
            offset = & tmp___8;
          } else {

          }
          if ((int )offset->type == 1) {
            if (opline->extended_value & 33554432UL) {
              if (offset->value.lval >= 0L) {
                if (offset->value.lval < (long )(*container)->value.str.len) {
                  result = 1;
                } else {

                }
              } else {

              }
            } else {
              if (offset->value.lval >= 0L) {
                if (offset->value.lval < (long )(*container)->value.str.len) {
                  if ((int )*((*container)->value.str.val + offset->value.lval) != 48) {
                    result = 1;
                  } else {

                  }
                } else {

                }
              } else {

              }
            }
          } else {

          }
        } else {

        }
      } else {

      }
    }
  }
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.type = (unsigned char)3;
  if (opline->extended_value & 33554432UL) {
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.lval = (long )result;
  } else {
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.lval = (long )(! result);
  }
  if (free_op1.var) {
    i_zval_ptr_dtor(free_op1.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_CV(0, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_VAR_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_CV(1, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_CLONE_SPEC_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *obj ;
  zend_class_entry *ce ;
  zend_function *clone ;
  zend_object_value (*clone_call)(zval *object ) ;
  long tmp ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  long tmp___1 ;
  char const   *tmp___2 ;
  long tmp___3 ;
  char const   *tmp___4 ;
  int __attribute__((__visibility__("default")))  tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  zval *retval ;
  void __attribute__((__visibility__("default")))  *tmp___8 ;
  temp_variable *__t ;
  long tmp___9 ;
  long tmp___10 ;

  {
  opline = execute_data->opline;
  obj = _get_obj_zval_ptr_unused();
  if (1 << 3 == 1) {
    zend_error_noreturn(1, "__clone method called on non-object");
  } else {
    tmp = __builtin_expect((long )((int )obj->type != 5), 0L);
    if (tmp) {
      zend_error_noreturn(1, "__clone method called on non-object");
    } else {

    }
  }
  tmp___0 = zend_get_class_entry((zval const   *)obj);
  ce = (zend_class_entry *)tmp___0;
  if (ce) {
    clone = ce->clone;
  } else {
    clone = (zend_function *)((void *)0);
  }
  clone_call = (zend_object_value (*)(zval *object ))(obj->value.obj.handlers)->clone_obj;
  tmp___1 = __builtin_expect((long )((unsigned int )clone_call == (unsigned int )((void *)0)), 0L);
  if (tmp___1) {
    if (ce) {
      zend_error_noreturn(1, "Trying to clone an uncloneable object of class %s", ce->name);
    } else {
      zend_error_noreturn(1, "Trying to clone an uncloneable object");
    }
  } else {

  }
  if (ce) {
    if (clone) {
      if (clone->op_array.fn_flags & 1024U) {
        tmp___3 = __builtin_expect((long )((unsigned int )ce != (unsigned int )executor_globals.scope), 0L);
        if (tmp___3) {
          if (executor_globals.scope) {
            tmp___2 = (executor_globals.scope)->name;
          } else {
            tmp___2 = "";
          }
          zend_error_noreturn(1, "Call to private %s::__clone() from context \'%s\'", ce->name, tmp___2);
        } else {

        }
      } else {
        if (clone->common.fn_flags & 512U) {
          tmp___5 = zend_check_protected(clone->common.scope, executor_globals.scope);
          if (tmp___5) {
            tmp___6 = 0;
          } else {
            tmp___6 = 1;
          }
          tmp___7 = __builtin_expect((long )tmp___6, 0L);
          if (tmp___7) {
            if (executor_globals.scope) {
              tmp___4 = (executor_globals.scope)->name;
            } else {
              tmp___4 = "";
            }
            zend_error_noreturn(1, "Call to protected %s::__clone() from context \'%s\'", ce->name, tmp___4);
          } else {

          }
        } else {

        }
      }
    } else {

    }
  } else {

  }
  tmp___10 = __builtin_expect((long )((unsigned int )executor_globals.exception == (unsigned int )((void *)0)), 1L);
  if (tmp___10) {
    while (1) {
      tmp___8 = _emalloc(sizeof(zval_gc_info ));
      retval = (zval *)tmp___8;
      ((zval_gc_info *)retval)->u.buffered = (gc_root_buffer *)((void *)0);
      break;
    }
    retval->value.obj = (*clone_call)(obj);
    retval->type = (unsigned char)5;
    zval_set_refcount_p(retval, 1U);
    zval_set_isref_p(retval);
    if (! (! ((int )opline->result_type & (1 << 5)))) {
      i_zval_ptr_dtor(retval);
    } else {
      tmp___9 = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
      if (tmp___9) {
        i_zval_ptr_dtor(retval);
      } else {
        while (1) {
          __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
          __t->var.ptr = retval;
          __t->var.ptr_ptr = & __t->var.ptr;
          break;
        }
      }
    }
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_EXIT_SPEC_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ 

  {
  _zend_bailout((char *)"/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-12-18-beda5efd41-622412d8e6/php/Zend/zend_vm_execute.h", 21247U);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_binary_assign_op_obj_helper_SPEC_UNUSED_CONST)(int (*binary_op)(zval *result , zval *op1 , zval *op2 ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op_data1 ;
  zval **object_ptr ;
  zval **tmp ;
  zval *object ;
  zval *property ;
  zval *value ;
  zval *tmp___0 ;
  int have_get_ptr ;
  long tmp___1 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zval **zptr ;
  zval **tmp___3 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_uint tmp___5 ;
  zend_bool tmp___6 ;
  zval *z ;
  zval *value___0 ;
  zval *tmp___7 ;
  zend_uint tmp___8 ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___9 ;
  zend_uint tmp___10 ;
  zend_bool tmp___11 ;
  long tmp___12 ;

  {
  opline = execute_data->opline;
  tmp = _get_obj_zval_ptr_ptr_unused();
  object_ptr = tmp;
  property = opline->op2.zv;
  tmp___0 = _get_zval_ptr((int )(opline + 1)->op1_type, (znode_op const   *)(& (opline + 1)->op1), (temp_variable const   *)execute_data->Ts, & free_op_data1, 0);
  value = tmp___0;
  have_get_ptr = 0;
  if (1 << 3 == 1 << 2) {
    tmp___1 = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___1) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  make_real_object(object_ptr);
  object = *object_ptr;
  tmp___12 = __builtin_expect((long )((int )object->type != 5), 0L);
  if (tmp___12) {
    zend_error(1 << 1L, "Attempt to assign property of non-object");
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = & executor_globals.uninitialized_zval;
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
    } else {

    }
  } else {
    if (opline->extended_value == 136UL) {
      if ((object->value.obj.handlers)->get_property_ptr_ptr) {
        tmp___3 = (*((object->value.obj.handlers)->get_property_ptr_ptr))(object, property, (struct _zend_literal  const  *)opline->op2.literal);
        zptr = tmp___3;
        if ((unsigned int )zptr != (unsigned int )((void *)0)) {
          tmp___6 = zval_isref_p(*zptr);
          if (tmp___6) {

          } else {
            while (1) {
              tmp___5 = zval_refcount_p(*zptr);
              if (tmp___5 > 1U) {
                zval_delref_p(*zptr);
                while (1) {
                  tmp___4 = _emalloc(sizeof(zval_gc_info ));
                  new_zv = (zval *)tmp___4;
                  ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                  break;
                }
                while (1) {
                  while (1) {
                    new_zv->value = (*zptr)->value;
                    new_zv->type = (*zptr)->type;
                    break;
                  }
                  zval_set_refcount_p(new_zv, 1U);
                  zval_unset_isref_p(new_zv);
                  break;
                }
                *zptr = new_zv;
                _zval_copy_ctor(new_zv);
              } else {

              }
              break;
            }
          }
          have_get_ptr = 1;
          (*binary_op)(*zptr, *zptr, value);
          if (! ((int )opline->result_type & (1 << 5))) {
            zval_addref_p(*zptr);
            ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = *zptr;
            ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
          } else {

          }
        } else {

        }
      } else {

      }
    } else {

    }
    if (! have_get_ptr) {
      z = (zval *)((void *)0);
      if (opline->extended_value == 136UL) {
        if ((object->value.obj.handlers)->read_property) {
          z = (*((object->value.obj.handlers)->read_property))(object, property, 0, (struct _zend_literal  const  *)opline->op2.literal);
        } else {

        }
      } else {
        if ((object->value.obj.handlers)->read_dimension) {
          z = (*((object->value.obj.handlers)->read_dimension))(object, property, 0);
        } else {

        }
      }
      if (z) {
        if ((int )z->type == 5) {
          if ((z->value.obj.handlers)->get) {
            tmp___7 = (*((z->value.obj.handlers)->get))(z);
            value___0 = tmp___7;
            tmp___8 = zval_refcount_p(z);
            if (tmp___8 == 0U) {
              if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                gc_remove_zval_from_buffer(z);
              } else {

              }
              _zval_dtor(z);
              while (1) {
                if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                  gc_remove_zval_from_buffer(z);
                } else {

                }
                _efree((void *)z);
                break;
              }
            } else {

            }
            z = value___0;
          } else {

          }
        } else {

        }
        zval_addref_p(z);
        tmp___11 = zval_isref_p(z);
        if (tmp___11) {

        } else {
          while (1) {
            tmp___10 = zval_refcount_p(z);
            if (tmp___10 > 1U) {
              zval_delref_p(z);
              while (1) {
                tmp___9 = _emalloc(sizeof(zval_gc_info ));
                new_zv___0 = (zval *)tmp___9;
                ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv___0->value = z->value;
                  new_zv___0->type = z->type;
                  break;
                }
                zval_set_refcount_p(new_zv___0, 1U);
                zval_unset_isref_p(new_zv___0);
                break;
              }
              z = new_zv___0;
              _zval_copy_ctor(new_zv___0);
            } else {

            }
            break;
          }
        }
        (*binary_op)(z, z, value);
        if (opline->extended_value == 136UL) {
          (*((object->value.obj.handlers)->write_property))(object, property, z, (struct _zend_literal  const  *)opline->op2.literal);
        } else {
          (*((object->value.obj.handlers)->write_dimension))(object, property, z);
        }
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(z);
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = z;
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
        } else {

        }
        i_zval_ptr_dtor(z);
      } else {
        zend_error(1 << 1L, "Attempt to assign property of non-object");
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = & executor_globals.uninitialized_zval;
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
        } else {

        }
      }
    } else {

    }
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
  }
  (execute_data->opline) ++;
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_binary_assign_op_helper_SPEC_UNUSED_CONST)(int (*binary_op)(zval *result , zval *op1 , zval *op2 ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op_data2 ;
  zend_free_op free_op_data1 ;
  zval **var_ptr ;
  zval *value ;
  int tmp ;
  zval **container ;
  zval **tmp___0 ;
  int tmp___1 ;
  zval *dim ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  temp_variable *__t ;
  long tmp___5 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;
  zend_uint tmp___7 ;
  zend_bool tmp___8 ;
  zval *objval ;
  zval *tmp___9 ;
  long tmp___10 ;
  temp_variable *__t___0 ;

  {
  opline = execute_data->opline;
  switch ((int )opline->extended_value) {
  case 136: 
  tmp = zend_binary_assign_op_obj_helper_SPEC_UNUSED_CONST(binary_op, execute_data);
  return (tmp);
  break;
  case 147: 
  tmp___0 = _get_obj_zval_ptr_ptr_unused();
  container = tmp___0;
  if (1 << 3 == 1 << 2) {
    tmp___3 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___3) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    tmp___2 = __builtin_expect((long )((int )(*container)->type == 5), 0L);
    if (tmp___2) {
      if (1 << 3 == 1 << 2) {
        zval_addref_p(*container);
      } else {

      }
      tmp___1 = zend_binary_assign_op_obj_helper_SPEC_UNUSED_CONST(binary_op, execute_data);
      return (tmp___1);
    } else {
      dim = opline->op2.zv;
      zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var), container, dim, 1, 2);
      value = _get_zval_ptr((int )(opline + 1)->op1_type, (znode_op const   *)(& (opline + 1)->op1), (temp_variable const   *)execute_data->Ts, & free_op_data1, 0);
      var_ptr = _get_zval_ptr_ptr_var((opline + 1)->op2.var, (temp_variable const   *)execute_data->Ts, & free_op_data2);
    }
  }
  break;
  default: 
  value = opline->op2.zv;
  var_ptr = (zval **)((void *)0);
  break;
  }
  tmp___4 = __builtin_expect((long )((unsigned int )var_ptr == (unsigned int )((void *)0)), 0L);
  if (tmp___4) {
    zend_error_noreturn(1, "Cannot use assign-op operators with overloaded objects nor string offsets");
  } else {

  }
  tmp___5 = __builtin_expect((long )((unsigned int )*var_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
  if (tmp___5) {
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      while (1) {
        __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t->var.ptr = & executor_globals.uninitialized_zval;
        __t->var.ptr_ptr = & __t->var.ptr;
        break;
      }
    } else {

    }
    if (opline->extended_value == 147UL) {
      (execute_data->opline) ++;
    } else {

    }
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  tmp___8 = zval_isref_p(*var_ptr);
  if (tmp___8) {

  } else {
    while (1) {
      tmp___7 = zval_refcount_p(*var_ptr);
      if (tmp___7 > 1U) {
        zval_delref_p(*var_ptr);
        while (1) {
          tmp___6 = _emalloc(sizeof(zval_gc_info ));
          new_zv = (zval *)tmp___6;
          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            new_zv->value = (*var_ptr)->value;
            new_zv->type = (*var_ptr)->type;
            break;
          }
          zval_set_refcount_p(new_zv, 1U);
          zval_unset_isref_p(new_zv);
          break;
        }
        *var_ptr = new_zv;
        _zval_copy_ctor(new_zv);
      } else {

      }
      break;
    }
  }
  tmp___10 = __builtin_expect((long )((int )(*var_ptr)->type == 5), 0L);
  if (tmp___10) {
    if (((*var_ptr)->value.obj.handlers)->get) {
      if (((*var_ptr)->value.obj.handlers)->set) {
        tmp___9 = (*(((*var_ptr)->value.obj.handlers)->get))(*var_ptr);
        objval = tmp___9;
        zval_addref_p(objval);
        (*binary_op)(objval, objval, value);
        (*(((*var_ptr)->value.obj.handlers)->set))(var_ptr, objval);
        i_zval_ptr_dtor(objval);
      } else {
        (*binary_op)(*var_ptr, *var_ptr, value);
      }
    } else {
      (*binary_op)(*var_ptr, *var_ptr, value);
    }
  } else {
    (*binary_op)(*var_ptr, *var_ptr, value);
  }
  if (! ((int )opline->result_type & (1 << 5))) {
    zval_addref_p(*var_ptr);
    while (1) {
      __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
      __t___0->var.ptr = *var_ptr;
      __t___0->var.ptr_ptr = & __t___0->var.ptr;
      break;
    }
  } else {

  }
  if (opline->extended_value == 147UL) {
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
    if (free_op_data2.var) {
      i_zval_ptr_dtor(free_op_data2.var);
    } else {

    }
    (execute_data->opline) ++;
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_ADD_SPEC_UNUSED_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_CONST((int (*)(zval *result , zval *op1 , zval *op2 ))(& add_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SUB_SPEC_UNUSED_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_CONST((int (*)(zval *result , zval *op1 , zval *op2 ))(& sub_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_MUL_SPEC_UNUSED_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_CONST((int (*)(zval *result , zval *op1 , zval *op2 ))(& mul_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_DIV_SPEC_UNUSED_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_CONST((int (*)(zval *result , zval *op1 , zval *op2 ))(& div_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_MOD_SPEC_UNUSED_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_CONST((int (*)(zval *result , zval *op1 , zval *op2 ))(& mod_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SL_SPEC_UNUSED_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_CONST((int (*)(zval *result , zval *op1 , zval *op2 ))(& shift_left_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SR_SPEC_UNUSED_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_CONST((int (*)(zval *result , zval *op1 , zval *op2 ))(& shift_right_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_CONCAT_SPEC_UNUSED_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_CONST((int (*)(zval *result , zval *op1 , zval *op2 ))(& concat_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_OR_SPEC_UNUSED_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_CONST((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_or_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_AND_SPEC_UNUSED_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_CONST((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_and_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_CONST((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_xor_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) zend_pre_incdec_property_helper_SPEC_UNUSED_CONST)(int (*incdec_op)(zval * ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **object_ptr ;
  zval *object ;
  zval *property ;
  zval **retval ;
  int have_get_ptr ;
  long tmp ;
  long tmp___0 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zval **zptr ;
  zval **tmp___2 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___3 ;
  zend_uint tmp___4 ;
  zend_bool tmp___5 ;
  zval *z ;
  zval *tmp___6 ;
  zval *value ;
  zval *tmp___7 ;
  zend_uint tmp___8 ;
  long tmp___9 ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___10 ;
  zend_uint tmp___11 ;
  zend_bool tmp___12 ;

  {
  opline = execute_data->opline;
  have_get_ptr = 0;
  object_ptr = _get_obj_zval_ptr_ptr_unused();
  property = opline->op2.zv;
  retval = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
  if (1 << 3 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot increment/decrement overloaded objects nor string offsets");
    } else {

    }
  } else {

  }
  make_real_object(object_ptr);
  object = *object_ptr;
  tmp___0 = __builtin_expect((long )((int )object->type != 5), 0L);
  if (tmp___0) {
    zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      *retval = & executor_globals.uninitialized_zval;
    } else {

    }
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  if ((object->value.obj.handlers)->get_property_ptr_ptr) {
    tmp___2 = (*((object->value.obj.handlers)->get_property_ptr_ptr))(object, property, (struct _zend_literal  const  *)opline->op2.literal);
    zptr = tmp___2;
    if ((unsigned int )zptr != (unsigned int )((void *)0)) {
      tmp___5 = zval_isref_p(*zptr);
      if (tmp___5) {

      } else {
        while (1) {
          tmp___4 = zval_refcount_p(*zptr);
          if (tmp___4 > 1U) {
            zval_delref_p(*zptr);
            while (1) {
              tmp___3 = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp___3;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*zptr)->value;
                new_zv->type = (*zptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *zptr = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
      have_get_ptr = 1;
      (*incdec_op)(*zptr);
      if (! ((int )opline->result_type & (1 << 5))) {
        *retval = *zptr;
        zval_addref_p(*retval);
      } else {

      }
    } else {

    }
  } else {

  }
  if (! have_get_ptr) {
    if ((object->value.obj.handlers)->read_property) {
      if ((object->value.obj.handlers)->write_property) {
        tmp___6 = (*((object->value.obj.handlers)->read_property))(object, property, 0, (struct _zend_literal  const  *)opline->op2.literal);
        z = tmp___6;
        tmp___9 = __builtin_expect((long )((int )z->type == 5), 0L);
        if (tmp___9) {
          if ((z->value.obj.handlers)->get) {
            tmp___7 = (*((z->value.obj.handlers)->get))(z);
            value = tmp___7;
            tmp___8 = zval_refcount_p(z);
            if (tmp___8 == 0U) {
              if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                gc_remove_zval_from_buffer(z);
              } else {

              }
              _zval_dtor(z);
              while (1) {
                if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                  gc_remove_zval_from_buffer(z);
                } else {

                }
                _efree((void *)z);
                break;
              }
            } else {

            }
            z = value;
          } else {

          }
        } else {

        }
        zval_addref_p(z);
        tmp___12 = zval_isref_p(z);
        if (tmp___12) {

        } else {
          while (1) {
            tmp___11 = zval_refcount_p(z);
            if (tmp___11 > 1U) {
              zval_delref_p(z);
              while (1) {
                tmp___10 = _emalloc(sizeof(zval_gc_info ));
                new_zv___0 = (zval *)tmp___10;
                ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv___0->value = z->value;
                  new_zv___0->type = z->type;
                  break;
                }
                zval_set_refcount_p(new_zv___0, 1U);
                zval_unset_isref_p(new_zv___0);
                break;
              }
              z = new_zv___0;
              _zval_copy_ctor(new_zv___0);
            } else {

            }
            break;
          }
        }
        (*incdec_op)(z);
        *retval = z;
        (*((object->value.obj.handlers)->write_property))(object, property, z, (struct _zend_literal  const  *)opline->op2.literal);
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(*retval);
        } else {

        }
        i_zval_ptr_dtor(z);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
      if (! ((int )opline->result_type & (1 << 5))) {
        zval_addref_p(& executor_globals.uninitialized_zval);
        *retval = & executor_globals.uninitialized_zval;
      } else {

      }
    }
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_PRE_INC_OBJ_SPEC_UNUSED_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_pre_incdec_property_helper_SPEC_UNUSED_CONST((int (*)(zval * ))(& increment_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_PRE_DEC_OBJ_SPEC_UNUSED_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_pre_incdec_property_helper_SPEC_UNUSED_CONST((int (*)(zval * ))(& decrement_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) zend_post_incdec_property_helper_SPEC_UNUSED_CONST)(int (*incdec_op)(zval * ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **object_ptr ;
  zval *object ;
  zval *property ;
  zval *retval ;
  int have_get_ptr ;
  long tmp ;
  long tmp___0 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zval **zptr ;
  zval **tmp___2 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___3 ;
  zend_uint tmp___4 ;
  zend_bool tmp___5 ;
  zval *z ;
  zval *tmp___6 ;
  zval *z_copy ;
  zval *value ;
  zval *tmp___7 ;
  zend_uint tmp___8 ;
  long tmp___9 ;
  void __attribute__((__visibility__("default")))  *tmp___10 ;

  {
  opline = execute_data->opline;
  have_get_ptr = 0;
  object_ptr = _get_obj_zval_ptr_ptr_unused();
  property = opline->op2.zv;
  retval = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  if (1 << 3 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot increment/decrement overloaded objects nor string offsets");
    } else {

    }
  } else {

  }
  make_real_object(object_ptr);
  object = *object_ptr;
  tmp___0 = __builtin_expect((long )((int )object->type != 5), 0L);
  if (tmp___0) {
    zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
    retval->type = (unsigned char)0;
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  if ((object->value.obj.handlers)->get_property_ptr_ptr) {
    tmp___2 = (*((object->value.obj.handlers)->get_property_ptr_ptr))(object, property, (struct _zend_literal  const  *)opline->op2.literal);
    zptr = tmp___2;
    if ((unsigned int )zptr != (unsigned int )((void *)0)) {
      have_get_ptr = 1;
      tmp___5 = zval_isref_p(*zptr);
      if (tmp___5) {

      } else {
        while (1) {
          tmp___4 = zval_refcount_p(*zptr);
          if (tmp___4 > 1U) {
            zval_delref_p(*zptr);
            while (1) {
              tmp___3 = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp___3;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*zptr)->value;
                new_zv->type = (*zptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *zptr = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
      while (1) {
        retval->value = (*zptr)->value;
        retval->type = (*zptr)->type;
        break;
      }
      _zval_copy_ctor(retval);
      (*incdec_op)(*zptr);
    } else {

    }
  } else {

  }
  if (! have_get_ptr) {
    if ((object->value.obj.handlers)->read_property) {
      if ((object->value.obj.handlers)->write_property) {
        tmp___6 = (*((object->value.obj.handlers)->read_property))(object, property, 0, (struct _zend_literal  const  *)opline->op2.literal);
        z = tmp___6;
        tmp___9 = __builtin_expect((long )((int )z->type == 5), 0L);
        if (tmp___9) {
          if ((z->value.obj.handlers)->get) {
            tmp___7 = (*((z->value.obj.handlers)->get))(z);
            value = tmp___7;
            tmp___8 = zval_refcount_p(z);
            if (tmp___8 == 0U) {
              if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                gc_remove_zval_from_buffer(z);
              } else {

              }
              _zval_dtor(z);
              while (1) {
                if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                  gc_remove_zval_from_buffer(z);
                } else {

                }
                _efree((void *)z);
                break;
              }
            } else {

            }
            z = value;
          } else {

          }
        } else {

        }
        while (1) {
          retval->value = z->value;
          retval->type = z->type;
          break;
        }
        _zval_copy_ctor(retval);
        while (1) {
          tmp___10 = _emalloc(sizeof(zval_gc_info ));
          z_copy = (zval *)tmp___10;
          ((zval_gc_info *)z_copy)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            z_copy->value = z->value;
            z_copy->type = z->type;
            break;
          }
          zval_set_refcount_p(z_copy, 1U);
          zval_unset_isref_p(z_copy);
          break;
        }
        _zval_copy_ctor(z_copy);
        (*incdec_op)(z_copy);
        zval_addref_p(z);
        (*((object->value.obj.handlers)->write_property))(object, property, z_copy, (struct _zend_literal  const  *)opline->op2.literal);
        i_zval_ptr_dtor(z_copy);
        i_zval_ptr_dtor(z);
      } else {
        zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
        retval->type = (unsigned char)0;
      }
    } else {
      zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
      retval->type = (unsigned char)0;
    }
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_POST_INC_OBJ_SPEC_UNUSED_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_post_incdec_property_helper_SPEC_UNUSED_CONST((int (*)(zval * ))(& increment_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_POST_DEC_OBJ_SPEC_UNUSED_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_post_incdec_property_helper_SPEC_UNUSED_CONST((int (*)(zval * ))(& decrement_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) zend_fetch_property_address_read_helper_SPEC_UNUSED_CONST)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *container ;
  zval *offset ;
  temp_variable *__t ;
  zval *retval ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  temp_variable *__t___0 ;
  long tmp___0 ;
  long tmp___1 ;

  {
  opline = execute_data->opline;
  container = _get_obj_zval_ptr_unused();
  offset = opline->op2.zv;
  tmp___0 = __builtin_expect((long )((int )container->type != 5), 0L);
  if (tmp___0) {
    goto _L;
  } else {
    tmp___1 = __builtin_expect((long )((unsigned int )(container->value.obj.handlers)->read_property == (unsigned int )((void *)0)), 0L);
    if (tmp___1) {
      _L: /* CIL Label */ 
      zend_error(1 << 3L, "Trying to get property of non-object");
      zval_addref_p(& executor_globals.uninitialized_zval);
      while (1) {
        __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t->var.ptr = & executor_globals.uninitialized_zval;
        __t->var.ptr_ptr = & __t->var.ptr;
        break;
      }
    } else {
      retval = (*((container->value.obj.handlers)->read_property))(container, offset, 0, (struct _zend_literal  const  *)opline->op2.literal);
      zval_addref_p(retval);
      while (1) {
        __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t___0->var.ptr = retval;
        __t___0->var.ptr_ptr = & __t___0->var.ptr;
        break;
      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_R_SPEC_UNUSED_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_property_address_read_helper_SPEC_UNUSED_CONST(execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_W_SPEC_UNUSED_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *property ;
  zval **container ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zend_uint tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___6 ;
  zval **retval_ptr ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___7 ;
  zend_uint tmp___8 ;
  zend_bool tmp___9 ;

  {
  opline = execute_data->opline;
  property = opline->op2.zv;
  if (1 << 3 == 1 << 2) {
    if (opline->extended_value & 134217728UL) {
      zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr));
      ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr = *(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr);
    } else {

    }
  } else {

  }
  container = _get_obj_zval_ptr_ptr_unused();
  if (1 << 3 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)opline->op2.literal, 1);
  if (1 << 3 == 1 << 2) {
    if (0) {
      tmp___5 = zval_refcount_p(free_op1.var);
      if (tmp___5 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___6 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___6 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___3 = zval_isref_p(__t->var.ptr);
                if (tmp___3) {

                } else {
                  tmp___4 = zval_refcount_p(__t->var.ptr);
                  if (tmp___4 > 2U) {
                    while (1) {
                      tmp___2 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___2 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___1 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___1;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  if (opline->extended_value & 67108864UL) {
    retval_ptr = ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr;
    zval_delref_p(*retval_ptr);
    tmp___9 = zval_isref_p(*retval_ptr);
    if (tmp___9) {

    } else {
      while (1) {
        tmp___8 = zval_refcount_p(*retval_ptr);
        if (tmp___8 > 1U) {
          zval_delref_p(*retval_ptr);
          while (1) {
            tmp___7 = _emalloc(sizeof(zval_gc_info ));
            new_zv___0 = (zval *)tmp___7;
            ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv___0->value = (*retval_ptr)->value;
              new_zv___0->type = (*retval_ptr)->type;
              break;
            }
            zval_set_refcount_p(new_zv___0, 1U);
            zval_unset_isref_p(new_zv___0);
            break;
          }
          *retval_ptr = new_zv___0;
          _zval_copy_ctor(new_zv___0);
        } else {

        }
        break;
      }
      zval_set_isref_p(*retval_ptr);
    }
    zval_addref_p(*retval_ptr);
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = *(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr);
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_RW_SPEC_UNUSED_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *property ;
  zval **container ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zend_uint tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___6 ;

  {
  opline = execute_data->opline;
  property = opline->op2.zv;
  container = _get_obj_zval_ptr_ptr_unused();
  if (1 << 3 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)opline->op2.literal, 2);
  if (1 << 3 == 1 << 2) {
    if (0) {
      tmp___5 = zval_refcount_p(free_op1.var);
      if (tmp___5 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___6 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___6 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___3 = zval_isref_p(__t->var.ptr);
                if (tmp___3) {

                } else {
                  tmp___4 = zval_refcount_p(__t->var.ptr);
                  if (tmp___4 > 2U) {
                    while (1) {
                      tmp___2 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___2 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___1 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___1;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_IS_SPEC_UNUSED_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *container ;
  zval *offset ;
  temp_variable *__t ;
  zval *retval ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  temp_variable *__t___0 ;
  long tmp___0 ;
  long tmp___1 ;

  {
  opline = execute_data->opline;
  container = _get_obj_zval_ptr_unused();
  offset = opline->op2.zv;
  tmp___0 = __builtin_expect((long )((int )container->type != 5), 0L);
  if (tmp___0) {
    goto _L;
  } else {
    tmp___1 = __builtin_expect((long )((unsigned int )(container->value.obj.handlers)->read_property == (unsigned int )((void *)0)), 0L);
    if (tmp___1) {
      _L: /* CIL Label */ 
      zval_addref_p(& executor_globals.uninitialized_zval);
      while (1) {
        __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t->var.ptr = & executor_globals.uninitialized_zval;
        __t->var.ptr_ptr = & __t->var.ptr;
        break;
      }
    } else {
      retval = (*((container->value.obj.handlers)->read_property))(container, offset, 3, (struct _zend_literal  const  *)opline->op2.literal);
      zval_addref_p(retval);
      while (1) {
        __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t___0->var.ptr = retval;
        __t___0->var.ptr_ptr = & __t___0->var.ptr;
        break;
      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *property ;
  zval **container ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zend_uint tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___6 ;
  int tmp___7 ;
  unsigned int tmp___8 ;

  {
  opline = execute_data->opline;
  if (execute_data->fbc) {
    if ((execute_data->fbc)->common.arg_info) {
      if ((opline->extended_value & 1048575UL) <= (unsigned long )(execute_data->fbc)->common.num_args) {
        tmp___8 = (unsigned int )((int )((execute_data->fbc)->common.arg_info + ((opline->extended_value & 1048575UL) - 1UL))->pass_by_reference & 3);
      } else {
        tmp___8 = (execute_data->fbc)->common.fn_flags & 50331648U;
      }
    } else {
      tmp___8 = (execute_data->fbc)->common.fn_flags & 50331648U;
    }
    if (tmp___8) {
      property = opline->op2.zv;
      container = _get_obj_zval_ptr_ptr_unused();
      if (1 << 3 == 1 << 2) {
        tmp___0 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
        if (tmp___0) {
          zend_error_noreturn(1, "Cannot use string offset as an object");
        } else {

        }
      } else {

      }
      zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)opline->op2.literal, 1);
      if (1 << 3 == 1 << 2) {
        if (0) {
          tmp___5 = zval_refcount_p(free_op1.var);
          if (tmp___5 == 1U) {
            if ((int )(free_op1.var)->type != 5) {
              goto _L;
            } else {
              tmp___6 = zend_objects_store_get_refcount(free_op1.var);
              if (tmp___6 == (zend_uint __attribute__((__visibility__("default")))  )1) {
                _L: /* CIL Label */ 
                while (1) {
                  __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
                  if (__t->var.ptr_ptr) {
                    __t->var.ptr = *(__t->var.ptr_ptr);
                    __t->var.ptr_ptr = & __t->var.ptr;
                    tmp___3 = zval_isref_p(__t->var.ptr);
                    if (tmp___3) {

                    } else {
                      tmp___4 = zval_refcount_p(__t->var.ptr);
                      if (tmp___4 > 2U) {
                        while (1) {
                          tmp___2 = zval_refcount_p(*(__t->var.ptr_ptr));
                          if (tmp___2 > 1U) {
                            zval_delref_p(*(__t->var.ptr_ptr));
                            while (1) {
                              tmp___1 = _emalloc(sizeof(zval_gc_info ));
                              new_zv = (zval *)tmp___1;
                              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                              break;
                            }
                            while (1) {
                              while (1) {
                                new_zv->value = (*(__t->var.ptr_ptr))->value;
                                new_zv->type = (*(__t->var.ptr_ptr))->type;
                                break;
                              }
                              zval_set_refcount_p(new_zv, 1U);
                              zval_unset_isref_p(new_zv);
                              break;
                            }
                            *(__t->var.ptr_ptr) = new_zv;
                            _zval_copy_ctor(new_zv);
                          } else {

                          }
                          break;
                        }
                      } else {

                      }
                    }
                  } else {

                  }
                  break;
                }
              } else {

              }
            }
          } else {

          }
        } else {

        }
      } else {

      }
      (execute_data->opline) ++;
      return (0);
    } else {
      tmp___7 = zend_fetch_property_address_read_helper_SPEC_UNUSED_CONST(execute_data);
      return (tmp___7);
    }
  } else {
    tmp___7 = zend_fetch_property_address_read_helper_SPEC_UNUSED_CONST(execute_data);
    return (tmp___7);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_res ;
  zval **container ;
  zval *property ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  long tmp___3 ;
  temp_variable *__t ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_uint tmp___5 ;
  zend_bool tmp___6 ;
  zend_uint tmp___7 ;
  zend_uint tmp___8 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___9 ;
  zval *new_zv___1 ;
  void __attribute__((__visibility__("default")))  *tmp___10 ;
  zend_uint tmp___11 ;
  zend_bool tmp___12 ;

  {
  opline = execute_data->opline;
  container = _get_obj_zval_ptr_ptr_unused();
  property = opline->op2.zv;
  if (1 << 3 == 1 << 4) {
    if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
      tmp___1 = zval_isref_p(*container);
      if (tmp___1) {

      } else {
        while (1) {
          tmp___0 = zval_refcount_p(*container);
          if (tmp___0 > 1U) {
            zval_delref_p(*container);
            while (1) {
              tmp = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*container)->value;
                new_zv->type = (*container)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *container = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
    } else {

    }
  } else {

  }
  if (1 << 3 == 1 << 2) {
    tmp___3 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___3) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)opline->op2.literal, 6);
  if (1 << 3 == 1 << 2) {
    if (0) {
      tmp___8 = zval_refcount_p(free_op1.var);
      if (tmp___8 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___9 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___9 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___6 = zval_isref_p(__t->var.ptr);
                if (tmp___6) {

                } else {
                  tmp___7 = zval_refcount_p(__t->var.ptr);
                  if (tmp___7 > 2U) {
                    while (1) {
                      tmp___5 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___5 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___4 = _emalloc(sizeof(zval_gc_info ));
                          new_zv___0 = (zval *)tmp___4;
                          ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv___0->value = (*(__t->var.ptr_ptr))->value;
                            new_zv___0->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv___0, 1U);
                          zval_unset_isref_p(new_zv___0);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv___0;
                        _zval_copy_ctor(new_zv___0);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  zend_pzval_unlock_func(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr), & free_res, 1);
  if ((unsigned int )((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
    tmp___12 = zval_isref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
    if (tmp___12) {

    } else {
      while (1) {
        tmp___11 = zval_refcount_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
        if (tmp___11 > 1U) {
          zval_delref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
          while (1) {
            tmp___10 = _emalloc(sizeof(zval_gc_info ));
            new_zv___1 = (zval *)tmp___10;
            ((zval_gc_info *)new_zv___1)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv___1->value = (*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr))->value;
              new_zv___1->type = (*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr))->type;
              break;
            }
            zval_set_refcount_p(new_zv___1, 1U);
            zval_unset_isref_p(new_zv___1);
            break;
          }
          *(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr) = new_zv___1;
          _zval_copy_ctor(new_zv___1);
        } else {

        }
        break;
      }
    }
  } else {

  }
  zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
  if (free_res.var) {
    i_zval_ptr_dtor(free_res.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_OBJ_SPEC_UNUSED_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **object_ptr ;
  zval *property_name ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zval **tmp___1 ;

  {
  opline = execute_data->opline;
  object_ptr = _get_obj_zval_ptr_ptr_unused();
  property_name = opline->op2.zv;
  if (1 << 3 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  if (! ((int )opline->result_type & (1 << 5))) {
    tmp___1 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
  } else {
    tmp___1 = (zval **)((void *)0);
  }
  zend_assign_to_object(tmp___1, object_ptr, property_name, (int )(opline + 1)->op1_type, & (opline + 1)->op1, (temp_variable const   *)execute_data->Ts, 136, (zend_literal const   *)opline->op2.literal);
  (execute_data->opline) ++;
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_CHAR_SPEC_UNUSED_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *str ;

  {
  opline = execute_data->opline;
  str = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  if (1 << 3 == 1 << 3) {
    str->value.str.val = (char *)((void *)0);
    str->value.str.len = 0;
    str->type = (unsigned char)6;
    str->refcount__gc = 1U;
    str->is_ref__gc = (unsigned char)0;
  } else {

  }
  add_char_to_string(str, (zval const   *)str, (zval const   *)opline->op2.zv);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_STRING_SPEC_UNUSED_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *str ;

  {
  opline = execute_data->opline;
  str = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  if (1 << 3 == 1 << 3) {
    str->value.str.val = (char *)((void *)0);
    str->value.str.len = 0;
    str->type = (unsigned char)6;
    str->refcount__gc = 1U;
    str->is_ref__gc = (unsigned char)0;
  } else {

  }
  add_string_to_string(str, (zval const   *)str, (zval const   *)opline->op2.zv);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_METHOD_CALL_SPEC_UNUSED_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *function_name ;
  char *function_name_strval ;
  int function_name_strlen ;
  long tmp ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  zval *object ;
  long tmp___1 ;
  zend_class_entry *tmp___2 ;
  zend_class_entry *tmp___3 ;
  char const   *tmp___4 ;
  zend_class_entry *tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  zend_function *tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  zval *this_ptr ;
  void __attribute__((__visibility__("default")))  *tmp___12 ;
  zend_bool tmp___13 ;

  {
  opline = execute_data->opline;
  zend_ptr_stack_3_push(& executor_globals.arg_types_stack, (void *)execute_data->fbc, (void *)execute_data->object, (void *)execute_data->called_scope);
  function_name = opline->op2.zv;
  function_name_strval = function_name->value.str.val;
  function_name_strlen = function_name->value.str.len;
  execute_data->object = _get_obj_zval_ptr_unused();
  tmp___10 = __builtin_expect((long )((unsigned int )execute_data->object != (unsigned int )((void *)0)), 1L);
  if (tmp___10) {
    tmp___11 = __builtin_expect((long )((int )(execute_data->object)->type == 5), 1L);
    if (tmp___11) {
      tmp___0 = zend_get_class_entry((zval const   *)execute_data->object);
      execute_data->called_scope = (zend_class_entry *)tmp___0;
      if ((unsigned int )*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) == (unsigned int )execute_data->called_scope) {
        tmp___9 = (zend_function *)*((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U));
      } else {
        tmp___9 = (zend_function *)((void *)0);
      }
      execute_data->fbc = tmp___9;
      if ((unsigned int )tmp___9 == (unsigned int )((void *)0)) {
        object = execute_data->object;
        tmp___1 = __builtin_expect((long )((unsigned int )((execute_data->object)->value.obj.handlers)->get_method == (unsigned int )((void *)0)), 0L);
        if (tmp___1) {
          zend_error_noreturn(1, "Object does not support method calls");
        } else {

        }
        execute_data->fbc = (*(((execute_data->object)->value.obj.handlers)->get_method))(& execute_data->object, function_name_strval, function_name_strlen, (struct _zend_literal  const  *)(opline->op2.literal + 1));
        tmp___6 = __builtin_expect((long )((unsigned int )execute_data->fbc == (unsigned int )((void *)0)), 0L);
        if (tmp___6) {
          if (execute_data->object) {
            if ((int )(execute_data->object)->type == 5) {
              if ((unsigned int )((execute_data->object)->value.obj.handlers)->get_class_entry != (unsigned int )((void *)0)) {
                tmp___5 = (*(((execute_data->object)->value.obj.handlers)->get_class_entry))((zval const   *)execute_data->object);
                if (tmp___5) {
                  tmp___3 = (*(((execute_data->object)->value.obj.handlers)->get_class_entry))((zval const   *)execute_data->object);
                  tmp___4 = tmp___3->name;
                } else {
                  tmp___4 = "";
                }
              } else {
                tmp___4 = "";
              }
            } else {
              tmp___4 = "";
            }
          } else {
            tmp___4 = "";
          }
          zend_error_noreturn(1, "Call to undefined method %s::%s()", tmp___4, function_name_strval);
        } else {

        }
        tmp___7 = __builtin_expect((long )(((execute_data->fbc)->common.fn_flags & 6291456U) == 0U), 1L);
        if (tmp___7) {
          tmp___8 = __builtin_expect((long )((unsigned int )execute_data->object == (unsigned int )object), 1L);
          if (tmp___8) {
            while (1) {
              *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)execute_data->called_scope;
              *((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U)) = (void *)execute_data->fbc;
              break;
            }
          } else {

          }
        } else {

        }
      } else {

      }
    } else {
      zend_error_noreturn(1, "Call to a member function %s() on a non-object", function_name_strval);
    }
  } else {
    zend_error_noreturn(1, "Call to a member function %s() on a non-object", function_name_strval);
  }
  if (((execute_data->fbc)->common.fn_flags & 1U) != 0U) {
    execute_data->object = (zval *)((void *)0);
  } else {
    tmp___13 = zval_isref_p(execute_data->object);
    if (tmp___13) {
      while (1) {
        tmp___12 = _emalloc(sizeof(zval_gc_info ));
        this_ptr = (zval *)tmp___12;
        ((zval_gc_info *)this_ptr)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      while (1) {
        while (1) {
          this_ptr->value = (execute_data->object)->value;
          this_ptr->type = (execute_data->object)->type;
          break;
        }
        zval_set_refcount_p(this_ptr, 1U);
        zval_unset_isref_p(this_ptr);
        break;
      }
      _zval_copy_ctor(this_ptr);
      execute_data->object = this_ptr;
    } else {
      zval_addref_p(execute_data->object);
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_CONSTANT_SPEC_UNUSED_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_constant *c ;
  zval *retval ;
  char *actual ;
  void const   *tmp ;
  char const   *__s ;
  int __l ;
  zval *__z ;
  char __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_class_entry *ce ;
  zval **value ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___1 ;
  long tmp___2 ;
  zend_class_entry *old_scope ;
  int __attribute__((__visibility__("default")))  tmp___3 ;
  long tmp___4 ;

  {
  opline = execute_data->opline;
  if (1 << 3 == 1 << 3) {
    if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
      c = (zend_constant *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
    } else {
      c = zend_quick_get_constant((zend_literal const   *)(opline->op2.literal + 1), opline->extended_value);
      if ((unsigned int )c == (unsigned int )((void *)0)) {
        if ((opline->extended_value & 16UL) != 0UL) {
          tmp = zend_memrchr((void const   *)(opline->op2.zv)->value.str.val, '\\', (unsigned int )(opline->op2.zv)->value.str.len);
          actual = (char *)tmp;
          if (! actual) {
            actual = (opline->op2.zv)->value.str.val;
          } else {
            actual ++;
          }
          zend_error(1 << 3L, "Use of undefined constant %s - assumed \'%s\'", actual, actual);
          while (1) {
            __s = (char const   *)actual;
            __l = (opline->op2.zv)->value.str.len - (actual - (opline->op2.zv)->value.str.val);
            __z = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
            __z->value.str.len = __l;
            tmp___0 = _estrndup(__s, (unsigned int )__l);
            __z->value.str.val = (char *)tmp___0;
            __z->type = (unsigned char)6;
            break;
          }
          (execute_data->opline) ++;
          return (0);
        } else {
          zend_error_noreturn(1, "Undefined constant \'%s\'", (opline->op2.zv)->value.str.val);
        }
      } else {
        while (1) {
          *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)c;
          break;
        }
      }
    }
    retval = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
    while (1) {
      retval->value = c->value.value;
      retval->type = c->value.type;
      break;
    }
    _zval_copy_ctor(retval);
    (execute_data->opline) ++;
    return (0);
  } else {
    if (1 << 3 == 1) {
      if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
        value = (zval **)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
        while (1) {
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value = (*value)->value;
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.type = (*value)->type;
          break;
        }
        _zval_copy_ctor(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var);
        (execute_data->opline) ++;
        return (0);
      } else {
        if (*((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot)) {
          ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot);
        } else {
          tmp___1 = zend_fetch_class_by_name((char const   *)(opline->op1.zv)->value.str.val, (unsigned int )(opline->op1.zv)->value.str.len, (zend_literal const   *)(opline->op1.literal + 1), (int )opline->extended_value);
          ce = (zend_class_entry *)tmp___1;
          tmp___2 = __builtin_expect((long )((unsigned int )ce == (unsigned int )((void *)0)), 0L);
          if (tmp___2) {
            zend_error_noreturn(1, "Undefined class constant \'%s\'", (opline->op2.zv)->value.str.val);
          } else {

          }
          while (1) {
            *((executor_globals.active_op_array)->run_time_cache + (opline->op1.literal)->cache_slot) = (void *)ce;
            break;
          }
        }
      }
    } else {
      ce = ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->class_entry;
      if ((unsigned int )*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) == (unsigned int )ce) {
        value = (zval **)*((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U));
      } else {
        value = (zval **)((void *)0);
      }
      if ((unsigned int )value != (unsigned int )((void *)0)) {
        while (1) {
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value = (*value)->value;
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.type = (*value)->type;
          break;
        }
        _zval_copy_ctor(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var);
        (execute_data->opline) ++;
        return (0);
      } else {

      }
    }
    tmp___3 = zend_hash_quick_find((HashTable const   *)(& ce->constants_table), (char const   *)(opline->op2.zv)->value.str.val, (unsigned int )((opline->op2.zv)->value.str.len + 1), ((zend_literal *)opline->op2.zv)->hash_value, (void **)(& value));
    tmp___4 = __builtin_expect((long )(tmp___3 == (int __attribute__((__visibility__("default")))  )0), 1L);
    if (tmp___4) {
      if ((int )(*value)->type == 9) {
        old_scope = executor_globals.scope;
        executor_globals.scope = ce;
        zval_update_constant(value, (void *)1);
        executor_globals.scope = old_scope;
      } else {
        if (((int )(*value)->type & 0x00f) == 8) {
          old_scope = executor_globals.scope;
          executor_globals.scope = ce;
          zval_update_constant(value, (void *)1);
          executor_globals.scope = old_scope;
        } else {

        }
      }
      if (1 << 3 == 1) {
        while (1) {
          *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)value;
          break;
        }
      } else {
        while (1) {
          *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
          *((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U)) = (void *)value;
          break;
        }
      }
      while (1) {
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value = (*value)->value;
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.type = (*value)->type;
        break;
      }
      _zval_copy_ctor(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var);
    } else {
      zend_error_noreturn(1, "Undefined class constant \'%s\'", (opline->op2.zv)->value.str.val);
    }
    (execute_data->opline) ++;
    return (0);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_ARRAY_SPEC_UNUSED_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;

  {
  opline = execute_data->opline;
  _array_init(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, 0U);
  if (1 << 3 == 1 << 3) {
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_UNSET_DIM_SPEC_UNUSED_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **container ;
  zval *offset ;
  ulong hval ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  HashTable *ht ;
  long tmp___2 ;
  register char const   *tmp___3 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___4 ;
  long tmp___5 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;

  {
  opline = execute_data->opline;
  container = _get_obj_zval_ptr_ptr_unused();
  if (1 << 3 == 1 << 4) {
    if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
      tmp___1 = zval_isref_p(*container);
      if (tmp___1) {

      } else {
        while (1) {
          tmp___0 = zval_refcount_p(*container);
          if (tmp___0 > 1U) {
            zval_delref_p(*container);
            while (1) {
              tmp = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*container)->value;
                new_zv->type = (*container)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *container = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
    } else {

    }
  } else {

  }
  offset = opline->op2.zv;
  if (1 << 3 != 1 << 2) {
    goto _L___0;
  } else {
    if (container) {
      _L___0: /* CIL Label */ 
      switch ((int )(*container)->type) {
      case 4: 
      ht = (*container)->value.ht;
      switch ((int )offset->type) {
      case 2: 
      tmp___2 = zend_dval_to_lval(offset->value.dval);
      hval = (unsigned long )tmp___2;
      goto num_index_dim;
      case 7: 
      case 3: 
      case 1: 
      hval = (unsigned long )offset->value.lval;
      zend_hash_del_key_or_index(ht, (char const   *)((void *)0), 0U, hval, 1);
      break;
      case 6: 
      if (1 == 1 << 4) {
        zval_addref_p(offset);
      } else {
        if (1 == 1 << 2) {
          zval_addref_p(offset);
        } else {

        }
      }
      if (1) {
        hval = ((zend_literal *)offset)->hash_value;
      } else {
        while (1) {
          tmp___3 = (char const   *)offset->value.str.val;
          if ((int const   )*tmp___3 == 45) {
            tmp___3 ++;
          } else {

          }
          if ((int const   )*tmp___3 >= 48) {
            if ((int const   )*tmp___3 <= 57) {
              end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
              if ((int const   )*end != 0) {
                break;
              } else {
                if ((int const   )*tmp___3 == 48) {
                  if (offset->value.str.len + 1 > 2) {
                    break;
                  } else {
                    goto _L;
                  }
                } else {
                  _L: /* CIL Label */ 
                  if (end - tmp___3 > 10) {
                    break;
                  } else {
                    if (end - tmp___3 == 10) {
                      if ((int const   )*tmp___3 > 50) {
                        break;
                      } else {

                      }
                    } else {

                    }
                  }
                }
              }
              hval = (unsigned long )((int const   )*tmp___3 - 48);
              while (1) {
                tmp___3 ++;
                if ((unsigned int )tmp___3 != (unsigned int )end) {
                  if ((int const   )*tmp___3 >= 48) {
                    if ((int const   )*tmp___3 <= 57) {

                    } else {
                      break;
                    }
                  } else {
                    break;
                  }
                } else {
                  break;
                }
                hval = hval * 10UL + (ulong )((int const   )*tmp___3 - 48);
              }
              if ((unsigned int )tmp___3 == (unsigned int )end) {
                if ((int )*(offset->value.str.val) == 45) {
                  if (hval - 1UL > 2147483647UL) {
                    break;
                  } else {

                  }
                  hval = (unsigned long )(- ((long )hval));
                } else {
                  if (hval > 2147483647UL) {
                    break;
                  } else {

                  }
                }
                goto num_index_dim;
              } else {

              }
            } else {

            }
          } else {

          }
          break;
        }
        if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
          if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
            hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
          } else {
            tmp___4 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
            hval = (unsigned long )tmp___4;
          }
        } else {
          tmp___4 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___4;
        }
      }
      if ((unsigned int )ht == (unsigned int )(& executor_globals.symbol_table)) {
        zend_delete_global_variable_ex((char const   *)offset->value.str.val, offset->value.str.len, hval);
      } else {
        zend_hash_del_key_or_index(ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, 2);
      }
      if (1 == 1 << 4) {
        i_zval_ptr_dtor(offset);
      } else {
        if (1 == 1 << 2) {
          i_zval_ptr_dtor(offset);
        } else {

        }
      }
      break;
      num_index_dim: 
      zend_hash_del_key_or_index(ht, (char const   *)((void *)0), 0U, hval, 1);
      if (1 == 1 << 4) {
        i_zval_ptr_dtor(offset);
      } else {
        if (1 == 1 << 2) {
          i_zval_ptr_dtor(offset);
        } else {

        }
      }
      break;
      case 0: 
      zend_hash_del_key_or_index(ht, "", sizeof(""), 0UL, 0);
      break;
      default: 
      zend_error(1 << 1L, "Illegal offset type in unset");
      break;
      }
      break;
      case 5: 
      tmp___5 = __builtin_expect((long )((unsigned int )((*container)->value.obj.handlers)->unset_dimension == (unsigned int )((void *)0)), 0L);
      if (tmp___5) {
        zend_error_noreturn(1, "Cannot use object as array");
      } else {

      }
      (*(((*container)->value.obj.handlers)->unset_dimension))(*container, offset);
      break;
      case 6: 
      zend_error_noreturn(1, "Cannot unset string offsets");
      return (0);
      default: ;
      break;
      }
    } else {

    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_UNSET_OBJ_SPEC_UNUSED_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **container ;
  zval *offset ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;

  {
  opline = execute_data->opline;
  container = _get_obj_zval_ptr_ptr_unused();
  offset = opline->op2.zv;
  if (1 << 3 != 1 << 2) {
    goto _L;
  } else {
    if (container) {
      _L: /* CIL Label */ 
      if (1 << 3 == 1 << 4) {
        if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
          tmp___1 = zval_isref_p(*container);
          if (tmp___1) {

          } else {
            while (1) {
              tmp___0 = zval_refcount_p(*container);
              if (tmp___0 > 1U) {
                zval_delref_p(*container);
                while (1) {
                  tmp = _emalloc(sizeof(zval_gc_info ));
                  new_zv = (zval *)tmp;
                  ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                  break;
                }
                while (1) {
                  while (1) {
                    new_zv->value = (*container)->value;
                    new_zv->type = (*container)->type;
                    break;
                  }
                  zval_set_refcount_p(new_zv, 1U);
                  zval_unset_isref_p(new_zv);
                  break;
                }
                *container = new_zv;
                _zval_copy_ctor(new_zv);
              } else {

              }
              break;
            }
          }
        } else {

        }
      } else {

      }
      if ((int )(*container)->type == 5) {
        if (((*container)->value.obj.handlers)->unset_property) {
          (*(((*container)->value.obj.handlers)->unset_property))(*container, offset, (struct _zend_literal  const  *)opline->op2.literal);
        } else {
          zend_error(1 << 3L, "Trying to unset property of non-object");
        }
      } else {

      }
    } else {

    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_CONST)(int prop_dim , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **container ;
  zval **value ;
  int result ;
  ulong hval ;
  zval *offset ;
  HashTable *ht ;
  int isset ;
  long tmp ;
  int __attribute__((__visibility__("default")))  tmp___0 ;
  register char const   *tmp___1 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___2 ;
  int __attribute__((__visibility__("default")))  tmp___3 ;
  int __attribute__((__visibility__("default")))  tmp___4 ;
  int tmp___5 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;
  zval tmp___7 ;

  {
  opline = execute_data->opline;
  value = (zval **)((void *)0);
  result = 0;
  container = _get_obj_zval_ptr_ptr_unused();
  offset = opline->op2.zv;
  if ((int )(*container)->type == 4) {
    if (! prop_dim) {
      isset = 0;
      ht = (*container)->value.ht;
      switch ((int )offset->type) {
      case 2: 
      tmp = zend_dval_to_lval(offset->value.dval);
      hval = (unsigned long )tmp;
      goto num_index_prop;
      case 7: 
      case 3: 
      case 1: 
      hval = (unsigned long )offset->value.lval;
      num_index_prop: 
      tmp___0 = zend_hash_index_find((HashTable const   *)ht, hval, (void **)(& value));
      if (tmp___0 == (int __attribute__((__visibility__("default")))  )0) {
        isset = 1;
      } else {

      }
      break;
      case 6: 
      if (1) {
        hval = ((zend_literal *)offset)->hash_value;
      } else {
        if (! prop_dim) {
          while (1) {
            tmp___1 = (char const   *)offset->value.str.val;
            if ((int const   )*tmp___1 == 45) {
              tmp___1 ++;
            } else {

            }
            if ((int const   )*tmp___1 >= 48) {
              if ((int const   )*tmp___1 <= 57) {
                end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
                if ((int const   )*end != 0) {
                  break;
                } else {
                  if ((int const   )*tmp___1 == 48) {
                    if (offset->value.str.len + 1 > 2) {
                      break;
                    } else {
                      goto _L;
                    }
                  } else {
                    _L: /* CIL Label */ 
                    if (end - tmp___1 > 10) {
                      break;
                    } else {
                      if (end - tmp___1 == 10) {
                        if ((int const   )*tmp___1 > 50) {
                          break;
                        } else {

                        }
                      } else {

                      }
                    }
                  }
                }
                hval = (unsigned long )((int const   )*tmp___1 - 48);
                while (1) {
                  tmp___1 ++;
                  if ((unsigned int )tmp___1 != (unsigned int )end) {
                    if ((int const   )*tmp___1 >= 48) {
                      if ((int const   )*tmp___1 <= 57) {

                      } else {
                        break;
                      }
                    } else {
                      break;
                    }
                  } else {
                    break;
                  }
                  hval = hval * 10UL + (ulong )((int const   )*tmp___1 - 48);
                }
                if ((unsigned int )tmp___1 == (unsigned int )end) {
                  if ((int )*(offset->value.str.val) == 45) {
                    if (hval - 1UL > 2147483647UL) {
                      break;
                    } else {

                    }
                    hval = (unsigned long )(- ((long )hval));
                  } else {
                    if (hval > 2147483647UL) {
                      break;
                    } else {

                    }
                  }
                  goto num_index_prop;
                } else {

                }
              } else {

              }
            } else {

            }
            break;
          }
        } else {

        }
        if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
          if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
            hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
          } else {
            tmp___2 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
            hval = (unsigned long )tmp___2;
          }
        } else {
          tmp___2 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___2;
        }
      }
      tmp___3 = zend_hash_quick_find((HashTable const   *)ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, (void **)(& value));
      if (tmp___3 == (int __attribute__((__visibility__("default")))  )0) {
        isset = 1;
      } else {

      }
      break;
      case 0: 
      tmp___4 = zend_hash_find((HashTable const   *)ht, "", sizeof(""), (void **)(& value));
      if (tmp___4 == (int __attribute__((__visibility__("default")))  )0) {
        isset = 1;
      } else {

      }
      break;
      default: 
      zend_error(1 << 1L, "Illegal offset type in isset or empty");
      break;
      }
      if (opline->extended_value & 33554432UL) {
        if (isset) {
          if ((int )(*value)->type == 0) {
            result = 0;
          } else {
            result = isset;
          }
        } else {
          result = isset;
        }
      } else {
        if (! isset) {
          result = 0;
        } else {
          tmp___5 = i_zend_is_true(*value);
          if (tmp___5) {
            result = 1;
          } else {
            result = 0;
          }
        }
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if ((int )(*container)->type == 5) {
      if (prop_dim) {
        if (((*container)->value.obj.handlers)->has_property) {
          result = (*(((*container)->value.obj.handlers)->has_property))(*container, offset, (opline->extended_value & 16777216UL) != 0UL, (struct _zend_literal  const  *)opline->op2.literal);
        } else {
          zend_error(1 << 3L, "Trying to check property of non-object");
          result = 0;
        }
      } else {
        if (((*container)->value.obj.handlers)->has_dimension) {
          result = (*(((*container)->value.obj.handlers)->has_dimension))(*container, offset, (opline->extended_value & 16777216UL) != 0UL);
        } else {
          zend_error(1 << 3L, "Trying to check element of non-array");
          result = 0;
        }
      }
    } else {
      if ((int )(*container)->type == 6) {
        if (! prop_dim) {
          if ((int )offset->type != 1) {
            while (1) {
              tmp___7.value = offset->value;
              tmp___7.type = offset->type;
              break;
            }
            _zval_copy_ctor(& tmp___7);
            convert_to_long(& tmp___7);
            offset = & tmp___7;
          } else {

          }
          if ((int )offset->type == 1) {
            if (opline->extended_value & 33554432UL) {
              if (offset->value.lval >= 0L) {
                if (offset->value.lval < (long )(*container)->value.str.len) {
                  result = 1;
                } else {

                }
              } else {

              }
            } else {
              if (offset->value.lval >= 0L) {
                if (offset->value.lval < (long )(*container)->value.str.len) {
                  if ((int )*((*container)->value.str.val + offset->value.lval) != 48) {
                    result = 1;
                  } else {

                  }
                } else {

                }
              } else {

              }
            }
          } else {

          }
        } else {

        }
      } else {

      }
    }
  }
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.type = (unsigned char)3;
  if (opline->extended_value & 33554432UL) {
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.lval = (long )result;
  } else {
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.lval = (long )(! result);
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_CONST(0, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_CONST(1, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) zend_binary_assign_op_obj_helper_SPEC_UNUSED_TMP)(int (*binary_op)(zval *result , zval *op1 , zval *op2 ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zend_free_op free_op_data1 ;
  zval **object_ptr ;
  zval **tmp ;
  zval *object ;
  zval *property ;
  zval *tmp___0 ;
  zval *value ;
  zval *tmp___1 ;
  int have_get_ptr ;
  long tmp___2 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___3 ;
  zval **zptr ;
  zend_literal *tmp___4 ;
  zval **tmp___5 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;
  zend_uint tmp___7 ;
  zend_bool tmp___8 ;
  zval *z ;
  zend_literal *tmp___9 ;
  zval *value___0 ;
  zval *tmp___10 ;
  zend_uint tmp___11 ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___12 ;
  zend_uint tmp___13 ;
  zend_bool tmp___14 ;
  zend_literal *tmp___15 ;
  long tmp___16 ;

  {
  opline = execute_data->opline;
  tmp = _get_obj_zval_ptr_ptr_unused();
  object_ptr = tmp;
  tmp___0 = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  property = tmp___0;
  tmp___1 = _get_zval_ptr((int )(opline + 1)->op1_type, (znode_op const   *)(& (opline + 1)->op1), (temp_variable const   *)execute_data->Ts, & free_op_data1, 0);
  value = tmp___1;
  have_get_ptr = 0;
  if (1 << 3 == 1 << 2) {
    tmp___2 = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___2) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  make_real_object(object_ptr);
  object = *object_ptr;
  tmp___16 = __builtin_expect((long )((int )object->type != 5), 0L);
  if (tmp___16) {
    zend_error(1 << 1L, "Attempt to assign property of non-object");
    _zval_dtor(free_op2.var);
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = & executor_globals.uninitialized_zval;
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
    } else {

    }
  } else {
    while (1) {
      while (1) {
        tmp___3 = _emalloc(sizeof(zval_gc_info ));
        _tmp = (zval *)tmp___3;
        ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      while (1) {
        while (1) {
          _tmp->value = property->value;
          _tmp->type = property->type;
          break;
        }
        zval_set_refcount_p(_tmp, 1U);
        zval_unset_isref_p(_tmp);
        break;
      }
      property = _tmp;
      break;
    }
    if (opline->extended_value == 136UL) {
      if ((object->value.obj.handlers)->get_property_ptr_ptr) {
        if (1 << 1 == 1) {
          tmp___4 = opline->op2.literal;
        } else {
          tmp___4 = (zend_literal *)((void *)0);
        }
        tmp___5 = (*((object->value.obj.handlers)->get_property_ptr_ptr))(object, property, (struct _zend_literal  const  *)tmp___4);
        zptr = tmp___5;
        if ((unsigned int )zptr != (unsigned int )((void *)0)) {
          tmp___8 = zval_isref_p(*zptr);
          if (tmp___8) {

          } else {
            while (1) {
              tmp___7 = zval_refcount_p(*zptr);
              if (tmp___7 > 1U) {
                zval_delref_p(*zptr);
                while (1) {
                  tmp___6 = _emalloc(sizeof(zval_gc_info ));
                  new_zv = (zval *)tmp___6;
                  ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                  break;
                }
                while (1) {
                  while (1) {
                    new_zv->value = (*zptr)->value;
                    new_zv->type = (*zptr)->type;
                    break;
                  }
                  zval_set_refcount_p(new_zv, 1U);
                  zval_unset_isref_p(new_zv);
                  break;
                }
                *zptr = new_zv;
                _zval_copy_ctor(new_zv);
              } else {

              }
              break;
            }
          }
          have_get_ptr = 1;
          (*binary_op)(*zptr, *zptr, value);
          if (! ((int )opline->result_type & (1 << 5))) {
            zval_addref_p(*zptr);
            ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = *zptr;
            ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
          } else {

          }
        } else {

        }
      } else {

      }
    } else {

    }
    if (! have_get_ptr) {
      z = (zval *)((void *)0);
      if (opline->extended_value == 136UL) {
        if ((object->value.obj.handlers)->read_property) {
          if (1 << 1 == 1) {
            tmp___9 = opline->op2.literal;
          } else {
            tmp___9 = (zend_literal *)((void *)0);
          }
          z = (*((object->value.obj.handlers)->read_property))(object, property, 0, (struct _zend_literal  const  *)tmp___9);
        } else {

        }
      } else {
        if ((object->value.obj.handlers)->read_dimension) {
          z = (*((object->value.obj.handlers)->read_dimension))(object, property, 0);
        } else {

        }
      }
      if (z) {
        if ((int )z->type == 5) {
          if ((z->value.obj.handlers)->get) {
            tmp___10 = (*((z->value.obj.handlers)->get))(z);
            value___0 = tmp___10;
            tmp___11 = zval_refcount_p(z);
            if (tmp___11 == 0U) {
              if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                gc_remove_zval_from_buffer(z);
              } else {

              }
              _zval_dtor(z);
              while (1) {
                if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                  gc_remove_zval_from_buffer(z);
                } else {

                }
                _efree((void *)z);
                break;
              }
            } else {

            }
            z = value___0;
          } else {

          }
        } else {

        }
        zval_addref_p(z);
        tmp___14 = zval_isref_p(z);
        if (tmp___14) {

        } else {
          while (1) {
            tmp___13 = zval_refcount_p(z);
            if (tmp___13 > 1U) {
              zval_delref_p(z);
              while (1) {
                tmp___12 = _emalloc(sizeof(zval_gc_info ));
                new_zv___0 = (zval *)tmp___12;
                ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv___0->value = z->value;
                  new_zv___0->type = z->type;
                  break;
                }
                zval_set_refcount_p(new_zv___0, 1U);
                zval_unset_isref_p(new_zv___0);
                break;
              }
              z = new_zv___0;
              _zval_copy_ctor(new_zv___0);
            } else {

            }
            break;
          }
        }
        (*binary_op)(z, z, value);
        if (opline->extended_value == 136UL) {
          if (1 << 1 == 1) {
            tmp___15 = opline->op2.literal;
          } else {
            tmp___15 = (zend_literal *)((void *)0);
          }
          (*((object->value.obj.handlers)->write_property))(object, property, z, (struct _zend_literal  const  *)tmp___15);
        } else {
          (*((object->value.obj.handlers)->write_dimension))(object, property, z);
        }
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(z);
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = z;
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
        } else {

        }
        i_zval_ptr_dtor(z);
      } else {
        zend_error(1 << 1L, "Attempt to assign property of non-object");
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = & executor_globals.uninitialized_zval;
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
        } else {

        }
      }
    } else {

    }
    i_zval_ptr_dtor(property);
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
  }
  (execute_data->opline) ++;
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_binary_assign_op_helper_SPEC_UNUSED_TMP)(int (*binary_op)(zval *result , zval *op1 , zval *op2 ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zend_free_op free_op_data2 ;
  zend_free_op free_op_data1 ;
  zval **var_ptr ;
  zval *value ;
  int tmp ;
  zval **container ;
  zval **tmp___0 ;
  int tmp___1 ;
  zval *dim ;
  zval *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  temp_variable *__t ;
  long tmp___6 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___7 ;
  zend_uint tmp___8 ;
  zend_bool tmp___9 ;
  zval *objval ;
  zval *tmp___10 ;
  long tmp___11 ;
  temp_variable *__t___0 ;

  {
  opline = execute_data->opline;
  switch ((int )opline->extended_value) {
  case 136: 
  tmp = zend_binary_assign_op_obj_helper_SPEC_UNUSED_TMP(binary_op, execute_data);
  return (tmp);
  break;
  case 147: 
  tmp___0 = _get_obj_zval_ptr_ptr_unused();
  container = tmp___0;
  if (1 << 3 == 1 << 2) {
    tmp___4 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___4) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    tmp___3 = __builtin_expect((long )((int )(*container)->type == 5), 0L);
    if (tmp___3) {
      if (1 << 3 == 1 << 2) {
        zval_addref_p(*container);
      } else {

      }
      tmp___1 = zend_binary_assign_op_obj_helper_SPEC_UNUSED_TMP(binary_op, execute_data);
      return (tmp___1);
    } else {
      tmp___2 = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
      dim = tmp___2;
      zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var), container, dim, 1 << 1, 2);
      value = _get_zval_ptr((int )(opline + 1)->op1_type, (znode_op const   *)(& (opline + 1)->op1), (temp_variable const   *)execute_data->Ts, & free_op_data1, 0);
      var_ptr = _get_zval_ptr_ptr_var((opline + 1)->op2.var, (temp_variable const   *)execute_data->Ts, & free_op_data2);
    }
  }
  break;
  default: 
  value = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  var_ptr = (zval **)((void *)0);
  break;
  }
  tmp___5 = __builtin_expect((long )((unsigned int )var_ptr == (unsigned int )((void *)0)), 0L);
  if (tmp___5) {
    zend_error_noreturn(1, "Cannot use assign-op operators with overloaded objects nor string offsets");
  } else {

  }
  tmp___6 = __builtin_expect((long )((unsigned int )*var_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
  if (tmp___6) {
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      while (1) {
        __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t->var.ptr = & executor_globals.uninitialized_zval;
        __t->var.ptr_ptr = & __t->var.ptr;
        break;
      }
    } else {

    }
    _zval_dtor(free_op2.var);
    if (opline->extended_value == 147UL) {
      (execute_data->opline) ++;
    } else {

    }
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  tmp___9 = zval_isref_p(*var_ptr);
  if (tmp___9) {

  } else {
    while (1) {
      tmp___8 = zval_refcount_p(*var_ptr);
      if (tmp___8 > 1U) {
        zval_delref_p(*var_ptr);
        while (1) {
          tmp___7 = _emalloc(sizeof(zval_gc_info ));
          new_zv = (zval *)tmp___7;
          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            new_zv->value = (*var_ptr)->value;
            new_zv->type = (*var_ptr)->type;
            break;
          }
          zval_set_refcount_p(new_zv, 1U);
          zval_unset_isref_p(new_zv);
          break;
        }
        *var_ptr = new_zv;
        _zval_copy_ctor(new_zv);
      } else {

      }
      break;
    }
  }
  tmp___11 = __builtin_expect((long )((int )(*var_ptr)->type == 5), 0L);
  if (tmp___11) {
    if (((*var_ptr)->value.obj.handlers)->get) {
      if (((*var_ptr)->value.obj.handlers)->set) {
        tmp___10 = (*(((*var_ptr)->value.obj.handlers)->get))(*var_ptr);
        objval = tmp___10;
        zval_addref_p(objval);
        (*binary_op)(objval, objval, value);
        (*(((*var_ptr)->value.obj.handlers)->set))(var_ptr, objval);
        i_zval_ptr_dtor(objval);
      } else {
        (*binary_op)(*var_ptr, *var_ptr, value);
      }
    } else {
      (*binary_op)(*var_ptr, *var_ptr, value);
    }
  } else {
    (*binary_op)(*var_ptr, *var_ptr, value);
  }
  if (! ((int )opline->result_type & (1 << 5))) {
    zval_addref_p(*var_ptr);
    while (1) {
      __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
      __t___0->var.ptr = *var_ptr;
      __t___0->var.ptr_ptr = & __t___0->var.ptr;
      break;
    }
  } else {

  }
  _zval_dtor(free_op2.var);
  if (opline->extended_value == 147UL) {
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
    if (free_op_data2.var) {
      i_zval_ptr_dtor(free_op_data2.var);
    } else {

    }
    (execute_data->opline) ++;
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_ADD_SPEC_UNUSED_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_TMP((int (*)(zval *result , zval *op1 , zval *op2 ))(& add_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SUB_SPEC_UNUSED_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_TMP((int (*)(zval *result , zval *op1 , zval *op2 ))(& sub_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_MUL_SPEC_UNUSED_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_TMP((int (*)(zval *result , zval *op1 , zval *op2 ))(& mul_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_DIV_SPEC_UNUSED_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_TMP((int (*)(zval *result , zval *op1 , zval *op2 ))(& div_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_MOD_SPEC_UNUSED_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_TMP((int (*)(zval *result , zval *op1 , zval *op2 ))(& mod_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SL_SPEC_UNUSED_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_TMP((int (*)(zval *result , zval *op1 , zval *op2 ))(& shift_left_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SR_SPEC_UNUSED_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_TMP((int (*)(zval *result , zval *op1 , zval *op2 ))(& shift_right_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_CONCAT_SPEC_UNUSED_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_TMP((int (*)(zval *result , zval *op1 , zval *op2 ))(& concat_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_OR_SPEC_UNUSED_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_TMP((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_or_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_AND_SPEC_UNUSED_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_TMP((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_and_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_TMP((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_xor_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) zend_pre_incdec_property_helper_SPEC_UNUSED_TMP)(int (*incdec_op)(zval * ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval **object_ptr ;
  zval *object ;
  zval *property ;
  zval **retval ;
  int have_get_ptr ;
  long tmp ;
  long tmp___0 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zval **zptr ;
  zend_literal *tmp___2 ;
  zval **tmp___3 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_uint tmp___5 ;
  zend_bool tmp___6 ;
  zval *z ;
  zend_literal *tmp___7 ;
  zval *tmp___8 ;
  zval *value ;
  zval *tmp___9 ;
  zend_uint tmp___10 ;
  long tmp___11 ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___12 ;
  zend_uint tmp___13 ;
  zend_bool tmp___14 ;
  zend_literal *tmp___15 ;

  {
  opline = execute_data->opline;
  have_get_ptr = 0;
  object_ptr = _get_obj_zval_ptr_ptr_unused();
  property = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  retval = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
  if (1 << 3 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot increment/decrement overloaded objects nor string offsets");
    } else {

    }
  } else {

  }
  make_real_object(object_ptr);
  object = *object_ptr;
  tmp___0 = __builtin_expect((long )((int )object->type != 5), 0L);
  if (tmp___0) {
    zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
    _zval_dtor(free_op2.var);
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      *retval = & executor_globals.uninitialized_zval;
    } else {

    }
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  while (1) {
    while (1) {
      tmp___1 = _emalloc(sizeof(zval_gc_info ));
      _tmp = (zval *)tmp___1;
      ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
      break;
    }
    while (1) {
      while (1) {
        _tmp->value = property->value;
        _tmp->type = property->type;
        break;
      }
      zval_set_refcount_p(_tmp, 1U);
      zval_unset_isref_p(_tmp);
      break;
    }
    property = _tmp;
    break;
  }
  if ((object->value.obj.handlers)->get_property_ptr_ptr) {
    if (1 << 1 == 1) {
      tmp___2 = opline->op2.literal;
    } else {
      tmp___2 = (zend_literal *)((void *)0);
    }
    tmp___3 = (*((object->value.obj.handlers)->get_property_ptr_ptr))(object, property, (struct _zend_literal  const  *)tmp___2);
    zptr = tmp___3;
    if ((unsigned int )zptr != (unsigned int )((void *)0)) {
      tmp___6 = zval_isref_p(*zptr);
      if (tmp___6) {

      } else {
        while (1) {
          tmp___5 = zval_refcount_p(*zptr);
          if (tmp___5 > 1U) {
            zval_delref_p(*zptr);
            while (1) {
              tmp___4 = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp___4;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*zptr)->value;
                new_zv->type = (*zptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *zptr = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
      have_get_ptr = 1;
      (*incdec_op)(*zptr);
      if (! ((int )opline->result_type & (1 << 5))) {
        *retval = *zptr;
        zval_addref_p(*retval);
      } else {

      }
    } else {

    }
  } else {

  }
  if (! have_get_ptr) {
    if ((object->value.obj.handlers)->read_property) {
      if ((object->value.obj.handlers)->write_property) {
        if (1 << 1 == 1) {
          tmp___7 = opline->op2.literal;
        } else {
          tmp___7 = (zend_literal *)((void *)0);
        }
        tmp___8 = (*((object->value.obj.handlers)->read_property))(object, property, 0, (struct _zend_literal  const  *)tmp___7);
        z = tmp___8;
        tmp___11 = __builtin_expect((long )((int )z->type == 5), 0L);
        if (tmp___11) {
          if ((z->value.obj.handlers)->get) {
            tmp___9 = (*((z->value.obj.handlers)->get))(z);
            value = tmp___9;
            tmp___10 = zval_refcount_p(z);
            if (tmp___10 == 0U) {
              if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                gc_remove_zval_from_buffer(z);
              } else {

              }
              _zval_dtor(z);
              while (1) {
                if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                  gc_remove_zval_from_buffer(z);
                } else {

                }
                _efree((void *)z);
                break;
              }
            } else {

            }
            z = value;
          } else {

          }
        } else {

        }
        zval_addref_p(z);
        tmp___14 = zval_isref_p(z);
        if (tmp___14) {

        } else {
          while (1) {
            tmp___13 = zval_refcount_p(z);
            if (tmp___13 > 1U) {
              zval_delref_p(z);
              while (1) {
                tmp___12 = _emalloc(sizeof(zval_gc_info ));
                new_zv___0 = (zval *)tmp___12;
                ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv___0->value = z->value;
                  new_zv___0->type = z->type;
                  break;
                }
                zval_set_refcount_p(new_zv___0, 1U);
                zval_unset_isref_p(new_zv___0);
                break;
              }
              z = new_zv___0;
              _zval_copy_ctor(new_zv___0);
            } else {

            }
            break;
          }
        }
        (*incdec_op)(z);
        *retval = z;
        if (1 << 1 == 1) {
          tmp___15 = opline->op2.literal;
        } else {
          tmp___15 = (zend_literal *)((void *)0);
        }
        (*((object->value.obj.handlers)->write_property))(object, property, z, (struct _zend_literal  const  *)tmp___15);
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(*retval);
        } else {

        }
        i_zval_ptr_dtor(z);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
      if (! ((int )opline->result_type & (1 << 5))) {
        zval_addref_p(& executor_globals.uninitialized_zval);
        *retval = & executor_globals.uninitialized_zval;
      } else {

      }
    }
  } else {

  }
  i_zval_ptr_dtor(property);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_PRE_INC_OBJ_SPEC_UNUSED_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_pre_incdec_property_helper_SPEC_UNUSED_TMP((int (*)(zval * ))(& increment_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_PRE_DEC_OBJ_SPEC_UNUSED_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_pre_incdec_property_helper_SPEC_UNUSED_TMP((int (*)(zval * ))(& decrement_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) zend_post_incdec_property_helper_SPEC_UNUSED_TMP)(int (*incdec_op)(zval * ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval **object_ptr ;
  zval *object ;
  zval *property ;
  zval *retval ;
  int have_get_ptr ;
  long tmp ;
  long tmp___0 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zval **zptr ;
  zend_literal *tmp___2 ;
  zval **tmp___3 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_uint tmp___5 ;
  zend_bool tmp___6 ;
  zval *z ;
  zend_literal *tmp___7 ;
  zval *tmp___8 ;
  zval *z_copy ;
  zval *value ;
  zval *tmp___9 ;
  zend_uint tmp___10 ;
  long tmp___11 ;
  void __attribute__((__visibility__("default")))  *tmp___12 ;
  zend_literal *tmp___13 ;

  {
  opline = execute_data->opline;
  have_get_ptr = 0;
  object_ptr = _get_obj_zval_ptr_ptr_unused();
  property = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  retval = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  if (1 << 3 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot increment/decrement overloaded objects nor string offsets");
    } else {

    }
  } else {

  }
  make_real_object(object_ptr);
  object = *object_ptr;
  tmp___0 = __builtin_expect((long )((int )object->type != 5), 0L);
  if (tmp___0) {
    zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
    _zval_dtor(free_op2.var);
    retval->type = (unsigned char)0;
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  while (1) {
    while (1) {
      tmp___1 = _emalloc(sizeof(zval_gc_info ));
      _tmp = (zval *)tmp___1;
      ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
      break;
    }
    while (1) {
      while (1) {
        _tmp->value = property->value;
        _tmp->type = property->type;
        break;
      }
      zval_set_refcount_p(_tmp, 1U);
      zval_unset_isref_p(_tmp);
      break;
    }
    property = _tmp;
    break;
  }
  if ((object->value.obj.handlers)->get_property_ptr_ptr) {
    if (1 << 1 == 1) {
      tmp___2 = opline->op2.literal;
    } else {
      tmp___2 = (zend_literal *)((void *)0);
    }
    tmp___3 = (*((object->value.obj.handlers)->get_property_ptr_ptr))(object, property, (struct _zend_literal  const  *)tmp___2);
    zptr = tmp___3;
    if ((unsigned int )zptr != (unsigned int )((void *)0)) {
      have_get_ptr = 1;
      tmp___6 = zval_isref_p(*zptr);
      if (tmp___6) {

      } else {
        while (1) {
          tmp___5 = zval_refcount_p(*zptr);
          if (tmp___5 > 1U) {
            zval_delref_p(*zptr);
            while (1) {
              tmp___4 = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp___4;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*zptr)->value;
                new_zv->type = (*zptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *zptr = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
      while (1) {
        retval->value = (*zptr)->value;
        retval->type = (*zptr)->type;
        break;
      }
      _zval_copy_ctor(retval);
      (*incdec_op)(*zptr);
    } else {

    }
  } else {

  }
  if (! have_get_ptr) {
    if ((object->value.obj.handlers)->read_property) {
      if ((object->value.obj.handlers)->write_property) {
        if (1 << 1 == 1) {
          tmp___7 = opline->op2.literal;
        } else {
          tmp___7 = (zend_literal *)((void *)0);
        }
        tmp___8 = (*((object->value.obj.handlers)->read_property))(object, property, 0, (struct _zend_literal  const  *)tmp___7);
        z = tmp___8;
        tmp___11 = __builtin_expect((long )((int )z->type == 5), 0L);
        if (tmp___11) {
          if ((z->value.obj.handlers)->get) {
            tmp___9 = (*((z->value.obj.handlers)->get))(z);
            value = tmp___9;
            tmp___10 = zval_refcount_p(z);
            if (tmp___10 == 0U) {
              if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                gc_remove_zval_from_buffer(z);
              } else {

              }
              _zval_dtor(z);
              while (1) {
                if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                  gc_remove_zval_from_buffer(z);
                } else {

                }
                _efree((void *)z);
                break;
              }
            } else {

            }
            z = value;
          } else {

          }
        } else {

        }
        while (1) {
          retval->value = z->value;
          retval->type = z->type;
          break;
        }
        _zval_copy_ctor(retval);
        while (1) {
          tmp___12 = _emalloc(sizeof(zval_gc_info ));
          z_copy = (zval *)tmp___12;
          ((zval_gc_info *)z_copy)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            z_copy->value = z->value;
            z_copy->type = z->type;
            break;
          }
          zval_set_refcount_p(z_copy, 1U);
          zval_unset_isref_p(z_copy);
          break;
        }
        _zval_copy_ctor(z_copy);
        (*incdec_op)(z_copy);
        zval_addref_p(z);
        if (1 << 1 == 1) {
          tmp___13 = opline->op2.literal;
        } else {
          tmp___13 = (zend_literal *)((void *)0);
        }
        (*((object->value.obj.handlers)->write_property))(object, property, z_copy, (struct _zend_literal  const  *)tmp___13);
        i_zval_ptr_dtor(z_copy);
        i_zval_ptr_dtor(z);
      } else {
        zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
        retval->type = (unsigned char)0;
      }
    } else {
      zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
      retval->type = (unsigned char)0;
    }
  } else {

  }
  i_zval_ptr_dtor(property);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_POST_INC_OBJ_SPEC_UNUSED_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_post_incdec_property_helper_SPEC_UNUSED_TMP((int (*)(zval * ))(& increment_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_POST_DEC_OBJ_SPEC_UNUSED_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_post_incdec_property_helper_SPEC_UNUSED_TMP((int (*)(zval * ))(& decrement_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) zend_fetch_property_address_read_helper_SPEC_UNUSED_TMP)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *container ;
  zend_free_op free_op2 ;
  zval *offset ;
  temp_variable *__t ;
  zval *retval ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_literal *tmp___0 ;
  temp_variable *__t___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  opline = execute_data->opline;
  container = _get_obj_zval_ptr_unused();
  offset = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___1 = __builtin_expect((long )((int )container->type != 5), 0L);
  if (tmp___1) {
    goto _L;
  } else {
    tmp___2 = __builtin_expect((long )((unsigned int )(container->value.obj.handlers)->read_property == (unsigned int )((void *)0)), 0L);
    if (tmp___2) {
      _L: /* CIL Label */ 
      zend_error(1 << 3L, "Trying to get property of non-object");
      zval_addref_p(& executor_globals.uninitialized_zval);
      while (1) {
        __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t->var.ptr = & executor_globals.uninitialized_zval;
        __t->var.ptr_ptr = & __t->var.ptr;
        break;
      }
      _zval_dtor(free_op2.var);
    } else {
      while (1) {
        while (1) {
          tmp = _emalloc(sizeof(zval_gc_info ));
          _tmp = (zval *)tmp;
          ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            _tmp->value = offset->value;
            _tmp->type = offset->type;
            break;
          }
          zval_set_refcount_p(_tmp, 1U);
          zval_unset_isref_p(_tmp);
          break;
        }
        offset = _tmp;
        break;
      }
      if (1 << 1 == 1) {
        tmp___0 = opline->op2.literal;
      } else {
        tmp___0 = (zend_literal *)((void *)0);
      }
      retval = (*((container->value.obj.handlers)->read_property))(container, offset, 0, (struct _zend_literal  const  *)tmp___0);
      zval_addref_p(retval);
      while (1) {
        __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t___0->var.ptr = retval;
        __t___0->var.ptr_ptr = & __t___0->var.ptr;
        break;
      }
      i_zval_ptr_dtor(offset);
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_R_SPEC_UNUSED_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_property_address_read_helper_SPEC_UNUSED_TMP(execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_W_SPEC_UNUSED_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *property ;
  zval **container ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zend_literal *tmp___1 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_uint tmp___3 ;
  zend_bool tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint tmp___6 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___7 ;
  zval **retval_ptr ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___8 ;
  zend_uint tmp___9 ;
  zend_bool tmp___10 ;

  {
  opline = execute_data->opline;
  property = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if (1 << 3 == 1 << 2) {
    if (opline->extended_value & 134217728UL) {
      zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr));
      ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr = *(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr);
    } else {

    }
  } else {

  }
  while (1) {
    while (1) {
      tmp = _emalloc(sizeof(zval_gc_info ));
      _tmp = (zval *)tmp;
      ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
      break;
    }
    while (1) {
      while (1) {
        _tmp->value = property->value;
        _tmp->type = property->type;
        break;
      }
      zval_set_refcount_p(_tmp, 1U);
      zval_unset_isref_p(_tmp);
      break;
    }
    property = _tmp;
    break;
  }
  container = _get_obj_zval_ptr_ptr_unused();
  if (1 << 3 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  if (1 << 1 == 1) {
    tmp___1 = opline->op2.literal;
  } else {
    tmp___1 = (zend_literal *)((void *)0);
  }
  zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)tmp___1, 1);
  i_zval_ptr_dtor(property);
  if (1 << 3 == 1 << 2) {
    if (0) {
      tmp___6 = zval_refcount_p(free_op1.var);
      if (tmp___6 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___7 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___7 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___4 = zval_isref_p(__t->var.ptr);
                if (tmp___4) {

                } else {
                  tmp___5 = zval_refcount_p(__t->var.ptr);
                  if (tmp___5 > 2U) {
                    while (1) {
                      tmp___3 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___3 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___2 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___2;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  if (opline->extended_value & 67108864UL) {
    retval_ptr = ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr;
    zval_delref_p(*retval_ptr);
    tmp___10 = zval_isref_p(*retval_ptr);
    if (tmp___10) {

    } else {
      while (1) {
        tmp___9 = zval_refcount_p(*retval_ptr);
        if (tmp___9 > 1U) {
          zval_delref_p(*retval_ptr);
          while (1) {
            tmp___8 = _emalloc(sizeof(zval_gc_info ));
            new_zv___0 = (zval *)tmp___8;
            ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv___0->value = (*retval_ptr)->value;
              new_zv___0->type = (*retval_ptr)->type;
              break;
            }
            zval_set_refcount_p(new_zv___0, 1U);
            zval_unset_isref_p(new_zv___0);
            break;
          }
          *retval_ptr = new_zv___0;
          _zval_copy_ctor(new_zv___0);
        } else {

        }
        break;
      }
      zval_set_isref_p(*retval_ptr);
    }
    zval_addref_p(*retval_ptr);
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = *(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr);
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_RW_SPEC_UNUSED_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *property ;
  zval **container ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zend_literal *tmp___1 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_uint tmp___3 ;
  zend_bool tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint tmp___6 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___7 ;

  {
  opline = execute_data->opline;
  property = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  container = _get_obj_zval_ptr_ptr_unused();
  while (1) {
    while (1) {
      tmp = _emalloc(sizeof(zval_gc_info ));
      _tmp = (zval *)tmp;
      ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
      break;
    }
    while (1) {
      while (1) {
        _tmp->value = property->value;
        _tmp->type = property->type;
        break;
      }
      zval_set_refcount_p(_tmp, 1U);
      zval_unset_isref_p(_tmp);
      break;
    }
    property = _tmp;
    break;
  }
  if (1 << 3 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  if (1 << 1 == 1) {
    tmp___1 = opline->op2.literal;
  } else {
    tmp___1 = (zend_literal *)((void *)0);
  }
  zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)tmp___1, 2);
  i_zval_ptr_dtor(property);
  if (1 << 3 == 1 << 2) {
    if (0) {
      tmp___6 = zval_refcount_p(free_op1.var);
      if (tmp___6 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___7 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___7 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___4 = zval_isref_p(__t->var.ptr);
                if (tmp___4) {

                } else {
                  tmp___5 = zval_refcount_p(__t->var.ptr);
                  if (tmp___5 > 2U) {
                    while (1) {
                      tmp___3 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___3 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___2 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___2;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_IS_SPEC_UNUSED_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *container ;
  zend_free_op free_op2 ;
  zval *offset ;
  temp_variable *__t ;
  zval *retval ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_literal *tmp___0 ;
  temp_variable *__t___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  opline = execute_data->opline;
  container = _get_obj_zval_ptr_unused();
  offset = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___1 = __builtin_expect((long )((int )container->type != 5), 0L);
  if (tmp___1) {
    goto _L;
  } else {
    tmp___2 = __builtin_expect((long )((unsigned int )(container->value.obj.handlers)->read_property == (unsigned int )((void *)0)), 0L);
    if (tmp___2) {
      _L: /* CIL Label */ 
      zval_addref_p(& executor_globals.uninitialized_zval);
      while (1) {
        __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t->var.ptr = & executor_globals.uninitialized_zval;
        __t->var.ptr_ptr = & __t->var.ptr;
        break;
      }
      _zval_dtor(free_op2.var);
    } else {
      while (1) {
        while (1) {
          tmp = _emalloc(sizeof(zval_gc_info ));
          _tmp = (zval *)tmp;
          ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            _tmp->value = offset->value;
            _tmp->type = offset->type;
            break;
          }
          zval_set_refcount_p(_tmp, 1U);
          zval_unset_isref_p(_tmp);
          break;
        }
        offset = _tmp;
        break;
      }
      if (1 << 1 == 1) {
        tmp___0 = opline->op2.literal;
      } else {
        tmp___0 = (zend_literal *)((void *)0);
      }
      retval = (*((container->value.obj.handlers)->read_property))(container, offset, 3, (struct _zend_literal  const  *)tmp___0);
      zval_addref_p(retval);
      while (1) {
        __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t___0->var.ptr = retval;
        __t___0->var.ptr_ptr = & __t___0->var.ptr;
        break;
      }
      i_zval_ptr_dtor(offset);
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *property ;
  zval **container ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zend_literal *tmp___1 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_uint tmp___3 ;
  zend_bool tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint tmp___6 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;

  {
  opline = execute_data->opline;
  if (execute_data->fbc) {
    if ((execute_data->fbc)->common.arg_info) {
      if ((opline->extended_value & 1048575UL) <= (unsigned long )(execute_data->fbc)->common.num_args) {
        tmp___9 = (unsigned int )((int )((execute_data->fbc)->common.arg_info + ((opline->extended_value & 1048575UL) - 1UL))->pass_by_reference & 3);
      } else {
        tmp___9 = (execute_data->fbc)->common.fn_flags & 50331648U;
      }
    } else {
      tmp___9 = (execute_data->fbc)->common.fn_flags & 50331648U;
    }
    if (tmp___9) {
      property = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
      container = _get_obj_zval_ptr_ptr_unused();
      while (1) {
        while (1) {
          tmp = _emalloc(sizeof(zval_gc_info ));
          _tmp = (zval *)tmp;
          ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            _tmp->value = property->value;
            _tmp->type = property->type;
            break;
          }
          zval_set_refcount_p(_tmp, 1U);
          zval_unset_isref_p(_tmp);
          break;
        }
        property = _tmp;
        break;
      }
      if (1 << 3 == 1 << 2) {
        tmp___0 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
        if (tmp___0) {
          zend_error_noreturn(1, "Cannot use string offset as an object");
        } else {

        }
      } else {

      }
      if (1 << 1 == 1) {
        tmp___1 = opline->op2.literal;
      } else {
        tmp___1 = (zend_literal *)((void *)0);
      }
      zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)tmp___1, 1);
      i_zval_ptr_dtor(property);
      if (1 << 3 == 1 << 2) {
        if (0) {
          tmp___6 = zval_refcount_p(free_op1.var);
          if (tmp___6 == 1U) {
            if ((int )(free_op1.var)->type != 5) {
              goto _L;
            } else {
              tmp___7 = zend_objects_store_get_refcount(free_op1.var);
              if (tmp___7 == (zend_uint __attribute__((__visibility__("default")))  )1) {
                _L: /* CIL Label */ 
                while (1) {
                  __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
                  if (__t->var.ptr_ptr) {
                    __t->var.ptr = *(__t->var.ptr_ptr);
                    __t->var.ptr_ptr = & __t->var.ptr;
                    tmp___4 = zval_isref_p(__t->var.ptr);
                    if (tmp___4) {

                    } else {
                      tmp___5 = zval_refcount_p(__t->var.ptr);
                      if (tmp___5 > 2U) {
                        while (1) {
                          tmp___3 = zval_refcount_p(*(__t->var.ptr_ptr));
                          if (tmp___3 > 1U) {
                            zval_delref_p(*(__t->var.ptr_ptr));
                            while (1) {
                              tmp___2 = _emalloc(sizeof(zval_gc_info ));
                              new_zv = (zval *)tmp___2;
                              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                              break;
                            }
                            while (1) {
                              while (1) {
                                new_zv->value = (*(__t->var.ptr_ptr))->value;
                                new_zv->type = (*(__t->var.ptr_ptr))->type;
                                break;
                              }
                              zval_set_refcount_p(new_zv, 1U);
                              zval_unset_isref_p(new_zv);
                              break;
                            }
                            *(__t->var.ptr_ptr) = new_zv;
                            _zval_copy_ctor(new_zv);
                          } else {

                          }
                          break;
                        }
                      } else {

                      }
                    }
                  } else {

                  }
                  break;
                }
              } else {

              }
            }
          } else {

          }
        } else {

        }
      } else {

      }
      (execute_data->opline) ++;
      return (0);
    } else {
      tmp___8 = zend_fetch_property_address_read_helper_SPEC_UNUSED_TMP(execute_data);
      return (tmp___8);
    }
  } else {
    tmp___8 = zend_fetch_property_address_read_helper_SPEC_UNUSED_TMP(execute_data);
    return (tmp___8);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zend_free_op free_res ;
  zval **container ;
  zval *property ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  long tmp___3 ;
  zend_literal *tmp___4 ;
  temp_variable *__t ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  zend_uint tmp___6 ;
  zend_bool tmp___7 ;
  zend_uint tmp___8 ;
  zend_uint tmp___9 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___10 ;
  zval *new_zv___1 ;
  void __attribute__((__visibility__("default")))  *tmp___11 ;
  zend_uint tmp___12 ;
  zend_bool tmp___13 ;

  {
  opline = execute_data->opline;
  container = _get_obj_zval_ptr_ptr_unused();
  property = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if (1 << 3 == 1 << 4) {
    if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
      tmp___1 = zval_isref_p(*container);
      if (tmp___1) {

      } else {
        while (1) {
          tmp___0 = zval_refcount_p(*container);
          if (tmp___0 > 1U) {
            zval_delref_p(*container);
            while (1) {
              tmp = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*container)->value;
                new_zv->type = (*container)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *container = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
    } else {

    }
  } else {

  }
  while (1) {
    while (1) {
      tmp___2 = _emalloc(sizeof(zval_gc_info ));
      _tmp = (zval *)tmp___2;
      ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
      break;
    }
    while (1) {
      while (1) {
        _tmp->value = property->value;
        _tmp->type = property->type;
        break;
      }
      zval_set_refcount_p(_tmp, 1U);
      zval_unset_isref_p(_tmp);
      break;
    }
    property = _tmp;
    break;
  }
  if (1 << 3 == 1 << 2) {
    tmp___3 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___3) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  if (1 << 1 == 1) {
    tmp___4 = opline->op2.literal;
  } else {
    tmp___4 = (zend_literal *)((void *)0);
  }
  zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)tmp___4, 6);
  i_zval_ptr_dtor(property);
  if (1 << 3 == 1 << 2) {
    if (0) {
      tmp___9 = zval_refcount_p(free_op1.var);
      if (tmp___9 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___10 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___10 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___7 = zval_isref_p(__t->var.ptr);
                if (tmp___7) {

                } else {
                  tmp___8 = zval_refcount_p(__t->var.ptr);
                  if (tmp___8 > 2U) {
                    while (1) {
                      tmp___6 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___6 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___5 = _emalloc(sizeof(zval_gc_info ));
                          new_zv___0 = (zval *)tmp___5;
                          ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv___0->value = (*(__t->var.ptr_ptr))->value;
                            new_zv___0->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv___0, 1U);
                          zval_unset_isref_p(new_zv___0);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv___0;
                        _zval_copy_ctor(new_zv___0);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  zend_pzval_unlock_func(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr), & free_res, 1);
  if ((unsigned int )((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
    tmp___13 = zval_isref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
    if (tmp___13) {

    } else {
      while (1) {
        tmp___12 = zval_refcount_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
        if (tmp___12 > 1U) {
          zval_delref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
          while (1) {
            tmp___11 = _emalloc(sizeof(zval_gc_info ));
            new_zv___1 = (zval *)tmp___11;
            ((zval_gc_info *)new_zv___1)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv___1->value = (*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr))->value;
              new_zv___1->type = (*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr))->type;
              break;
            }
            zval_set_refcount_p(new_zv___1, 1U);
            zval_unset_isref_p(new_zv___1);
            break;
          }
          *(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr) = new_zv___1;
          _zval_copy_ctor(new_zv___1);
        } else {

        }
        break;
      }
    }
  } else {

  }
  zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
  if (free_res.var) {
    i_zval_ptr_dtor(free_res.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval **object_ptr ;
  zval *property_name ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zend_literal *tmp___1 ;
  zval **tmp___2 ;

  {
  opline = execute_data->opline;
  object_ptr = _get_obj_zval_ptr_ptr_unused();
  property_name = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  while (1) {
    while (1) {
      tmp = _emalloc(sizeof(zval_gc_info ));
      _tmp = (zval *)tmp;
      ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
      break;
    }
    while (1) {
      while (1) {
        _tmp->value = property_name->value;
        _tmp->type = property_name->type;
        break;
      }
      zval_set_refcount_p(_tmp, 1U);
      zval_unset_isref_p(_tmp);
      break;
    }
    property_name = _tmp;
    break;
  }
  if (1 << 3 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  if (1 << 1 == 1) {
    tmp___1 = opline->op2.literal;
  } else {
    tmp___1 = (zend_literal *)((void *)0);
  }
  if (! ((int )opline->result_type & (1 << 5))) {
    tmp___2 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
  } else {
    tmp___2 = (zval **)((void *)0);
  }
  zend_assign_to_object(tmp___2, object_ptr, property_name, (int )(opline + 1)->op1_type, & (opline + 1)->op1, (temp_variable const   *)execute_data->Ts, 136, (zend_literal const   *)tmp___1);
  i_zval_ptr_dtor(property_name);
  (execute_data->opline) ++;
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_VAR_SPEC_UNUSED_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *str ;
  zval *var ;
  zval var_copy ;
  int use_copy ;

  {
  opline = execute_data->opline;
  str = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  use_copy = 0;
  var = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if (1 << 3 == 1 << 3) {
    str->value.str.val = (char *)((void *)0);
    str->value.str.len = 0;
    str->type = (unsigned char)6;
    str->refcount__gc = 1U;
    str->is_ref__gc = (unsigned char)0;
  } else {

  }
  if ((int )var->type != 6) {
    zend_make_printable_zval(var, & var_copy, & use_copy);
    if (use_copy) {
      var = & var_copy;
    } else {

    }
  } else {

  }
  add_string_to_string(str, (zval const   *)str, (zval const   *)var);
  if (use_copy) {
    _zval_dtor(var);
  } else {

  }
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_METHOD_CALL_SPEC_UNUSED_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *function_name ;
  char *function_name_strval ;
  int function_name_strlen ;
  zend_free_op free_op2 ;
  long tmp ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  zval *object ;
  long tmp___1 ;
  zend_literal *tmp___2 ;
  zend_class_entry *tmp___3 ;
  zend_class_entry *tmp___4 ;
  char const   *tmp___5 ;
  zend_class_entry *tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  zend_function *tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  zval *this_ptr ;
  void __attribute__((__visibility__("default")))  *tmp___13 ;
  zend_bool tmp___14 ;

  {
  opline = execute_data->opline;
  zend_ptr_stack_3_push(& executor_globals.arg_types_stack, (void *)execute_data->fbc, (void *)execute_data->object, (void *)execute_data->called_scope);
  function_name = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if (1 << 1 != 1) {
    tmp = __builtin_expect((long )((int )function_name->type != 6), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Method name must be a string");
    } else {

    }
  } else {

  }
  function_name_strval = function_name->value.str.val;
  function_name_strlen = function_name->value.str.len;
  execute_data->object = _get_obj_zval_ptr_unused();
  tmp___11 = __builtin_expect((long )((unsigned int )execute_data->object != (unsigned int )((void *)0)), 1L);
  if (tmp___11) {
    tmp___12 = __builtin_expect((long )((int )(execute_data->object)->type == 5), 1L);
    if (tmp___12) {
      tmp___0 = zend_get_class_entry((zval const   *)execute_data->object);
      execute_data->called_scope = (zend_class_entry *)tmp___0;
      if (1 << 1 != 1) {
        goto _L;
      } else {
        if ((unsigned int )*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) == (unsigned int )execute_data->called_scope) {
          tmp___10 = (zend_function *)*((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U));
        } else {
          tmp___10 = (zend_function *)((void *)0);
        }
        execute_data->fbc = tmp___10;
        if ((unsigned int )tmp___10 == (unsigned int )((void *)0)) {
          _L: /* CIL Label */ 
          object = execute_data->object;
          tmp___1 = __builtin_expect((long )((unsigned int )((execute_data->object)->value.obj.handlers)->get_method == (unsigned int )((void *)0)), 0L);
          if (tmp___1) {
            zend_error_noreturn(1, "Object does not support method calls");
          } else {

          }
          if (1 << 1 == 1) {
            tmp___2 = opline->op2.literal + 1;
          } else {
            tmp___2 = (zend_literal *)((void *)0);
          }
          execute_data->fbc = (*(((execute_data->object)->value.obj.handlers)->get_method))(& execute_data->object, function_name_strval, function_name_strlen, (struct _zend_literal  const  *)tmp___2);
          tmp___7 = __builtin_expect((long )((unsigned int )execute_data->fbc == (unsigned int )((void *)0)), 0L);
          if (tmp___7) {
            if (execute_data->object) {
              if ((int )(execute_data->object)->type == 5) {
                if ((unsigned int )((execute_data->object)->value.obj.handlers)->get_class_entry != (unsigned int )((void *)0)) {
                  tmp___6 = (*(((execute_data->object)->value.obj.handlers)->get_class_entry))((zval const   *)execute_data->object);
                  if (tmp___6) {
                    tmp___4 = (*(((execute_data->object)->value.obj.handlers)->get_class_entry))((zval const   *)execute_data->object);
                    tmp___5 = tmp___4->name;
                  } else {
                    tmp___5 = "";
                  }
                } else {
                  tmp___5 = "";
                }
              } else {
                tmp___5 = "";
              }
            } else {
              tmp___5 = "";
            }
            zend_error_noreturn(1, "Call to undefined method %s::%s()", tmp___5, function_name_strval);
          } else {

          }
          if (1 << 1 == 1) {
            tmp___8 = __builtin_expect((long )(((execute_data->fbc)->common.fn_flags & 6291456U) == 0U), 1L);
            if (tmp___8) {
              tmp___9 = __builtin_expect((long )((unsigned int )execute_data->object == (unsigned int )object), 1L);
              if (tmp___9) {
                while (1) {
                  *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)execute_data->called_scope;
                  *((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U)) = (void *)execute_data->fbc;
                  break;
                }
              } else {

              }
            } else {

            }
          } else {

          }
        } else {

        }
      }
    } else {
      zend_error_noreturn(1, "Call to a member function %s() on a non-object", function_name_strval);
    }
  } else {
    zend_error_noreturn(1, "Call to a member function %s() on a non-object", function_name_strval);
  }
  if (((execute_data->fbc)->common.fn_flags & 1U) != 0U) {
    execute_data->object = (zval *)((void *)0);
  } else {
    tmp___14 = zval_isref_p(execute_data->object);
    if (tmp___14) {
      while (1) {
        tmp___13 = _emalloc(sizeof(zval_gc_info ));
        this_ptr = (zval *)tmp___13;
        ((zval_gc_info *)this_ptr)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      while (1) {
        while (1) {
          this_ptr->value = (execute_data->object)->value;
          this_ptr->type = (execute_data->object)->type;
          break;
        }
        zval_set_refcount_p(this_ptr, 1U);
        zval_unset_isref_p(this_ptr);
        break;
      }
      _zval_copy_ctor(this_ptr);
      execute_data->object = this_ptr;
    } else {
      zval_addref_p(execute_data->object);
    }
  }
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_ARRAY_SPEC_UNUSED_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;

  {
  opline = execute_data->opline;
  _array_init(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, 0U);
  if (1 << 3 == 1 << 3) {
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_UNSET_DIM_SPEC_UNUSED_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval **container ;
  zval *offset ;
  ulong hval ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  HashTable *ht ;
  long tmp___2 ;
  register char const   *tmp___3 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___4 ;
  long tmp___5 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;

  {
  opline = execute_data->opline;
  container = _get_obj_zval_ptr_ptr_unused();
  if (1 << 3 == 1 << 4) {
    if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
      tmp___1 = zval_isref_p(*container);
      if (tmp___1) {

      } else {
        while (1) {
          tmp___0 = zval_refcount_p(*container);
          if (tmp___0 > 1U) {
            zval_delref_p(*container);
            while (1) {
              tmp = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*container)->value;
                new_zv->type = (*container)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *container = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
    } else {

    }
  } else {

  }
  offset = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if (1 << 3 != 1 << 2) {
    goto _L___0;
  } else {
    if (container) {
      _L___0: /* CIL Label */ 
      switch ((int )(*container)->type) {
      case 4: 
      ht = (*container)->value.ht;
      switch ((int )offset->type) {
      case 2: 
      tmp___2 = zend_dval_to_lval(offset->value.dval);
      hval = (unsigned long )tmp___2;
      goto num_index_dim;
      case 7: 
      case 3: 
      case 1: 
      hval = (unsigned long )offset->value.lval;
      zend_hash_del_key_or_index(ht, (char const   *)((void *)0), 0U, hval, 1);
      break;
      case 6: 
      if (1 << 1 == 1 << 4) {
        zval_addref_p(offset);
      } else {
        if (1 << 1 == 1 << 2) {
          zval_addref_p(offset);
        } else {

        }
      }
      if (1 << 1 == 1) {
        hval = ((zend_literal *)offset)->hash_value;
      } else {
        while (1) {
          tmp___3 = (char const   *)offset->value.str.val;
          if ((int const   )*tmp___3 == 45) {
            tmp___3 ++;
          } else {

          }
          if ((int const   )*tmp___3 >= 48) {
            if ((int const   )*tmp___3 <= 57) {
              end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
              if ((int const   )*end != 0) {
                break;
              } else {
                if ((int const   )*tmp___3 == 48) {
                  if (offset->value.str.len + 1 > 2) {
                    break;
                  } else {
                    goto _L;
                  }
                } else {
                  _L: /* CIL Label */ 
                  if (end - tmp___3 > 10) {
                    break;
                  } else {
                    if (end - tmp___3 == 10) {
                      if ((int const   )*tmp___3 > 50) {
                        break;
                      } else {

                      }
                    } else {

                    }
                  }
                }
              }
              hval = (unsigned long )((int const   )*tmp___3 - 48);
              while (1) {
                tmp___3 ++;
                if ((unsigned int )tmp___3 != (unsigned int )end) {
                  if ((int const   )*tmp___3 >= 48) {
                    if ((int const   )*tmp___3 <= 57) {

                    } else {
                      break;
                    }
                  } else {
                    break;
                  }
                } else {
                  break;
                }
                hval = hval * 10UL + (ulong )((int const   )*tmp___3 - 48);
              }
              if ((unsigned int )tmp___3 == (unsigned int )end) {
                if ((int )*(offset->value.str.val) == 45) {
                  if (hval - 1UL > 2147483647UL) {
                    break;
                  } else {

                  }
                  hval = (unsigned long )(- ((long )hval));
                } else {
                  if (hval > 2147483647UL) {
                    break;
                  } else {

                  }
                }
                goto num_index_dim;
              } else {

              }
            } else {

            }
          } else {

          }
          break;
        }
        if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
          if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
            hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
          } else {
            tmp___4 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
            hval = (unsigned long )tmp___4;
          }
        } else {
          tmp___4 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___4;
        }
      }
      if ((unsigned int )ht == (unsigned int )(& executor_globals.symbol_table)) {
        zend_delete_global_variable_ex((char const   *)offset->value.str.val, offset->value.str.len, hval);
      } else {
        zend_hash_del_key_or_index(ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, 2);
      }
      if (1 << 1 == 1 << 4) {
        i_zval_ptr_dtor(offset);
      } else {
        if (1 << 1 == 1 << 2) {
          i_zval_ptr_dtor(offset);
        } else {

        }
      }
      break;
      num_index_dim: 
      zend_hash_del_key_or_index(ht, (char const   *)((void *)0), 0U, hval, 1);
      if (1 << 1 == 1 << 4) {
        i_zval_ptr_dtor(offset);
      } else {
        if (1 << 1 == 1 << 2) {
          i_zval_ptr_dtor(offset);
        } else {

        }
      }
      break;
      case 0: 
      zend_hash_del_key_or_index(ht, "", sizeof(""), 0UL, 0);
      break;
      default: 
      zend_error(1 << 1L, "Illegal offset type in unset");
      break;
      }
      _zval_dtor(free_op2.var);
      break;
      case 5: 
      tmp___5 = __builtin_expect((long )((unsigned int )((*container)->value.obj.handlers)->unset_dimension == (unsigned int )((void *)0)), 0L);
      if (tmp___5) {
        zend_error_noreturn(1, "Cannot use object as array");
      } else {

      }
      while (1) {
        while (1) {
          tmp___6 = _emalloc(sizeof(zval_gc_info ));
          _tmp = (zval *)tmp___6;
          ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            _tmp->value = offset->value;
            _tmp->type = offset->type;
            break;
          }
          zval_set_refcount_p(_tmp, 1U);
          zval_unset_isref_p(_tmp);
          break;
        }
        offset = _tmp;
        break;
      }
      (*(((*container)->value.obj.handlers)->unset_dimension))(*container, offset);
      i_zval_ptr_dtor(offset);
      break;
      case 6: 
      zend_error_noreturn(1, "Cannot unset string offsets");
      return (0);
      default: 
      _zval_dtor(free_op2.var);
      break;
      }
    } else {
      _zval_dtor(free_op2.var);
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_UNSET_OBJ_SPEC_UNUSED_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval **container ;
  zval *offset ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_literal *tmp___3 ;

  {
  opline = execute_data->opline;
  container = _get_obj_zval_ptr_ptr_unused();
  offset = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if (1 << 3 != 1 << 2) {
    goto _L;
  } else {
    if (container) {
      _L: /* CIL Label */ 
      if (1 << 3 == 1 << 4) {
        if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
          tmp___1 = zval_isref_p(*container);
          if (tmp___1) {

          } else {
            while (1) {
              tmp___0 = zval_refcount_p(*container);
              if (tmp___0 > 1U) {
                zval_delref_p(*container);
                while (1) {
                  tmp = _emalloc(sizeof(zval_gc_info ));
                  new_zv = (zval *)tmp;
                  ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                  break;
                }
                while (1) {
                  while (1) {
                    new_zv->value = (*container)->value;
                    new_zv->type = (*container)->type;
                    break;
                  }
                  zval_set_refcount_p(new_zv, 1U);
                  zval_unset_isref_p(new_zv);
                  break;
                }
                *container = new_zv;
                _zval_copy_ctor(new_zv);
              } else {

              }
              break;
            }
          }
        } else {

        }
      } else {

      }
      if ((int )(*container)->type == 5) {
        while (1) {
          while (1) {
            tmp___2 = _emalloc(sizeof(zval_gc_info ));
            _tmp = (zval *)tmp___2;
            ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              _tmp->value = offset->value;
              _tmp->type = offset->type;
              break;
            }
            zval_set_refcount_p(_tmp, 1U);
            zval_unset_isref_p(_tmp);
            break;
          }
          offset = _tmp;
          break;
        }
        if (((*container)->value.obj.handlers)->unset_property) {
          if (1 << 1 == 1) {
            tmp___3 = opline->op2.literal;
          } else {
            tmp___3 = (zend_literal *)((void *)0);
          }
          (*(((*container)->value.obj.handlers)->unset_property))(*container, offset, (struct _zend_literal  const  *)tmp___3);
        } else {
          zend_error(1 << 3L, "Trying to unset property of non-object");
        }
        i_zval_ptr_dtor(offset);
      } else {
        _zval_dtor(free_op2.var);
      }
    } else {
      _zval_dtor(free_op2.var);
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_TMP)(int prop_dim , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval **container ;
  zval **value ;
  int result ;
  ulong hval ;
  zval *offset ;
  HashTable *ht ;
  int isset ;
  long tmp ;
  int __attribute__((__visibility__("default")))  tmp___0 ;
  register char const   *tmp___1 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___2 ;
  int __attribute__((__visibility__("default")))  tmp___3 ;
  int __attribute__((__visibility__("default")))  tmp___4 ;
  int tmp___5 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;
  zend_literal *tmp___7 ;
  zval tmp___8 ;

  {
  opline = execute_data->opline;
  value = (zval **)((void *)0);
  result = 0;
  container = _get_obj_zval_ptr_ptr_unused();
  offset = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if ((int )(*container)->type == 4) {
    if (! prop_dim) {
      isset = 0;
      ht = (*container)->value.ht;
      switch ((int )offset->type) {
      case 2: 
      tmp = zend_dval_to_lval(offset->value.dval);
      hval = (unsigned long )tmp;
      goto num_index_prop;
      case 7: 
      case 3: 
      case 1: 
      hval = (unsigned long )offset->value.lval;
      num_index_prop: 
      tmp___0 = zend_hash_index_find((HashTable const   *)ht, hval, (void **)(& value));
      if (tmp___0 == (int __attribute__((__visibility__("default")))  )0) {
        isset = 1;
      } else {

      }
      break;
      case 6: 
      if (1 << 1 == 1) {
        hval = ((zend_literal *)offset)->hash_value;
      } else {
        if (! prop_dim) {
          while (1) {
            tmp___1 = (char const   *)offset->value.str.val;
            if ((int const   )*tmp___1 == 45) {
              tmp___1 ++;
            } else {

            }
            if ((int const   )*tmp___1 >= 48) {
              if ((int const   )*tmp___1 <= 57) {
                end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
                if ((int const   )*end != 0) {
                  break;
                } else {
                  if ((int const   )*tmp___1 == 48) {
                    if (offset->value.str.len + 1 > 2) {
                      break;
                    } else {
                      goto _L;
                    }
                  } else {
                    _L: /* CIL Label */ 
                    if (end - tmp___1 > 10) {
                      break;
                    } else {
                      if (end - tmp___1 == 10) {
                        if ((int const   )*tmp___1 > 50) {
                          break;
                        } else {

                        }
                      } else {

                      }
                    }
                  }
                }
                hval = (unsigned long )((int const   )*tmp___1 - 48);
                while (1) {
                  tmp___1 ++;
                  if ((unsigned int )tmp___1 != (unsigned int )end) {
                    if ((int const   )*tmp___1 >= 48) {
                      if ((int const   )*tmp___1 <= 57) {

                      } else {
                        break;
                      }
                    } else {
                      break;
                    }
                  } else {
                    break;
                  }
                  hval = hval * 10UL + (ulong )((int const   )*tmp___1 - 48);
                }
                if ((unsigned int )tmp___1 == (unsigned int )end) {
                  if ((int )*(offset->value.str.val) == 45) {
                    if (hval - 1UL > 2147483647UL) {
                      break;
                    } else {

                    }
                    hval = (unsigned long )(- ((long )hval));
                  } else {
                    if (hval > 2147483647UL) {
                      break;
                    } else {

                    }
                  }
                  goto num_index_prop;
                } else {

                }
              } else {

              }
            } else {

            }
            break;
          }
        } else {

        }
        if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
          if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
            hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
          } else {
            tmp___2 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
            hval = (unsigned long )tmp___2;
          }
        } else {
          tmp___2 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___2;
        }
      }
      tmp___3 = zend_hash_quick_find((HashTable const   *)ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, (void **)(& value));
      if (tmp___3 == (int __attribute__((__visibility__("default")))  )0) {
        isset = 1;
      } else {

      }
      break;
      case 0: 
      tmp___4 = zend_hash_find((HashTable const   *)ht, "", sizeof(""), (void **)(& value));
      if (tmp___4 == (int __attribute__((__visibility__("default")))  )0) {
        isset = 1;
      } else {

      }
      break;
      default: 
      zend_error(1 << 1L, "Illegal offset type in isset or empty");
      break;
      }
      if (opline->extended_value & 33554432UL) {
        if (isset) {
          if ((int )(*value)->type == 0) {
            result = 0;
          } else {
            result = isset;
          }
        } else {
          result = isset;
        }
      } else {
        if (! isset) {
          result = 0;
        } else {
          tmp___5 = i_zend_is_true(*value);
          if (tmp___5) {
            result = 1;
          } else {
            result = 0;
          }
        }
      }
      _zval_dtor(free_op2.var);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if ((int )(*container)->type == 5) {
      while (1) {
        while (1) {
          tmp___6 = _emalloc(sizeof(zval_gc_info ));
          _tmp = (zval *)tmp___6;
          ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            _tmp->value = offset->value;
            _tmp->type = offset->type;
            break;
          }
          zval_set_refcount_p(_tmp, 1U);
          zval_unset_isref_p(_tmp);
          break;
        }
        offset = _tmp;
        break;
      }
      if (prop_dim) {
        if (((*container)->value.obj.handlers)->has_property) {
          if (1 << 1 == 1) {
            tmp___7 = opline->op2.literal;
          } else {
            tmp___7 = (zend_literal *)((void *)0);
          }
          result = (*(((*container)->value.obj.handlers)->has_property))(*container, offset, (opline->extended_value & 16777216UL) != 0UL, (struct _zend_literal  const  *)tmp___7);
        } else {
          zend_error(1 << 3L, "Trying to check property of non-object");
          result = 0;
        }
      } else {
        if (((*container)->value.obj.handlers)->has_dimension) {
          result = (*(((*container)->value.obj.handlers)->has_dimension))(*container, offset, (opline->extended_value & 16777216UL) != 0UL);
        } else {
          zend_error(1 << 3L, "Trying to check element of non-array");
          result = 0;
        }
      }
      i_zval_ptr_dtor(offset);
    } else {
      if ((int )(*container)->type == 6) {
        if (! prop_dim) {
          if ((int )offset->type != 1) {
            while (1) {
              tmp___8.value = offset->value;
              tmp___8.type = offset->type;
              break;
            }
            _zval_copy_ctor(& tmp___8);
            convert_to_long(& tmp___8);
            offset = & tmp___8;
          } else {

          }
          if ((int )offset->type == 1) {
            if (opline->extended_value & 33554432UL) {
              if (offset->value.lval >= 0L) {
                if (offset->value.lval < (long )(*container)->value.str.len) {
                  result = 1;
                } else {

                }
              } else {

              }
            } else {
              if (offset->value.lval >= 0L) {
                if (offset->value.lval < (long )(*container)->value.str.len) {
                  if ((int )*((*container)->value.str.val + offset->value.lval) != 48) {
                    result = 1;
                  } else {

                  }
                } else {

                }
              } else {

              }
            }
          } else {

          }
          _zval_dtor(free_op2.var);
        } else {
          _zval_dtor(free_op2.var);
        }
      } else {
        _zval_dtor(free_op2.var);
      }
    }
  }
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.type = (unsigned char)3;
  if (opline->extended_value & 33554432UL) {
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.lval = (long )result;
  } else {
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.lval = (long )(! result);
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_TMP(0, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_TMP(1, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) zend_binary_assign_op_obj_helper_SPEC_UNUSED_VAR)(int (*binary_op)(zval *result , zval *op1 , zval *op2 ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zend_free_op free_op_data1 ;
  zval **object_ptr ;
  zval **tmp ;
  zval *object ;
  zval *property ;
  zval *tmp___0 ;
  zval *value ;
  zval *tmp___1 ;
  int have_get_ptr ;
  long tmp___2 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___3 ;
  zval **zptr ;
  zend_literal *tmp___4 ;
  zval **tmp___5 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;
  zend_uint tmp___7 ;
  zend_bool tmp___8 ;
  zval *z ;
  zend_literal *tmp___9 ;
  zval *value___0 ;
  zval *tmp___10 ;
  zend_uint tmp___11 ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___12 ;
  zend_uint tmp___13 ;
  zend_bool tmp___14 ;
  zend_literal *tmp___15 ;
  long tmp___16 ;

  {
  opline = execute_data->opline;
  tmp = _get_obj_zval_ptr_ptr_unused();
  object_ptr = tmp;
  tmp___0 = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  property = tmp___0;
  tmp___1 = _get_zval_ptr((int )(opline + 1)->op1_type, (znode_op const   *)(& (opline + 1)->op1), (temp_variable const   *)execute_data->Ts, & free_op_data1, 0);
  value = tmp___1;
  have_get_ptr = 0;
  if (1 << 3 == 1 << 2) {
    tmp___2 = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___2) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  make_real_object(object_ptr);
  object = *object_ptr;
  tmp___16 = __builtin_expect((long )((int )object->type != 5), 0L);
  if (tmp___16) {
    zend_error(1 << 1L, "Attempt to assign property of non-object");
    if (free_op2.var) {
      i_zval_ptr_dtor(free_op2.var);
    } else {

    }
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = & executor_globals.uninitialized_zval;
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
    } else {

    }
  } else {
    if (opline->extended_value == 136UL) {
      if ((object->value.obj.handlers)->get_property_ptr_ptr) {
        if (1 << 2 == 1) {
          tmp___4 = opline->op2.literal;
        } else {
          tmp___4 = (zend_literal *)((void *)0);
        }
        tmp___5 = (*((object->value.obj.handlers)->get_property_ptr_ptr))(object, property, (struct _zend_literal  const  *)tmp___4);
        zptr = tmp___5;
        if ((unsigned int )zptr != (unsigned int )((void *)0)) {
          tmp___8 = zval_isref_p(*zptr);
          if (tmp___8) {

          } else {
            while (1) {
              tmp___7 = zval_refcount_p(*zptr);
              if (tmp___7 > 1U) {
                zval_delref_p(*zptr);
                while (1) {
                  tmp___6 = _emalloc(sizeof(zval_gc_info ));
                  new_zv = (zval *)tmp___6;
                  ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                  break;
                }
                while (1) {
                  while (1) {
                    new_zv->value = (*zptr)->value;
                    new_zv->type = (*zptr)->type;
                    break;
                  }
                  zval_set_refcount_p(new_zv, 1U);
                  zval_unset_isref_p(new_zv);
                  break;
                }
                *zptr = new_zv;
                _zval_copy_ctor(new_zv);
              } else {

              }
              break;
            }
          }
          have_get_ptr = 1;
          (*binary_op)(*zptr, *zptr, value);
          if (! ((int )opline->result_type & (1 << 5))) {
            zval_addref_p(*zptr);
            ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = *zptr;
            ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
          } else {

          }
        } else {

        }
      } else {

      }
    } else {

    }
    if (! have_get_ptr) {
      z = (zval *)((void *)0);
      if (opline->extended_value == 136UL) {
        if ((object->value.obj.handlers)->read_property) {
          if (1 << 2 == 1) {
            tmp___9 = opline->op2.literal;
          } else {
            tmp___9 = (zend_literal *)((void *)0);
          }
          z = (*((object->value.obj.handlers)->read_property))(object, property, 0, (struct _zend_literal  const  *)tmp___9);
        } else {

        }
      } else {
        if ((object->value.obj.handlers)->read_dimension) {
          z = (*((object->value.obj.handlers)->read_dimension))(object, property, 0);
        } else {

        }
      }
      if (z) {
        if ((int )z->type == 5) {
          if ((z->value.obj.handlers)->get) {
            tmp___10 = (*((z->value.obj.handlers)->get))(z);
            value___0 = tmp___10;
            tmp___11 = zval_refcount_p(z);
            if (tmp___11 == 0U) {
              if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                gc_remove_zval_from_buffer(z);
              } else {

              }
              _zval_dtor(z);
              while (1) {
                if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                  gc_remove_zval_from_buffer(z);
                } else {

                }
                _efree((void *)z);
                break;
              }
            } else {

            }
            z = value___0;
          } else {

          }
        } else {

        }
        zval_addref_p(z);
        tmp___14 = zval_isref_p(z);
        if (tmp___14) {

        } else {
          while (1) {
            tmp___13 = zval_refcount_p(z);
            if (tmp___13 > 1U) {
              zval_delref_p(z);
              while (1) {
                tmp___12 = _emalloc(sizeof(zval_gc_info ));
                new_zv___0 = (zval *)tmp___12;
                ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv___0->value = z->value;
                  new_zv___0->type = z->type;
                  break;
                }
                zval_set_refcount_p(new_zv___0, 1U);
                zval_unset_isref_p(new_zv___0);
                break;
              }
              z = new_zv___0;
              _zval_copy_ctor(new_zv___0);
            } else {

            }
            break;
          }
        }
        (*binary_op)(z, z, value);
        if (opline->extended_value == 136UL) {
          if (1 << 2 == 1) {
            tmp___15 = opline->op2.literal;
          } else {
            tmp___15 = (zend_literal *)((void *)0);
          }
          (*((object->value.obj.handlers)->write_property))(object, property, z, (struct _zend_literal  const  *)tmp___15);
        } else {
          (*((object->value.obj.handlers)->write_dimension))(object, property, z);
        }
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(z);
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = z;
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
        } else {

        }
        i_zval_ptr_dtor(z);
      } else {
        zend_error(1 << 1L, "Attempt to assign property of non-object");
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = & executor_globals.uninitialized_zval;
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
        } else {

        }
      }
    } else {

    }
    if (free_op2.var) {
      i_zval_ptr_dtor(free_op2.var);
    } else {

    }
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
  }
  (execute_data->opline) ++;
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_binary_assign_op_helper_SPEC_UNUSED_VAR)(int (*binary_op)(zval *result , zval *op1 , zval *op2 ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zend_free_op free_op_data2 ;
  zend_free_op free_op_data1 ;
  zval **var_ptr ;
  zval *value ;
  int tmp ;
  zval **container ;
  zval **tmp___0 ;
  int tmp___1 ;
  zval *dim ;
  zval *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  temp_variable *__t ;
  long tmp___6 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___7 ;
  zend_uint tmp___8 ;
  zend_bool tmp___9 ;
  zval *objval ;
  zval *tmp___10 ;
  long tmp___11 ;
  temp_variable *__t___0 ;

  {
  opline = execute_data->opline;
  switch ((int )opline->extended_value) {
  case 136: 
  tmp = zend_binary_assign_op_obj_helper_SPEC_UNUSED_VAR(binary_op, execute_data);
  return (tmp);
  break;
  case 147: 
  tmp___0 = _get_obj_zval_ptr_ptr_unused();
  container = tmp___0;
  if (1 << 3 == 1 << 2) {
    tmp___4 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___4) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    tmp___3 = __builtin_expect((long )((int )(*container)->type == 5), 0L);
    if (tmp___3) {
      if (1 << 3 == 1 << 2) {
        zval_addref_p(*container);
      } else {

      }
      tmp___1 = zend_binary_assign_op_obj_helper_SPEC_UNUSED_VAR(binary_op, execute_data);
      return (tmp___1);
    } else {
      tmp___2 = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
      dim = tmp___2;
      zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var), container, dim, 1 << 2, 2);
      value = _get_zval_ptr((int )(opline + 1)->op1_type, (znode_op const   *)(& (opline + 1)->op1), (temp_variable const   *)execute_data->Ts, & free_op_data1, 0);
      var_ptr = _get_zval_ptr_ptr_var((opline + 1)->op2.var, (temp_variable const   *)execute_data->Ts, & free_op_data2);
    }
  }
  break;
  default: 
  value = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  var_ptr = (zval **)((void *)0);
  break;
  }
  tmp___5 = __builtin_expect((long )((unsigned int )var_ptr == (unsigned int )((void *)0)), 0L);
  if (tmp___5) {
    zend_error_noreturn(1, "Cannot use assign-op operators with overloaded objects nor string offsets");
  } else {

  }
  tmp___6 = __builtin_expect((long )((unsigned int )*var_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
  if (tmp___6) {
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      while (1) {
        __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t->var.ptr = & executor_globals.uninitialized_zval;
        __t->var.ptr_ptr = & __t->var.ptr;
        break;
      }
    } else {

    }
    if (free_op2.var) {
      i_zval_ptr_dtor(free_op2.var);
    } else {

    }
    if (opline->extended_value == 147UL) {
      (execute_data->opline) ++;
    } else {

    }
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  tmp___9 = zval_isref_p(*var_ptr);
  if (tmp___9) {

  } else {
    while (1) {
      tmp___8 = zval_refcount_p(*var_ptr);
      if (tmp___8 > 1U) {
        zval_delref_p(*var_ptr);
        while (1) {
          tmp___7 = _emalloc(sizeof(zval_gc_info ));
          new_zv = (zval *)tmp___7;
          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            new_zv->value = (*var_ptr)->value;
            new_zv->type = (*var_ptr)->type;
            break;
          }
          zval_set_refcount_p(new_zv, 1U);
          zval_unset_isref_p(new_zv);
          break;
        }
        *var_ptr = new_zv;
        _zval_copy_ctor(new_zv);
      } else {

      }
      break;
    }
  }
  tmp___11 = __builtin_expect((long )((int )(*var_ptr)->type == 5), 0L);
  if (tmp___11) {
    if (((*var_ptr)->value.obj.handlers)->get) {
      if (((*var_ptr)->value.obj.handlers)->set) {
        tmp___10 = (*(((*var_ptr)->value.obj.handlers)->get))(*var_ptr);
        objval = tmp___10;
        zval_addref_p(objval);
        (*binary_op)(objval, objval, value);
        (*(((*var_ptr)->value.obj.handlers)->set))(var_ptr, objval);
        i_zval_ptr_dtor(objval);
      } else {
        (*binary_op)(*var_ptr, *var_ptr, value);
      }
    } else {
      (*binary_op)(*var_ptr, *var_ptr, value);
    }
  } else {
    (*binary_op)(*var_ptr, *var_ptr, value);
  }
  if (! ((int )opline->result_type & (1 << 5))) {
    zval_addref_p(*var_ptr);
    while (1) {
      __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
      __t___0->var.ptr = *var_ptr;
      __t___0->var.ptr_ptr = & __t___0->var.ptr;
      break;
    }
  } else {

  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  if (opline->extended_value == 147UL) {
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
    if (free_op_data2.var) {
      i_zval_ptr_dtor(free_op_data2.var);
    } else {

    }
    (execute_data->opline) ++;
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_ADD_SPEC_UNUSED_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_VAR((int (*)(zval *result , zval *op1 , zval *op2 ))(& add_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SUB_SPEC_UNUSED_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_VAR((int (*)(zval *result , zval *op1 , zval *op2 ))(& sub_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_MUL_SPEC_UNUSED_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_VAR((int (*)(zval *result , zval *op1 , zval *op2 ))(& mul_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_DIV_SPEC_UNUSED_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_VAR((int (*)(zval *result , zval *op1 , zval *op2 ))(& div_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_MOD_SPEC_UNUSED_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_VAR((int (*)(zval *result , zval *op1 , zval *op2 ))(& mod_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SL_SPEC_UNUSED_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_VAR((int (*)(zval *result , zval *op1 , zval *op2 ))(& shift_left_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SR_SPEC_UNUSED_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_VAR((int (*)(zval *result , zval *op1 , zval *op2 ))(& shift_right_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_CONCAT_SPEC_UNUSED_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_VAR((int (*)(zval *result , zval *op1 , zval *op2 ))(& concat_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_OR_SPEC_UNUSED_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_VAR((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_or_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_AND_SPEC_UNUSED_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_VAR((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_and_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_VAR((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_xor_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) zend_pre_incdec_property_helper_SPEC_UNUSED_VAR)(int (*incdec_op)(zval * ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval **object_ptr ;
  zval *object ;
  zval *property ;
  zval **retval ;
  int have_get_ptr ;
  long tmp ;
  long tmp___0 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zval **zptr ;
  zend_literal *tmp___2 ;
  zval **tmp___3 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_uint tmp___5 ;
  zend_bool tmp___6 ;
  zval *z ;
  zend_literal *tmp___7 ;
  zval *tmp___8 ;
  zval *value ;
  zval *tmp___9 ;
  zend_uint tmp___10 ;
  long tmp___11 ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___12 ;
  zend_uint tmp___13 ;
  zend_bool tmp___14 ;
  zend_literal *tmp___15 ;

  {
  opline = execute_data->opline;
  have_get_ptr = 0;
  object_ptr = _get_obj_zval_ptr_ptr_unused();
  property = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  retval = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
  if (1 << 3 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot increment/decrement overloaded objects nor string offsets");
    } else {

    }
  } else {

  }
  make_real_object(object_ptr);
  object = *object_ptr;
  tmp___0 = __builtin_expect((long )((int )object->type != 5), 0L);
  if (tmp___0) {
    zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
    if (free_op2.var) {
      i_zval_ptr_dtor(free_op2.var);
    } else {

    }
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      *retval = & executor_globals.uninitialized_zval;
    } else {

    }
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  if ((object->value.obj.handlers)->get_property_ptr_ptr) {
    if (1 << 2 == 1) {
      tmp___2 = opline->op2.literal;
    } else {
      tmp___2 = (zend_literal *)((void *)0);
    }
    tmp___3 = (*((object->value.obj.handlers)->get_property_ptr_ptr))(object, property, (struct _zend_literal  const  *)tmp___2);
    zptr = tmp___3;
    if ((unsigned int )zptr != (unsigned int )((void *)0)) {
      tmp___6 = zval_isref_p(*zptr);
      if (tmp___6) {

      } else {
        while (1) {
          tmp___5 = zval_refcount_p(*zptr);
          if (tmp___5 > 1U) {
            zval_delref_p(*zptr);
            while (1) {
              tmp___4 = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp___4;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*zptr)->value;
                new_zv->type = (*zptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *zptr = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
      have_get_ptr = 1;
      (*incdec_op)(*zptr);
      if (! ((int )opline->result_type & (1 << 5))) {
        *retval = *zptr;
        zval_addref_p(*retval);
      } else {

      }
    } else {

    }
  } else {

  }
  if (! have_get_ptr) {
    if ((object->value.obj.handlers)->read_property) {
      if ((object->value.obj.handlers)->write_property) {
        if (1 << 2 == 1) {
          tmp___7 = opline->op2.literal;
        } else {
          tmp___7 = (zend_literal *)((void *)0);
        }
        tmp___8 = (*((object->value.obj.handlers)->read_property))(object, property, 0, (struct _zend_literal  const  *)tmp___7);
        z = tmp___8;
        tmp___11 = __builtin_expect((long )((int )z->type == 5), 0L);
        if (tmp___11) {
          if ((z->value.obj.handlers)->get) {
            tmp___9 = (*((z->value.obj.handlers)->get))(z);
            value = tmp___9;
            tmp___10 = zval_refcount_p(z);
            if (tmp___10 == 0U) {
              if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                gc_remove_zval_from_buffer(z);
              } else {

              }
              _zval_dtor(z);
              while (1) {
                if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                  gc_remove_zval_from_buffer(z);
                } else {

                }
                _efree((void *)z);
                break;
              }
            } else {

            }
            z = value;
          } else {

          }
        } else {

        }
        zval_addref_p(z);
        tmp___14 = zval_isref_p(z);
        if (tmp___14) {

        } else {
          while (1) {
            tmp___13 = zval_refcount_p(z);
            if (tmp___13 > 1U) {
              zval_delref_p(z);
              while (1) {
                tmp___12 = _emalloc(sizeof(zval_gc_info ));
                new_zv___0 = (zval *)tmp___12;
                ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv___0->value = z->value;
                  new_zv___0->type = z->type;
                  break;
                }
                zval_set_refcount_p(new_zv___0, 1U);
                zval_unset_isref_p(new_zv___0);
                break;
              }
              z = new_zv___0;
              _zval_copy_ctor(new_zv___0);
            } else {

            }
            break;
          }
        }
        (*incdec_op)(z);
        *retval = z;
        if (1 << 2 == 1) {
          tmp___15 = opline->op2.literal;
        } else {
          tmp___15 = (zend_literal *)((void *)0);
        }
        (*((object->value.obj.handlers)->write_property))(object, property, z, (struct _zend_literal  const  *)tmp___15);
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(*retval);
        } else {

        }
        i_zval_ptr_dtor(z);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
      if (! ((int )opline->result_type & (1 << 5))) {
        zval_addref_p(& executor_globals.uninitialized_zval);
        *retval = & executor_globals.uninitialized_zval;
      } else {

      }
    }
  } else {

  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_PRE_INC_OBJ_SPEC_UNUSED_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_pre_incdec_property_helper_SPEC_UNUSED_VAR((int (*)(zval * ))(& increment_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_PRE_DEC_OBJ_SPEC_UNUSED_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_pre_incdec_property_helper_SPEC_UNUSED_VAR((int (*)(zval * ))(& decrement_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) zend_post_incdec_property_helper_SPEC_UNUSED_VAR)(int (*incdec_op)(zval * ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval **object_ptr ;
  zval *object ;
  zval *property ;
  zval *retval ;
  int have_get_ptr ;
  long tmp ;
  long tmp___0 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zval **zptr ;
  zend_literal *tmp___2 ;
  zval **tmp___3 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_uint tmp___5 ;
  zend_bool tmp___6 ;
  zval *z ;
  zend_literal *tmp___7 ;
  zval *tmp___8 ;
  zval *z_copy ;
  zval *value ;
  zval *tmp___9 ;
  zend_uint tmp___10 ;
  long tmp___11 ;
  void __attribute__((__visibility__("default")))  *tmp___12 ;
  zend_literal *tmp___13 ;

  {
  opline = execute_data->opline;
  have_get_ptr = 0;
  object_ptr = _get_obj_zval_ptr_ptr_unused();
  property = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  retval = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  if (1 << 3 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot increment/decrement overloaded objects nor string offsets");
    } else {

    }
  } else {

  }
  make_real_object(object_ptr);
  object = *object_ptr;
  tmp___0 = __builtin_expect((long )((int )object->type != 5), 0L);
  if (tmp___0) {
    zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
    if (free_op2.var) {
      i_zval_ptr_dtor(free_op2.var);
    } else {

    }
    retval->type = (unsigned char)0;
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  if ((object->value.obj.handlers)->get_property_ptr_ptr) {
    if (1 << 2 == 1) {
      tmp___2 = opline->op2.literal;
    } else {
      tmp___2 = (zend_literal *)((void *)0);
    }
    tmp___3 = (*((object->value.obj.handlers)->get_property_ptr_ptr))(object, property, (struct _zend_literal  const  *)tmp___2);
    zptr = tmp___3;
    if ((unsigned int )zptr != (unsigned int )((void *)0)) {
      have_get_ptr = 1;
      tmp___6 = zval_isref_p(*zptr);
      if (tmp___6) {

      } else {
        while (1) {
          tmp___5 = zval_refcount_p(*zptr);
          if (tmp___5 > 1U) {
            zval_delref_p(*zptr);
            while (1) {
              tmp___4 = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp___4;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*zptr)->value;
                new_zv->type = (*zptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *zptr = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
      while (1) {
        retval->value = (*zptr)->value;
        retval->type = (*zptr)->type;
        break;
      }
      _zval_copy_ctor(retval);
      (*incdec_op)(*zptr);
    } else {

    }
  } else {

  }
  if (! have_get_ptr) {
    if ((object->value.obj.handlers)->read_property) {
      if ((object->value.obj.handlers)->write_property) {
        if (1 << 2 == 1) {
          tmp___7 = opline->op2.literal;
        } else {
          tmp___7 = (zend_literal *)((void *)0);
        }
        tmp___8 = (*((object->value.obj.handlers)->read_property))(object, property, 0, (struct _zend_literal  const  *)tmp___7);
        z = tmp___8;
        tmp___11 = __builtin_expect((long )((int )z->type == 5), 0L);
        if (tmp___11) {
          if ((z->value.obj.handlers)->get) {
            tmp___9 = (*((z->value.obj.handlers)->get))(z);
            value = tmp___9;
            tmp___10 = zval_refcount_p(z);
            if (tmp___10 == 0U) {
              if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                gc_remove_zval_from_buffer(z);
              } else {

              }
              _zval_dtor(z);
              while (1) {
                if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                  gc_remove_zval_from_buffer(z);
                } else {

                }
                _efree((void *)z);
                break;
              }
            } else {

            }
            z = value;
          } else {

          }
        } else {

        }
        while (1) {
          retval->value = z->value;
          retval->type = z->type;
          break;
        }
        _zval_copy_ctor(retval);
        while (1) {
          tmp___12 = _emalloc(sizeof(zval_gc_info ));
          z_copy = (zval *)tmp___12;
          ((zval_gc_info *)z_copy)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            z_copy->value = z->value;
            z_copy->type = z->type;
            break;
          }
          zval_set_refcount_p(z_copy, 1U);
          zval_unset_isref_p(z_copy);
          break;
        }
        _zval_copy_ctor(z_copy);
        (*incdec_op)(z_copy);
        zval_addref_p(z);
        if (1 << 2 == 1) {
          tmp___13 = opline->op2.literal;
        } else {
          tmp___13 = (zend_literal *)((void *)0);
        }
        (*((object->value.obj.handlers)->write_property))(object, property, z_copy, (struct _zend_literal  const  *)tmp___13);
        i_zval_ptr_dtor(z_copy);
        i_zval_ptr_dtor(z);
      } else {
        zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
        retval->type = (unsigned char)0;
      }
    } else {
      zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
      retval->type = (unsigned char)0;
    }
  } else {

  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_POST_INC_OBJ_SPEC_UNUSED_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_post_incdec_property_helper_SPEC_UNUSED_VAR((int (*)(zval * ))(& increment_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_POST_DEC_OBJ_SPEC_UNUSED_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_post_incdec_property_helper_SPEC_UNUSED_VAR((int (*)(zval * ))(& decrement_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) zend_fetch_property_address_read_helper_SPEC_UNUSED_VAR)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *container ;
  zend_free_op free_op2 ;
  zval *offset ;
  temp_variable *__t ;
  zval *retval ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_literal *tmp___0 ;
  temp_variable *__t___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  opline = execute_data->opline;
  container = _get_obj_zval_ptr_unused();
  offset = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___1 = __builtin_expect((long )((int )container->type != 5), 0L);
  if (tmp___1) {
    goto _L;
  } else {
    tmp___2 = __builtin_expect((long )((unsigned int )(container->value.obj.handlers)->read_property == (unsigned int )((void *)0)), 0L);
    if (tmp___2) {
      _L: /* CIL Label */ 
      zend_error(1 << 3L, "Trying to get property of non-object");
      zval_addref_p(& executor_globals.uninitialized_zval);
      while (1) {
        __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t->var.ptr = & executor_globals.uninitialized_zval;
        __t->var.ptr_ptr = & __t->var.ptr;
        break;
      }
      if (free_op2.var) {
        i_zval_ptr_dtor(free_op2.var);
      } else {

      }
    } else {
      if (1 << 2 == 1) {
        tmp___0 = opline->op2.literal;
      } else {
        tmp___0 = (zend_literal *)((void *)0);
      }
      retval = (*((container->value.obj.handlers)->read_property))(container, offset, 0, (struct _zend_literal  const  *)tmp___0);
      zval_addref_p(retval);
      while (1) {
        __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t___0->var.ptr = retval;
        __t___0->var.ptr_ptr = & __t___0->var.ptr;
        break;
      }
      if (free_op2.var) {
        i_zval_ptr_dtor(free_op2.var);
      } else {

      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_R_SPEC_UNUSED_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_property_address_read_helper_SPEC_UNUSED_VAR(execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_W_SPEC_UNUSED_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *property ;
  zval **container ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zend_literal *tmp___1 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_uint tmp___3 ;
  zend_bool tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint tmp___6 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___7 ;
  zval **retval_ptr ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___8 ;
  zend_uint tmp___9 ;
  zend_bool tmp___10 ;

  {
  opline = execute_data->opline;
  property = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if (1 << 3 == 1 << 2) {
    if (opline->extended_value & 134217728UL) {
      zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr));
      ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr = *(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr);
    } else {

    }
  } else {

  }
  container = _get_obj_zval_ptr_ptr_unused();
  if (1 << 3 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  if (1 << 2 == 1) {
    tmp___1 = opline->op2.literal;
  } else {
    tmp___1 = (zend_literal *)((void *)0);
  }
  zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)tmp___1, 1);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  if (1 << 3 == 1 << 2) {
    if (0) {
      tmp___6 = zval_refcount_p(free_op1.var);
      if (tmp___6 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___7 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___7 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___4 = zval_isref_p(__t->var.ptr);
                if (tmp___4) {

                } else {
                  tmp___5 = zval_refcount_p(__t->var.ptr);
                  if (tmp___5 > 2U) {
                    while (1) {
                      tmp___3 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___3 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___2 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___2;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  if (opline->extended_value & 67108864UL) {
    retval_ptr = ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr;
    zval_delref_p(*retval_ptr);
    tmp___10 = zval_isref_p(*retval_ptr);
    if (tmp___10) {

    } else {
      while (1) {
        tmp___9 = zval_refcount_p(*retval_ptr);
        if (tmp___9 > 1U) {
          zval_delref_p(*retval_ptr);
          while (1) {
            tmp___8 = _emalloc(sizeof(zval_gc_info ));
            new_zv___0 = (zval *)tmp___8;
            ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv___0->value = (*retval_ptr)->value;
              new_zv___0->type = (*retval_ptr)->type;
              break;
            }
            zval_set_refcount_p(new_zv___0, 1U);
            zval_unset_isref_p(new_zv___0);
            break;
          }
          *retval_ptr = new_zv___0;
          _zval_copy_ctor(new_zv___0);
        } else {

        }
        break;
      }
      zval_set_isref_p(*retval_ptr);
    }
    zval_addref_p(*retval_ptr);
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = *(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr);
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_RW_SPEC_UNUSED_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *property ;
  zval **container ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zend_literal *tmp___1 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_uint tmp___3 ;
  zend_bool tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint tmp___6 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___7 ;

  {
  opline = execute_data->opline;
  property = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  container = _get_obj_zval_ptr_ptr_unused();
  if (1 << 3 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  if (1 << 2 == 1) {
    tmp___1 = opline->op2.literal;
  } else {
    tmp___1 = (zend_literal *)((void *)0);
  }
  zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)tmp___1, 2);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  if (1 << 3 == 1 << 2) {
    if (0) {
      tmp___6 = zval_refcount_p(free_op1.var);
      if (tmp___6 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___7 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___7 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___4 = zval_isref_p(__t->var.ptr);
                if (tmp___4) {

                } else {
                  tmp___5 = zval_refcount_p(__t->var.ptr);
                  if (tmp___5 > 2U) {
                    while (1) {
                      tmp___3 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___3 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___2 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___2;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_IS_SPEC_UNUSED_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *container ;
  zend_free_op free_op2 ;
  zval *offset ;
  temp_variable *__t ;
  zval *retval ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_literal *tmp___0 ;
  temp_variable *__t___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  opline = execute_data->opline;
  container = _get_obj_zval_ptr_unused();
  offset = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___1 = __builtin_expect((long )((int )container->type != 5), 0L);
  if (tmp___1) {
    goto _L;
  } else {
    tmp___2 = __builtin_expect((long )((unsigned int )(container->value.obj.handlers)->read_property == (unsigned int )((void *)0)), 0L);
    if (tmp___2) {
      _L: /* CIL Label */ 
      zval_addref_p(& executor_globals.uninitialized_zval);
      while (1) {
        __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t->var.ptr = & executor_globals.uninitialized_zval;
        __t->var.ptr_ptr = & __t->var.ptr;
        break;
      }
      if (free_op2.var) {
        i_zval_ptr_dtor(free_op2.var);
      } else {

      }
    } else {
      if (1 << 2 == 1) {
        tmp___0 = opline->op2.literal;
      } else {
        tmp___0 = (zend_literal *)((void *)0);
      }
      retval = (*((container->value.obj.handlers)->read_property))(container, offset, 3, (struct _zend_literal  const  *)tmp___0);
      zval_addref_p(retval);
      while (1) {
        __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t___0->var.ptr = retval;
        __t___0->var.ptr_ptr = & __t___0->var.ptr;
        break;
      }
      if (free_op2.var) {
        i_zval_ptr_dtor(free_op2.var);
      } else {

      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *property ;
  zval **container ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zend_literal *tmp___1 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_uint tmp___3 ;
  zend_bool tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint tmp___6 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;

  {
  opline = execute_data->opline;
  if (execute_data->fbc) {
    if ((execute_data->fbc)->common.arg_info) {
      if ((opline->extended_value & 1048575UL) <= (unsigned long )(execute_data->fbc)->common.num_args) {
        tmp___9 = (unsigned int )((int )((execute_data->fbc)->common.arg_info + ((opline->extended_value & 1048575UL) - 1UL))->pass_by_reference & 3);
      } else {
        tmp___9 = (execute_data->fbc)->common.fn_flags & 50331648U;
      }
    } else {
      tmp___9 = (execute_data->fbc)->common.fn_flags & 50331648U;
    }
    if (tmp___9) {
      property = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
      container = _get_obj_zval_ptr_ptr_unused();
      if (1 << 3 == 1 << 2) {
        tmp___0 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
        if (tmp___0) {
          zend_error_noreturn(1, "Cannot use string offset as an object");
        } else {

        }
      } else {

      }
      if (1 << 2 == 1) {
        tmp___1 = opline->op2.literal;
      } else {
        tmp___1 = (zend_literal *)((void *)0);
      }
      zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)tmp___1, 1);
      if (free_op2.var) {
        i_zval_ptr_dtor(free_op2.var);
      } else {

      }
      if (1 << 3 == 1 << 2) {
        if (0) {
          tmp___6 = zval_refcount_p(free_op1.var);
          if (tmp___6 == 1U) {
            if ((int )(free_op1.var)->type != 5) {
              goto _L;
            } else {
              tmp___7 = zend_objects_store_get_refcount(free_op1.var);
              if (tmp___7 == (zend_uint __attribute__((__visibility__("default")))  )1) {
                _L: /* CIL Label */ 
                while (1) {
                  __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
                  if (__t->var.ptr_ptr) {
                    __t->var.ptr = *(__t->var.ptr_ptr);
                    __t->var.ptr_ptr = & __t->var.ptr;
                    tmp___4 = zval_isref_p(__t->var.ptr);
                    if (tmp___4) {

                    } else {
                      tmp___5 = zval_refcount_p(__t->var.ptr);
                      if (tmp___5 > 2U) {
                        while (1) {
                          tmp___3 = zval_refcount_p(*(__t->var.ptr_ptr));
                          if (tmp___3 > 1U) {
                            zval_delref_p(*(__t->var.ptr_ptr));
                            while (1) {
                              tmp___2 = _emalloc(sizeof(zval_gc_info ));
                              new_zv = (zval *)tmp___2;
                              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                              break;
                            }
                            while (1) {
                              while (1) {
                                new_zv->value = (*(__t->var.ptr_ptr))->value;
                                new_zv->type = (*(__t->var.ptr_ptr))->type;
                                break;
                              }
                              zval_set_refcount_p(new_zv, 1U);
                              zval_unset_isref_p(new_zv);
                              break;
                            }
                            *(__t->var.ptr_ptr) = new_zv;
                            _zval_copy_ctor(new_zv);
                          } else {

                          }
                          break;
                        }
                      } else {

                      }
                    }
                  } else {

                  }
                  break;
                }
              } else {

              }
            }
          } else {

          }
        } else {

        }
      } else {

      }
      (execute_data->opline) ++;
      return (0);
    } else {
      tmp___8 = zend_fetch_property_address_read_helper_SPEC_UNUSED_VAR(execute_data);
      return (tmp___8);
    }
  } else {
    tmp___8 = zend_fetch_property_address_read_helper_SPEC_UNUSED_VAR(execute_data);
    return (tmp___8);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zend_free_op free_res ;
  zval **container ;
  zval *property ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  long tmp___3 ;
  zend_literal *tmp___4 ;
  temp_variable *__t ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  zend_uint tmp___6 ;
  zend_bool tmp___7 ;
  zend_uint tmp___8 ;
  zend_uint tmp___9 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___10 ;
  zval *new_zv___1 ;
  void __attribute__((__visibility__("default")))  *tmp___11 ;
  zend_uint tmp___12 ;
  zend_bool tmp___13 ;

  {
  opline = execute_data->opline;
  container = _get_obj_zval_ptr_ptr_unused();
  property = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if (1 << 3 == 1 << 4) {
    if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
      tmp___1 = zval_isref_p(*container);
      if (tmp___1) {

      } else {
        while (1) {
          tmp___0 = zval_refcount_p(*container);
          if (tmp___0 > 1U) {
            zval_delref_p(*container);
            while (1) {
              tmp = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*container)->value;
                new_zv->type = (*container)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *container = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
    } else {

    }
  } else {

  }
  if (1 << 3 == 1 << 2) {
    tmp___3 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___3) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  if (1 << 2 == 1) {
    tmp___4 = opline->op2.literal;
  } else {
    tmp___4 = (zend_literal *)((void *)0);
  }
  zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)tmp___4, 6);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  if (1 << 3 == 1 << 2) {
    if (0) {
      tmp___9 = zval_refcount_p(free_op1.var);
      if (tmp___9 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___10 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___10 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___7 = zval_isref_p(__t->var.ptr);
                if (tmp___7) {

                } else {
                  tmp___8 = zval_refcount_p(__t->var.ptr);
                  if (tmp___8 > 2U) {
                    while (1) {
                      tmp___6 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___6 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___5 = _emalloc(sizeof(zval_gc_info ));
                          new_zv___0 = (zval *)tmp___5;
                          ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv___0->value = (*(__t->var.ptr_ptr))->value;
                            new_zv___0->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv___0, 1U);
                          zval_unset_isref_p(new_zv___0);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv___0;
                        _zval_copy_ctor(new_zv___0);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  zend_pzval_unlock_func(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr), & free_res, 1);
  if ((unsigned int )((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
    tmp___13 = zval_isref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
    if (tmp___13) {

    } else {
      while (1) {
        tmp___12 = zval_refcount_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
        if (tmp___12 > 1U) {
          zval_delref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
          while (1) {
            tmp___11 = _emalloc(sizeof(zval_gc_info ));
            new_zv___1 = (zval *)tmp___11;
            ((zval_gc_info *)new_zv___1)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv___1->value = (*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr))->value;
              new_zv___1->type = (*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr))->type;
              break;
            }
            zval_set_refcount_p(new_zv___1, 1U);
            zval_unset_isref_p(new_zv___1);
            break;
          }
          *(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr) = new_zv___1;
          _zval_copy_ctor(new_zv___1);
        } else {

        }
        break;
      }
    }
  } else {

  }
  zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
  if (free_res.var) {
    i_zval_ptr_dtor(free_res.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_OBJ_SPEC_UNUSED_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval **object_ptr ;
  zval *property_name ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zend_literal *tmp___1 ;
  zval **tmp___2 ;

  {
  opline = execute_data->opline;
  object_ptr = _get_obj_zval_ptr_ptr_unused();
  property_name = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if (1 << 3 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  if (1 << 2 == 1) {
    tmp___1 = opline->op2.literal;
  } else {
    tmp___1 = (zend_literal *)((void *)0);
  }
  if (! ((int )opline->result_type & (1 << 5))) {
    tmp___2 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
  } else {
    tmp___2 = (zval **)((void *)0);
  }
  zend_assign_to_object(tmp___2, object_ptr, property_name, (int )(opline + 1)->op1_type, & (opline + 1)->op1, (temp_variable const   *)execute_data->Ts, 136, (zend_literal const   *)tmp___1);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_VAR_SPEC_UNUSED_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *str ;
  zval *var ;
  zval var_copy ;
  int use_copy ;

  {
  opline = execute_data->opline;
  str = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  use_copy = 0;
  var = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if (1 << 3 == 1 << 3) {
    str->value.str.val = (char *)((void *)0);
    str->value.str.len = 0;
    str->type = (unsigned char)6;
    str->refcount__gc = 1U;
    str->is_ref__gc = (unsigned char)0;
  } else {

  }
  if ((int )var->type != 6) {
    zend_make_printable_zval(var, & var_copy, & use_copy);
    if (use_copy) {
      var = & var_copy;
    } else {

    }
  } else {

  }
  add_string_to_string(str, (zval const   *)str, (zval const   *)var);
  if (use_copy) {
    _zval_dtor(var);
  } else {

  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_METHOD_CALL_SPEC_UNUSED_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *function_name ;
  char *function_name_strval ;
  int function_name_strlen ;
  zend_free_op free_op2 ;
  long tmp ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  zval *object ;
  long tmp___1 ;
  zend_literal *tmp___2 ;
  zend_class_entry *tmp___3 ;
  zend_class_entry *tmp___4 ;
  char const   *tmp___5 ;
  zend_class_entry *tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  zend_function *tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  zval *this_ptr ;
  void __attribute__((__visibility__("default")))  *tmp___13 ;
  zend_bool tmp___14 ;

  {
  opline = execute_data->opline;
  zend_ptr_stack_3_push(& executor_globals.arg_types_stack, (void *)execute_data->fbc, (void *)execute_data->object, (void *)execute_data->called_scope);
  function_name = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if (1 << 2 != 1) {
    tmp = __builtin_expect((long )((int )function_name->type != 6), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Method name must be a string");
    } else {

    }
  } else {

  }
  function_name_strval = function_name->value.str.val;
  function_name_strlen = function_name->value.str.len;
  execute_data->object = _get_obj_zval_ptr_unused();
  tmp___11 = __builtin_expect((long )((unsigned int )execute_data->object != (unsigned int )((void *)0)), 1L);
  if (tmp___11) {
    tmp___12 = __builtin_expect((long )((int )(execute_data->object)->type == 5), 1L);
    if (tmp___12) {
      tmp___0 = zend_get_class_entry((zval const   *)execute_data->object);
      execute_data->called_scope = (zend_class_entry *)tmp___0;
      if (1 << 2 != 1) {
        goto _L;
      } else {
        if ((unsigned int )*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) == (unsigned int )execute_data->called_scope) {
          tmp___10 = (zend_function *)*((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U));
        } else {
          tmp___10 = (zend_function *)((void *)0);
        }
        execute_data->fbc = tmp___10;
        if ((unsigned int )tmp___10 == (unsigned int )((void *)0)) {
          _L: /* CIL Label */ 
          object = execute_data->object;
          tmp___1 = __builtin_expect((long )((unsigned int )((execute_data->object)->value.obj.handlers)->get_method == (unsigned int )((void *)0)), 0L);
          if (tmp___1) {
            zend_error_noreturn(1, "Object does not support method calls");
          } else {

          }
          if (1 << 2 == 1) {
            tmp___2 = opline->op2.literal + 1;
          } else {
            tmp___2 = (zend_literal *)((void *)0);
          }
          execute_data->fbc = (*(((execute_data->object)->value.obj.handlers)->get_method))(& execute_data->object, function_name_strval, function_name_strlen, (struct _zend_literal  const  *)tmp___2);
          tmp___7 = __builtin_expect((long )((unsigned int )execute_data->fbc == (unsigned int )((void *)0)), 0L);
          if (tmp___7) {
            if (execute_data->object) {
              if ((int )(execute_data->object)->type == 5) {
                if ((unsigned int )((execute_data->object)->value.obj.handlers)->get_class_entry != (unsigned int )((void *)0)) {
                  tmp___6 = (*(((execute_data->object)->value.obj.handlers)->get_class_entry))((zval const   *)execute_data->object);
                  if (tmp___6) {
                    tmp___4 = (*(((execute_data->object)->value.obj.handlers)->get_class_entry))((zval const   *)execute_data->object);
                    tmp___5 = tmp___4->name;
                  } else {
                    tmp___5 = "";
                  }
                } else {
                  tmp___5 = "";
                }
              } else {
                tmp___5 = "";
              }
            } else {
              tmp___5 = "";
            }
            zend_error_noreturn(1, "Call to undefined method %s::%s()", tmp___5, function_name_strval);
          } else {

          }
          if (1 << 2 == 1) {
            tmp___8 = __builtin_expect((long )(((execute_data->fbc)->common.fn_flags & 6291456U) == 0U), 1L);
            if (tmp___8) {
              tmp___9 = __builtin_expect((long )((unsigned int )execute_data->object == (unsigned int )object), 1L);
              if (tmp___9) {
                while (1) {
                  *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)execute_data->called_scope;
                  *((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U)) = (void *)execute_data->fbc;
                  break;
                }
              } else {

              }
            } else {

            }
          } else {

          }
        } else {

        }
      }
    } else {
      zend_error_noreturn(1, "Call to a member function %s() on a non-object", function_name_strval);
    }
  } else {
    zend_error_noreturn(1, "Call to a member function %s() on a non-object", function_name_strval);
  }
  if (((execute_data->fbc)->common.fn_flags & 1U) != 0U) {
    execute_data->object = (zval *)((void *)0);
  } else {
    tmp___14 = zval_isref_p(execute_data->object);
    if (tmp___14) {
      while (1) {
        tmp___13 = _emalloc(sizeof(zval_gc_info ));
        this_ptr = (zval *)tmp___13;
        ((zval_gc_info *)this_ptr)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      while (1) {
        while (1) {
          this_ptr->value = (execute_data->object)->value;
          this_ptr->type = (execute_data->object)->type;
          break;
        }
        zval_set_refcount_p(this_ptr, 1U);
        zval_unset_isref_p(this_ptr);
        break;
      }
      _zval_copy_ctor(this_ptr);
      execute_data->object = this_ptr;
    } else {
      zval_addref_p(execute_data->object);
    }
  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_ARRAY_SPEC_UNUSED_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;

  {
  opline = execute_data->opline;
  _array_init(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, 0U);
  if (1 << 3 == 1 << 3) {
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_UNSET_DIM_SPEC_UNUSED_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval **container ;
  zval *offset ;
  ulong hval ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  HashTable *ht ;
  long tmp___2 ;
  register char const   *tmp___3 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___4 ;
  long tmp___5 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;

  {
  opline = execute_data->opline;
  container = _get_obj_zval_ptr_ptr_unused();
  if (1 << 3 == 1 << 4) {
    if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
      tmp___1 = zval_isref_p(*container);
      if (tmp___1) {

      } else {
        while (1) {
          tmp___0 = zval_refcount_p(*container);
          if (tmp___0 > 1U) {
            zval_delref_p(*container);
            while (1) {
              tmp = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*container)->value;
                new_zv->type = (*container)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *container = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
    } else {

    }
  } else {

  }
  offset = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if (1 << 3 != 1 << 2) {
    goto _L___0;
  } else {
    if (container) {
      _L___0: /* CIL Label */ 
      switch ((int )(*container)->type) {
      case 4: 
      ht = (*container)->value.ht;
      switch ((int )offset->type) {
      case 2: 
      tmp___2 = zend_dval_to_lval(offset->value.dval);
      hval = (unsigned long )tmp___2;
      goto num_index_dim;
      case 7: 
      case 3: 
      case 1: 
      hval = (unsigned long )offset->value.lval;
      zend_hash_del_key_or_index(ht, (char const   *)((void *)0), 0U, hval, 1);
      break;
      case 6: 
      if (1 << 2 == 1 << 4) {
        zval_addref_p(offset);
      } else {
        if (1 << 2 == 1 << 2) {
          zval_addref_p(offset);
        } else {

        }
      }
      if (1 << 2 == 1) {
        hval = ((zend_literal *)offset)->hash_value;
      } else {
        while (1) {
          tmp___3 = (char const   *)offset->value.str.val;
          if ((int const   )*tmp___3 == 45) {
            tmp___3 ++;
          } else {

          }
          if ((int const   )*tmp___3 >= 48) {
            if ((int const   )*tmp___3 <= 57) {
              end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
              if ((int const   )*end != 0) {
                break;
              } else {
                if ((int const   )*tmp___3 == 48) {
                  if (offset->value.str.len + 1 > 2) {
                    break;
                  } else {
                    goto _L;
                  }
                } else {
                  _L: /* CIL Label */ 
                  if (end - tmp___3 > 10) {
                    break;
                  } else {
                    if (end - tmp___3 == 10) {
                      if ((int const   )*tmp___3 > 50) {
                        break;
                      } else {

                      }
                    } else {

                    }
                  }
                }
              }
              hval = (unsigned long )((int const   )*tmp___3 - 48);
              while (1) {
                tmp___3 ++;
                if ((unsigned int )tmp___3 != (unsigned int )end) {
                  if ((int const   )*tmp___3 >= 48) {
                    if ((int const   )*tmp___3 <= 57) {

                    } else {
                      break;
                    }
                  } else {
                    break;
                  }
                } else {
                  break;
                }
                hval = hval * 10UL + (ulong )((int const   )*tmp___3 - 48);
              }
              if ((unsigned int )tmp___3 == (unsigned int )end) {
                if ((int )*(offset->value.str.val) == 45) {
                  if (hval - 1UL > 2147483647UL) {
                    break;
                  } else {

                  }
                  hval = (unsigned long )(- ((long )hval));
                } else {
                  if (hval > 2147483647UL) {
                    break;
                  } else {

                  }
                }
                goto num_index_dim;
              } else {

              }
            } else {

            }
          } else {

          }
          break;
        }
        if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
          if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
            hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
          } else {
            tmp___4 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
            hval = (unsigned long )tmp___4;
          }
        } else {
          tmp___4 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___4;
        }
      }
      if ((unsigned int )ht == (unsigned int )(& executor_globals.symbol_table)) {
        zend_delete_global_variable_ex((char const   *)offset->value.str.val, offset->value.str.len, hval);
      } else {
        zend_hash_del_key_or_index(ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, 2);
      }
      if (1 << 2 == 1 << 4) {
        i_zval_ptr_dtor(offset);
      } else {
        if (1 << 2 == 1 << 2) {
          i_zval_ptr_dtor(offset);
        } else {

        }
      }
      break;
      num_index_dim: 
      zend_hash_del_key_or_index(ht, (char const   *)((void *)0), 0U, hval, 1);
      if (1 << 2 == 1 << 4) {
        i_zval_ptr_dtor(offset);
      } else {
        if (1 << 2 == 1 << 2) {
          i_zval_ptr_dtor(offset);
        } else {

        }
      }
      break;
      case 0: 
      zend_hash_del_key_or_index(ht, "", sizeof(""), 0UL, 0);
      break;
      default: 
      zend_error(1 << 1L, "Illegal offset type in unset");
      break;
      }
      if (free_op2.var) {
        i_zval_ptr_dtor(free_op2.var);
      } else {

      }
      break;
      case 5: 
      tmp___5 = __builtin_expect((long )((unsigned int )((*container)->value.obj.handlers)->unset_dimension == (unsigned int )((void *)0)), 0L);
      if (tmp___5) {
        zend_error_noreturn(1, "Cannot use object as array");
      } else {

      }
      (*(((*container)->value.obj.handlers)->unset_dimension))(*container, offset);
      if (free_op2.var) {
        i_zval_ptr_dtor(free_op2.var);
      } else {

      }
      break;
      case 6: 
      zend_error_noreturn(1, "Cannot unset string offsets");
      return (0);
      default: ;
      if (free_op2.var) {
        i_zval_ptr_dtor(free_op2.var);
      } else {

      }
      break;
      }
    } else {
      if (free_op2.var) {
        i_zval_ptr_dtor(free_op2.var);
      } else {

      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_UNSET_OBJ_SPEC_UNUSED_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval **container ;
  zval *offset ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_literal *tmp___3 ;

  {
  opline = execute_data->opline;
  container = _get_obj_zval_ptr_ptr_unused();
  offset = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if (1 << 3 != 1 << 2) {
    goto _L;
  } else {
    if (container) {
      _L: /* CIL Label */ 
      if (1 << 3 == 1 << 4) {
        if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
          tmp___1 = zval_isref_p(*container);
          if (tmp___1) {

          } else {
            while (1) {
              tmp___0 = zval_refcount_p(*container);
              if (tmp___0 > 1U) {
                zval_delref_p(*container);
                while (1) {
                  tmp = _emalloc(sizeof(zval_gc_info ));
                  new_zv = (zval *)tmp;
                  ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                  break;
                }
                while (1) {
                  while (1) {
                    new_zv->value = (*container)->value;
                    new_zv->type = (*container)->type;
                    break;
                  }
                  zval_set_refcount_p(new_zv, 1U);
                  zval_unset_isref_p(new_zv);
                  break;
                }
                *container = new_zv;
                _zval_copy_ctor(new_zv);
              } else {

              }
              break;
            }
          }
        } else {

        }
      } else {

      }
      if ((int )(*container)->type == 5) {
        if (((*container)->value.obj.handlers)->unset_property) {
          if (1 << 2 == 1) {
            tmp___3 = opline->op2.literal;
          } else {
            tmp___3 = (zend_literal *)((void *)0);
          }
          (*(((*container)->value.obj.handlers)->unset_property))(*container, offset, (struct _zend_literal  const  *)tmp___3);
        } else {
          zend_error(1 << 3L, "Trying to unset property of non-object");
        }
        if (free_op2.var) {
          i_zval_ptr_dtor(free_op2.var);
        } else {

        }
      } else {
        if (free_op2.var) {
          i_zval_ptr_dtor(free_op2.var);
        } else {

        }
      }
    } else {
      if (free_op2.var) {
        i_zval_ptr_dtor(free_op2.var);
      } else {

      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_VAR)(int prop_dim , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval **container ;
  zval **value ;
  int result ;
  ulong hval ;
  zval *offset ;
  HashTable *ht ;
  int isset ;
  long tmp ;
  int __attribute__((__visibility__("default")))  tmp___0 ;
  register char const   *tmp___1 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___2 ;
  int __attribute__((__visibility__("default")))  tmp___3 ;
  int __attribute__((__visibility__("default")))  tmp___4 ;
  int tmp___5 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;
  zend_literal *tmp___7 ;
  zval tmp___8 ;

  {
  opline = execute_data->opline;
  value = (zval **)((void *)0);
  result = 0;
  container = _get_obj_zval_ptr_ptr_unused();
  offset = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if ((int )(*container)->type == 4) {
    if (! prop_dim) {
      isset = 0;
      ht = (*container)->value.ht;
      switch ((int )offset->type) {
      case 2: 
      tmp = zend_dval_to_lval(offset->value.dval);
      hval = (unsigned long )tmp;
      goto num_index_prop;
      case 7: 
      case 3: 
      case 1: 
      hval = (unsigned long )offset->value.lval;
      num_index_prop: 
      tmp___0 = zend_hash_index_find((HashTable const   *)ht, hval, (void **)(& value));
      if (tmp___0 == (int __attribute__((__visibility__("default")))  )0) {
        isset = 1;
      } else {

      }
      break;
      case 6: 
      if (1 << 2 == 1) {
        hval = ((zend_literal *)offset)->hash_value;
      } else {
        if (! prop_dim) {
          while (1) {
            tmp___1 = (char const   *)offset->value.str.val;
            if ((int const   )*tmp___1 == 45) {
              tmp___1 ++;
            } else {

            }
            if ((int const   )*tmp___1 >= 48) {
              if ((int const   )*tmp___1 <= 57) {
                end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
                if ((int const   )*end != 0) {
                  break;
                } else {
                  if ((int const   )*tmp___1 == 48) {
                    if (offset->value.str.len + 1 > 2) {
                      break;
                    } else {
                      goto _L;
                    }
                  } else {
                    _L: /* CIL Label */ 
                    if (end - tmp___1 > 10) {
                      break;
                    } else {
                      if (end - tmp___1 == 10) {
                        if ((int const   )*tmp___1 > 50) {
                          break;
                        } else {

                        }
                      } else {

                      }
                    }
                  }
                }
                hval = (unsigned long )((int const   )*tmp___1 - 48);
                while (1) {
                  tmp___1 ++;
                  if ((unsigned int )tmp___1 != (unsigned int )end) {
                    if ((int const   )*tmp___1 >= 48) {
                      if ((int const   )*tmp___1 <= 57) {

                      } else {
                        break;
                      }
                    } else {
                      break;
                    }
                  } else {
                    break;
                  }
                  hval = hval * 10UL + (ulong )((int const   )*tmp___1 - 48);
                }
                if ((unsigned int )tmp___1 == (unsigned int )end) {
                  if ((int )*(offset->value.str.val) == 45) {
                    if (hval - 1UL > 2147483647UL) {
                      break;
                    } else {

                    }
                    hval = (unsigned long )(- ((long )hval));
                  } else {
                    if (hval > 2147483647UL) {
                      break;
                    } else {

                    }
                  }
                  goto num_index_prop;
                } else {

                }
              } else {

              }
            } else {

            }
            break;
          }
        } else {

        }
        if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
          if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
            hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
          } else {
            tmp___2 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
            hval = (unsigned long )tmp___2;
          }
        } else {
          tmp___2 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___2;
        }
      }
      tmp___3 = zend_hash_quick_find((HashTable const   *)ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, (void **)(& value));
      if (tmp___3 == (int __attribute__((__visibility__("default")))  )0) {
        isset = 1;
      } else {

      }
      break;
      case 0: 
      tmp___4 = zend_hash_find((HashTable const   *)ht, "", sizeof(""), (void **)(& value));
      if (tmp___4 == (int __attribute__((__visibility__("default")))  )0) {
        isset = 1;
      } else {

      }
      break;
      default: 
      zend_error(1 << 1L, "Illegal offset type in isset or empty");
      break;
      }
      if (opline->extended_value & 33554432UL) {
        if (isset) {
          if ((int )(*value)->type == 0) {
            result = 0;
          } else {
            result = isset;
          }
        } else {
          result = isset;
        }
      } else {
        if (! isset) {
          result = 0;
        } else {
          tmp___5 = i_zend_is_true(*value);
          if (tmp___5) {
            result = 1;
          } else {
            result = 0;
          }
        }
      }
      if (free_op2.var) {
        i_zval_ptr_dtor(free_op2.var);
      } else {

      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    if ((int )(*container)->type == 5) {
      if (prop_dim) {
        if (((*container)->value.obj.handlers)->has_property) {
          if (1 << 2 == 1) {
            tmp___7 = opline->op2.literal;
          } else {
            tmp___7 = (zend_literal *)((void *)0);
          }
          result = (*(((*container)->value.obj.handlers)->has_property))(*container, offset, (opline->extended_value & 16777216UL) != 0UL, (struct _zend_literal  const  *)tmp___7);
        } else {
          zend_error(1 << 3L, "Trying to check property of non-object");
          result = 0;
        }
      } else {
        if (((*container)->value.obj.handlers)->has_dimension) {
          result = (*(((*container)->value.obj.handlers)->has_dimension))(*container, offset, (opline->extended_value & 16777216UL) != 0UL);
        } else {
          zend_error(1 << 3L, "Trying to check element of non-array");
          result = 0;
        }
      }
      if (free_op2.var) {
        i_zval_ptr_dtor(free_op2.var);
      } else {

      }
    } else {
      if ((int )(*container)->type == 6) {
        if (! prop_dim) {
          if ((int )offset->type != 1) {
            while (1) {
              tmp___8.value = offset->value;
              tmp___8.type = offset->type;
              break;
            }
            _zval_copy_ctor(& tmp___8);
            convert_to_long(& tmp___8);
            offset = & tmp___8;
          } else {

          }
          if ((int )offset->type == 1) {
            if (opline->extended_value & 33554432UL) {
              if (offset->value.lval >= 0L) {
                if (offset->value.lval < (long )(*container)->value.str.len) {
                  result = 1;
                } else {

                }
              } else {

              }
            } else {
              if (offset->value.lval >= 0L) {
                if (offset->value.lval < (long )(*container)->value.str.len) {
                  if ((int )*((*container)->value.str.val + offset->value.lval) != 48) {
                    result = 1;
                  } else {

                  }
                } else {

                }
              } else {

              }
            }
          } else {

          }
          if (free_op2.var) {
            i_zval_ptr_dtor(free_op2.var);
          } else {

          }
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        if (free_op2.var) {
          i_zval_ptr_dtor(free_op2.var);
        } else {

        }
      }
    }
  }
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.type = (unsigned char)3;
  if (opline->extended_value & 33554432UL) {
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.lval = (long )result;
  } else {
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.lval = (long )(! result);
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_VAR(0, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_VAR(1, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) zend_binary_assign_op_obj_helper_SPEC_UNUSED_UNUSED)(int (*binary_op)(zval *result , zval *op1 , zval *op2 ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op_data1 ;
  zval **object_ptr ;
  zval **tmp ;
  zval *object ;
  zval *property ;
  zval *value ;
  zval *tmp___0 ;
  int have_get_ptr ;
  long tmp___1 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zval **zptr ;
  zend_literal *tmp___3 ;
  zval **tmp___4 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  zend_uint tmp___6 ;
  zend_bool tmp___7 ;
  zval *z ;
  zend_literal *tmp___8 ;
  zval *value___0 ;
  zval *tmp___9 ;
  zend_uint tmp___10 ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___11 ;
  zend_uint tmp___12 ;
  zend_bool tmp___13 ;
  zend_literal *tmp___14 ;
  long tmp___15 ;

  {
  opline = execute_data->opline;
  tmp = _get_obj_zval_ptr_ptr_unused();
  object_ptr = tmp;
  property = (zval *)((void *)0);
  tmp___0 = _get_zval_ptr((int )(opline + 1)->op1_type, (znode_op const   *)(& (opline + 1)->op1), (temp_variable const   *)execute_data->Ts, & free_op_data1, 0);
  value = tmp___0;
  have_get_ptr = 0;
  if (1 << 3 == 1 << 2) {
    tmp___1 = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___1) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  make_real_object(object_ptr);
  object = *object_ptr;
  tmp___15 = __builtin_expect((long )((int )object->type != 5), 0L);
  if (tmp___15) {
    zend_error(1 << 1L, "Attempt to assign property of non-object");
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = & executor_globals.uninitialized_zval;
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
    } else {

    }
  } else {
    if (opline->extended_value == 136UL) {
      if ((object->value.obj.handlers)->get_property_ptr_ptr) {
        if (1 << 3 == 1) {
          tmp___3 = opline->op2.literal;
        } else {
          tmp___3 = (zend_literal *)((void *)0);
        }
        tmp___4 = (*((object->value.obj.handlers)->get_property_ptr_ptr))(object, property, (struct _zend_literal  const  *)tmp___3);
        zptr = tmp___4;
        if ((unsigned int )zptr != (unsigned int )((void *)0)) {
          tmp___7 = zval_isref_p(*zptr);
          if (tmp___7) {

          } else {
            while (1) {
              tmp___6 = zval_refcount_p(*zptr);
              if (tmp___6 > 1U) {
                zval_delref_p(*zptr);
                while (1) {
                  tmp___5 = _emalloc(sizeof(zval_gc_info ));
                  new_zv = (zval *)tmp___5;
                  ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                  break;
                }
                while (1) {
                  while (1) {
                    new_zv->value = (*zptr)->value;
                    new_zv->type = (*zptr)->type;
                    break;
                  }
                  zval_set_refcount_p(new_zv, 1U);
                  zval_unset_isref_p(new_zv);
                  break;
                }
                *zptr = new_zv;
                _zval_copy_ctor(new_zv);
              } else {

              }
              break;
            }
          }
          have_get_ptr = 1;
          (*binary_op)(*zptr, *zptr, value);
          if (! ((int )opline->result_type & (1 << 5))) {
            zval_addref_p(*zptr);
            ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = *zptr;
            ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
          } else {

          }
        } else {

        }
      } else {

      }
    } else {

    }
    if (! have_get_ptr) {
      z = (zval *)((void *)0);
      if (opline->extended_value == 136UL) {
        if ((object->value.obj.handlers)->read_property) {
          if (1 << 3 == 1) {
            tmp___8 = opline->op2.literal;
          } else {
            tmp___8 = (zend_literal *)((void *)0);
          }
          z = (*((object->value.obj.handlers)->read_property))(object, property, 0, (struct _zend_literal  const  *)tmp___8);
        } else {

        }
      } else {
        if ((object->value.obj.handlers)->read_dimension) {
          z = (*((object->value.obj.handlers)->read_dimension))(object, property, 0);
        } else {

        }
      }
      if (z) {
        if ((int )z->type == 5) {
          if ((z->value.obj.handlers)->get) {
            tmp___9 = (*((z->value.obj.handlers)->get))(z);
            value___0 = tmp___9;
            tmp___10 = zval_refcount_p(z);
            if (tmp___10 == 0U) {
              if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                gc_remove_zval_from_buffer(z);
              } else {

              }
              _zval_dtor(z);
              while (1) {
                if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                  gc_remove_zval_from_buffer(z);
                } else {

                }
                _efree((void *)z);
                break;
              }
            } else {

            }
            z = value___0;
          } else {

          }
        } else {

        }
        zval_addref_p(z);
        tmp___13 = zval_isref_p(z);
        if (tmp___13) {

        } else {
          while (1) {
            tmp___12 = zval_refcount_p(z);
            if (tmp___12 > 1U) {
              zval_delref_p(z);
              while (1) {
                tmp___11 = _emalloc(sizeof(zval_gc_info ));
                new_zv___0 = (zval *)tmp___11;
                ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv___0->value = z->value;
                  new_zv___0->type = z->type;
                  break;
                }
                zval_set_refcount_p(new_zv___0, 1U);
                zval_unset_isref_p(new_zv___0);
                break;
              }
              z = new_zv___0;
              _zval_copy_ctor(new_zv___0);
            } else {

            }
            break;
          }
        }
        (*binary_op)(z, z, value);
        if (opline->extended_value == 136UL) {
          if (1 << 3 == 1) {
            tmp___14 = opline->op2.literal;
          } else {
            tmp___14 = (zend_literal *)((void *)0);
          }
          (*((object->value.obj.handlers)->write_property))(object, property, z, (struct _zend_literal  const  *)tmp___14);
        } else {
          (*((object->value.obj.handlers)->write_dimension))(object, property, z);
        }
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(z);
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = z;
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
        } else {

        }
        i_zval_ptr_dtor(z);
      } else {
        zend_error(1 << 1L, "Attempt to assign property of non-object");
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = & executor_globals.uninitialized_zval;
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
        } else {

        }
      }
    } else {

    }
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
  }
  (execute_data->opline) ++;
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED)(int (*binary_op)(zval *result , zval *op1 , zval *op2 ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op_data2 ;
  zend_free_op free_op_data1 ;
  zval **var_ptr ;
  zval *value ;
  int tmp ;
  zval **container ;
  zval **tmp___0 ;
  int tmp___1 ;
  zval *dim ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  temp_variable *__t ;
  long tmp___5 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;
  zend_uint tmp___7 ;
  zend_bool tmp___8 ;
  zval *objval ;
  zval *tmp___9 ;
  long tmp___10 ;
  temp_variable *__t___0 ;

  {
  opline = execute_data->opline;
  switch ((int )opline->extended_value) {
  case 136: 
  tmp = zend_binary_assign_op_obj_helper_SPEC_UNUSED_UNUSED(binary_op, execute_data);
  return (tmp);
  break;
  case 147: 
  tmp___0 = _get_obj_zval_ptr_ptr_unused();
  container = tmp___0;
  if (1 << 3 == 1 << 2) {
    tmp___3 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___3) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    tmp___2 = __builtin_expect((long )((int )(*container)->type == 5), 0L);
    if (tmp___2) {
      if (1 << 3 == 1 << 2) {
        zval_addref_p(*container);
      } else {

      }
      tmp___1 = zend_binary_assign_op_obj_helper_SPEC_UNUSED_UNUSED(binary_op, execute_data);
      return (tmp___1);
    } else {
      dim = (zval *)((void *)0);
      zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var), container, dim, 1 << 3, 2);
      value = _get_zval_ptr((int )(opline + 1)->op1_type, (znode_op const   *)(& (opline + 1)->op1), (temp_variable const   *)execute_data->Ts, & free_op_data1, 0);
      var_ptr = _get_zval_ptr_ptr_var((opline + 1)->op2.var, (temp_variable const   *)execute_data->Ts, & free_op_data2);
    }
  }
  break;
  default: 
  value = (zval *)((void *)0);
  var_ptr = (zval **)((void *)0);
  break;
  }
  tmp___4 = __builtin_expect((long )((unsigned int )var_ptr == (unsigned int )((void *)0)), 0L);
  if (tmp___4) {
    zend_error_noreturn(1, "Cannot use assign-op operators with overloaded objects nor string offsets");
  } else {

  }
  tmp___5 = __builtin_expect((long )((unsigned int )*var_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
  if (tmp___5) {
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      while (1) {
        __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t->var.ptr = & executor_globals.uninitialized_zval;
        __t->var.ptr_ptr = & __t->var.ptr;
        break;
      }
    } else {

    }
    if (opline->extended_value == 147UL) {
      (execute_data->opline) ++;
    } else {

    }
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  tmp___8 = zval_isref_p(*var_ptr);
  if (tmp___8) {

  } else {
    while (1) {
      tmp___7 = zval_refcount_p(*var_ptr);
      if (tmp___7 > 1U) {
        zval_delref_p(*var_ptr);
        while (1) {
          tmp___6 = _emalloc(sizeof(zval_gc_info ));
          new_zv = (zval *)tmp___6;
          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            new_zv->value = (*var_ptr)->value;
            new_zv->type = (*var_ptr)->type;
            break;
          }
          zval_set_refcount_p(new_zv, 1U);
          zval_unset_isref_p(new_zv);
          break;
        }
        *var_ptr = new_zv;
        _zval_copy_ctor(new_zv);
      } else {

      }
      break;
    }
  }
  tmp___10 = __builtin_expect((long )((int )(*var_ptr)->type == 5), 0L);
  if (tmp___10) {
    if (((*var_ptr)->value.obj.handlers)->get) {
      if (((*var_ptr)->value.obj.handlers)->set) {
        tmp___9 = (*(((*var_ptr)->value.obj.handlers)->get))(*var_ptr);
        objval = tmp___9;
        zval_addref_p(objval);
        (*binary_op)(objval, objval, value);
        (*(((*var_ptr)->value.obj.handlers)->set))(var_ptr, objval);
        i_zval_ptr_dtor(objval);
      } else {
        (*binary_op)(*var_ptr, *var_ptr, value);
      }
    } else {
      (*binary_op)(*var_ptr, *var_ptr, value);
    }
  } else {
    (*binary_op)(*var_ptr, *var_ptr, value);
  }
  if (! ((int )opline->result_type & (1 << 5))) {
    zval_addref_p(*var_ptr);
    while (1) {
      __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
      __t___0->var.ptr = *var_ptr;
      __t___0->var.ptr_ptr = & __t___0->var.ptr;
      break;
    }
  } else {

  }
  if (opline->extended_value == 147UL) {
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
    if (free_op_data2.var) {
      i_zval_ptr_dtor(free_op_data2.var);
    } else {

    }
    (execute_data->opline) ++;
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_ADD_SPEC_UNUSED_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED((int (*)(zval *result , zval *op1 , zval *op2 ))(& add_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SUB_SPEC_UNUSED_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED((int (*)(zval *result , zval *op1 , zval *op2 ))(& sub_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_MUL_SPEC_UNUSED_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED((int (*)(zval *result , zval *op1 , zval *op2 ))(& mul_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_DIV_SPEC_UNUSED_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED((int (*)(zval *result , zval *op1 , zval *op2 ))(& div_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_MOD_SPEC_UNUSED_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED((int (*)(zval *result , zval *op1 , zval *op2 ))(& mod_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SL_SPEC_UNUSED_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED((int (*)(zval *result , zval *op1 , zval *op2 ))(& shift_left_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SR_SPEC_UNUSED_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED((int (*)(zval *result , zval *op1 , zval *op2 ))(& shift_right_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_CONCAT_SPEC_UNUSED_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED((int (*)(zval *result , zval *op1 , zval *op2 ))(& concat_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_OR_SPEC_UNUSED_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_or_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_AND_SPEC_UNUSED_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_and_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_xor_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_ARRAY_SPEC_UNUSED_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;

  {
  opline = execute_data->opline;
  _array_init(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, 0U);
  if (1 << 3 == 1 << 3) {
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_binary_assign_op_obj_helper_SPEC_UNUSED_CV)(int (*binary_op)(zval *result , zval *op1 , zval *op2 ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op_data1 ;
  zval **object_ptr ;
  zval **tmp ;
  zval *object ;
  zval *property ;
  zval *tmp___0 ;
  zval *value ;
  zval *tmp___1 ;
  int have_get_ptr ;
  long tmp___2 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___3 ;
  zval **zptr ;
  zend_literal *tmp___4 ;
  zval **tmp___5 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;
  zend_uint tmp___7 ;
  zend_bool tmp___8 ;
  zval *z ;
  zend_literal *tmp___9 ;
  zval *value___0 ;
  zval *tmp___10 ;
  zend_uint tmp___11 ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___12 ;
  zend_uint tmp___13 ;
  zend_bool tmp___14 ;
  zend_literal *tmp___15 ;
  long tmp___16 ;

  {
  opline = execute_data->opline;
  tmp = _get_obj_zval_ptr_ptr_unused();
  object_ptr = tmp;
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  property = tmp___0;
  tmp___1 = _get_zval_ptr((int )(opline + 1)->op1_type, (znode_op const   *)(& (opline + 1)->op1), (temp_variable const   *)execute_data->Ts, & free_op_data1, 0);
  value = tmp___1;
  have_get_ptr = 0;
  if (1 << 3 == 1 << 2) {
    tmp___2 = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___2) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  make_real_object(object_ptr);
  object = *object_ptr;
  tmp___16 = __builtin_expect((long )((int )object->type != 5), 0L);
  if (tmp___16) {
    zend_error(1 << 1L, "Attempt to assign property of non-object");
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = & executor_globals.uninitialized_zval;
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
    } else {

    }
  } else {
    if (opline->extended_value == 136UL) {
      if ((object->value.obj.handlers)->get_property_ptr_ptr) {
        if (1 << 4 == 1) {
          tmp___4 = opline->op2.literal;
        } else {
          tmp___4 = (zend_literal *)((void *)0);
        }
        tmp___5 = (*((object->value.obj.handlers)->get_property_ptr_ptr))(object, property, (struct _zend_literal  const  *)tmp___4);
        zptr = tmp___5;
        if ((unsigned int )zptr != (unsigned int )((void *)0)) {
          tmp___8 = zval_isref_p(*zptr);
          if (tmp___8) {

          } else {
            while (1) {
              tmp___7 = zval_refcount_p(*zptr);
              if (tmp___7 > 1U) {
                zval_delref_p(*zptr);
                while (1) {
                  tmp___6 = _emalloc(sizeof(zval_gc_info ));
                  new_zv = (zval *)tmp___6;
                  ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                  break;
                }
                while (1) {
                  while (1) {
                    new_zv->value = (*zptr)->value;
                    new_zv->type = (*zptr)->type;
                    break;
                  }
                  zval_set_refcount_p(new_zv, 1U);
                  zval_unset_isref_p(new_zv);
                  break;
                }
                *zptr = new_zv;
                _zval_copy_ctor(new_zv);
              } else {

              }
              break;
            }
          }
          have_get_ptr = 1;
          (*binary_op)(*zptr, *zptr, value);
          if (! ((int )opline->result_type & (1 << 5))) {
            zval_addref_p(*zptr);
            ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = *zptr;
            ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
          } else {

          }
        } else {

        }
      } else {

      }
    } else {

    }
    if (! have_get_ptr) {
      z = (zval *)((void *)0);
      if (opline->extended_value == 136UL) {
        if ((object->value.obj.handlers)->read_property) {
          if (1 << 4 == 1) {
            tmp___9 = opline->op2.literal;
          } else {
            tmp___9 = (zend_literal *)((void *)0);
          }
          z = (*((object->value.obj.handlers)->read_property))(object, property, 0, (struct _zend_literal  const  *)tmp___9);
        } else {

        }
      } else {
        if ((object->value.obj.handlers)->read_dimension) {
          z = (*((object->value.obj.handlers)->read_dimension))(object, property, 0);
        } else {

        }
      }
      if (z) {
        if ((int )z->type == 5) {
          if ((z->value.obj.handlers)->get) {
            tmp___10 = (*((z->value.obj.handlers)->get))(z);
            value___0 = tmp___10;
            tmp___11 = zval_refcount_p(z);
            if (tmp___11 == 0U) {
              if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                gc_remove_zval_from_buffer(z);
              } else {

              }
              _zval_dtor(z);
              while (1) {
                if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                  gc_remove_zval_from_buffer(z);
                } else {

                }
                _efree((void *)z);
                break;
              }
            } else {

            }
            z = value___0;
          } else {

          }
        } else {

        }
        zval_addref_p(z);
        tmp___14 = zval_isref_p(z);
        if (tmp___14) {

        } else {
          while (1) {
            tmp___13 = zval_refcount_p(z);
            if (tmp___13 > 1U) {
              zval_delref_p(z);
              while (1) {
                tmp___12 = _emalloc(sizeof(zval_gc_info ));
                new_zv___0 = (zval *)tmp___12;
                ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv___0->value = z->value;
                  new_zv___0->type = z->type;
                  break;
                }
                zval_set_refcount_p(new_zv___0, 1U);
                zval_unset_isref_p(new_zv___0);
                break;
              }
              z = new_zv___0;
              _zval_copy_ctor(new_zv___0);
            } else {

            }
            break;
          }
        }
        (*binary_op)(z, z, value);
        if (opline->extended_value == 136UL) {
          if (1 << 4 == 1) {
            tmp___15 = opline->op2.literal;
          } else {
            tmp___15 = (zend_literal *)((void *)0);
          }
          (*((object->value.obj.handlers)->write_property))(object, property, z, (struct _zend_literal  const  *)tmp___15);
        } else {
          (*((object->value.obj.handlers)->write_dimension))(object, property, z);
        }
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(z);
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = z;
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
        } else {

        }
        i_zval_ptr_dtor(z);
      } else {
        zend_error(1 << 1L, "Attempt to assign property of non-object");
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = & executor_globals.uninitialized_zval;
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
        } else {

        }
      }
    } else {

    }
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
  }
  (execute_data->opline) ++;
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_binary_assign_op_helper_SPEC_UNUSED_CV)(int (*binary_op)(zval *result , zval *op1 , zval *op2 ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op_data2 ;
  zend_free_op free_op_data1 ;
  zval **var_ptr ;
  zval *value ;
  int tmp ;
  zval **container ;
  zval **tmp___0 ;
  int tmp___1 ;
  zval *dim ;
  zval *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  temp_variable *__t ;
  long tmp___6 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___7 ;
  zend_uint tmp___8 ;
  zend_bool tmp___9 ;
  zval *objval ;
  zval *tmp___10 ;
  long tmp___11 ;
  temp_variable *__t___0 ;

  {
  opline = execute_data->opline;
  switch ((int )opline->extended_value) {
  case 136: 
  tmp = zend_binary_assign_op_obj_helper_SPEC_UNUSED_CV(binary_op, execute_data);
  return (tmp);
  break;
  case 147: 
  tmp___0 = _get_obj_zval_ptr_ptr_unused();
  container = tmp___0;
  if (1 << 3 == 1 << 2) {
    tmp___4 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___4) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    tmp___3 = __builtin_expect((long )((int )(*container)->type == 5), 0L);
    if (tmp___3) {
      if (1 << 3 == 1 << 2) {
        zval_addref_p(*container);
      } else {

      }
      tmp___1 = zend_binary_assign_op_obj_helper_SPEC_UNUSED_CV(binary_op, execute_data);
      return (tmp___1);
    } else {
      tmp___2 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
      dim = tmp___2;
      zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var), container, dim, 1 << 4, 2);
      value = _get_zval_ptr((int )(opline + 1)->op1_type, (znode_op const   *)(& (opline + 1)->op1), (temp_variable const   *)execute_data->Ts, & free_op_data1, 0);
      var_ptr = _get_zval_ptr_ptr_var((opline + 1)->op2.var, (temp_variable const   *)execute_data->Ts, & free_op_data2);
    }
  }
  break;
  default: 
  value = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  var_ptr = (zval **)((void *)0);
  break;
  }
  tmp___5 = __builtin_expect((long )((unsigned int )var_ptr == (unsigned int )((void *)0)), 0L);
  if (tmp___5) {
    zend_error_noreturn(1, "Cannot use assign-op operators with overloaded objects nor string offsets");
  } else {

  }
  tmp___6 = __builtin_expect((long )((unsigned int )*var_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
  if (tmp___6) {
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      while (1) {
        __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t->var.ptr = & executor_globals.uninitialized_zval;
        __t->var.ptr_ptr = & __t->var.ptr;
        break;
      }
    } else {

    }
    if (opline->extended_value == 147UL) {
      (execute_data->opline) ++;
    } else {

    }
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  tmp___9 = zval_isref_p(*var_ptr);
  if (tmp___9) {

  } else {
    while (1) {
      tmp___8 = zval_refcount_p(*var_ptr);
      if (tmp___8 > 1U) {
        zval_delref_p(*var_ptr);
        while (1) {
          tmp___7 = _emalloc(sizeof(zval_gc_info ));
          new_zv = (zval *)tmp___7;
          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            new_zv->value = (*var_ptr)->value;
            new_zv->type = (*var_ptr)->type;
            break;
          }
          zval_set_refcount_p(new_zv, 1U);
          zval_unset_isref_p(new_zv);
          break;
        }
        *var_ptr = new_zv;
        _zval_copy_ctor(new_zv);
      } else {

      }
      break;
    }
  }
  tmp___11 = __builtin_expect((long )((int )(*var_ptr)->type == 5), 0L);
  if (tmp___11) {
    if (((*var_ptr)->value.obj.handlers)->get) {
      if (((*var_ptr)->value.obj.handlers)->set) {
        tmp___10 = (*(((*var_ptr)->value.obj.handlers)->get))(*var_ptr);
        objval = tmp___10;
        zval_addref_p(objval);
        (*binary_op)(objval, objval, value);
        (*(((*var_ptr)->value.obj.handlers)->set))(var_ptr, objval);
        i_zval_ptr_dtor(objval);
      } else {
        (*binary_op)(*var_ptr, *var_ptr, value);
      }
    } else {
      (*binary_op)(*var_ptr, *var_ptr, value);
    }
  } else {
    (*binary_op)(*var_ptr, *var_ptr, value);
  }
  if (! ((int )opline->result_type & (1 << 5))) {
    zval_addref_p(*var_ptr);
    while (1) {
      __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
      __t___0->var.ptr = *var_ptr;
      __t___0->var.ptr_ptr = & __t___0->var.ptr;
      break;
    }
  } else {

  }
  if (opline->extended_value == 147UL) {
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
    if (free_op_data2.var) {
      i_zval_ptr_dtor(free_op_data2.var);
    } else {

    }
    (execute_data->opline) ++;
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_ADD_SPEC_UNUSED_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_CV((int (*)(zval *result , zval *op1 , zval *op2 ))(& add_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SUB_SPEC_UNUSED_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_CV((int (*)(zval *result , zval *op1 , zval *op2 ))(& sub_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_MUL_SPEC_UNUSED_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_CV((int (*)(zval *result , zval *op1 , zval *op2 ))(& mul_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_DIV_SPEC_UNUSED_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_CV((int (*)(zval *result , zval *op1 , zval *op2 ))(& div_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_MOD_SPEC_UNUSED_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_CV((int (*)(zval *result , zval *op1 , zval *op2 ))(& mod_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SL_SPEC_UNUSED_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_CV((int (*)(zval *result , zval *op1 , zval *op2 ))(& shift_left_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SR_SPEC_UNUSED_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_CV((int (*)(zval *result , zval *op1 , zval *op2 ))(& shift_right_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_CONCAT_SPEC_UNUSED_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_CV((int (*)(zval *result , zval *op1 , zval *op2 ))(& concat_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_OR_SPEC_UNUSED_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_CV((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_or_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_AND_SPEC_UNUSED_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_CV((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_and_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_UNUSED_CV((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_xor_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) zend_pre_incdec_property_helper_SPEC_UNUSED_CV)(int (*incdec_op)(zval * ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **object_ptr ;
  zval *object ;
  zval *property ;
  zval **retval ;
  int have_get_ptr ;
  long tmp ;
  long tmp___0 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zval **zptr ;
  zend_literal *tmp___2 ;
  zval **tmp___3 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_uint tmp___5 ;
  zend_bool tmp___6 ;
  zval *z ;
  zend_literal *tmp___7 ;
  zval *tmp___8 ;
  zval *value ;
  zval *tmp___9 ;
  zend_uint tmp___10 ;
  long tmp___11 ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___12 ;
  zend_uint tmp___13 ;
  zend_bool tmp___14 ;
  zend_literal *tmp___15 ;

  {
  opline = execute_data->opline;
  have_get_ptr = 0;
  object_ptr = _get_obj_zval_ptr_ptr_unused();
  property = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  retval = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
  if (1 << 3 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot increment/decrement overloaded objects nor string offsets");
    } else {

    }
  } else {

  }
  make_real_object(object_ptr);
  object = *object_ptr;
  tmp___0 = __builtin_expect((long )((int )object->type != 5), 0L);
  if (tmp___0) {
    zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      *retval = & executor_globals.uninitialized_zval;
    } else {

    }
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  if ((object->value.obj.handlers)->get_property_ptr_ptr) {
    if (1 << 4 == 1) {
      tmp___2 = opline->op2.literal;
    } else {
      tmp___2 = (zend_literal *)((void *)0);
    }
    tmp___3 = (*((object->value.obj.handlers)->get_property_ptr_ptr))(object, property, (struct _zend_literal  const  *)tmp___2);
    zptr = tmp___3;
    if ((unsigned int )zptr != (unsigned int )((void *)0)) {
      tmp___6 = zval_isref_p(*zptr);
      if (tmp___6) {

      } else {
        while (1) {
          tmp___5 = zval_refcount_p(*zptr);
          if (tmp___5 > 1U) {
            zval_delref_p(*zptr);
            while (1) {
              tmp___4 = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp___4;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*zptr)->value;
                new_zv->type = (*zptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *zptr = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
      have_get_ptr = 1;
      (*incdec_op)(*zptr);
      if (! ((int )opline->result_type & (1 << 5))) {
        *retval = *zptr;
        zval_addref_p(*retval);
      } else {

      }
    } else {

    }
  } else {

  }
  if (! have_get_ptr) {
    if ((object->value.obj.handlers)->read_property) {
      if ((object->value.obj.handlers)->write_property) {
        if (1 << 4 == 1) {
          tmp___7 = opline->op2.literal;
        } else {
          tmp___7 = (zend_literal *)((void *)0);
        }
        tmp___8 = (*((object->value.obj.handlers)->read_property))(object, property, 0, (struct _zend_literal  const  *)tmp___7);
        z = tmp___8;
        tmp___11 = __builtin_expect((long )((int )z->type == 5), 0L);
        if (tmp___11) {
          if ((z->value.obj.handlers)->get) {
            tmp___9 = (*((z->value.obj.handlers)->get))(z);
            value = tmp___9;
            tmp___10 = zval_refcount_p(z);
            if (tmp___10 == 0U) {
              if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                gc_remove_zval_from_buffer(z);
              } else {

              }
              _zval_dtor(z);
              while (1) {
                if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                  gc_remove_zval_from_buffer(z);
                } else {

                }
                _efree((void *)z);
                break;
              }
            } else {

            }
            z = value;
          } else {

          }
        } else {

        }
        zval_addref_p(z);
        tmp___14 = zval_isref_p(z);
        if (tmp___14) {

        } else {
          while (1) {
            tmp___13 = zval_refcount_p(z);
            if (tmp___13 > 1U) {
              zval_delref_p(z);
              while (1) {
                tmp___12 = _emalloc(sizeof(zval_gc_info ));
                new_zv___0 = (zval *)tmp___12;
                ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv___0->value = z->value;
                  new_zv___0->type = z->type;
                  break;
                }
                zval_set_refcount_p(new_zv___0, 1U);
                zval_unset_isref_p(new_zv___0);
                break;
              }
              z = new_zv___0;
              _zval_copy_ctor(new_zv___0);
            } else {

            }
            break;
          }
        }
        (*incdec_op)(z);
        *retval = z;
        if (1 << 4 == 1) {
          tmp___15 = opline->op2.literal;
        } else {
          tmp___15 = (zend_literal *)((void *)0);
        }
        (*((object->value.obj.handlers)->write_property))(object, property, z, (struct _zend_literal  const  *)tmp___15);
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(*retval);
        } else {

        }
        i_zval_ptr_dtor(z);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
      if (! ((int )opline->result_type & (1 << 5))) {
        zval_addref_p(& executor_globals.uninitialized_zval);
        *retval = & executor_globals.uninitialized_zval;
      } else {

      }
    }
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_PRE_INC_OBJ_SPEC_UNUSED_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_pre_incdec_property_helper_SPEC_UNUSED_CV((int (*)(zval * ))(& increment_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_PRE_DEC_OBJ_SPEC_UNUSED_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_pre_incdec_property_helper_SPEC_UNUSED_CV((int (*)(zval * ))(& decrement_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) zend_post_incdec_property_helper_SPEC_UNUSED_CV)(int (*incdec_op)(zval * ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **object_ptr ;
  zval *object ;
  zval *property ;
  zval *retval ;
  int have_get_ptr ;
  long tmp ;
  long tmp___0 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zval **zptr ;
  zend_literal *tmp___2 ;
  zval **tmp___3 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_uint tmp___5 ;
  zend_bool tmp___6 ;
  zval *z ;
  zend_literal *tmp___7 ;
  zval *tmp___8 ;
  zval *z_copy ;
  zval *value ;
  zval *tmp___9 ;
  zend_uint tmp___10 ;
  long tmp___11 ;
  void __attribute__((__visibility__("default")))  *tmp___12 ;
  zend_literal *tmp___13 ;

  {
  opline = execute_data->opline;
  have_get_ptr = 0;
  object_ptr = _get_obj_zval_ptr_ptr_unused();
  property = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  retval = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  if (1 << 3 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot increment/decrement overloaded objects nor string offsets");
    } else {

    }
  } else {

  }
  make_real_object(object_ptr);
  object = *object_ptr;
  tmp___0 = __builtin_expect((long )((int )object->type != 5), 0L);
  if (tmp___0) {
    zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
    retval->type = (unsigned char)0;
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  if ((object->value.obj.handlers)->get_property_ptr_ptr) {
    if (1 << 4 == 1) {
      tmp___2 = opline->op2.literal;
    } else {
      tmp___2 = (zend_literal *)((void *)0);
    }
    tmp___3 = (*((object->value.obj.handlers)->get_property_ptr_ptr))(object, property, (struct _zend_literal  const  *)tmp___2);
    zptr = tmp___3;
    if ((unsigned int )zptr != (unsigned int )((void *)0)) {
      have_get_ptr = 1;
      tmp___6 = zval_isref_p(*zptr);
      if (tmp___6) {

      } else {
        while (1) {
          tmp___5 = zval_refcount_p(*zptr);
          if (tmp___5 > 1U) {
            zval_delref_p(*zptr);
            while (1) {
              tmp___4 = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp___4;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*zptr)->value;
                new_zv->type = (*zptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *zptr = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
      while (1) {
        retval->value = (*zptr)->value;
        retval->type = (*zptr)->type;
        break;
      }
      _zval_copy_ctor(retval);
      (*incdec_op)(*zptr);
    } else {

    }
  } else {

  }
  if (! have_get_ptr) {
    if ((object->value.obj.handlers)->read_property) {
      if ((object->value.obj.handlers)->write_property) {
        if (1 << 4 == 1) {
          tmp___7 = opline->op2.literal;
        } else {
          tmp___7 = (zend_literal *)((void *)0);
        }
        tmp___8 = (*((object->value.obj.handlers)->read_property))(object, property, 0, (struct _zend_literal  const  *)tmp___7);
        z = tmp___8;
        tmp___11 = __builtin_expect((long )((int )z->type == 5), 0L);
        if (tmp___11) {
          if ((z->value.obj.handlers)->get) {
            tmp___9 = (*((z->value.obj.handlers)->get))(z);
            value = tmp___9;
            tmp___10 = zval_refcount_p(z);
            if (tmp___10 == 0U) {
              if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                gc_remove_zval_from_buffer(z);
              } else {

              }
              _zval_dtor(z);
              while (1) {
                if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                  gc_remove_zval_from_buffer(z);
                } else {

                }
                _efree((void *)z);
                break;
              }
            } else {

            }
            z = value;
          } else {

          }
        } else {

        }
        while (1) {
          retval->value = z->value;
          retval->type = z->type;
          break;
        }
        _zval_copy_ctor(retval);
        while (1) {
          tmp___12 = _emalloc(sizeof(zval_gc_info ));
          z_copy = (zval *)tmp___12;
          ((zval_gc_info *)z_copy)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            z_copy->value = z->value;
            z_copy->type = z->type;
            break;
          }
          zval_set_refcount_p(z_copy, 1U);
          zval_unset_isref_p(z_copy);
          break;
        }
        _zval_copy_ctor(z_copy);
        (*incdec_op)(z_copy);
        zval_addref_p(z);
        if (1 << 4 == 1) {
          tmp___13 = opline->op2.literal;
        } else {
          tmp___13 = (zend_literal *)((void *)0);
        }
        (*((object->value.obj.handlers)->write_property))(object, property, z_copy, (struct _zend_literal  const  *)tmp___13);
        i_zval_ptr_dtor(z_copy);
        i_zval_ptr_dtor(z);
      } else {
        zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
        retval->type = (unsigned char)0;
      }
    } else {
      zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
      retval->type = (unsigned char)0;
    }
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_POST_INC_OBJ_SPEC_UNUSED_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_post_incdec_property_helper_SPEC_UNUSED_CV((int (*)(zval * ))(& increment_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_POST_DEC_OBJ_SPEC_UNUSED_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_post_incdec_property_helper_SPEC_UNUSED_CV((int (*)(zval * ))(& decrement_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) zend_fetch_property_address_read_helper_SPEC_UNUSED_CV)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *container ;
  zval *offset ;
  temp_variable *__t ;
  zval *retval ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_literal *tmp___0 ;
  temp_variable *__t___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  opline = execute_data->opline;
  container = _get_obj_zval_ptr_unused();
  offset = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___1 = __builtin_expect((long )((int )container->type != 5), 0L);
  if (tmp___1) {
    goto _L;
  } else {
    tmp___2 = __builtin_expect((long )((unsigned int )(container->value.obj.handlers)->read_property == (unsigned int )((void *)0)), 0L);
    if (tmp___2) {
      _L: /* CIL Label */ 
      zend_error(1 << 3L, "Trying to get property of non-object");
      zval_addref_p(& executor_globals.uninitialized_zval);
      while (1) {
        __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t->var.ptr = & executor_globals.uninitialized_zval;
        __t->var.ptr_ptr = & __t->var.ptr;
        break;
      }
    } else {
      if (1 << 4 == 1) {
        tmp___0 = opline->op2.literal;
      } else {
        tmp___0 = (zend_literal *)((void *)0);
      }
      retval = (*((container->value.obj.handlers)->read_property))(container, offset, 0, (struct _zend_literal  const  *)tmp___0);
      zval_addref_p(retval);
      while (1) {
        __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t___0->var.ptr = retval;
        __t___0->var.ptr_ptr = & __t___0->var.ptr;
        break;
      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_R_SPEC_UNUSED_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_property_address_read_helper_SPEC_UNUSED_CV(execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_W_SPEC_UNUSED_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *property ;
  zval **container ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zend_literal *tmp___1 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_uint tmp___3 ;
  zend_bool tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint tmp___6 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___7 ;
  zval **retval_ptr ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___8 ;
  zend_uint tmp___9 ;
  zend_bool tmp___10 ;

  {
  opline = execute_data->opline;
  property = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  if (1 << 3 == 1 << 2) {
    if (opline->extended_value & 134217728UL) {
      zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr));
      ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr = *(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr);
    } else {

    }
  } else {

  }
  container = _get_obj_zval_ptr_ptr_unused();
  if (1 << 3 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  if (1 << 4 == 1) {
    tmp___1 = opline->op2.literal;
  } else {
    tmp___1 = (zend_literal *)((void *)0);
  }
  zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)tmp___1, 1);
  if (1 << 3 == 1 << 2) {
    if (0) {
      tmp___6 = zval_refcount_p(free_op1.var);
      if (tmp___6 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___7 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___7 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___4 = zval_isref_p(__t->var.ptr);
                if (tmp___4) {

                } else {
                  tmp___5 = zval_refcount_p(__t->var.ptr);
                  if (tmp___5 > 2U) {
                    while (1) {
                      tmp___3 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___3 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___2 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___2;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  if (opline->extended_value & 67108864UL) {
    retval_ptr = ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr;
    zval_delref_p(*retval_ptr);
    tmp___10 = zval_isref_p(*retval_ptr);
    if (tmp___10) {

    } else {
      while (1) {
        tmp___9 = zval_refcount_p(*retval_ptr);
        if (tmp___9 > 1U) {
          zval_delref_p(*retval_ptr);
          while (1) {
            tmp___8 = _emalloc(sizeof(zval_gc_info ));
            new_zv___0 = (zval *)tmp___8;
            ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv___0->value = (*retval_ptr)->value;
              new_zv___0->type = (*retval_ptr)->type;
              break;
            }
            zval_set_refcount_p(new_zv___0, 1U);
            zval_unset_isref_p(new_zv___0);
            break;
          }
          *retval_ptr = new_zv___0;
          _zval_copy_ctor(new_zv___0);
        } else {

        }
        break;
      }
      zval_set_isref_p(*retval_ptr);
    }
    zval_addref_p(*retval_ptr);
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = *(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr);
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_RW_SPEC_UNUSED_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *property ;
  zval **container ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zend_literal *tmp___1 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_uint tmp___3 ;
  zend_bool tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint tmp___6 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___7 ;

  {
  opline = execute_data->opline;
  property = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  container = _get_obj_zval_ptr_ptr_unused();
  if (1 << 3 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  if (1 << 4 == 1) {
    tmp___1 = opline->op2.literal;
  } else {
    tmp___1 = (zend_literal *)((void *)0);
  }
  zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)tmp___1, 2);
  if (1 << 3 == 1 << 2) {
    if (0) {
      tmp___6 = zval_refcount_p(free_op1.var);
      if (tmp___6 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___7 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___7 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___4 = zval_isref_p(__t->var.ptr);
                if (tmp___4) {

                } else {
                  tmp___5 = zval_refcount_p(__t->var.ptr);
                  if (tmp___5 > 2U) {
                    while (1) {
                      tmp___3 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___3 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___2 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___2;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_IS_SPEC_UNUSED_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *container ;
  zval *offset ;
  temp_variable *__t ;
  zval *retval ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_literal *tmp___0 ;
  temp_variable *__t___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  opline = execute_data->opline;
  container = _get_obj_zval_ptr_unused();
  offset = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___1 = __builtin_expect((long )((int )container->type != 5), 0L);
  if (tmp___1) {
    goto _L;
  } else {
    tmp___2 = __builtin_expect((long )((unsigned int )(container->value.obj.handlers)->read_property == (unsigned int )((void *)0)), 0L);
    if (tmp___2) {
      _L: /* CIL Label */ 
      zval_addref_p(& executor_globals.uninitialized_zval);
      while (1) {
        __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t->var.ptr = & executor_globals.uninitialized_zval;
        __t->var.ptr_ptr = & __t->var.ptr;
        break;
      }
    } else {
      if (1 << 4 == 1) {
        tmp___0 = opline->op2.literal;
      } else {
        tmp___0 = (zend_literal *)((void *)0);
      }
      retval = (*((container->value.obj.handlers)->read_property))(container, offset, 3, (struct _zend_literal  const  *)tmp___0);
      zval_addref_p(retval);
      while (1) {
        __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t___0->var.ptr = retval;
        __t___0->var.ptr_ptr = & __t___0->var.ptr;
        break;
      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *property ;
  zval **container ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zend_literal *tmp___1 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_uint tmp___3 ;
  zend_bool tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint tmp___6 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;

  {
  opline = execute_data->opline;
  if (execute_data->fbc) {
    if ((execute_data->fbc)->common.arg_info) {
      if ((opline->extended_value & 1048575UL) <= (unsigned long )(execute_data->fbc)->common.num_args) {
        tmp___9 = (unsigned int )((int )((execute_data->fbc)->common.arg_info + ((opline->extended_value & 1048575UL) - 1UL))->pass_by_reference & 3);
      } else {
        tmp___9 = (execute_data->fbc)->common.fn_flags & 50331648U;
      }
    } else {
      tmp___9 = (execute_data->fbc)->common.fn_flags & 50331648U;
    }
    if (tmp___9) {
      property = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
      container = _get_obj_zval_ptr_ptr_unused();
      if (1 << 3 == 1 << 2) {
        tmp___0 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
        if (tmp___0) {
          zend_error_noreturn(1, "Cannot use string offset as an object");
        } else {

        }
      } else {

      }
      if (1 << 4 == 1) {
        tmp___1 = opline->op2.literal;
      } else {
        tmp___1 = (zend_literal *)((void *)0);
      }
      zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)tmp___1, 1);
      if (1 << 3 == 1 << 2) {
        if (0) {
          tmp___6 = zval_refcount_p(free_op1.var);
          if (tmp___6 == 1U) {
            if ((int )(free_op1.var)->type != 5) {
              goto _L;
            } else {
              tmp___7 = zend_objects_store_get_refcount(free_op1.var);
              if (tmp___7 == (zend_uint __attribute__((__visibility__("default")))  )1) {
                _L: /* CIL Label */ 
                while (1) {
                  __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
                  if (__t->var.ptr_ptr) {
                    __t->var.ptr = *(__t->var.ptr_ptr);
                    __t->var.ptr_ptr = & __t->var.ptr;
                    tmp___4 = zval_isref_p(__t->var.ptr);
                    if (tmp___4) {

                    } else {
                      tmp___5 = zval_refcount_p(__t->var.ptr);
                      if (tmp___5 > 2U) {
                        while (1) {
                          tmp___3 = zval_refcount_p(*(__t->var.ptr_ptr));
                          if (tmp___3 > 1U) {
                            zval_delref_p(*(__t->var.ptr_ptr));
                            while (1) {
                              tmp___2 = _emalloc(sizeof(zval_gc_info ));
                              new_zv = (zval *)tmp___2;
                              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                              break;
                            }
                            while (1) {
                              while (1) {
                                new_zv->value = (*(__t->var.ptr_ptr))->value;
                                new_zv->type = (*(__t->var.ptr_ptr))->type;
                                break;
                              }
                              zval_set_refcount_p(new_zv, 1U);
                              zval_unset_isref_p(new_zv);
                              break;
                            }
                            *(__t->var.ptr_ptr) = new_zv;
                            _zval_copy_ctor(new_zv);
                          } else {

                          }
                          break;
                        }
                      } else {

                      }
                    }
                  } else {

                  }
                  break;
                }
              } else {

              }
            }
          } else {

          }
        } else {

        }
      } else {

      }
      (execute_data->opline) ++;
      return (0);
    } else {
      tmp___8 = zend_fetch_property_address_read_helper_SPEC_UNUSED_CV(execute_data);
      return (tmp___8);
    }
  } else {
    tmp___8 = zend_fetch_property_address_read_helper_SPEC_UNUSED_CV(execute_data);
    return (tmp___8);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_res ;
  zval **container ;
  zval *property ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  long tmp___3 ;
  zend_literal *tmp___4 ;
  temp_variable *__t ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  zend_uint tmp___6 ;
  zend_bool tmp___7 ;
  zend_uint tmp___8 ;
  zend_uint tmp___9 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___10 ;
  zval *new_zv___1 ;
  void __attribute__((__visibility__("default")))  *tmp___11 ;
  zend_uint tmp___12 ;
  zend_bool tmp___13 ;

  {
  opline = execute_data->opline;
  container = _get_obj_zval_ptr_ptr_unused();
  property = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  if (1 << 3 == 1 << 4) {
    if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
      tmp___1 = zval_isref_p(*container);
      if (tmp___1) {

      } else {
        while (1) {
          tmp___0 = zval_refcount_p(*container);
          if (tmp___0 > 1U) {
            zval_delref_p(*container);
            while (1) {
              tmp = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*container)->value;
                new_zv->type = (*container)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *container = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
    } else {

    }
  } else {

  }
  if (1 << 3 == 1 << 2) {
    tmp___3 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___3) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  if (1 << 4 == 1) {
    tmp___4 = opline->op2.literal;
  } else {
    tmp___4 = (zend_literal *)((void *)0);
  }
  zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)tmp___4, 6);
  if (1 << 3 == 1 << 2) {
    if (0) {
      tmp___9 = zval_refcount_p(free_op1.var);
      if (tmp___9 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___10 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___10 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___7 = zval_isref_p(__t->var.ptr);
                if (tmp___7) {

                } else {
                  tmp___8 = zval_refcount_p(__t->var.ptr);
                  if (tmp___8 > 2U) {
                    while (1) {
                      tmp___6 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___6 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___5 = _emalloc(sizeof(zval_gc_info ));
                          new_zv___0 = (zval *)tmp___5;
                          ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv___0->value = (*(__t->var.ptr_ptr))->value;
                            new_zv___0->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv___0, 1U);
                          zval_unset_isref_p(new_zv___0);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv___0;
                        _zval_copy_ctor(new_zv___0);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  zend_pzval_unlock_func(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr), & free_res, 1);
  if ((unsigned int )((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
    tmp___13 = zval_isref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
    if (tmp___13) {

    } else {
      while (1) {
        tmp___12 = zval_refcount_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
        if (tmp___12 > 1U) {
          zval_delref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
          while (1) {
            tmp___11 = _emalloc(sizeof(zval_gc_info ));
            new_zv___1 = (zval *)tmp___11;
            ((zval_gc_info *)new_zv___1)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv___1->value = (*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr))->value;
              new_zv___1->type = (*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr))->type;
              break;
            }
            zval_set_refcount_p(new_zv___1, 1U);
            zval_unset_isref_p(new_zv___1);
            break;
          }
          *(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr) = new_zv___1;
          _zval_copy_ctor(new_zv___1);
        } else {

        }
        break;
      }
    }
  } else {

  }
  zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
  if (free_res.var) {
    i_zval_ptr_dtor(free_res.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_OBJ_SPEC_UNUSED_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **object_ptr ;
  zval *property_name ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zend_literal *tmp___1 ;
  zval **tmp___2 ;

  {
  opline = execute_data->opline;
  object_ptr = _get_obj_zval_ptr_ptr_unused();
  property_name = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  if (1 << 3 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  if (1 << 4 == 1) {
    tmp___1 = opline->op2.literal;
  } else {
    tmp___1 = (zend_literal *)((void *)0);
  }
  if (! ((int )opline->result_type & (1 << 5))) {
    tmp___2 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
  } else {
    tmp___2 = (zval **)((void *)0);
  }
  zend_assign_to_object(tmp___2, object_ptr, property_name, (int )(opline + 1)->op1_type, & (opline + 1)->op1, (temp_variable const   *)execute_data->Ts, 136, (zend_literal const   *)tmp___1);
  (execute_data->opline) ++;
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_VAR_SPEC_UNUSED_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *str ;
  zval *var ;
  zval var_copy ;
  int use_copy ;

  {
  opline = execute_data->opline;
  str = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  use_copy = 0;
  var = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  if (1 << 3 == 1 << 3) {
    str->value.str.val = (char *)((void *)0);
    str->value.str.len = 0;
    str->type = (unsigned char)6;
    str->refcount__gc = 1U;
    str->is_ref__gc = (unsigned char)0;
  } else {

  }
  if ((int )var->type != 6) {
    zend_make_printable_zval(var, & var_copy, & use_copy);
    if (use_copy) {
      var = & var_copy;
    } else {

    }
  } else {

  }
  add_string_to_string(str, (zval const   *)str, (zval const   *)var);
  if (use_copy) {
    _zval_dtor(var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_METHOD_CALL_SPEC_UNUSED_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *function_name ;
  char *function_name_strval ;
  int function_name_strlen ;
  long tmp ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  zval *object ;
  long tmp___1 ;
  zend_literal *tmp___2 ;
  zend_class_entry *tmp___3 ;
  zend_class_entry *tmp___4 ;
  char const   *tmp___5 ;
  zend_class_entry *tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  zend_function *tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  zval *this_ptr ;
  void __attribute__((__visibility__("default")))  *tmp___13 ;
  zend_bool tmp___14 ;

  {
  opline = execute_data->opline;
  zend_ptr_stack_3_push(& executor_globals.arg_types_stack, (void *)execute_data->fbc, (void *)execute_data->object, (void *)execute_data->called_scope);
  function_name = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  if (1 << 4 != 1) {
    tmp = __builtin_expect((long )((int )function_name->type != 6), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Method name must be a string");
    } else {

    }
  } else {

  }
  function_name_strval = function_name->value.str.val;
  function_name_strlen = function_name->value.str.len;
  execute_data->object = _get_obj_zval_ptr_unused();
  tmp___11 = __builtin_expect((long )((unsigned int )execute_data->object != (unsigned int )((void *)0)), 1L);
  if (tmp___11) {
    tmp___12 = __builtin_expect((long )((int )(execute_data->object)->type == 5), 1L);
    if (tmp___12) {
      tmp___0 = zend_get_class_entry((zval const   *)execute_data->object);
      execute_data->called_scope = (zend_class_entry *)tmp___0;
      if (1 << 4 != 1) {
        goto _L;
      } else {
        if ((unsigned int )*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) == (unsigned int )execute_data->called_scope) {
          tmp___10 = (zend_function *)*((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U));
        } else {
          tmp___10 = (zend_function *)((void *)0);
        }
        execute_data->fbc = tmp___10;
        if ((unsigned int )tmp___10 == (unsigned int )((void *)0)) {
          _L: /* CIL Label */ 
          object = execute_data->object;
          tmp___1 = __builtin_expect((long )((unsigned int )((execute_data->object)->value.obj.handlers)->get_method == (unsigned int )((void *)0)), 0L);
          if (tmp___1) {
            zend_error_noreturn(1, "Object does not support method calls");
          } else {

          }
          if (1 << 4 == 1) {
            tmp___2 = opline->op2.literal + 1;
          } else {
            tmp___2 = (zend_literal *)((void *)0);
          }
          execute_data->fbc = (*(((execute_data->object)->value.obj.handlers)->get_method))(& execute_data->object, function_name_strval, function_name_strlen, (struct _zend_literal  const  *)tmp___2);
          tmp___7 = __builtin_expect((long )((unsigned int )execute_data->fbc == (unsigned int )((void *)0)), 0L);
          if (tmp___7) {
            if (execute_data->object) {
              if ((int )(execute_data->object)->type == 5) {
                if ((unsigned int )((execute_data->object)->value.obj.handlers)->get_class_entry != (unsigned int )((void *)0)) {
                  tmp___6 = (*(((execute_data->object)->value.obj.handlers)->get_class_entry))((zval const   *)execute_data->object);
                  if (tmp___6) {
                    tmp___4 = (*(((execute_data->object)->value.obj.handlers)->get_class_entry))((zval const   *)execute_data->object);
                    tmp___5 = tmp___4->name;
                  } else {
                    tmp___5 = "";
                  }
                } else {
                  tmp___5 = "";
                }
              } else {
                tmp___5 = "";
              }
            } else {
              tmp___5 = "";
            }
            zend_error_noreturn(1, "Call to undefined method %s::%s()", tmp___5, function_name_strval);
          } else {

          }
          if (1 << 4 == 1) {
            tmp___8 = __builtin_expect((long )(((execute_data->fbc)->common.fn_flags & 6291456U) == 0U), 1L);
            if (tmp___8) {
              tmp___9 = __builtin_expect((long )((unsigned int )execute_data->object == (unsigned int )object), 1L);
              if (tmp___9) {
                while (1) {
                  *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)execute_data->called_scope;
                  *((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U)) = (void *)execute_data->fbc;
                  break;
                }
              } else {

              }
            } else {

            }
          } else {

          }
        } else {

        }
      }
    } else {
      zend_error_noreturn(1, "Call to a member function %s() on a non-object", function_name_strval);
    }
  } else {
    zend_error_noreturn(1, "Call to a member function %s() on a non-object", function_name_strval);
  }
  if (((execute_data->fbc)->common.fn_flags & 1U) != 0U) {
    execute_data->object = (zval *)((void *)0);
  } else {
    tmp___14 = zval_isref_p(execute_data->object);
    if (tmp___14) {
      while (1) {
        tmp___13 = _emalloc(sizeof(zval_gc_info ));
        this_ptr = (zval *)tmp___13;
        ((zval_gc_info *)this_ptr)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      while (1) {
        while (1) {
          this_ptr->value = (execute_data->object)->value;
          this_ptr->type = (execute_data->object)->type;
          break;
        }
        zval_set_refcount_p(this_ptr, 1U);
        zval_unset_isref_p(this_ptr);
        break;
      }
      _zval_copy_ctor(this_ptr);
      execute_data->object = this_ptr;
    } else {
      zval_addref_p(execute_data->object);
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_ARRAY_SPEC_UNUSED_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;

  {
  opline = execute_data->opline;
  _array_init(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, 0U);
  if (1 << 3 == 1 << 3) {
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_UNSET_DIM_SPEC_UNUSED_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **container ;
  zval *offset ;
  ulong hval ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  HashTable *ht ;
  long tmp___2 ;
  register char const   *tmp___3 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___4 ;
  long tmp___5 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;

  {
  opline = execute_data->opline;
  container = _get_obj_zval_ptr_ptr_unused();
  if (1 << 3 == 1 << 4) {
    if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
      tmp___1 = zval_isref_p(*container);
      if (tmp___1) {

      } else {
        while (1) {
          tmp___0 = zval_refcount_p(*container);
          if (tmp___0 > 1U) {
            zval_delref_p(*container);
            while (1) {
              tmp = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*container)->value;
                new_zv->type = (*container)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *container = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
    } else {

    }
  } else {

  }
  offset = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  if (1 << 3 != 1 << 2) {
    goto _L___0;
  } else {
    if (container) {
      _L___0: /* CIL Label */ 
      switch ((int )(*container)->type) {
      case 4: 
      ht = (*container)->value.ht;
      switch ((int )offset->type) {
      case 2: 
      tmp___2 = zend_dval_to_lval(offset->value.dval);
      hval = (unsigned long )tmp___2;
      goto num_index_dim;
      case 7: 
      case 3: 
      case 1: 
      hval = (unsigned long )offset->value.lval;
      zend_hash_del_key_or_index(ht, (char const   *)((void *)0), 0U, hval, 1);
      break;
      case 6: 
      if (1 << 4 == 1 << 4) {
        zval_addref_p(offset);
      } else {
        if (1 << 4 == 1 << 2) {
          zval_addref_p(offset);
        } else {

        }
      }
      if (1 << 4 == 1) {
        hval = ((zend_literal *)offset)->hash_value;
      } else {
        while (1) {
          tmp___3 = (char const   *)offset->value.str.val;
          if ((int const   )*tmp___3 == 45) {
            tmp___3 ++;
          } else {

          }
          if ((int const   )*tmp___3 >= 48) {
            if ((int const   )*tmp___3 <= 57) {
              end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
              if ((int const   )*end != 0) {
                break;
              } else {
                if ((int const   )*tmp___3 == 48) {
                  if (offset->value.str.len + 1 > 2) {
                    break;
                  } else {
                    goto _L;
                  }
                } else {
                  _L: /* CIL Label */ 
                  if (end - tmp___3 > 10) {
                    break;
                  } else {
                    if (end - tmp___3 == 10) {
                      if ((int const   )*tmp___3 > 50) {
                        break;
                      } else {

                      }
                    } else {

                    }
                  }
                }
              }
              hval = (unsigned long )((int const   )*tmp___3 - 48);
              while (1) {
                tmp___3 ++;
                if ((unsigned int )tmp___3 != (unsigned int )end) {
                  if ((int const   )*tmp___3 >= 48) {
                    if ((int const   )*tmp___3 <= 57) {

                    } else {
                      break;
                    }
                  } else {
                    break;
                  }
                } else {
                  break;
                }
                hval = hval * 10UL + (ulong )((int const   )*tmp___3 - 48);
              }
              if ((unsigned int )tmp___3 == (unsigned int )end) {
                if ((int )*(offset->value.str.val) == 45) {
                  if (hval - 1UL > 2147483647UL) {
                    break;
                  } else {

                  }
                  hval = (unsigned long )(- ((long )hval));
                } else {
                  if (hval > 2147483647UL) {
                    break;
                  } else {

                  }
                }
                goto num_index_dim;
              } else {

              }
            } else {

            }
          } else {

          }
          break;
        }
        if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
          if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
            hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
          } else {
            tmp___4 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
            hval = (unsigned long )tmp___4;
          }
        } else {
          tmp___4 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___4;
        }
      }
      if ((unsigned int )ht == (unsigned int )(& executor_globals.symbol_table)) {
        zend_delete_global_variable_ex((char const   *)offset->value.str.val, offset->value.str.len, hval);
      } else {
        zend_hash_del_key_or_index(ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, 2);
      }
      if (1 << 4 == 1 << 4) {
        i_zval_ptr_dtor(offset);
      } else {
        if (1 << 4 == 1 << 2) {
          i_zval_ptr_dtor(offset);
        } else {

        }
      }
      break;
      num_index_dim: 
      zend_hash_del_key_or_index(ht, (char const   *)((void *)0), 0U, hval, 1);
      if (1 << 4 == 1 << 4) {
        i_zval_ptr_dtor(offset);
      } else {
        if (1 << 4 == 1 << 2) {
          i_zval_ptr_dtor(offset);
        } else {

        }
      }
      break;
      case 0: 
      zend_hash_del_key_or_index(ht, "", sizeof(""), 0UL, 0);
      break;
      default: 
      zend_error(1 << 1L, "Illegal offset type in unset");
      break;
      }
      break;
      case 5: 
      tmp___5 = __builtin_expect((long )((unsigned int )((*container)->value.obj.handlers)->unset_dimension == (unsigned int )((void *)0)), 0L);
      if (tmp___5) {
        zend_error_noreturn(1, "Cannot use object as array");
      } else {

      }
      (*(((*container)->value.obj.handlers)->unset_dimension))(*container, offset);
      break;
      case 6: 
      zend_error_noreturn(1, "Cannot unset string offsets");
      return (0);
      default: ;
      break;
      }
    } else {

    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_UNSET_OBJ_SPEC_UNUSED_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **container ;
  zval *offset ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_literal *tmp___3 ;

  {
  opline = execute_data->opline;
  container = _get_obj_zval_ptr_ptr_unused();
  offset = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  if (1 << 3 != 1 << 2) {
    goto _L;
  } else {
    if (container) {
      _L: /* CIL Label */ 
      if (1 << 3 == 1 << 4) {
        if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
          tmp___1 = zval_isref_p(*container);
          if (tmp___1) {

          } else {
            while (1) {
              tmp___0 = zval_refcount_p(*container);
              if (tmp___0 > 1U) {
                zval_delref_p(*container);
                while (1) {
                  tmp = _emalloc(sizeof(zval_gc_info ));
                  new_zv = (zval *)tmp;
                  ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                  break;
                }
                while (1) {
                  while (1) {
                    new_zv->value = (*container)->value;
                    new_zv->type = (*container)->type;
                    break;
                  }
                  zval_set_refcount_p(new_zv, 1U);
                  zval_unset_isref_p(new_zv);
                  break;
                }
                *container = new_zv;
                _zval_copy_ctor(new_zv);
              } else {

              }
              break;
            }
          }
        } else {

        }
      } else {

      }
      if ((int )(*container)->type == 5) {
        if (((*container)->value.obj.handlers)->unset_property) {
          if (1 << 4 == 1) {
            tmp___3 = opline->op2.literal;
          } else {
            tmp___3 = (zend_literal *)((void *)0);
          }
          (*(((*container)->value.obj.handlers)->unset_property))(*container, offset, (struct _zend_literal  const  *)tmp___3);
        } else {
          zend_error(1 << 3L, "Trying to unset property of non-object");
        }
      } else {

      }
    } else {

    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_CV)(int prop_dim , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **container ;
  zval **value ;
  int result ;
  ulong hval ;
  zval *offset ;
  HashTable *ht ;
  int isset ;
  long tmp ;
  int __attribute__((__visibility__("default")))  tmp___0 ;
  register char const   *tmp___1 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___2 ;
  int __attribute__((__visibility__("default")))  tmp___3 ;
  int __attribute__((__visibility__("default")))  tmp___4 ;
  int tmp___5 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;
  zend_literal *tmp___7 ;
  zval tmp___8 ;

  {
  opline = execute_data->opline;
  value = (zval **)((void *)0);
  result = 0;
  container = _get_obj_zval_ptr_ptr_unused();
  offset = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  if ((int )(*container)->type == 4) {
    if (! prop_dim) {
      isset = 0;
      ht = (*container)->value.ht;
      switch ((int )offset->type) {
      case 2: 
      tmp = zend_dval_to_lval(offset->value.dval);
      hval = (unsigned long )tmp;
      goto num_index_prop;
      case 7: 
      case 3: 
      case 1: 
      hval = (unsigned long )offset->value.lval;
      num_index_prop: 
      tmp___0 = zend_hash_index_find((HashTable const   *)ht, hval, (void **)(& value));
      if (tmp___0 == (int __attribute__((__visibility__("default")))  )0) {
        isset = 1;
      } else {

      }
      break;
      case 6: 
      if (1 << 4 == 1) {
        hval = ((zend_literal *)offset)->hash_value;
      } else {
        if (! prop_dim) {
          while (1) {
            tmp___1 = (char const   *)offset->value.str.val;
            if ((int const   )*tmp___1 == 45) {
              tmp___1 ++;
            } else {

            }
            if ((int const   )*tmp___1 >= 48) {
              if ((int const   )*tmp___1 <= 57) {
                end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
                if ((int const   )*end != 0) {
                  break;
                } else {
                  if ((int const   )*tmp___1 == 48) {
                    if (offset->value.str.len + 1 > 2) {
                      break;
                    } else {
                      goto _L;
                    }
                  } else {
                    _L: /* CIL Label */ 
                    if (end - tmp___1 > 10) {
                      break;
                    } else {
                      if (end - tmp___1 == 10) {
                        if ((int const   )*tmp___1 > 50) {
                          break;
                        } else {

                        }
                      } else {

                      }
                    }
                  }
                }
                hval = (unsigned long )((int const   )*tmp___1 - 48);
                while (1) {
                  tmp___1 ++;
                  if ((unsigned int )tmp___1 != (unsigned int )end) {
                    if ((int const   )*tmp___1 >= 48) {
                      if ((int const   )*tmp___1 <= 57) {

                      } else {
                        break;
                      }
                    } else {
                      break;
                    }
                  } else {
                    break;
                  }
                  hval = hval * 10UL + (ulong )((int const   )*tmp___1 - 48);
                }
                if ((unsigned int )tmp___1 == (unsigned int )end) {
                  if ((int )*(offset->value.str.val) == 45) {
                    if (hval - 1UL > 2147483647UL) {
                      break;
                    } else {

                    }
                    hval = (unsigned long )(- ((long )hval));
                  } else {
                    if (hval > 2147483647UL) {
                      break;
                    } else {

                    }
                  }
                  goto num_index_prop;
                } else {

                }
              } else {

              }
            } else {

            }
            break;
          }
        } else {

        }
        if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
          if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
            hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
          } else {
            tmp___2 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
            hval = (unsigned long )tmp___2;
          }
        } else {
          tmp___2 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___2;
        }
      }
      tmp___3 = zend_hash_quick_find((HashTable const   *)ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, (void **)(& value));
      if (tmp___3 == (int __attribute__((__visibility__("default")))  )0) {
        isset = 1;
      } else {

      }
      break;
      case 0: 
      tmp___4 = zend_hash_find((HashTable const   *)ht, "", sizeof(""), (void **)(& value));
      if (tmp___4 == (int __attribute__((__visibility__("default")))  )0) {
        isset = 1;
      } else {

      }
      break;
      default: 
      zend_error(1 << 1L, "Illegal offset type in isset or empty");
      break;
      }
      if (opline->extended_value & 33554432UL) {
        if (isset) {
          if ((int )(*value)->type == 0) {
            result = 0;
          } else {
            result = isset;
          }
        } else {
          result = isset;
        }
      } else {
        if (! isset) {
          result = 0;
        } else {
          tmp___5 = i_zend_is_true(*value);
          if (tmp___5) {
            result = 1;
          } else {
            result = 0;
          }
        }
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if ((int )(*container)->type == 5) {
      if (prop_dim) {
        if (((*container)->value.obj.handlers)->has_property) {
          if (1 << 4 == 1) {
            tmp___7 = opline->op2.literal;
          } else {
            tmp___7 = (zend_literal *)((void *)0);
          }
          result = (*(((*container)->value.obj.handlers)->has_property))(*container, offset, (opline->extended_value & 16777216UL) != 0UL, (struct _zend_literal  const  *)tmp___7);
        } else {
          zend_error(1 << 3L, "Trying to check property of non-object");
          result = 0;
        }
      } else {
        if (((*container)->value.obj.handlers)->has_dimension) {
          result = (*(((*container)->value.obj.handlers)->has_dimension))(*container, offset, (opline->extended_value & 16777216UL) != 0UL);
        } else {
          zend_error(1 << 3L, "Trying to check element of non-array");
          result = 0;
        }
      }
    } else {
      if ((int )(*container)->type == 6) {
        if (! prop_dim) {
          if ((int )offset->type != 1) {
            while (1) {
              tmp___8.value = offset->value;
              tmp___8.type = offset->type;
              break;
            }
            _zval_copy_ctor(& tmp___8);
            convert_to_long(& tmp___8);
            offset = & tmp___8;
          } else {

          }
          if ((int )offset->type == 1) {
            if (opline->extended_value & 33554432UL) {
              if (offset->value.lval >= 0L) {
                if (offset->value.lval < (long )(*container)->value.str.len) {
                  result = 1;
                } else {

                }
              } else {

              }
            } else {
              if (offset->value.lval >= 0L) {
                if (offset->value.lval < (long )(*container)->value.str.len) {
                  if ((int )*((*container)->value.str.val + offset->value.lval) != 48) {
                    result = 1;
                  } else {

                  }
                } else {

                }
              } else {

              }
            }
          } else {

          }
        } else {

        }
      } else {

      }
    }
  }
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.type = (unsigned char)3;
  if (opline->extended_value & 33554432UL) {
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.lval = (long )result;
  } else {
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.lval = (long )(! result);
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_CV(0, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_CV(1, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_NOT_SPEC_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  bitwise_not_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BOOL_NOT_SPEC_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  boolean_not_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_PRE_INC_SPEC_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **var_ptr ;
  long tmp ;
  temp_variable *__t ;
  long tmp___0 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zval *val ;
  zval *tmp___4 ;
  long tmp___5 ;
  temp_variable *__t___0 ;

  {
  opline = execute_data->opline;
  var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )var_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot increment/decrement overloaded objects nor string offsets");
    } else {

    }
  } else {

  }
  if (1 << 4 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )*var_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
    if (tmp___0) {
      if (! ((int )opline->result_type & (1 << 5))) {
        zval_addref_p(& executor_globals.uninitialized_zval);
        while (1) {
          __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
          __t->var.ptr = & executor_globals.uninitialized_zval;
          __t->var.ptr_ptr = & __t->var.ptr;
          break;
        }
      } else {

      }
      (execute_data->opline) ++;
      return (0);
    } else {

    }
  } else {

  }
  tmp___3 = zval_isref_p(*var_ptr);
  if (tmp___3) {

  } else {
    while (1) {
      tmp___2 = zval_refcount_p(*var_ptr);
      if (tmp___2 > 1U) {
        zval_delref_p(*var_ptr);
        while (1) {
          tmp___1 = _emalloc(sizeof(zval_gc_info ));
          new_zv = (zval *)tmp___1;
          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            new_zv->value = (*var_ptr)->value;
            new_zv->type = (*var_ptr)->type;
            break;
          }
          zval_set_refcount_p(new_zv, 1U);
          zval_unset_isref_p(new_zv);
          break;
        }
        *var_ptr = new_zv;
        _zval_copy_ctor(new_zv);
      } else {

      }
      break;
    }
  }
  tmp___5 = __builtin_expect((long )((int )(*var_ptr)->type == 5), 0L);
  if (tmp___5) {
    if (((*var_ptr)->value.obj.handlers)->get) {
      if (((*var_ptr)->value.obj.handlers)->set) {
        tmp___4 = (*(((*var_ptr)->value.obj.handlers)->get))(*var_ptr);
        val = tmp___4;
        zval_addref_p(val);
        fast_increment_function(val);
        (*(((*var_ptr)->value.obj.handlers)->set))(var_ptr, val);
        i_zval_ptr_dtor(val);
      } else {
        fast_increment_function(*var_ptr);
      }
    } else {
      fast_increment_function(*var_ptr);
    }
  } else {
    fast_increment_function(*var_ptr);
  }
  if (! ((int )opline->result_type & (1 << 5))) {
    zval_addref_p(*var_ptr);
    while (1) {
      __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
      __t___0->var.ptr = *var_ptr;
      __t___0->var.ptr_ptr = & __t___0->var.ptr;
      break;
    }
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_PRE_DEC_SPEC_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **var_ptr ;
  long tmp ;
  temp_variable *__t ;
  long tmp___0 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zval *val ;
  zval *tmp___4 ;
  long tmp___5 ;
  temp_variable *__t___0 ;

  {
  opline = execute_data->opline;
  var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )var_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot increment/decrement overloaded objects nor string offsets");
    } else {

    }
  } else {

  }
  if (1 << 4 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )*var_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
    if (tmp___0) {
      if (! ((int )opline->result_type & (1 << 5))) {
        zval_addref_p(& executor_globals.uninitialized_zval);
        while (1) {
          __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
          __t->var.ptr = & executor_globals.uninitialized_zval;
          __t->var.ptr_ptr = & __t->var.ptr;
          break;
        }
      } else {

      }
      (execute_data->opline) ++;
      return (0);
    } else {

    }
  } else {

  }
  tmp___3 = zval_isref_p(*var_ptr);
  if (tmp___3) {

  } else {
    while (1) {
      tmp___2 = zval_refcount_p(*var_ptr);
      if (tmp___2 > 1U) {
        zval_delref_p(*var_ptr);
        while (1) {
          tmp___1 = _emalloc(sizeof(zval_gc_info ));
          new_zv = (zval *)tmp___1;
          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            new_zv->value = (*var_ptr)->value;
            new_zv->type = (*var_ptr)->type;
            break;
          }
          zval_set_refcount_p(new_zv, 1U);
          zval_unset_isref_p(new_zv);
          break;
        }
        *var_ptr = new_zv;
        _zval_copy_ctor(new_zv);
      } else {

      }
      break;
    }
  }
  tmp___5 = __builtin_expect((long )((int )(*var_ptr)->type == 5), 0L);
  if (tmp___5) {
    if (((*var_ptr)->value.obj.handlers)->get) {
      if (((*var_ptr)->value.obj.handlers)->set) {
        tmp___4 = (*(((*var_ptr)->value.obj.handlers)->get))(*var_ptr);
        val = tmp___4;
        zval_addref_p(val);
        fast_decrement_function(val);
        (*(((*var_ptr)->value.obj.handlers)->set))(var_ptr, val);
        i_zval_ptr_dtor(val);
      } else {
        fast_decrement_function(*var_ptr);
      }
    } else {
      fast_decrement_function(*var_ptr);
    }
  } else {
    fast_decrement_function(*var_ptr);
  }
  if (! ((int )opline->result_type & (1 << 5))) {
    zval_addref_p(*var_ptr);
    while (1) {
      __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
      __t___0->var.ptr = *var_ptr;
      __t___0->var.ptr_ptr = & __t___0->var.ptr;
      break;
    }
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_POST_INC_SPEC_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **var_ptr ;
  zval *retval ;
  long tmp ;
  long tmp___0 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zval *val ;
  zval *tmp___4 ;
  long tmp___5 ;

  {
  opline = execute_data->opline;
  var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )var_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot increment/decrement overloaded objects nor string offsets");
    } else {

    }
  } else {

  }
  if (1 << 4 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )*var_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
    if (tmp___0) {
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.type = (unsigned char)0;
      (execute_data->opline) ++;
      return (0);
    } else {

    }
  } else {

  }
  retval = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    retval->value = (*var_ptr)->value;
    retval->type = (*var_ptr)->type;
    break;
  }
  _zval_copy_ctor(retval);
  tmp___3 = zval_isref_p(*var_ptr);
  if (tmp___3) {

  } else {
    while (1) {
      tmp___2 = zval_refcount_p(*var_ptr);
      if (tmp___2 > 1U) {
        zval_delref_p(*var_ptr);
        while (1) {
          tmp___1 = _emalloc(sizeof(zval_gc_info ));
          new_zv = (zval *)tmp___1;
          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            new_zv->value = (*var_ptr)->value;
            new_zv->type = (*var_ptr)->type;
            break;
          }
          zval_set_refcount_p(new_zv, 1U);
          zval_unset_isref_p(new_zv);
          break;
        }
        *var_ptr = new_zv;
        _zval_copy_ctor(new_zv);
      } else {

      }
      break;
    }
  }
  tmp___5 = __builtin_expect((long )((int )(*var_ptr)->type == 5), 0L);
  if (tmp___5) {
    if (((*var_ptr)->value.obj.handlers)->get) {
      if (((*var_ptr)->value.obj.handlers)->set) {
        tmp___4 = (*(((*var_ptr)->value.obj.handlers)->get))(*var_ptr);
        val = tmp___4;
        zval_addref_p(val);
        fast_increment_function(val);
        (*(((*var_ptr)->value.obj.handlers)->set))(var_ptr, val);
        i_zval_ptr_dtor(val);
      } else {
        fast_increment_function(*var_ptr);
      }
    } else {
      fast_increment_function(*var_ptr);
    }
  } else {
    fast_increment_function(*var_ptr);
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_POST_DEC_SPEC_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **var_ptr ;
  zval *retval ;
  long tmp ;
  long tmp___0 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zval *val ;
  zval *tmp___4 ;
  long tmp___5 ;

  {
  opline = execute_data->opline;
  var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )var_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot increment/decrement overloaded objects nor string offsets");
    } else {

    }
  } else {

  }
  if (1 << 4 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )*var_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
    if (tmp___0) {
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.type = (unsigned char)0;
      (execute_data->opline) ++;
      return (0);
    } else {

    }
  } else {

  }
  retval = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    retval->value = (*var_ptr)->value;
    retval->type = (*var_ptr)->type;
    break;
  }
  _zval_copy_ctor(retval);
  tmp___3 = zval_isref_p(*var_ptr);
  if (tmp___3) {

  } else {
    while (1) {
      tmp___2 = zval_refcount_p(*var_ptr);
      if (tmp___2 > 1U) {
        zval_delref_p(*var_ptr);
        while (1) {
          tmp___1 = _emalloc(sizeof(zval_gc_info ));
          new_zv = (zval *)tmp___1;
          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            new_zv->value = (*var_ptr)->value;
            new_zv->type = (*var_ptr)->type;
            break;
          }
          zval_set_refcount_p(new_zv, 1U);
          zval_unset_isref_p(new_zv);
          break;
        }
        *var_ptr = new_zv;
        _zval_copy_ctor(new_zv);
      } else {

      }
      break;
    }
  }
  tmp___5 = __builtin_expect((long )((int )(*var_ptr)->type == 5), 0L);
  if (tmp___5) {
    if (((*var_ptr)->value.obj.handlers)->get) {
      if (((*var_ptr)->value.obj.handlers)->set) {
        tmp___4 = (*(((*var_ptr)->value.obj.handlers)->get))(*var_ptr);
        val = tmp___4;
        zval_addref_p(val);
        fast_decrement_function(val);
        (*(((*var_ptr)->value.obj.handlers)->set))(var_ptr, val);
        i_zval_ptr_dtor(val);
      } else {
        fast_decrement_function(*var_ptr);
      }
    } else {
      fast_decrement_function(*var_ptr);
    }
  } else {
    fast_decrement_function(*var_ptr);
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ECHO_SPEC_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval z_copy ;
  zval *z ;
  int __attribute__((__visibility__("default")))  tmp ;
  long tmp___0 ;

  {
  opline = execute_data->opline;
  z = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  if (1 << 4 != 1) {
    tmp___0 = __builtin_expect((long )((int )z->type == 5), 0L);
    if (tmp___0) {
      if ((unsigned int )(z->value.obj.handlers)->get_method != (unsigned int )((void *)0)) {
        if (1 << 4 == 1 << 1) {
          z->refcount__gc = 1U;
          z->is_ref__gc = (unsigned char)0;
        } else {

        }
        tmp = zend_std_cast_object_tostring(z, & z_copy, 6);
        if (tmp == (int __attribute__((__visibility__("default")))  )0) {
          zend_print_variable(& z_copy);
          _zval_dtor(& z_copy);
        } else {
          zend_print_variable(z);
        }
      } else {
        zend_print_variable(z);
      }
    } else {
      zend_print_variable(z);
    }
  } else {
    zend_print_variable(z);
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_PRINT_SPEC_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *__z ;
  int tmp ;

  {
  opline = execute_data->opline;
  __z = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  __z->value.lval = 1L;
  __z->type = (unsigned char)1;
  tmp = ZEND_ECHO_SPEC_CV_HANDLER(execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_JMPZ_SPEC_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *val ;
  int ret ;
  long tmp ;
  long tmp___0 ;

  {
  opline = execute_data->opline;
  val = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 1) {
    tmp___0 = __builtin_expect((long )((int )val->type == 3), 1L);
    if (tmp___0) {
      ret = (int )val->value.lval;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    ret = i_zend_is_true(val);
    tmp = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
    if (tmp) {
      return (0);
    } else {

    }
  }
  if (! ret) {
    execute_data->opline = opline->op2.jmp_addr;
    return (0);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_JMPNZ_SPEC_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *val ;
  int ret ;
  long tmp ;
  long tmp___0 ;

  {
  opline = execute_data->opline;
  val = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 1) {
    tmp___0 = __builtin_expect((long )((int )val->type == 3), 1L);
    if (tmp___0) {
      ret = (int )val->value.lval;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    ret = i_zend_is_true(val);
    tmp = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
    if (tmp) {
      return (0);
    } else {

    }
  }
  if (ret) {
    execute_data->opline = opline->op2.jmp_addr;
    return (0);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_JMPZNZ_SPEC_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *val ;
  int retval ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  opline = execute_data->opline;
  val = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 1) {
    tmp___0 = __builtin_expect((long )((int )val->type == 3), 1L);
    if (tmp___0) {
      retval = (int )val->value.lval;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    retval = i_zend_is_true(val);
    tmp = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
    if (tmp) {
      return (0);
    } else {

    }
  }
  tmp___1 = __builtin_expect((long )(retval != 0), 1L);
  if (tmp___1) {
    execute_data->opline = (execute_data->op_array)->opcodes + opline->extended_value;
    return (0);
  } else {
    execute_data->opline = (execute_data->op_array)->opcodes + opline->op2.opline_num;
    return (0);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_JMPZ_EX_SPEC_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *val ;
  int retval ;
  long tmp ;
  long tmp___0 ;

  {
  opline = execute_data->opline;
  val = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 1) {
    tmp___0 = __builtin_expect((long )((int )val->type == 3), 1L);
    if (tmp___0) {
      retval = (int )val->value.lval;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    retval = i_zend_is_true(val);
    tmp = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
    if (tmp) {
      return (0);
    } else {

    }
  }
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.lval = (long )retval;
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.type = (unsigned char)3;
  if (! retval) {
    execute_data->opline = opline->op2.jmp_addr;
    return (0);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_JMPNZ_EX_SPEC_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *val ;
  int retval ;
  long tmp ;
  long tmp___0 ;

  {
  opline = execute_data->opline;
  val = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 1) {
    tmp___0 = __builtin_expect((long )((int )val->type == 3), 1L);
    if (tmp___0) {
      retval = (int )val->value.lval;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    retval = i_zend_is_true(val);
    tmp = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
    if (tmp) {
      return (0);
    } else {

    }
  }
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.lval = (long )retval;
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.type = (unsigned char)3;
  if (retval) {
    execute_data->opline = opline->op2.jmp_addr;
    return (0);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_RETURN_SPEC_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *retval_ptr ;
  zval *ret ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zval *ret___0 ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_bool tmp___1 ;
  zend_uint tmp___2 ;
  zval *ret___1 ;
  void __attribute__((__visibility__("default")))  *tmp___3 ;
  int tmp___4 ;

  {
  opline = execute_data->opline;
  retval_ptr = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  if (! executor_globals.return_value_ptr_ptr) {
    if (1 << 4 == 1 << 1) {

    } else {

    }
  } else {
    if (1 << 4 == 1) {
      goto _L___0;
    } else {
      tmp___1 = zval_isref_p(retval_ptr);
      if (tmp___1) {
        tmp___2 = zval_refcount_p(retval_ptr);
        if (tmp___2 > 0U) {
          _L___0: /* CIL Label */ 
          while (1) {
            tmp = _emalloc(sizeof(zval_gc_info ));
            ret = (zval *)tmp;
            ((zval_gc_info *)ret)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              ret->value = retval_ptr->value;
              ret->type = retval_ptr->type;
              break;
            }
            zval_set_refcount_p(ret, 1U);
            zval_unset_isref_p(ret);
            break;
          }
          _zval_copy_ctor(ret);
          *(executor_globals.return_value_ptr_ptr) = ret;
        } else {
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
        if (1 << 4 == 1 << 4) {
          goto _L;
        } else {
          if (1 << 4 == 1 << 2) {
            _L: /* CIL Label */ 
            if ((unsigned int )retval_ptr == (unsigned int )(& executor_globals.uninitialized_zval)) {
              while (1) {
                tmp___0 = _emalloc(sizeof(zval_gc_info ));
                ret___0 = (zval *)tmp___0;
                ((zval_gc_info *)ret___0)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              *ret___0 = (struct _zval_struct )zval_used_for_init;
              *(executor_globals.return_value_ptr_ptr) = ret___0;
            } else {
              *(executor_globals.return_value_ptr_ptr) = retval_ptr;
              zval_addref_p(retval_ptr);
            }
          } else {
            *(executor_globals.return_value_ptr_ptr) = retval_ptr;
            zval_addref_p(retval_ptr);
          }
        }
      }
    }
  }
  tmp___4 = zend_leave_helper_SPEC(execute_data);
  return (tmp___4);
}
}
static int ( __attribute__((__fastcall__)) ZEND_RETURN_BY_REF_SPEC_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *retval_ptr ;
  zval **retval_ptr_ptr ;
  zval *ret ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zval *ret___0 ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  long tmp___1 ;
  zend_bool tmp___2 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___3 ;
  zend_uint tmp___4 ;
  zend_bool tmp___5 ;
  int tmp___6 ;

  {
  opline = execute_data->opline;
  while (1) {
    if (1 << 4 == 1) {
      goto _L;
    } else {
      if (1 << 4 == 1 << 1) {
        _L: /* CIL Label */ 
        zend_error(1 << 3L, "Only variable references should be returned by reference");
        retval_ptr = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
        if (! executor_globals.return_value_ptr_ptr) {
          if (1 << 4 == 1 << 1) {

          } else {

          }
        } else {
          while (1) {
            tmp = _emalloc(sizeof(zval_gc_info ));
            ret = (zval *)tmp;
            ((zval_gc_info *)ret)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              ret->value = retval_ptr->value;
              ret->type = retval_ptr->type;
              break;
            }
            zval_set_refcount_p(ret, 1U);
            zval_unset_isref_p(ret);
            break;
          }
          _zval_copy_ctor(ret);
          *(executor_globals.return_value_ptr_ptr) = ret;
        }
        break;
      } else {

      }
    }
    retval_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var);
    if (1 << 4 == 1 << 2) {
      tmp___1 = __builtin_expect((long )((unsigned int )retval_ptr_ptr == (unsigned int )((void *)0)), 0L);
      if (tmp___1) {
        zend_error_noreturn(1, "Cannot return string offsets by reference");
      } else {

      }
    } else {

    }
    if (1 << 4 == 1 << 2) {
      tmp___2 = zval_isref_p(*retval_ptr_ptr);
      if (tmp___2) {

      } else {
        if (opline->extended_value == 1UL) {
          if (((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.fcall_returned_reference) {

          } else {
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
          if ((unsigned int )((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr == (unsigned int )(& ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr)) {
            zend_error(1 << 3L, "Only variable references should be returned by reference");
            if (executor_globals.return_value_ptr_ptr) {
              retval_ptr = *retval_ptr_ptr;
              *(executor_globals.return_value_ptr_ptr) = retval_ptr;
              zval_addref_p(retval_ptr);
            } else {

            }
            break;
          } else {

          }
        }
      }
    } else {

    }
    if (executor_globals.return_value_ptr_ptr) {
      tmp___5 = zval_isref_p(*retval_ptr_ptr);
      if (tmp___5) {

      } else {
        while (1) {
          tmp___4 = zval_refcount_p(*retval_ptr_ptr);
          if (tmp___4 > 1U) {
            zval_delref_p(*retval_ptr_ptr);
            while (1) {
              tmp___3 = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp___3;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*retval_ptr_ptr)->value;
                new_zv->type = (*retval_ptr_ptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *retval_ptr_ptr = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
        zval_set_isref_p(*retval_ptr_ptr);
      }
      zval_addref_p(*retval_ptr_ptr);
      *(executor_globals.return_value_ptr_ptr) = *retval_ptr_ptr;
    } else {

    }
    break;
  }
  tmp___6 = zend_leave_helper_SPEC(execute_data);
  return (tmp___6);
}
}
static int ( __attribute__((__fastcall__)) ZEND_THROW_SPEC_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *value ;
  zval *exception ;
  long tmp ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;

  {
  opline = execute_data->opline;
  value = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1) {
    zend_error_noreturn(1, "Can only throw objects");
  } else {
    tmp = __builtin_expect((long )((int )value->type != 5), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Can only throw objects");
    } else {

    }
  }
  zend_exception_save();
  while (1) {
    tmp___0 = _emalloc(sizeof(zval_gc_info ));
    exception = (zval *)tmp___0;
    ((zval_gc_info *)exception)->u.buffered = (gc_root_buffer *)((void *)0);
    break;
  }
  while (1) {
    while (1) {
      exception->value = value->value;
      exception->type = value->type;
      break;
    }
    zval_set_refcount_p(exception, 1U);
    zval_unset_isref_p(exception);
    break;
  }
  _zval_copy_ctor(exception);
  zend_throw_exception_object(exception);
  zend_exception_restore();
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_send_by_var_helper_SPEC_CV)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *varptr ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zval *original_var ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_bool tmp___1 ;

  {
  opline = execute_data->opline;
  varptr = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  if ((unsigned int )varptr == (unsigned int )(& executor_globals.uninitialized_zval)) {
    while (1) {
      tmp = _emalloc(sizeof(zval_gc_info ));
      varptr = (zval *)tmp;
      ((zval_gc_info *)varptr)->u.buffered = (gc_root_buffer *)((void *)0);
      break;
    }
    *varptr = (struct _zval_struct )zval_used_for_init;
    zval_set_refcount_p(varptr, 0U);
  } else {
    tmp___1 = zval_isref_p(varptr);
    if (tmp___1) {
      original_var = varptr;
      while (1) {
        tmp___0 = _emalloc(sizeof(zval_gc_info ));
        varptr = (zval *)tmp___0;
        ((zval_gc_info *)varptr)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      while (1) {
        varptr->value = original_var->value;
        varptr->type = original_var->type;
        break;
      }
      zval_unset_isref_p(varptr);
      zval_set_refcount_p(varptr, 0U);
      _zval_copy_ctor(varptr);
    } else {

    }
  }
  zval_addref_p(varptr);
  zend_vm_stack_push((void *)varptr);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SEND_VAR_NO_REF_SPEC_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *varptr ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  zval *valptr ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  zend_bool tmp___6 ;
  zend_uint tmp___7 ;

  {
  opline = execute_data->opline;
  if (opline->extended_value & (unsigned long )(1 << 1)) {
    if (! (opline->extended_value & 1UL)) {
      tmp = zend_send_by_var_helper_SPEC_CV(execute_data);
      return (tmp);
    } else {

    }
  } else {
    if (execute_data->fbc) {
      if ((execute_data->fbc)->common.arg_info) {
        if (opline->op2.opline_num <= (execute_data->fbc)->common.num_args) {
          tmp___1 = (unsigned int )((int )((execute_data->fbc)->common.arg_info + (opline->op2.opline_num - 1U))->pass_by_reference & 3);
        } else {
          tmp___1 = (execute_data->fbc)->common.fn_flags & 50331648U;
        }
      } else {
        tmp___1 = (execute_data->fbc)->common.fn_flags & 50331648U;
      }
      if (tmp___1) {

      } else {
        tmp___0 = zend_send_by_var_helper_SPEC_CV(execute_data);
        return (tmp___0);
      }
    } else {
      tmp___0 = zend_send_by_var_helper_SPEC_CV(execute_data);
      return (tmp___0);
    }
  }
  if (1 << 4 == 1 << 2) {
    if (opline->extended_value & (unsigned long )(1 << 2)) {
      if (((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.fcall_returned_reference) {
        if (((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr) {
          varptr = ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr;
          zend_pzval_unlock_func(varptr, & free_op1, 0);
        } else {
          varptr = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
        }
      } else {
        varptr = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
      }
    } else {
      varptr = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
    }
  } else {
    varptr = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  }
  if (! (opline->extended_value & (unsigned long )(1 << 2))) {
    goto _L___1;
  } else {
    if (((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.fcall_returned_reference) {
      _L___1: /* CIL Label */ 
      if ((unsigned int )varptr != (unsigned int )(& executor_globals.uninitialized_zval)) {
        tmp___6 = zval_isref_p(varptr);
        if (tmp___6) {
          zval_set_isref_p(varptr);
          zval_addref_p(varptr);
          zend_vm_stack_push((void *)varptr);
        } else {
          tmp___7 = zval_refcount_p(varptr);
          if (tmp___7 == 1U) {
            if (1 << 4 == 1 << 4) {
              zval_set_isref_p(varptr);
              zval_addref_p(varptr);
              zend_vm_stack_push((void *)varptr);
            } else {
              if (free_op1.var) {
                zval_set_isref_p(varptr);
                zval_addref_p(varptr);
                zend_vm_stack_push((void *)varptr);
              } else {
                goto _L___0;
              }
            }
          } else {
            goto _L___0;
          }
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      _L: /* CIL Label */ 
      if (opline->extended_value & (unsigned long )(1 << 1)) {
        tmp___4 = ! (opline->extended_value & (unsigned long )(1 << 3));
      } else {
        if (execute_data->fbc) {
          if ((execute_data->fbc)->common.arg_info) {
            if (opline->op2.opline_num <= (execute_data->fbc)->common.num_args) {
              tmp___2 = (unsigned int )((int )((execute_data->fbc)->common.arg_info + (opline->op2.opline_num - 1U))->pass_by_reference & 2);
            } else {
              tmp___2 = (execute_data->fbc)->common.fn_flags & 33554432U;
            }
          } else {
            tmp___2 = (execute_data->fbc)->common.fn_flags & 33554432U;
          }
          if (tmp___2) {
            tmp___3 = 0;
          } else {
            tmp___3 = 1;
          }
        } else {
          tmp___3 = 1;
        }
        tmp___4 = tmp___3;
      }
      if (tmp___4) {
        zend_error(1 << 11L, "Only variables should be passed by reference");
      } else {

      }
      while (1) {
        tmp___5 = _emalloc(sizeof(zval_gc_info ));
        valptr = (zval *)tmp___5;
        ((zval_gc_info *)valptr)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      while (1) {
        while (1) {
          valptr->value = varptr->value;
          valptr->type = varptr->type;
          break;
        }
        zval_set_refcount_p(valptr, 1U);
        zval_unset_isref_p(valptr);
        break;
      }
      _zval_copy_ctor(valptr);
      zend_vm_stack_push((void *)valptr);
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SEND_REF_SPEC_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **varptr_ptr ;
  zval *varptr ;
  long tmp ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_uint tmp___5 ;
  zend_bool tmp___6 ;

  {
  opline = execute_data->opline;
  varptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )varptr_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Only variables can be passed by reference");
    } else {

    }
  } else {

  }
  if (1 << 4 == 1 << 2) {
    tmp___1 = __builtin_expect((long )((unsigned int )*varptr_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
    if (tmp___1) {
      while (1) {
        tmp___0 = _emalloc(sizeof(zval_gc_info ));
        varptr = (zval *)tmp___0;
        ((zval_gc_info *)varptr)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      *varptr = (struct _zval_struct )zval_used_for_init;
      zend_vm_stack_push((void *)varptr);
      (execute_data->opline) ++;
      return (0);
    } else {

    }
  } else {

  }
  if ((int )(execute_data->function_state.function)->type == 1) {
    if (execute_data->fbc) {
      if ((execute_data->fbc)->common.arg_info) {
        if (opline->op2.opline_num <= (execute_data->fbc)->common.num_args) {
          tmp___3 = (unsigned int )((int )((execute_data->fbc)->common.arg_info + (opline->op2.opline_num - 1U))->pass_by_reference & 3);
        } else {
          tmp___3 = (execute_data->fbc)->common.fn_flags & 50331648U;
        }
      } else {
        tmp___3 = (execute_data->fbc)->common.fn_flags & 50331648U;
      }
      if (tmp___3) {

      } else {
        tmp___2 = zend_send_by_var_helper_SPEC_CV(execute_data);
        return (tmp___2);
      }
    } else {
      tmp___2 = zend_send_by_var_helper_SPEC_CV(execute_data);
      return (tmp___2);
    }
  } else {

  }
  tmp___6 = zval_isref_p(*varptr_ptr);
  if (tmp___6) {

  } else {
    while (1) {
      tmp___5 = zval_refcount_p(*varptr_ptr);
      if (tmp___5 > 1U) {
        zval_delref_p(*varptr_ptr);
        while (1) {
          tmp___4 = _emalloc(sizeof(zval_gc_info ));
          new_zv = (zval *)tmp___4;
          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            new_zv->value = (*varptr_ptr)->value;
            new_zv->type = (*varptr_ptr)->type;
            break;
          }
          zval_set_refcount_p(new_zv, 1U);
          zval_unset_isref_p(new_zv);
          break;
        }
        *varptr_ptr = new_zv;
        _zval_copy_ctor(new_zv);
      } else {

      }
      break;
    }
    zval_set_isref_p(*varptr_ptr);
  }
  varptr = *varptr_ptr;
  zval_addref_p(varptr);
  zend_vm_stack_push((void *)varptr);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SEND_VAR_SPEC_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  if (opline->extended_value == 61UL) {
    if (execute_data->fbc) {
      if ((execute_data->fbc)->common.arg_info) {
        if (opline->op2.opline_num <= (execute_data->fbc)->common.num_args) {
          tmp___0 = (unsigned int )((int )((execute_data->fbc)->common.arg_info + (opline->op2.opline_num - 1U))->pass_by_reference & 3);
        } else {
          tmp___0 = (execute_data->fbc)->common.fn_flags & 50331648U;
        }
      } else {
        tmp___0 = (execute_data->fbc)->common.fn_flags & 50331648U;
      }
      if (tmp___0) {
        tmp = ZEND_SEND_REF_SPEC_CV_HANDLER(execute_data);
        return (tmp);
      } else {

      }
    } else {

    }
  } else {

  }
  tmp___1 = zend_send_by_var_helper_SPEC_CV(execute_data);
  return (tmp___1);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BOOL_SPEC_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *retval ;
  zval *__z ;
  zval *tmp ;
  int tmp___0 ;

  {
  opline = execute_data->opline;
  retval = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = retval;
    tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
    tmp___0 = i_zend_is_true(tmp);
    __z->value.lval = (long )(tmp___0 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_CLONE_SPEC_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *obj ;
  zend_class_entry *ce ;
  zend_function *clone ;
  zend_object_value (*clone_call)(zval *object ) ;
  long tmp ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  long tmp___1 ;
  char const   *tmp___2 ;
  long tmp___3 ;
  char const   *tmp___4 ;
  int __attribute__((__visibility__("default")))  tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  zval *retval ;
  void __attribute__((__visibility__("default")))  *tmp___8 ;
  temp_variable *__t ;
  long tmp___9 ;
  long tmp___10 ;

  {
  opline = execute_data->opline;
  obj = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1) {
    zend_error_noreturn(1, "__clone method called on non-object");
  } else {
    tmp = __builtin_expect((long )((int )obj->type != 5), 0L);
    if (tmp) {
      zend_error_noreturn(1, "__clone method called on non-object");
    } else {

    }
  }
  tmp___0 = zend_get_class_entry((zval const   *)obj);
  ce = (zend_class_entry *)tmp___0;
  if (ce) {
    clone = ce->clone;
  } else {
    clone = (zend_function *)((void *)0);
  }
  clone_call = (zend_object_value (*)(zval *object ))(obj->value.obj.handlers)->clone_obj;
  tmp___1 = __builtin_expect((long )((unsigned int )clone_call == (unsigned int )((void *)0)), 0L);
  if (tmp___1) {
    if (ce) {
      zend_error_noreturn(1, "Trying to clone an uncloneable object of class %s", ce->name);
    } else {
      zend_error_noreturn(1, "Trying to clone an uncloneable object");
    }
  } else {

  }
  if (ce) {
    if (clone) {
      if (clone->op_array.fn_flags & 1024U) {
        tmp___3 = __builtin_expect((long )((unsigned int )ce != (unsigned int )executor_globals.scope), 0L);
        if (tmp___3) {
          if (executor_globals.scope) {
            tmp___2 = (executor_globals.scope)->name;
          } else {
            tmp___2 = "";
          }
          zend_error_noreturn(1, "Call to private %s::__clone() from context \'%s\'", ce->name, tmp___2);
        } else {

        }
      } else {
        if (clone->common.fn_flags & 512U) {
          tmp___5 = zend_check_protected(clone->common.scope, executor_globals.scope);
          if (tmp___5) {
            tmp___6 = 0;
          } else {
            tmp___6 = 1;
          }
          tmp___7 = __builtin_expect((long )tmp___6, 0L);
          if (tmp___7) {
            if (executor_globals.scope) {
              tmp___4 = (executor_globals.scope)->name;
            } else {
              tmp___4 = "";
            }
            zend_error_noreturn(1, "Call to protected %s::__clone() from context \'%s\'", ce->name, tmp___4);
          } else {

          }
        } else {

        }
      }
    } else {

    }
  } else {

  }
  tmp___10 = __builtin_expect((long )((unsigned int )executor_globals.exception == (unsigned int )((void *)0)), 1L);
  if (tmp___10) {
    while (1) {
      tmp___8 = _emalloc(sizeof(zval_gc_info ));
      retval = (zval *)tmp___8;
      ((zval_gc_info *)retval)->u.buffered = (gc_root_buffer *)((void *)0);
      break;
    }
    retval->value.obj = (*clone_call)(obj);
    retval->type = (unsigned char)5;
    zval_set_refcount_p(retval, 1U);
    zval_set_isref_p(retval);
    if (! (! ((int )opline->result_type & (1 << 5)))) {
      i_zval_ptr_dtor(retval);
    } else {
      tmp___9 = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
      if (tmp___9) {
        i_zval_ptr_dtor(retval);
      } else {
        while (1) {
          __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
          __t->var.ptr = retval;
          __t->var.ptr_ptr = & __t->var.ptr;
          break;
        }
      }
    }
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_CAST_SPEC_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *expr ;
  zval *result ;
  zval var_copy ;
  int use_copy ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  expr = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  if (opline->extended_value != 6UL) {
    while (1) {
      result->value = expr->value;
      result->type = expr->type;
      break;
    }
    _zval_copy_ctor(result);
  } else {

  }
  switch ((int )opline->extended_value) {
  case 0: 
  convert_to_null(result);
  break;
  case 3: 
  convert_to_boolean(result);
  break;
  case 1: 
  convert_to_long(result);
  break;
  case 2: 
  convert_to_double(result);
  break;
  case 6: 
  zend_make_printable_zval(expr, & var_copy, & use_copy);
  if (use_copy) {
    while (1) {
      result->value = var_copy.value;
      result->type = var_copy.type;
      break;
    }
  } else {
    while (1) {
      result->value = expr->value;
      result->type = expr->type;
      break;
    }
    _zval_copy_ctor(result);
  }
  break;
  case 4: 
  convert_to_array(result);
  break;
  case 5: 
  convert_to_object(result);
  break;
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INCLUDE_OR_EVAL_SPEC_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_op_array *new_op_array ;
  zval *inc_filename ;
  zval tmp_inc_filename ;
  zend_bool failure_retval ;
  zend_file_handle file_handle ;
  char *resolved_path ;
  char __attribute__((__visibility__("default")))  *tmp ;
  size_t tmp___0 ;
  int __attribute__((__visibility__("default")))  tmp___1 ;
  char __attribute__((__visibility__("default")))  *tmp___2 ;
  int tmp___3 ;
  zend_op_array __attribute__((__visibility__("default")))  *tmp___4 ;
  size_t tmp___5 ;
  int __attribute__((__visibility__("default")))  tmp___6 ;
  int __attribute__((__visibility__("default")))  tmp___7 ;
  zend_op_array __attribute__((__visibility__("default")))  *tmp___8 ;
  char *eval_desc ;
  char __attribute__((__visibility__("default")))  *tmp___9 ;
  zend_op_array __attribute__((__visibility__("default")))  *tmp___10 ;
  size_t tmp___11 ;
  long tmp___12 ;
  zval *retval ;
  void __attribute__((__visibility__("default")))  *tmp___13 ;
  zval *__z ;
  long tmp___14 ;
  zval *retval___0 ;
  void __attribute__((__visibility__("default")))  *tmp___15 ;
  zval *__z___0 ;
  temp_variable *__t ;
  long tmp___16 ;
  long tmp___17 ;

  {
  opline = execute_data->opline;
  new_op_array = (zend_op_array *)((void *)0);
  failure_retval = (zend_bool )0;
  inc_filename = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  if ((int )inc_filename->type != 6) {
    while (1) {
      tmp_inc_filename.value = inc_filename->value;
      tmp_inc_filename.type = inc_filename->type;
      break;
    }
    _zval_copy_ctor(& tmp_inc_filename);
    if ((int )tmp_inc_filename.type != 6) {
      _convert_to_string(& tmp_inc_filename);
    } else {

    }
    inc_filename = & tmp_inc_filename;
  } else {

  }
  if (opline->extended_value != 1UL) {
    tmp___11 = strlen((char const   *)inc_filename->value.str.val);
    if (tmp___11 != (size_t )inc_filename->value.str.len) {
      if (opline->extended_value == (ulong )(1 << 2)) {
        zend_message_dispatcher(1L, (void const   *)inc_filename->value.str.val);
      } else {
        if (opline->extended_value == (ulong )(1 << 1)) {
          zend_message_dispatcher(1L, (void const   *)inc_filename->value.str.val);
        } else {
          zend_message_dispatcher(2L, (void const   *)inc_filename->value.str.val);
        }
      }
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    switch ((int )opline->extended_value) {
    case 1 << 2: 
    case 1 << 4: 
    tmp = (*zend_resolve_path)((char const   *)inc_filename->value.str.val, inc_filename->value.str.len);
    resolved_path = (char *)tmp;
    if (resolved_path) {
      tmp___0 = strlen((char const   *)resolved_path);
      tmp___1 = zend_hash_exists((HashTable const   *)(& executor_globals.included_files), (char const   *)resolved_path, tmp___0 + 1U);
      failure_retval = (unsigned char )tmp___1;
    } else {
      resolved_path = inc_filename->value.str.val;
    }
    if (failure_retval) {

    } else {
      tmp___7 = zend_stream_open((char const   *)resolved_path, & file_handle);
      if (0 == (int )tmp___7) {
        if (! file_handle.opened_path) {
          tmp___2 = _estrdup((char const   *)resolved_path);
          file_handle.opened_path = (char *)tmp___2;
        } else {

        }
        tmp___5 = strlen((char const   *)file_handle.opened_path);
        tmp___6 = zend_hash_add_empty_element(& executor_globals.included_files, (char const   *)file_handle.opened_path, tmp___5 + 1U);
        if (tmp___6 == (int __attribute__((__visibility__("default")))  )0) {
          if (opline->extended_value == (ulong )(1 << 2)) {
            tmp___3 = 1 << 1;
          } else {
            tmp___3 = 1 << 3;
          }
          tmp___4 = (*zend_compile_file)(& file_handle, tmp___3);
          new_op_array = (zend_op_array *)tmp___4;
          zend_destroy_file_handle(& file_handle);
        } else {
          zend_file_handle_dtor(& file_handle);
          failure_retval = (unsigned char)1;
        }
      } else {
        if (opline->extended_value == (ulong )(1 << 2)) {
          zend_message_dispatcher(1L, (void const   *)inc_filename->value.str.val);
        } else {
          zend_message_dispatcher(2L, (void const   *)inc_filename->value.str.val);
        }
      }
    }
    if ((unsigned int )resolved_path != (unsigned int )inc_filename->value.str.val) {
      _efree((void *)resolved_path);
    } else {

    }
    break;
    case 1 << 1: 
    case 1 << 3: 
    tmp___8 = compile_filename((int )opline->extended_value, inc_filename);
    new_op_array = (zend_op_array *)tmp___8;
    break;
    case 1: 
    tmp___9 = zend_make_compiled_string_description("eval()\'d code");
    eval_desc = (char *)tmp___9;
    tmp___10 = (*zend_compile_string)(inc_filename, eval_desc);
    new_op_array = (zend_op_array *)tmp___10;
    _efree((void *)eval_desc);
    break;
    }
  }
  if ((unsigned int )inc_filename == (unsigned int )(& tmp_inc_filename)) {
    _zval_dtor(& tmp_inc_filename);
  } else {

  }
  tmp___17 = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
  if (tmp___17) {
    return (0);
  } else {
    tmp___16 = __builtin_expect((long )((unsigned int )new_op_array != (unsigned int )((void *)0)), 1L);
    if (tmp___16) {
      execute_data->original_return_value = executor_globals.return_value_ptr_ptr;
      executor_globals.active_op_array = new_op_array;
      if (! ((int )opline->result_type & (1 << 5))) {
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = (zval *)((void *)0);
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
        executor_globals.return_value_ptr_ptr = ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr;
      } else {
        executor_globals.return_value_ptr_ptr = (zval **)((void *)0);
      }
      execute_data->current_object = execute_data->object;
      execute_data->function_state.function = (zend_function *)new_op_array;
      execute_data->object = (zval *)((void *)0);
      if (! executor_globals.active_symbol_table) {
        zend_rebuild_symbol_table();
      } else {

      }
      tmp___12 = __builtin_expect((long )((unsigned int )zend_execute == (unsigned int )(& execute)), 1L);
      if (tmp___12) {
        return (2);
      } else {
        (*zend_execute)(new_op_array);
      }
      execute_data->function_state.function = (zend_function *)execute_data->op_array;
      execute_data->object = execute_data->current_object;
      executor_globals.opline_ptr = & execute_data->opline;
      executor_globals.active_op_array = execute_data->op_array;
      executor_globals.return_value_ptr_ptr = execute_data->original_return_value;
      destroy_op_array(new_op_array);
      _efree((void *)new_op_array);
      tmp___14 = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
      if (tmp___14) {
        zend_throw_exception_internal((zval *)((void *)0));
        return (0);
      } else {
        if (! ((int )opline->result_type & (1 << 5))) {
          if (! ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr) {
            while (1) {
              tmp___13 = _emalloc(sizeof(zval_gc_info ));
              retval = (zval *)tmp___13;
              ((zval_gc_info *)retval)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              __z = retval;
              __z->value.lval = 1L;
              __z->type = (unsigned char)3;
              break;
            }
            retval->refcount__gc = 1U;
            retval->is_ref__gc = (unsigned char)0;
            ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = retval;
          } else {

          }
        } else {

        }
      }
    } else {
      if (! ((int )opline->result_type & (1 << 5))) {
        while (1) {
          tmp___15 = _emalloc(sizeof(zval_gc_info ));
          retval___0 = (zval *)tmp___15;
          ((zval_gc_info *)retval___0)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          __z___0 = retval___0;
          __z___0->value.lval = (long )((int )failure_retval != 0);
          __z___0->type = (unsigned char)3;
          break;
        }
        retval___0->refcount__gc = 1U;
        retval___0->is_ref__gc = (unsigned char)0;
        while (1) {
          __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
          __t->var.ptr = retval___0;
          __t->var.ptr_ptr = & __t->var.ptr;
          break;
        }
      } else {

      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FE_RESET_SPEC_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *array_ptr ;
  zval **array_ptr_ptr ;
  HashTable *fe_ht ;
  zend_object_iterator *iter ;
  zend_class_entry *ce ;
  zend_bool is_empty ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___1 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_uint tmp___3 ;
  zend_bool tmp___4 ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  zend_uint tmp___6 ;
  zend_bool tmp___7 ;
  zval *tmp___8 ;
  void __attribute__((__visibility__("default")))  *tmp___9 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___10 ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___11 ;
  zval *tmp___12 ;
  void __attribute__((__visibility__("default")))  *tmp___13 ;
  zend_bool tmp___14 ;
  zend_uint tmp___15 ;
  zval __attribute__((__visibility__("default")))  *tmp___16 ;
  long tmp___17 ;
  long tmp___18 ;
  int tmp___19 ;
  long tmp___20 ;
  zend_object *zobj ;
  zend_object __attribute__((__visibility__("default")))  *tmp___21 ;
  char *str_key ;
  uint str_key_len ;
  ulong int_key ;
  zend_uchar key_type ;
  int __attribute__((__visibility__("default")))  tmp___22 ;
  int __attribute__((__visibility__("default")))  tmp___23 ;
  int __attribute__((__visibility__("default")))  tmp___24 ;
  int tmp___25 ;
  int __attribute__((__visibility__("default")))  tmp___26 ;
  int __attribute__((__visibility__("default")))  tmp___27 ;
  int tmp___28 ;
  int __attribute__((__visibility__("default")))  tmp___29 ;
  HashTable *tmp___30 ;
  HashTable *tmp___31 ;
  long tmp___32 ;

  {
  opline = execute_data->opline;
  iter = (zend_object_iterator *)((void *)0);
  ce = (zend_class_entry *)((void *)0);
  is_empty = (zend_bool )0;
  if (1 << 4 == 1 << 4) {
    goto _L___4;
  } else {
    if (1 << 4 == 1 << 2) {
      _L___4: /* CIL Label */ 
      if (opline->extended_value & 1UL) {
        array_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
        if ((unsigned int )array_ptr_ptr == (unsigned int )((void *)0)) {
          goto _L___0;
        } else {
          if ((unsigned int )array_ptr_ptr == (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
            _L___0: /* CIL Label */ 
            while (1) {
              tmp = _emalloc(sizeof(zval_gc_info ));
              array_ptr = (zval *)tmp;
              ((zval_gc_info *)array_ptr)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            array_ptr->refcount__gc = 1U;
            array_ptr->is_ref__gc = (unsigned char)0;
            array_ptr->type = (unsigned char)0;
          } else {
            if ((int )(*array_ptr_ptr)->type == 5) {
              if ((unsigned int )((*array_ptr_ptr)->value.obj.handlers)->get_class_entry == (unsigned int )((void *)0)) {
                zend_error(1 << 1L, "foreach() cannot iterate over objects without PHP class");
                tmp___0 = __builtin_expect((long )(! executor_globals.exception), 1L);
                if (tmp___0) {
                  execute_data->opline = (execute_data->op_array)->opcodes + opline->op2.opline_num;
                } else {

                }
                return (0);
              } else {

              }
              tmp___1 = zend_get_class_entry((zval const   *)*array_ptr_ptr);
              ce = (zend_class_entry *)tmp___1;
              if (! ce) {
                goto _L;
              } else {
                if ((unsigned int )ce->get_iterator == (unsigned int )((void *)0)) {
                  _L: /* CIL Label */ 
                  tmp___4 = zval_isref_p(*array_ptr_ptr);
                  if (tmp___4) {

                  } else {
                    while (1) {
                      tmp___3 = zval_refcount_p(*array_ptr_ptr);
                      if (tmp___3 > 1U) {
                        zval_delref_p(*array_ptr_ptr);
                        while (1) {
                          tmp___2 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___2;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*array_ptr_ptr)->value;
                            new_zv->type = (*array_ptr_ptr)->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *array_ptr_ptr = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  }
                  zval_addref_p(*array_ptr_ptr);
                } else {

                }
              }
              array_ptr = *array_ptr_ptr;
            } else {
              if ((int )(*array_ptr_ptr)->type == 4) {
                tmp___7 = zval_isref_p(*array_ptr_ptr);
                if (tmp___7) {

                } else {
                  while (1) {
                    tmp___6 = zval_refcount_p(*array_ptr_ptr);
                    if (tmp___6 > 1U) {
                      zval_delref_p(*array_ptr_ptr);
                      while (1) {
                        tmp___5 = _emalloc(sizeof(zval_gc_info ));
                        new_zv___0 = (zval *)tmp___5;
                        ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                        break;
                      }
                      while (1) {
                        while (1) {
                          new_zv___0->value = (*array_ptr_ptr)->value;
                          new_zv___0->type = (*array_ptr_ptr)->type;
                          break;
                        }
                        zval_set_refcount_p(new_zv___0, 1U);
                        zval_unset_isref_p(new_zv___0);
                        break;
                      }
                      *array_ptr_ptr = new_zv___0;
                      _zval_copy_ctor(new_zv___0);
                    } else {

                    }
                    break;
                  }
                }
                if (opline->extended_value & 1UL) {
                  zval_set_isref_p(*array_ptr_ptr);
                } else {

                }
              } else {

              }
              array_ptr = *array_ptr_ptr;
              zval_addref_p(array_ptr);
            }
          }
        }
      } else {
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ 
      array_ptr = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
      if ((int )array_ptr->type == 5) {
        tmp___11 = zend_get_class_entry((zval const   *)array_ptr);
        ce = (zend_class_entry *)tmp___11;
        if (! ce) {
          zval_addref_p(array_ptr);
        } else {
          if (! ce->get_iterator) {
            zval_addref_p(array_ptr);
          } else {

          }
        }
      } else {
        if (1 << 4 == 1) {
          goto _L___1;
        } else {
          if (1 << 4 == 1 << 4) {
            goto _L___2;
          } else {
            if (1 << 4 == 1 << 2) {
              _L___2: /* CIL Label */ 
              tmp___14 = zval_isref_p(array_ptr);
              if (tmp___14) {
                zval_addref_p(array_ptr);
              } else {
                tmp___15 = zval_refcount_p(array_ptr);
                if (tmp___15 > 1U) {
                  _L___1: /* CIL Label */ 
                  while (1) {
                    tmp___13 = _emalloc(sizeof(zval_gc_info ));
                    tmp___12 = (zval *)tmp___13;
                    ((zval_gc_info *)tmp___12)->u.buffered = (gc_root_buffer *)((void *)0);
                    break;
                  }
                  while (1) {
                    while (1) {
                      tmp___12->value = array_ptr->value;
                      tmp___12->type = array_ptr->type;
                      break;
                    }
                    zval_set_refcount_p(tmp___12, 1U);
                    zval_unset_isref_p(tmp___12);
                    break;
                  }
                  _zval_copy_ctor(tmp___12);
                  array_ptr = tmp___12;
                } else {
                  zval_addref_p(array_ptr);
                }
              }
            } else {
              zval_addref_p(array_ptr);
            }
          }
        }
      }
    }
  }
  if (ce) {
    if (ce->get_iterator) {
      iter = (*(ce->get_iterator))(ce, array_ptr, (int )(opline->extended_value & (unsigned long )(1 << 1)));
      if (iter) {
        tmp___17 = __builtin_expect((long )((unsigned int )executor_globals.exception == (unsigned int )((void *)0)), 1L);
        if (tmp___17) {
          tmp___16 = zend_iterator_wrap(iter);
          array_ptr = (zval *)tmp___16;
        } else {
          goto _L___5;
        }
      } else {
        _L___5: /* CIL Label */ 
        if (! executor_globals.exception) {
          zend_throw_exception_ex((zend_class_entry *)((void *)0), 0L, (char *)"Object of type %s did not create an Iterator", ce->name);
        } else {

        }
        zend_throw_exception_internal((zval *)((void *)0));
        return (0);
      }
    } else {

    }
  } else {

  }
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->fe.ptr = array_ptr;
  if (iter) {
    iter->index = 0UL;
    if ((iter->funcs)->rewind) {
      (*((iter->funcs)->rewind))(iter);
      tmp___18 = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
      if (tmp___18) {
        i_zval_ptr_dtor(array_ptr);
        return (0);
      } else {

      }
    } else {

    }
    tmp___19 = (*((iter->funcs)->valid))(iter);
    is_empty = (unsigned char )(tmp___19 != 0);
    tmp___20 = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
    if (tmp___20) {
      i_zval_ptr_dtor(array_ptr);
      return (0);
    } else {

    }
    iter->index = 4294967295UL;
  } else {
    if ((int )array_ptr->type == 4) {
      fe_ht = array_ptr->value.ht;
    } else {
      if ((int )array_ptr->type == 5) {
        tmp___30 = (*((array_ptr->value.obj.handlers)->get_properties))(array_ptr);
        tmp___31 = tmp___30;
      } else {
        tmp___31 = (HashTable *)((void *)0);
      }
      fe_ht = tmp___31;
    }
    if ((unsigned int )fe_ht != (unsigned int )((void *)0)) {
      zend_hash_internal_pointer_reset_ex(fe_ht, (HashPosition *)((void *)0));
      if (ce) {
        tmp___21 = zend_objects_get_address((zval const   *)array_ptr);
        zobj = (zend_object *)tmp___21;
        while (1) {
          tmp___26 = zend_hash_get_current_key_type_ex(fe_ht, (HashPosition *)((void *)0));
          if (tmp___26 == (int __attribute__((__visibility__("default")))  )3) {
            tmp___25 = -1;
          } else {
            tmp___25 = 0;
          }
          if (tmp___25 == 0) {

          } else {
            break;
          }
          tmp___22 = zend_hash_get_current_key_ex((HashTable const   *)fe_ht, & str_key, & str_key_len, & int_key, (unsigned char)0, (HashPosition *)((void *)0));
          key_type = (unsigned char )tmp___22;
          if ((int )key_type != 3) {
            if ((int )key_type == 2) {
              break;
            } else {
              tmp___23 = zend_check_property_access(zobj, (char const   *)str_key, (int )(str_key_len - 1U));
              if (tmp___23 == (int __attribute__((__visibility__("default")))  )0) {
                break;
              } else {

              }
            }
          } else {

          }
          zend_hash_move_forward_ex(fe_ht, (HashPosition *)((void *)0));
        }
      } else {

      }
      tmp___29 = zend_hash_get_current_key_type_ex(fe_ht, (HashPosition *)((void *)0));
      if (tmp___29 == (int __attribute__((__visibility__("default")))  )3) {
        tmp___28 = -1;
      } else {
        tmp___28 = 0;
      }
      is_empty = (unsigned char )(tmp___28 != 0);
      zend_hash_get_pointer((HashTable const   *)fe_ht, & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->fe.fe_pos);
    } else {
      zend_error(1 << 1L, "Invalid argument supplied for foreach()");
      is_empty = (unsigned char)1;
    }
  }
  if (is_empty) {
    tmp___32 = __builtin_expect((long )(! executor_globals.exception), 1L);
    if (tmp___32) {
      execute_data->opline = (execute_data->op_array)->opcodes + opline->op2.opline_num;
    } else {

    }
    return (0);
  } else {
    (execute_data->opline) ++;
    return (0);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_EXIT_SPEC_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *ptr ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  if (1 << 4 != 1 << 3) {
    tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
    ptr = tmp;
    if ((int )ptr->type == 1) {
      executor_globals.exit_status = (int )ptr->value.lval;
    } else {
      zend_print_variable(ptr);
    }
  } else {

  }
  _zend_bailout((char *)"/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-12-18-beda5efd41-622412d8e6/php/Zend/zend_vm_execute.h", 27307U);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_JMP_SET_SPEC_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *value ;
  long tmp ;
  int tmp___0 ;

  {
  opline = execute_data->opline;
  value = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  tmp___0 = i_zend_is_true(value);
  if (tmp___0) {
    while (1) {
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value = value->value;
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.type = value->type;
      break;
    }
    _zval_copy_ctor(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var);
    tmp = __builtin_expect((long )(! executor_globals.exception), 1L);
    if (tmp) {
      execute_data->opline = opline->op2.jmp_addr;
    } else {

    }
    return (0);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_JMP_SET_VAR_SPEC_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *value ;
  zval *ret ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  value = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  tmp___1 = i_zend_is_true(value);
  if (tmp___1) {
    if (1 << 4 == 1 << 2) {
      zval_addref_p(value);
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = value;
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
    } else {
      if (1 << 4 == 1 << 4) {
        zval_addref_p(value);
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = value;
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
      } else {
        while (1) {
          tmp = _emalloc(sizeof(zval_gc_info ));
          ret = (zval *)tmp;
          ((zval_gc_info *)ret)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            ret->value = value->value;
            ret->type = value->type;
            break;
          }
          zval_set_refcount_p(ret, 1U);
          zval_unset_isref_p(ret);
          break;
        }
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = ret;
        ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
        _zval_copy_ctor(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr);
      }
    }
    tmp___0 = __builtin_expect((long )(! executor_globals.exception), 1L);
    if (tmp___0) {
      execute_data->opline = opline->op2.jmp_addr;
    } else {

    }
    return (0);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_QM_ASSIGN_SPEC_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *value ;

  {
  opline = execute_data->opline;
  value = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  while (1) {
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value = value->value;
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.type = value->type;
    break;
  }
  _zval_copy_ctor(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_QM_ASSIGN_VAR_SPEC_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *value ;
  zval *ret ;
  void __attribute__((__visibility__("default")))  *tmp ;

  {
  opline = execute_data->opline;
  value = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 2) {
    zval_addref_p(value);
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = value;
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
  } else {
    if (1 << 4 == 1 << 4) {
      zval_addref_p(value);
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = value;
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
    } else {
      while (1) {
        tmp = _emalloc(sizeof(zval_gc_info ));
        ret = (zval *)tmp;
        ((zval_gc_info *)ret)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      while (1) {
        while (1) {
          ret->value = value->value;
          ret->type = value->type;
          break;
        }
        zval_set_refcount_p(ret, 1U);
        zval_unset_isref_p(ret);
        break;
      }
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = ret;
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
      _zval_copy_ctor(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr);
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INSTANCEOF_SPEC_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *expr ;
  zend_bool result ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp ;
  zend_bool __attribute__((__visibility__("default")))  tmp___0 ;
  zval *__z ;

  {
  opline = execute_data->opline;
  expr = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  if ((int )expr->type == 5) {
    if ((expr->value.obj.handlers)->get_class_entry) {
      tmp = zend_get_class_entry((zval const   *)expr);
      tmp___0 = instanceof_function((zend_class_entry const   *)tmp, (zend_class_entry const   *)((temp_variable *)((char *)execute_data->Ts + opline->op2.var))->class_entry);
      result = (unsigned char )tmp___0;
    } else {
      result = (unsigned char)0;
    }
  } else {
    result = (unsigned char)0;
  }
  while (1) {
    __z = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
    __z->value.lval = (long )((int )result != 0);
    __z->type = (unsigned char)3;
    break;
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  fast_add_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp, opline->op2.zv);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SUB_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  fast_sub_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp, opline->op2.zv);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_MUL_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  fast_mul_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp, opline->op2.zv);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_DIV_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  fast_div_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp, opline->op2.zv);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_MOD_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  fast_mod_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp, opline->op2.zv);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SL_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  shift_left_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp, opline->op2.zv);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SR_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  shift_right_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp, opline->op2.zv);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_CONCAT_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  concat_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp, opline->op2.zv);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_IDENTICAL_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  is_identical_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp, opline->op2.zv);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_NOT_IDENTICAL_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *result ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  is_identical_function(result, tmp, opline->op2.zv);
  result->value.lval = (long )(! result->value.lval);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_EQUAL_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  int tmp___0 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
    tmp___0 = fast_equal_function(result, tmp, opline->op2.zv);
    __z->value.lval = (long )(tmp___0 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_NOT_EQUAL_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  int tmp___0 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
    tmp___0 = fast_not_equal_function(result, tmp, opline->op2.zv);
    __z->value.lval = (long )(tmp___0 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_SMALLER_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  int tmp___0 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
    tmp___0 = fast_is_smaller_function(result, tmp, opline->op2.zv);
    __z->value.lval = (long )(tmp___0 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  int tmp___0 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
    tmp___0 = fast_is_smaller_or_equal_function(result, tmp, opline->op2.zv);
    __z->value.lval = (long )(tmp___0 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_OR_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  bitwise_or_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp, opline->op2.zv);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_AND_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  bitwise_and_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp, opline->op2.zv);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_XOR_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  bitwise_xor_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp, opline->op2.zv);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BOOL_XOR_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  boolean_xor_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp, opline->op2.zv);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_binary_assign_op_obj_helper_SPEC_CV_CONST)(int (*binary_op)(zval *result , zval *op1 , zval *op2 ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op_data1 ;
  zval **object_ptr ;
  zval **tmp ;
  zval *object ;
  zval *property ;
  zval *value ;
  zval *tmp___0 ;
  int have_get_ptr ;
  long tmp___1 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zval **zptr ;
  zval **tmp___3 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_uint tmp___5 ;
  zend_bool tmp___6 ;
  zval *z ;
  zval *value___0 ;
  zval *tmp___7 ;
  zend_uint tmp___8 ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___9 ;
  zend_uint tmp___10 ;
  zend_bool tmp___11 ;
  long tmp___12 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var);
  object_ptr = tmp;
  property = opline->op2.zv;
  tmp___0 = _get_zval_ptr((int )(opline + 1)->op1_type, (znode_op const   *)(& (opline + 1)->op1), (temp_variable const   *)execute_data->Ts, & free_op_data1, 0);
  value = tmp___0;
  have_get_ptr = 0;
  if (1 << 4 == 1 << 2) {
    tmp___1 = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___1) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  make_real_object(object_ptr);
  object = *object_ptr;
  tmp___12 = __builtin_expect((long )((int )object->type != 5), 0L);
  if (tmp___12) {
    zend_error(1 << 1L, "Attempt to assign property of non-object");
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = & executor_globals.uninitialized_zval;
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
    } else {

    }
  } else {
    if (opline->extended_value == 136UL) {
      if ((object->value.obj.handlers)->get_property_ptr_ptr) {
        tmp___3 = (*((object->value.obj.handlers)->get_property_ptr_ptr))(object, property, (struct _zend_literal  const  *)opline->op2.literal);
        zptr = tmp___3;
        if ((unsigned int )zptr != (unsigned int )((void *)0)) {
          tmp___6 = zval_isref_p(*zptr);
          if (tmp___6) {

          } else {
            while (1) {
              tmp___5 = zval_refcount_p(*zptr);
              if (tmp___5 > 1U) {
                zval_delref_p(*zptr);
                while (1) {
                  tmp___4 = _emalloc(sizeof(zval_gc_info ));
                  new_zv = (zval *)tmp___4;
                  ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                  break;
                }
                while (1) {
                  while (1) {
                    new_zv->value = (*zptr)->value;
                    new_zv->type = (*zptr)->type;
                    break;
                  }
                  zval_set_refcount_p(new_zv, 1U);
                  zval_unset_isref_p(new_zv);
                  break;
                }
                *zptr = new_zv;
                _zval_copy_ctor(new_zv);
              } else {

              }
              break;
            }
          }
          have_get_ptr = 1;
          (*binary_op)(*zptr, *zptr, value);
          if (! ((int )opline->result_type & (1 << 5))) {
            zval_addref_p(*zptr);
            ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = *zptr;
            ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
          } else {

          }
        } else {

        }
      } else {

      }
    } else {

    }
    if (! have_get_ptr) {
      z = (zval *)((void *)0);
      if (opline->extended_value == 136UL) {
        if ((object->value.obj.handlers)->read_property) {
          z = (*((object->value.obj.handlers)->read_property))(object, property, 0, (struct _zend_literal  const  *)opline->op2.literal);
        } else {

        }
      } else {
        if ((object->value.obj.handlers)->read_dimension) {
          z = (*((object->value.obj.handlers)->read_dimension))(object, property, 0);
        } else {

        }
      }
      if (z) {
        if ((int )z->type == 5) {
          if ((z->value.obj.handlers)->get) {
            tmp___7 = (*((z->value.obj.handlers)->get))(z);
            value___0 = tmp___7;
            tmp___8 = zval_refcount_p(z);
            if (tmp___8 == 0U) {
              if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                gc_remove_zval_from_buffer(z);
              } else {

              }
              _zval_dtor(z);
              while (1) {
                if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                  gc_remove_zval_from_buffer(z);
                } else {

                }
                _efree((void *)z);
                break;
              }
            } else {

            }
            z = value___0;
          } else {

          }
        } else {

        }
        zval_addref_p(z);
        tmp___11 = zval_isref_p(z);
        if (tmp___11) {

        } else {
          while (1) {
            tmp___10 = zval_refcount_p(z);
            if (tmp___10 > 1U) {
              zval_delref_p(z);
              while (1) {
                tmp___9 = _emalloc(sizeof(zval_gc_info ));
                new_zv___0 = (zval *)tmp___9;
                ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv___0->value = z->value;
                  new_zv___0->type = z->type;
                  break;
                }
                zval_set_refcount_p(new_zv___0, 1U);
                zval_unset_isref_p(new_zv___0);
                break;
              }
              z = new_zv___0;
              _zval_copy_ctor(new_zv___0);
            } else {

            }
            break;
          }
        }
        (*binary_op)(z, z, value);
        if (opline->extended_value == 136UL) {
          (*((object->value.obj.handlers)->write_property))(object, property, z, (struct _zend_literal  const  *)opline->op2.literal);
        } else {
          (*((object->value.obj.handlers)->write_dimension))(object, property, z);
        }
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(z);
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = z;
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
        } else {

        }
        i_zval_ptr_dtor(z);
      } else {
        zend_error(1 << 1L, "Attempt to assign property of non-object");
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = & executor_globals.uninitialized_zval;
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
        } else {

        }
      }
    } else {

    }
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
  }
  (execute_data->opline) ++;
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_binary_assign_op_helper_SPEC_CV_CONST)(int (*binary_op)(zval *result , zval *op1 , zval *op2 ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op_data2 ;
  zend_free_op free_op_data1 ;
  zval **var_ptr ;
  zval *value ;
  int tmp ;
  zval **container ;
  zval **tmp___0 ;
  int tmp___1 ;
  zval *dim ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  temp_variable *__t ;
  long tmp___5 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;
  zend_uint tmp___7 ;
  zend_bool tmp___8 ;
  zval *objval ;
  zval *tmp___9 ;
  long tmp___10 ;
  temp_variable *__t___0 ;

  {
  opline = execute_data->opline;
  switch ((int )opline->extended_value) {
  case 136: 
  tmp = zend_binary_assign_op_obj_helper_SPEC_CV_CONST(binary_op, execute_data);
  return (tmp);
  break;
  case 147: 
  tmp___0 = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var);
  container = tmp___0;
  if (1 << 4 == 1 << 2) {
    tmp___3 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___3) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    tmp___2 = __builtin_expect((long )((int )(*container)->type == 5), 0L);
    if (tmp___2) {
      if (1 << 4 == 1 << 2) {
        zval_addref_p(*container);
      } else {

      }
      tmp___1 = zend_binary_assign_op_obj_helper_SPEC_CV_CONST(binary_op, execute_data);
      return (tmp___1);
    } else {
      dim = opline->op2.zv;
      zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var), container, dim, 1, 2);
      value = _get_zval_ptr((int )(opline + 1)->op1_type, (znode_op const   *)(& (opline + 1)->op1), (temp_variable const   *)execute_data->Ts, & free_op_data1, 0);
      var_ptr = _get_zval_ptr_ptr_var((opline + 1)->op2.var, (temp_variable const   *)execute_data->Ts, & free_op_data2);
    }
  }
  break;
  default: 
  value = opline->op2.zv;
  var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var);
  break;
  }
  tmp___4 = __builtin_expect((long )((unsigned int )var_ptr == (unsigned int )((void *)0)), 0L);
  if (tmp___4) {
    zend_error_noreturn(1, "Cannot use assign-op operators with overloaded objects nor string offsets");
  } else {

  }
  tmp___5 = __builtin_expect((long )((unsigned int )*var_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
  if (tmp___5) {
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      while (1) {
        __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t->var.ptr = & executor_globals.uninitialized_zval;
        __t->var.ptr_ptr = & __t->var.ptr;
        break;
      }
    } else {

    }
    if (opline->extended_value == 147UL) {
      (execute_data->opline) ++;
    } else {

    }
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  tmp___8 = zval_isref_p(*var_ptr);
  if (tmp___8) {

  } else {
    while (1) {
      tmp___7 = zval_refcount_p(*var_ptr);
      if (tmp___7 > 1U) {
        zval_delref_p(*var_ptr);
        while (1) {
          tmp___6 = _emalloc(sizeof(zval_gc_info ));
          new_zv = (zval *)tmp___6;
          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            new_zv->value = (*var_ptr)->value;
            new_zv->type = (*var_ptr)->type;
            break;
          }
          zval_set_refcount_p(new_zv, 1U);
          zval_unset_isref_p(new_zv);
          break;
        }
        *var_ptr = new_zv;
        _zval_copy_ctor(new_zv);
      } else {

      }
      break;
    }
  }
  tmp___10 = __builtin_expect((long )((int )(*var_ptr)->type == 5), 0L);
  if (tmp___10) {
    if (((*var_ptr)->value.obj.handlers)->get) {
      if (((*var_ptr)->value.obj.handlers)->set) {
        tmp___9 = (*(((*var_ptr)->value.obj.handlers)->get))(*var_ptr);
        objval = tmp___9;
        zval_addref_p(objval);
        (*binary_op)(objval, objval, value);
        (*(((*var_ptr)->value.obj.handlers)->set))(var_ptr, objval);
        i_zval_ptr_dtor(objval);
      } else {
        (*binary_op)(*var_ptr, *var_ptr, value);
      }
    } else {
      (*binary_op)(*var_ptr, *var_ptr, value);
    }
  } else {
    (*binary_op)(*var_ptr, *var_ptr, value);
  }
  if (! ((int )opline->result_type & (1 << 5))) {
    zval_addref_p(*var_ptr);
    while (1) {
      __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
      __t___0->var.ptr = *var_ptr;
      __t___0->var.ptr_ptr = & __t___0->var.ptr;
      break;
    }
  } else {

  }
  if (opline->extended_value == 147UL) {
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
    if (free_op_data2.var) {
      i_zval_ptr_dtor(free_op_data2.var);
    } else {

    }
    (execute_data->opline) ++;
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_ADD_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_CONST((int (*)(zval *result , zval *op1 , zval *op2 ))(& add_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SUB_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_CONST((int (*)(zval *result , zval *op1 , zval *op2 ))(& sub_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_MUL_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_CONST((int (*)(zval *result , zval *op1 , zval *op2 ))(& mul_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_DIV_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_CONST((int (*)(zval *result , zval *op1 , zval *op2 ))(& div_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_MOD_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_CONST((int (*)(zval *result , zval *op1 , zval *op2 ))(& mod_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SL_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_CONST((int (*)(zval *result , zval *op1 , zval *op2 ))(& shift_left_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SR_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_CONST((int (*)(zval *result , zval *op1 , zval *op2 ))(& shift_right_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_CONCAT_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_CONST((int (*)(zval *result , zval *op1 , zval *op2 ))(& concat_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_OR_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_CONST((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_or_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_AND_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_CONST((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_and_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_XOR_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_CONST((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_xor_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) zend_pre_incdec_property_helper_SPEC_CV_CONST)(int (*incdec_op)(zval * ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **object_ptr ;
  zval *object ;
  zval *property ;
  zval **retval ;
  int have_get_ptr ;
  long tmp ;
  long tmp___0 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zval **zptr ;
  zval **tmp___2 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___3 ;
  zend_uint tmp___4 ;
  zend_bool tmp___5 ;
  zval *z ;
  zval *tmp___6 ;
  zval *value ;
  zval *tmp___7 ;
  zend_uint tmp___8 ;
  long tmp___9 ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___10 ;
  zend_uint tmp___11 ;
  zend_bool tmp___12 ;

  {
  opline = execute_data->opline;
  have_get_ptr = 0;
  object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var);
  property = opline->op2.zv;
  retval = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
  if (1 << 4 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot increment/decrement overloaded objects nor string offsets");
    } else {

    }
  } else {

  }
  make_real_object(object_ptr);
  object = *object_ptr;
  tmp___0 = __builtin_expect((long )((int )object->type != 5), 0L);
  if (tmp___0) {
    zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      *retval = & executor_globals.uninitialized_zval;
    } else {

    }
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  if ((object->value.obj.handlers)->get_property_ptr_ptr) {
    tmp___2 = (*((object->value.obj.handlers)->get_property_ptr_ptr))(object, property, (struct _zend_literal  const  *)opline->op2.literal);
    zptr = tmp___2;
    if ((unsigned int )zptr != (unsigned int )((void *)0)) {
      tmp___5 = zval_isref_p(*zptr);
      if (tmp___5) {

      } else {
        while (1) {
          tmp___4 = zval_refcount_p(*zptr);
          if (tmp___4 > 1U) {
            zval_delref_p(*zptr);
            while (1) {
              tmp___3 = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp___3;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*zptr)->value;
                new_zv->type = (*zptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *zptr = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
      have_get_ptr = 1;
      (*incdec_op)(*zptr);
      if (! ((int )opline->result_type & (1 << 5))) {
        *retval = *zptr;
        zval_addref_p(*retval);
      } else {

      }
    } else {

    }
  } else {

  }
  if (! have_get_ptr) {
    if ((object->value.obj.handlers)->read_property) {
      if ((object->value.obj.handlers)->write_property) {
        tmp___6 = (*((object->value.obj.handlers)->read_property))(object, property, 0, (struct _zend_literal  const  *)opline->op2.literal);
        z = tmp___6;
        tmp___9 = __builtin_expect((long )((int )z->type == 5), 0L);
        if (tmp___9) {
          if ((z->value.obj.handlers)->get) {
            tmp___7 = (*((z->value.obj.handlers)->get))(z);
            value = tmp___7;
            tmp___8 = zval_refcount_p(z);
            if (tmp___8 == 0U) {
              if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                gc_remove_zval_from_buffer(z);
              } else {

              }
              _zval_dtor(z);
              while (1) {
                if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                  gc_remove_zval_from_buffer(z);
                } else {

                }
                _efree((void *)z);
                break;
              }
            } else {

            }
            z = value;
          } else {

          }
        } else {

        }
        zval_addref_p(z);
        tmp___12 = zval_isref_p(z);
        if (tmp___12) {

        } else {
          while (1) {
            tmp___11 = zval_refcount_p(z);
            if (tmp___11 > 1U) {
              zval_delref_p(z);
              while (1) {
                tmp___10 = _emalloc(sizeof(zval_gc_info ));
                new_zv___0 = (zval *)tmp___10;
                ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv___0->value = z->value;
                  new_zv___0->type = z->type;
                  break;
                }
                zval_set_refcount_p(new_zv___0, 1U);
                zval_unset_isref_p(new_zv___0);
                break;
              }
              z = new_zv___0;
              _zval_copy_ctor(new_zv___0);
            } else {

            }
            break;
          }
        }
        (*incdec_op)(z);
        *retval = z;
        (*((object->value.obj.handlers)->write_property))(object, property, z, (struct _zend_literal  const  *)opline->op2.literal);
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(*retval);
        } else {

        }
        i_zval_ptr_dtor(z);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
      if (! ((int )opline->result_type & (1 << 5))) {
        zval_addref_p(& executor_globals.uninitialized_zval);
        *retval = & executor_globals.uninitialized_zval;
      } else {

      }
    }
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_PRE_INC_OBJ_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_pre_incdec_property_helper_SPEC_CV_CONST((int (*)(zval * ))(& increment_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_PRE_DEC_OBJ_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_pre_incdec_property_helper_SPEC_CV_CONST((int (*)(zval * ))(& decrement_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) zend_post_incdec_property_helper_SPEC_CV_CONST)(int (*incdec_op)(zval * ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **object_ptr ;
  zval *object ;
  zval *property ;
  zval *retval ;
  int have_get_ptr ;
  long tmp ;
  long tmp___0 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zval **zptr ;
  zval **tmp___2 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___3 ;
  zend_uint tmp___4 ;
  zend_bool tmp___5 ;
  zval *z ;
  zval *tmp___6 ;
  zval *z_copy ;
  zval *value ;
  zval *tmp___7 ;
  zend_uint tmp___8 ;
  long tmp___9 ;
  void __attribute__((__visibility__("default")))  *tmp___10 ;

  {
  opline = execute_data->opline;
  have_get_ptr = 0;
  object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var);
  property = opline->op2.zv;
  retval = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  if (1 << 4 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot increment/decrement overloaded objects nor string offsets");
    } else {

    }
  } else {

  }
  make_real_object(object_ptr);
  object = *object_ptr;
  tmp___0 = __builtin_expect((long )((int )object->type != 5), 0L);
  if (tmp___0) {
    zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
    retval->type = (unsigned char)0;
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  if ((object->value.obj.handlers)->get_property_ptr_ptr) {
    tmp___2 = (*((object->value.obj.handlers)->get_property_ptr_ptr))(object, property, (struct _zend_literal  const  *)opline->op2.literal);
    zptr = tmp___2;
    if ((unsigned int )zptr != (unsigned int )((void *)0)) {
      have_get_ptr = 1;
      tmp___5 = zval_isref_p(*zptr);
      if (tmp___5) {

      } else {
        while (1) {
          tmp___4 = zval_refcount_p(*zptr);
          if (tmp___4 > 1U) {
            zval_delref_p(*zptr);
            while (1) {
              tmp___3 = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp___3;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*zptr)->value;
                new_zv->type = (*zptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *zptr = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
      while (1) {
        retval->value = (*zptr)->value;
        retval->type = (*zptr)->type;
        break;
      }
      _zval_copy_ctor(retval);
      (*incdec_op)(*zptr);
    } else {

    }
  } else {

  }
  if (! have_get_ptr) {
    if ((object->value.obj.handlers)->read_property) {
      if ((object->value.obj.handlers)->write_property) {
        tmp___6 = (*((object->value.obj.handlers)->read_property))(object, property, 0, (struct _zend_literal  const  *)opline->op2.literal);
        z = tmp___6;
        tmp___9 = __builtin_expect((long )((int )z->type == 5), 0L);
        if (tmp___9) {
          if ((z->value.obj.handlers)->get) {
            tmp___7 = (*((z->value.obj.handlers)->get))(z);
            value = tmp___7;
            tmp___8 = zval_refcount_p(z);
            if (tmp___8 == 0U) {
              if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                gc_remove_zval_from_buffer(z);
              } else {

              }
              _zval_dtor(z);
              while (1) {
                if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                  gc_remove_zval_from_buffer(z);
                } else {

                }
                _efree((void *)z);
                break;
              }
            } else {

            }
            z = value;
          } else {

          }
        } else {

        }
        while (1) {
          retval->value = z->value;
          retval->type = z->type;
          break;
        }
        _zval_copy_ctor(retval);
        while (1) {
          tmp___10 = _emalloc(sizeof(zval_gc_info ));
          z_copy = (zval *)tmp___10;
          ((zval_gc_info *)z_copy)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            z_copy->value = z->value;
            z_copy->type = z->type;
            break;
          }
          zval_set_refcount_p(z_copy, 1U);
          zval_unset_isref_p(z_copy);
          break;
        }
        _zval_copy_ctor(z_copy);
        (*incdec_op)(z_copy);
        zval_addref_p(z);
        (*((object->value.obj.handlers)->write_property))(object, property, z_copy, (struct _zend_literal  const  *)opline->op2.literal);
        i_zval_ptr_dtor(z_copy);
        i_zval_ptr_dtor(z);
      } else {
        zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
        retval->type = (unsigned char)0;
      }
    } else {
      zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
      retval->type = (unsigned char)0;
    }
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_POST_INC_OBJ_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_post_incdec_property_helper_SPEC_CV_CONST((int (*)(zval * ))(& increment_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_POST_DEC_OBJ_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_post_incdec_property_helper_SPEC_CV_CONST((int (*)(zval * ))(& decrement_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) zend_fetch_var_address_helper_SPEC_CV_CONST)(int type , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *varname ;
  zval **retval ;
  zval tmp_varname ;
  HashTable *target_symbol_table ;
  ulong hash_value ;
  long tmp ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_literal *tmp___1 ;
  zval __attribute__((__visibility__("default")))  **tmp___2 ;
  ulong __attribute__((__visibility__("default")))  tmp___3 ;
  int __attribute__((__visibility__("default")))  tmp___4 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  zend_uint tmp___6 ;
  zend_bool tmp___7 ;
  temp_variable *__t ;
  zend_free_op free_res ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___8 ;
  zend_uint tmp___9 ;
  zend_bool tmp___10 ;

  {
  opline = execute_data->opline;
  varname = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  if (1 << 4 != 1) {
    tmp = __builtin_expect((long )((int )varname->type != 6), 0L);
    if (tmp) {
      while (1) {
        tmp_varname.value = varname->value;
        tmp_varname.type = varname->type;
        break;
      }
      _zval_copy_ctor(& tmp_varname);
      zval_set_refcount_p(& tmp_varname, 1U);
      zval_unset_isref_p(& tmp_varname);
      if ((int )tmp_varname.type != 6) {
        _convert_to_string(& tmp_varname);
      } else {

      }
      varname = & tmp_varname;
    } else {

    }
  } else {

  }
  if (1 != 1 << 3) {
    if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
      ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
    } else {
      tmp___0 = zend_fetch_class_by_name((char const   *)(opline->op2.zv)->value.str.val, (unsigned int )(opline->op2.zv)->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), 0);
      ce = (zend_class_entry *)tmp___0;
      while (1) {
        *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
        break;
      }
    }
    if (1 << 4 == 1) {
      tmp___1 = opline->op1.literal;
    } else {
      tmp___1 = (zend_literal *)((void *)0);
    }
    tmp___2 = zend_std_get_static_property(ce, (char const   *)varname->value.str.val, varname->value.str.len, (unsigned char)0, (struct _zend_literal  const  *)tmp___1);
    retval = (zval **)tmp___2;
  } else {
    target_symbol_table = zend_get_target_symbol_table((int )(opline->extended_value & 1879048192UL));
    if (1 << 4 == 1) {
      hash_value = ((zend_literal *)varname)->hash_value;
    } else {
      if ((unsigned int )varname->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
        if ((unsigned int )varname->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
          hash_value = ((Bucket *)(varname->value.str.val - sizeof(Bucket )))->h;
        } else {
          tmp___3 = zend_hash_func((char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1));
          hash_value = (unsigned long )tmp___3;
        }
      } else {
        tmp___3 = zend_hash_func((char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1));
        hash_value = (unsigned long )tmp___3;
      }
    }
    tmp___4 = zend_hash_quick_find((HashTable const   *)target_symbol_table, (char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1), hash_value, (void **)(& retval));
    if (tmp___4 == (int __attribute__((__visibility__("default")))  )-1) {
      switch (type) {
      case 0: 
      case 6: 
      zend_error(1 << 3L, "Undefined variable: %s", varname->value.str.val);
      case 3: 
      retval = & executor_globals.uninitialized_zval_ptr;
      break;
      case 2: 
      zend_error(1 << 3L, "Undefined variable: %s", varname->value.str.val);
      case 1: 
      zval_addref_p(& executor_globals.uninitialized_zval);
      _zend_hash_quick_add_or_update(target_symbol_table, (char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1), hash_value, (void *)(& executor_globals.uninitialized_zval_ptr), sizeof(zval *), (void **)(& retval), 1);
      break;
      }
    } else {

    }
    switch ((int )(opline->extended_value & 1879048192UL)) {
    case 0x00000000: 
    if (1 << 4 != 1 << 1) {

    } else {

    }
    break;
    case 0x10000000: 
    break;
    case 0x20000000: 
    zval_update_constant(retval, (void *)1);
    break;
    case 0x40000000: 
    if (1 << 4 == 1 << 2) {
      if (! free_op1.var) {
        zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr));
      } else {

      }
    } else {

    }
    break;
    }
  }
  if (1 << 4 != 1) {
    if ((unsigned int )varname == (unsigned int )(& tmp_varname)) {
      _zval_dtor(& tmp_varname);
    } else {

    }
  } else {

  }
  if (opline->extended_value & 67108864UL) {
    tmp___7 = zval_isref_p(*retval);
    if (tmp___7) {

    } else {
      while (1) {
        tmp___6 = zval_refcount_p(*retval);
        if (tmp___6 > 1U) {
          zval_delref_p(*retval);
          while (1) {
            tmp___5 = _emalloc(sizeof(zval_gc_info ));
            new_zv = (zval *)tmp___5;
            ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv->value = (*retval)->value;
              new_zv->type = (*retval)->type;
              break;
            }
            zval_set_refcount_p(new_zv, 1U);
            zval_unset_isref_p(new_zv);
            break;
          }
          *retval = new_zv;
          _zval_copy_ctor(new_zv);
        } else {

        }
        break;
      }
      zval_set_isref_p(*retval);
    }
  } else {

  }
  zval_addref_p(*retval);
  switch (type) {
  case 0: 
  case 3: 
  while (1) {
    __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
    __t->var.ptr = *retval;
    __t->var.ptr_ptr = & __t->var.ptr;
    break;
  }
  break;
  case 6: 
  zend_pzval_unlock_func(*retval, & free_res, 1);
  if ((unsigned int )retval != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
    tmp___10 = zval_isref_p(*retval);
    if (tmp___10) {

    } else {
      while (1) {
        tmp___9 = zval_refcount_p(*retval);
        if (tmp___9 > 1U) {
          zval_delref_p(*retval);
          while (1) {
            tmp___8 = _emalloc(sizeof(zval_gc_info ));
            new_zv___0 = (zval *)tmp___8;
            ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv___0->value = (*retval)->value;
              new_zv___0->type = (*retval)->type;
              break;
            }
            zval_set_refcount_p(new_zv___0, 1U);
            zval_unset_isref_p(new_zv___0);
            break;
          }
          *retval = new_zv___0;
          _zval_copy_ctor(new_zv___0);
        } else {

        }
        break;
      }
    }
  } else {

  }
  zval_addref_p(*retval);
  if (free_res.var) {
    i_zval_ptr_dtor(free_res.var);
  } else {

  }
  default: 
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = retval;
  break;
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_R_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_CV_CONST(0, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_W_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_CV_CONST(1, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_RW_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_CV_CONST(2, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_FUNC_ARG_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  unsigned int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
  opline = execute_data->opline;
  if (execute_data->fbc) {
    if ((execute_data->fbc)->common.arg_info) {
      if ((opline->extended_value & 1048575UL) <= (unsigned long )(execute_data->fbc)->common.num_args) {
        tmp___1 = (unsigned int )((int )((execute_data->fbc)->common.arg_info + ((opline->extended_value & 1048575UL) - 1UL))->pass_by_reference & 3);
      } else {
        tmp___1 = (execute_data->fbc)->common.fn_flags & 50331648U;
      }
    } else {
      tmp___1 = (execute_data->fbc)->common.fn_flags & 50331648U;
    }
    if (tmp___1) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___2 = zend_fetch_var_address_helper_SPEC_CV_CONST(tmp___0, execute_data);
  return (tmp___2);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_UNSET_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_CV_CONST(6, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_IS_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_CV_CONST(3, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_R_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **container ;

  {
  opline = execute_data->opline;
  if (opline->extended_value & 134217728UL) {
    if (1 << 4 != 1 << 4) {
      if (((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr) {
        zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr));
      } else {

      }
    } else {

    }
  } else {

  }
  container = _get_zval_ptr_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  zend_fetch_dimension_address_read((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, opline->op2.zv, 1, 0);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_W_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **container ;
  long tmp ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_uint tmp___1 ;
  zend_bool tmp___2 ;
  zend_uint tmp___3 ;
  zend_uint tmp___4 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___5 ;
  zval **retval_ptr ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;
  zend_uint tmp___7 ;
  zend_bool tmp___8 ;
  long tmp___9 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, opline->op2.zv, 1, 1);
  if (1 << 4 == 1 << 2) {
    if (0) {
      tmp___4 = zval_refcount_p(free_op1.var);
      if (tmp___4 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___5 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___5 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___2 = zval_isref_p(__t->var.ptr);
                if (tmp___2) {

                } else {
                  tmp___3 = zval_refcount_p(__t->var.ptr);
                  if (tmp___3 > 2U) {
                    while (1) {
                      tmp___1 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___1 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___0 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___0;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  tmp___9 = __builtin_expect((long )(opline->extended_value != 0UL), 0L);
  if (tmp___9) {
    retval_ptr = ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr;
    if (retval_ptr) {
      zval_delref_p(*retval_ptr);
      tmp___8 = zval_isref_p(*retval_ptr);
      if (tmp___8) {

      } else {
        while (1) {
          tmp___7 = zval_refcount_p(*retval_ptr);
          if (tmp___7 > 1U) {
            zval_delref_p(*retval_ptr);
            while (1) {
              tmp___6 = _emalloc(sizeof(zval_gc_info ));
              new_zv___0 = (zval *)tmp___6;
              ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv___0->value = (*retval_ptr)->value;
                new_zv___0->type = (*retval_ptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv___0, 1U);
              zval_unset_isref_p(new_zv___0);
              break;
            }
            *retval_ptr = new_zv___0;
            _zval_copy_ctor(new_zv___0);
          } else {

          }
          break;
        }
        zval_set_isref_p(*retval_ptr);
      }
      zval_addref_p(*retval_ptr);
    } else {

    }
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_RW_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **container ;
  long tmp ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_uint tmp___1 ;
  zend_bool tmp___2 ;
  zend_uint tmp___3 ;
  zend_uint tmp___4 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___5 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, opline->op2.zv, 1, 2);
  if (1 << 4 == 1 << 2) {
    if (0) {
      tmp___4 = zval_refcount_p(free_op1.var);
      if (tmp___4 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___5 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___5 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___2 = zval_isref_p(__t->var.ptr);
                if (tmp___2) {

                } else {
                  tmp___3 = zval_refcount_p(__t->var.ptr);
                  if (tmp___3 > 2U) {
                    while (1) {
                      tmp___1 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___1 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___0 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___0;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_IS_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **container ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_cv_BP_VAR_IS(execute_data->CVs, opline->op1.var);
  zend_fetch_dimension_address_read((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, opline->op2.zv, 1, 3);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **container ;
  long tmp ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_uint tmp___1 ;
  zend_bool tmp___2 ;
  zend_uint tmp___3 ;
  zend_uint tmp___4 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___5 ;
  unsigned int tmp___6 ;

  {
  opline = execute_data->opline;
  if (execute_data->fbc) {
    if ((execute_data->fbc)->common.arg_info) {
      if ((opline->extended_value & 1048575UL) <= (unsigned long )(execute_data->fbc)->common.num_args) {
        tmp___6 = (unsigned int )((int )((execute_data->fbc)->common.arg_info + ((opline->extended_value & 1048575UL) - 1UL))->pass_by_reference & 3);
      } else {
        tmp___6 = (execute_data->fbc)->common.fn_flags & 50331648U;
      }
    } else {
      tmp___6 = (execute_data->fbc)->common.fn_flags & 50331648U;
    }
    if (tmp___6) {
      container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var);
      if (1 << 4 == 1 << 2) {
        tmp = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
        if (tmp) {
          zend_error_noreturn(1, "Cannot use string offset as an array");
        } else {

        }
      } else {

      }
      zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, opline->op2.zv, 1, 1);
      if (1 << 4 == 1 << 2) {
        if (0) {
          tmp___4 = zval_refcount_p(free_op1.var);
          if (tmp___4 == 1U) {
            if ((int )(free_op1.var)->type != 5) {
              goto _L;
            } else {
              tmp___5 = zend_objects_store_get_refcount(free_op1.var);
              if (tmp___5 == (zend_uint __attribute__((__visibility__("default")))  )1) {
                _L: /* CIL Label */ 
                while (1) {
                  __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
                  if (__t->var.ptr_ptr) {
                    __t->var.ptr = *(__t->var.ptr_ptr);
                    __t->var.ptr_ptr = & __t->var.ptr;
                    tmp___2 = zval_isref_p(__t->var.ptr);
                    if (tmp___2) {

                    } else {
                      tmp___3 = zval_refcount_p(__t->var.ptr);
                      if (tmp___3 > 2U) {
                        while (1) {
                          tmp___1 = zval_refcount_p(*(__t->var.ptr_ptr));
                          if (tmp___1 > 1U) {
                            zval_delref_p(*(__t->var.ptr_ptr));
                            while (1) {
                              tmp___0 = _emalloc(sizeof(zval_gc_info ));
                              new_zv = (zval *)tmp___0;
                              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                              break;
                            }
                            while (1) {
                              while (1) {
                                new_zv->value = (*(__t->var.ptr_ptr))->value;
                                new_zv->type = (*(__t->var.ptr_ptr))->type;
                                break;
                              }
                              zval_set_refcount_p(new_zv, 1U);
                              zval_unset_isref_p(new_zv);
                              break;
                            }
                            *(__t->var.ptr_ptr) = new_zv;
                            _zval_copy_ctor(new_zv);
                          } else {

                          }
                          break;
                        }
                      } else {

                      }
                    }
                  } else {

                  }
                  break;
                }
              } else {

              }
            }
          } else {

          }
        } else {

        }
      } else {

      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if (1 == 1 << 3) {
      zend_error_noreturn(1, "Cannot use [] for reading");
    } else {

    }
    container = _get_zval_ptr_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
    zend_fetch_dimension_address_read((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, opline->op2.zv, 1, 0);
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_UNSET_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **container ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  long tmp___2 ;
  temp_variable *__t ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___3 ;
  zend_uint tmp___4 ;
  zend_bool tmp___5 ;
  zend_uint tmp___6 ;
  zend_uint tmp___7 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___8 ;
  zend_free_op free_res ;
  zval **retval_ptr ;
  zval *new_zv___1 ;
  void __attribute__((__visibility__("default")))  *tmp___9 ;
  zend_uint tmp___10 ;
  zend_bool tmp___11 ;
  long tmp___12 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 4) {
    if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
      tmp___1 = zval_isref_p(*container);
      if (tmp___1) {

      } else {
        while (1) {
          tmp___0 = zval_refcount_p(*container);
          if (tmp___0 > 1U) {
            zval_delref_p(*container);
            while (1) {
              tmp = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*container)->value;
                new_zv->type = (*container)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *container = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
    } else {

    }
  } else {

  }
  if (1 << 4 == 1 << 2) {
    tmp___2 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___2) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, opline->op2.zv, 1, 6);
  if (1 << 4 == 1 << 2) {
    if (0) {
      tmp___7 = zval_refcount_p(free_op1.var);
      if (tmp___7 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___8 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___8 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___5 = zval_isref_p(__t->var.ptr);
                if (tmp___5) {

                } else {
                  tmp___6 = zval_refcount_p(__t->var.ptr);
                  if (tmp___6 > 2U) {
                    while (1) {
                      tmp___4 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___4 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___3 = _emalloc(sizeof(zval_gc_info ));
                          new_zv___0 = (zval *)tmp___3;
                          ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv___0->value = (*(__t->var.ptr_ptr))->value;
                            new_zv___0->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv___0, 1U);
                          zval_unset_isref_p(new_zv___0);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv___0;
                        _zval_copy_ctor(new_zv___0);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  tmp___12 = __builtin_expect((long )((unsigned int )((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr == (unsigned int )((void *)0)), 0L);
  if (tmp___12) {
    zend_error_noreturn(1, "Cannot unset string offsets");
  } else {
    retval_ptr = ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr;
    zend_pzval_unlock_func(*retval_ptr, & free_res, 1);
    if ((unsigned int )retval_ptr != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
      tmp___11 = zval_isref_p(*retval_ptr);
      if (tmp___11) {

      } else {
        while (1) {
          tmp___10 = zval_refcount_p(*retval_ptr);
          if (tmp___10 > 1U) {
            zval_delref_p(*retval_ptr);
            while (1) {
              tmp___9 = _emalloc(sizeof(zval_gc_info ));
              new_zv___1 = (zval *)tmp___9;
              ((zval_gc_info *)new_zv___1)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv___1->value = (*retval_ptr)->value;
                new_zv___1->type = (*retval_ptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv___1, 1U);
              zval_unset_isref_p(new_zv___1);
              break;
            }
            *retval_ptr = new_zv___1;
            _zval_copy_ctor(new_zv___1);
          } else {

          }
          break;
        }
      }
    } else {

    }
    zval_addref_p(*retval_ptr);
    if (free_res.var) {
      i_zval_ptr_dtor(free_res.var);
    } else {

    }
    (execute_data->opline) ++;
    return (0);
  }
}
}
static int ( __attribute__((__fastcall__)) zend_fetch_property_address_read_helper_SPEC_CV_CONST)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *container ;
  zval *offset ;
  temp_variable *__t ;
  zval *retval ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  temp_variable *__t___0 ;
  long tmp___0 ;
  long tmp___1 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  offset = opline->op2.zv;
  tmp___0 = __builtin_expect((long )((int )container->type != 5), 0L);
  if (tmp___0) {
    goto _L;
  } else {
    tmp___1 = __builtin_expect((long )((unsigned int )(container->value.obj.handlers)->read_property == (unsigned int )((void *)0)), 0L);
    if (tmp___1) {
      _L: /* CIL Label */ 
      zend_error(1 << 3L, "Trying to get property of non-object");
      zval_addref_p(& executor_globals.uninitialized_zval);
      while (1) {
        __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t->var.ptr = & executor_globals.uninitialized_zval;
        __t->var.ptr_ptr = & __t->var.ptr;
        break;
      }
    } else {
      retval = (*((container->value.obj.handlers)->read_property))(container, offset, 0, (struct _zend_literal  const  *)opline->op2.literal);
      zval_addref_p(retval);
      while (1) {
        __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t___0->var.ptr = retval;
        __t___0->var.ptr_ptr = & __t___0->var.ptr;
        break;
      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_R_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_property_address_read_helper_SPEC_CV_CONST(execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_W_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *property ;
  zval **container ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zend_uint tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___6 ;
  zval **retval_ptr ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___7 ;
  zend_uint tmp___8 ;
  zend_bool tmp___9 ;

  {
  opline = execute_data->opline;
  property = opline->op2.zv;
  if (1 << 4 == 1 << 2) {
    if (opline->extended_value & 134217728UL) {
      zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr));
      ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr = *(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr);
    } else {

    }
  } else {

  }
  container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)opline->op2.literal, 1);
  if (1 << 4 == 1 << 2) {
    if (0) {
      tmp___5 = zval_refcount_p(free_op1.var);
      if (tmp___5 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___6 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___6 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___3 = zval_isref_p(__t->var.ptr);
                if (tmp___3) {

                } else {
                  tmp___4 = zval_refcount_p(__t->var.ptr);
                  if (tmp___4 > 2U) {
                    while (1) {
                      tmp___2 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___2 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___1 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___1;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  if (opline->extended_value & 67108864UL) {
    retval_ptr = ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr;
    zval_delref_p(*retval_ptr);
    tmp___9 = zval_isref_p(*retval_ptr);
    if (tmp___9) {

    } else {
      while (1) {
        tmp___8 = zval_refcount_p(*retval_ptr);
        if (tmp___8 > 1U) {
          zval_delref_p(*retval_ptr);
          while (1) {
            tmp___7 = _emalloc(sizeof(zval_gc_info ));
            new_zv___0 = (zval *)tmp___7;
            ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv___0->value = (*retval_ptr)->value;
              new_zv___0->type = (*retval_ptr)->type;
              break;
            }
            zval_set_refcount_p(new_zv___0, 1U);
            zval_unset_isref_p(new_zv___0);
            break;
          }
          *retval_ptr = new_zv___0;
          _zval_copy_ctor(new_zv___0);
        } else {

        }
        break;
      }
      zval_set_isref_p(*retval_ptr);
    }
    zval_addref_p(*retval_ptr);
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = *(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr);
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_RW_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *property ;
  zval **container ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zend_uint tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___6 ;

  {
  opline = execute_data->opline;
  property = opline->op2.zv;
  container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)opline->op2.literal, 2);
  if (1 << 4 == 1 << 2) {
    if (0) {
      tmp___5 = zval_refcount_p(free_op1.var);
      if (tmp___5 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___6 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___6 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___3 = zval_isref_p(__t->var.ptr);
                if (tmp___3) {

                } else {
                  tmp___4 = zval_refcount_p(__t->var.ptr);
                  if (tmp___4 > 2U) {
                    while (1) {
                      tmp___2 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___2 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___1 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___1;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_IS_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *container ;
  zval *offset ;
  temp_variable *__t ;
  zval *retval ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  temp_variable *__t___0 ;
  long tmp___0 ;
  long tmp___1 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_cv_BP_VAR_IS(execute_data->CVs, opline->op1.var);
  offset = opline->op2.zv;
  tmp___0 = __builtin_expect((long )((int )container->type != 5), 0L);
  if (tmp___0) {
    goto _L;
  } else {
    tmp___1 = __builtin_expect((long )((unsigned int )(container->value.obj.handlers)->read_property == (unsigned int )((void *)0)), 0L);
    if (tmp___1) {
      _L: /* CIL Label */ 
      zval_addref_p(& executor_globals.uninitialized_zval);
      while (1) {
        __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t->var.ptr = & executor_globals.uninitialized_zval;
        __t->var.ptr_ptr = & __t->var.ptr;
        break;
      }
    } else {
      retval = (*((container->value.obj.handlers)->read_property))(container, offset, 3, (struct _zend_literal  const  *)opline->op2.literal);
      zval_addref_p(retval);
      while (1) {
        __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t___0->var.ptr = retval;
        __t___0->var.ptr_ptr = & __t___0->var.ptr;
        break;
      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *property ;
  zval **container ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zend_uint tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___6 ;
  int tmp___7 ;
  unsigned int tmp___8 ;

  {
  opline = execute_data->opline;
  if (execute_data->fbc) {
    if ((execute_data->fbc)->common.arg_info) {
      if ((opline->extended_value & 1048575UL) <= (unsigned long )(execute_data->fbc)->common.num_args) {
        tmp___8 = (unsigned int )((int )((execute_data->fbc)->common.arg_info + ((opline->extended_value & 1048575UL) - 1UL))->pass_by_reference & 3);
      } else {
        tmp___8 = (execute_data->fbc)->common.fn_flags & 50331648U;
      }
    } else {
      tmp___8 = (execute_data->fbc)->common.fn_flags & 50331648U;
    }
    if (tmp___8) {
      property = opline->op2.zv;
      container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var);
      if (1 << 4 == 1 << 2) {
        tmp___0 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
        if (tmp___0) {
          zend_error_noreturn(1, "Cannot use string offset as an object");
        } else {

        }
      } else {

      }
      zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)opline->op2.literal, 1);
      if (1 << 4 == 1 << 2) {
        if (0) {
          tmp___5 = zval_refcount_p(free_op1.var);
          if (tmp___5 == 1U) {
            if ((int )(free_op1.var)->type != 5) {
              goto _L;
            } else {
              tmp___6 = zend_objects_store_get_refcount(free_op1.var);
              if (tmp___6 == (zend_uint __attribute__((__visibility__("default")))  )1) {
                _L: /* CIL Label */ 
                while (1) {
                  __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
                  if (__t->var.ptr_ptr) {
                    __t->var.ptr = *(__t->var.ptr_ptr);
                    __t->var.ptr_ptr = & __t->var.ptr;
                    tmp___3 = zval_isref_p(__t->var.ptr);
                    if (tmp___3) {

                    } else {
                      tmp___4 = zval_refcount_p(__t->var.ptr);
                      if (tmp___4 > 2U) {
                        while (1) {
                          tmp___2 = zval_refcount_p(*(__t->var.ptr_ptr));
                          if (tmp___2 > 1U) {
                            zval_delref_p(*(__t->var.ptr_ptr));
                            while (1) {
                              tmp___1 = _emalloc(sizeof(zval_gc_info ));
                              new_zv = (zval *)tmp___1;
                              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                              break;
                            }
                            while (1) {
                              while (1) {
                                new_zv->value = (*(__t->var.ptr_ptr))->value;
                                new_zv->type = (*(__t->var.ptr_ptr))->type;
                                break;
                              }
                              zval_set_refcount_p(new_zv, 1U);
                              zval_unset_isref_p(new_zv);
                              break;
                            }
                            *(__t->var.ptr_ptr) = new_zv;
                            _zval_copy_ctor(new_zv);
                          } else {

                          }
                          break;
                        }
                      } else {

                      }
                    }
                  } else {

                  }
                  break;
                }
              } else {

              }
            }
          } else {

          }
        } else {

        }
      } else {

      }
      (execute_data->opline) ++;
      return (0);
    } else {
      tmp___7 = zend_fetch_property_address_read_helper_SPEC_CV_CONST(execute_data);
      return (tmp___7);
    }
  } else {
    tmp___7 = zend_fetch_property_address_read_helper_SPEC_CV_CONST(execute_data);
    return (tmp___7);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_UNSET_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_res ;
  zval **container ;
  zval *property ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  long tmp___3 ;
  temp_variable *__t ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_uint tmp___5 ;
  zend_bool tmp___6 ;
  zend_uint tmp___7 ;
  zend_uint tmp___8 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___9 ;
  zval *new_zv___1 ;
  void __attribute__((__visibility__("default")))  *tmp___10 ;
  zend_uint tmp___11 ;
  zend_bool tmp___12 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data->CVs, opline->op1.var);
  property = opline->op2.zv;
  if (1 << 4 == 1 << 4) {
    if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
      tmp___1 = zval_isref_p(*container);
      if (tmp___1) {

      } else {
        while (1) {
          tmp___0 = zval_refcount_p(*container);
          if (tmp___0 > 1U) {
            zval_delref_p(*container);
            while (1) {
              tmp = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*container)->value;
                new_zv->type = (*container)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *container = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
    } else {

    }
  } else {

  }
  if (1 << 4 == 1 << 2) {
    tmp___3 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___3) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)opline->op2.literal, 6);
  if (1 << 4 == 1 << 2) {
    if (0) {
      tmp___8 = zval_refcount_p(free_op1.var);
      if (tmp___8 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___9 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___9 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___6 = zval_isref_p(__t->var.ptr);
                if (tmp___6) {

                } else {
                  tmp___7 = zval_refcount_p(__t->var.ptr);
                  if (tmp___7 > 2U) {
                    while (1) {
                      tmp___5 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___5 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___4 = _emalloc(sizeof(zval_gc_info ));
                          new_zv___0 = (zval *)tmp___4;
                          ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv___0->value = (*(__t->var.ptr_ptr))->value;
                            new_zv___0->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv___0, 1U);
                          zval_unset_isref_p(new_zv___0);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv___0;
                        _zval_copy_ctor(new_zv___0);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  zend_pzval_unlock_func(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr), & free_res, 1);
  if ((unsigned int )((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
    tmp___12 = zval_isref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
    if (tmp___12) {

    } else {
      while (1) {
        tmp___11 = zval_refcount_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
        if (tmp___11 > 1U) {
          zval_delref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
          while (1) {
            tmp___10 = _emalloc(sizeof(zval_gc_info ));
            new_zv___1 = (zval *)tmp___10;
            ((zval_gc_info *)new_zv___1)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv___1->value = (*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr))->value;
              new_zv___1->type = (*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr))->type;
              break;
            }
            zval_set_refcount_p(new_zv___1, 1U);
            zval_unset_isref_p(new_zv___1);
            break;
          }
          *(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr) = new_zv___1;
          _zval_copy_ctor(new_zv___1);
        } else {

        }
        break;
      }
    }
  } else {

  }
  zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
  if (free_res.var) {
    i_zval_ptr_dtor(free_res.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_OBJ_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **object_ptr ;
  zval *property_name ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zval **tmp___1 ;

  {
  opline = execute_data->opline;
  object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var);
  property_name = opline->op2.zv;
  if (1 << 4 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  if (! ((int )opline->result_type & (1 << 5))) {
    tmp___1 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
  } else {
    tmp___1 = (zval **)((void *)0);
  }
  zend_assign_to_object(tmp___1, object_ptr, property_name, (int )(opline + 1)->op1_type, & (opline + 1)->op1, (temp_variable const   *)execute_data->Ts, 136, (zend_literal const   *)opline->op2.literal);
  (execute_data->opline) ++;
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_DIM_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **object_ptr ;
  long tmp ;
  zval *property_name ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  zval **tmp___1 ;
  zend_free_op free_op_data1 ;
  zend_free_op free_op_data2 ;
  zval *value ;
  zval *dim ;
  zval **variable_ptr_ptr ;
  zval *retval ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  char const   *__s ;
  int __l ;
  zval *__z ;
  char __attribute__((__visibility__("default")))  *tmp___3 ;
  temp_variable *__t ;
  temp_variable *__t___0 ;
  int tmp___4 ;
  temp_variable *__t___1 ;
  temp_variable *__t___2 ;
  long tmp___5 ;
  long tmp___6 ;

  {
  opline = execute_data->opline;
  object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  if ((int )(*object_ptr)->type == 5) {
    property_name = opline->op2.zv;
    if (! ((int )opline->result_type & (1 << 5))) {
      tmp___1 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
    } else {
      tmp___1 = (zval **)((void *)0);
    }
    zend_assign_to_object(tmp___1, object_ptr, property_name, (int )(opline + 1)->op1_type, & (opline + 1)->op1, (temp_variable const   *)execute_data->Ts, 147, (zend_literal const   *)opline->op2.literal);
  } else {
    dim = opline->op2.zv;
    zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var), object_ptr, dim, 1, 1);
    value = _get_zval_ptr((int )(opline + 1)->op1_type, (znode_op const   *)(& (opline + 1)->op1), (temp_variable const   *)execute_data->Ts, & free_op_data1, 0);
    variable_ptr_ptr = _get_zval_ptr_ptr_var((opline + 1)->op2.var, (temp_variable const   *)execute_data->Ts, & free_op_data2);
    tmp___6 = __builtin_expect((long )((unsigned int )variable_ptr_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___6) {
      tmp___4 = zend_assign_to_string_offset((temp_variable const   *)((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var)), (zval const   *)value, (int )(opline + 1)->op1_type);
      if (tmp___4) {
        if (! ((int )opline->result_type & (1 << 5))) {
          while (1) {
            tmp___2 = _emalloc(sizeof(zval_gc_info ));
            retval = (zval *)tmp___2;
            ((zval_gc_info *)retval)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            __s = (char const   *)((((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var))->str_offset.str)->value.str.val + ((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var))->str_offset.offset);
            __l = 1;
            __z = retval;
            __z->value.str.len = __l;
            tmp___3 = _estrndup(__s, (unsigned int )__l);
            __z->value.str.val = (char *)tmp___3;
            __z->type = (unsigned char)6;
            break;
          }
          retval->refcount__gc = 1U;
          retval->is_ref__gc = (unsigned char)0;
          while (1) {
            __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t->var.ptr = retval;
            __t->var.ptr_ptr = & __t->var.ptr;
            break;
          }
        } else {

        }
      } else {
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          while (1) {
            __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___0->var.ptr = & executor_globals.uninitialized_zval;
            __t___0->var.ptr_ptr = & __t___0->var.ptr;
            break;
          }
        } else {

        }
      }
    } else {
      tmp___5 = __builtin_expect((long )((unsigned int )*variable_ptr_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
      if (tmp___5) {
        if ((unsigned long )free_op_data1.var & 1UL) {
          _zval_dtor(value);
        } else {

        }
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          while (1) {
            __t___1 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___1->var.ptr = & executor_globals.uninitialized_zval;
            __t___1->var.ptr_ptr = & __t___1->var.ptr;
            break;
          }
        } else {

        }
      } else {
        if ((int )(opline + 1)->op1_type == 1 << 1) {
          value = zend_assign_tmp_to_variable(variable_ptr_ptr, value);
        } else {
          if ((int )(opline + 1)->op1_type == 1) {
            value = zend_assign_const_to_variable(variable_ptr_ptr, value);
          } else {
            value = zend_assign_to_variable(variable_ptr_ptr, value);
          }
        }
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(value);
          while (1) {
            __t___2 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___2->var.ptr = value;
            __t___2->var.ptr_ptr = & __t___2->var.ptr;
            break;
          }
        } else {

        }
      }
    }
    if (free_op_data2.var) {
      i_zval_ptr_dtor(free_op_data2.var);
    } else {

    }
    if ((unsigned int )free_op_data1.var != (unsigned int )((void *)0)) {
      if (((unsigned long )free_op_data1.var & 1UL) == 0UL) {
        i_zval_ptr_dtor(free_op_data1.var);
      } else {

      }
    } else {

    }
  }
  (execute_data->opline) ++;
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *value ;
  zval **variable_ptr_ptr ;
  zval *retval ;
  void __attribute__((__visibility__("default")))  *tmp ;
  char const   *__s ;
  int __l ;
  zval *__z ;
  char __attribute__((__visibility__("default")))  *tmp___0 ;
  temp_variable *__t ;
  temp_variable *__t___0 ;
  int tmp___1 ;
  temp_variable *__t___1 ;
  temp_variable *__t___2 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  opline = execute_data->opline;
  value = opline->op2.zv;
  variable_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 2) {
    tmp___3 = __builtin_expect((long )((unsigned int )variable_ptr_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___3) {
      tmp___1 = zend_assign_to_string_offset((temp_variable const   *)((temp_variable *)((char *)execute_data->Ts + opline->op1.var)), (zval const   *)value, 1);
      if (tmp___1) {
        if (! ((int )opline->result_type & (1 << 5))) {
          while (1) {
            tmp = _emalloc(sizeof(zval_gc_info ));
            retval = (zval *)tmp;
            ((zval_gc_info *)retval)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            __s = (char const   *)((((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->str_offset.str)->value.str.val + ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->str_offset.offset);
            __l = 1;
            __z = retval;
            __z->value.str.len = __l;
            tmp___0 = _estrndup(__s, (unsigned int )__l);
            __z->value.str.val = (char *)tmp___0;
            __z->type = (unsigned char)6;
            break;
          }
          retval->refcount__gc = 1U;
          retval->is_ref__gc = (unsigned char)0;
          while (1) {
            __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t->var.ptr = retval;
            __t->var.ptr_ptr = & __t->var.ptr;
            break;
          }
        } else {

        }
      } else {
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          while (1) {
            __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___0->var.ptr = & executor_globals.uninitialized_zval;
            __t___0->var.ptr_ptr = & __t___0->var.ptr;
            break;
          }
        } else {

        }
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if (1 << 4 == 1 << 2) {
      tmp___2 = __builtin_expect((long )((unsigned int )*variable_ptr_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
      if (tmp___2) {
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          while (1) {
            __t___1 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___1->var.ptr = & executor_globals.uninitialized_zval;
            __t___1->var.ptr_ptr = & __t___1->var.ptr;
            break;
          }
        } else {

        }
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      if (1 == 1 << 1) {
        value = zend_assign_tmp_to_variable(variable_ptr_ptr, value);
      } else {
        value = zend_assign_const_to_variable(variable_ptr_ptr, value);
      }
      if (! ((int )opline->result_type & (1 << 5))) {
        zval_addref_p(value);
        while (1) {
          __t___2 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
          __t___2->var.ptr = value;
          __t___2->var.ptr_ptr = & __t___2->var.ptr;
          break;
        }
      } else {

      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_METHOD_CALL_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *function_name ;
  char *function_name_strval ;
  int function_name_strlen ;
  long tmp ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  zval *object ;
  long tmp___1 ;
  zend_class_entry *tmp___2 ;
  zend_class_entry *tmp___3 ;
  char const   *tmp___4 ;
  zend_class_entry *tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  zend_function *tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  zval *this_ptr ;
  void __attribute__((__visibility__("default")))  *tmp___12 ;
  zend_bool tmp___13 ;

  {
  opline = execute_data->opline;
  zend_ptr_stack_3_push(& executor_globals.arg_types_stack, (void *)execute_data->fbc, (void *)execute_data->object, (void *)execute_data->called_scope);
  function_name = opline->op2.zv;
  function_name_strval = function_name->value.str.val;
  function_name_strlen = function_name->value.str.len;
  execute_data->object = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  tmp___10 = __builtin_expect((long )((unsigned int )execute_data->object != (unsigned int )((void *)0)), 1L);
  if (tmp___10) {
    tmp___11 = __builtin_expect((long )((int )(execute_data->object)->type == 5), 1L);
    if (tmp___11) {
      tmp___0 = zend_get_class_entry((zval const   *)execute_data->object);
      execute_data->called_scope = (zend_class_entry *)tmp___0;
      if ((unsigned int )*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) == (unsigned int )execute_data->called_scope) {
        tmp___9 = (zend_function *)*((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U));
      } else {
        tmp___9 = (zend_function *)((void *)0);
      }
      execute_data->fbc = tmp___9;
      if ((unsigned int )tmp___9 == (unsigned int )((void *)0)) {
        object = execute_data->object;
        tmp___1 = __builtin_expect((long )((unsigned int )((execute_data->object)->value.obj.handlers)->get_method == (unsigned int )((void *)0)), 0L);
        if (tmp___1) {
          zend_error_noreturn(1, "Object does not support method calls");
        } else {

        }
        execute_data->fbc = (*(((execute_data->object)->value.obj.handlers)->get_method))(& execute_data->object, function_name_strval, function_name_strlen, (struct _zend_literal  const  *)(opline->op2.literal + 1));
        tmp___6 = __builtin_expect((long )((unsigned int )execute_data->fbc == (unsigned int )((void *)0)), 0L);
        if (tmp___6) {
          if (execute_data->object) {
            if ((int )(execute_data->object)->type == 5) {
              if ((unsigned int )((execute_data->object)->value.obj.handlers)->get_class_entry != (unsigned int )((void *)0)) {
                tmp___5 = (*(((execute_data->object)->value.obj.handlers)->get_class_entry))((zval const   *)execute_data->object);
                if (tmp___5) {
                  tmp___3 = (*(((execute_data->object)->value.obj.handlers)->get_class_entry))((zval const   *)execute_data->object);
                  tmp___4 = tmp___3->name;
                } else {
                  tmp___4 = "";
                }
              } else {
                tmp___4 = "";
              }
            } else {
              tmp___4 = "";
            }
          } else {
            tmp___4 = "";
          }
          zend_error_noreturn(1, "Call to undefined method %s::%s()", tmp___4, function_name_strval);
        } else {

        }
        tmp___7 = __builtin_expect((long )(((execute_data->fbc)->common.fn_flags & 6291456U) == 0U), 1L);
        if (tmp___7) {
          tmp___8 = __builtin_expect((long )((unsigned int )execute_data->object == (unsigned int )object), 1L);
          if (tmp___8) {
            while (1) {
              *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)execute_data->called_scope;
              *((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U)) = (void *)execute_data->fbc;
              break;
            }
          } else {

          }
        } else {

        }
      } else {

      }
    } else {
      zend_error_noreturn(1, "Call to a member function %s() on a non-object", function_name_strval);
    }
  } else {
    zend_error_noreturn(1, "Call to a member function %s() on a non-object", function_name_strval);
  }
  if (((execute_data->fbc)->common.fn_flags & 1U) != 0U) {
    execute_data->object = (zval *)((void *)0);
  } else {
    tmp___13 = zval_isref_p(execute_data->object);
    if (tmp___13) {
      while (1) {
        tmp___12 = _emalloc(sizeof(zval_gc_info ));
        this_ptr = (zval *)tmp___12;
        ((zval_gc_info *)this_ptr)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      while (1) {
        while (1) {
          this_ptr->value = (execute_data->object)->value;
          this_ptr->type = (execute_data->object)->type;
          break;
        }
        zval_set_refcount_p(this_ptr, 1U);
        zval_unset_isref_p(this_ptr);
        break;
      }
      _zval_copy_ctor(this_ptr);
      execute_data->object = this_ptr;
    } else {
      zval_addref_p(execute_data->object);
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_CASE_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  if (1 << 4 == 1 << 2) {
    zval_addref_p(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr);
  } else {

  }
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  is_equal_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp, opline->op2.zv);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *expr_ptr ;
  zval **expr_ptr_ptr ;
  zval **tmp ;
  long tmp___0 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zval *new_expr ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zval *new_expr___0 ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  zend_bool tmp___6 ;
  zval *offset ;
  ulong hval ;
  long tmp___7 ;
  register char const   *tmp___8 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___9 ;

  {
  opline = execute_data->opline;
  if (1 << 4 == 1 << 2) {
    goto _L___1;
  } else {
    if (1 << 4 == 1 << 4) {
      _L___1: /* CIL Label */ 
      if (opline->extended_value) {
        tmp = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var);
        expr_ptr_ptr = tmp;
        if (1 << 4 == 1 << 2) {
          tmp___0 = __builtin_expect((long )((unsigned int )expr_ptr_ptr == (unsigned int )((void *)0)), 0L);
          if (tmp___0) {
            zend_error_noreturn(1, "Cannot create references to/from string offsets");
          } else {

          }
        } else {

        }
        tmp___3 = zval_isref_p(*expr_ptr_ptr);
        if (tmp___3) {

        } else {
          while (1) {
            tmp___2 = zval_refcount_p(*expr_ptr_ptr);
            if (tmp___2 > 1U) {
              zval_delref_p(*expr_ptr_ptr);
              while (1) {
                tmp___1 = _emalloc(sizeof(zval_gc_info ));
                new_zv = (zval *)tmp___1;
                ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv->value = (*expr_ptr_ptr)->value;
                  new_zv->type = (*expr_ptr_ptr)->type;
                  break;
                }
                zval_set_refcount_p(new_zv, 1U);
                zval_unset_isref_p(new_zv);
                break;
              }
              *expr_ptr_ptr = new_zv;
              _zval_copy_ctor(new_zv);
            } else {

            }
            break;
          }
          zval_set_isref_p(*expr_ptr_ptr);
        }
        expr_ptr = *expr_ptr_ptr;
        zval_addref_p(expr_ptr);
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      expr_ptr = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
      if (1 << 4 == 1) {
        goto _L;
      } else {
        tmp___6 = zval_isref_p(expr_ptr);
        if (tmp___6) {
          _L: /* CIL Label */ 
          while (1) {
            tmp___5 = _emalloc(sizeof(zval_gc_info ));
            new_expr___0 = (zval *)tmp___5;
            ((zval_gc_info *)new_expr___0)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_expr___0->value = expr_ptr->value;
              new_expr___0->type = expr_ptr->type;
              break;
            }
            zval_set_refcount_p(new_expr___0, 1U);
            zval_unset_isref_p(new_expr___0);
            break;
          }
          expr_ptr = new_expr___0;
          _zval_copy_ctor(expr_ptr);
        } else {
          zval_addref_p(expr_ptr);
        }
      }
    }
  }
  if (1 != 1 << 3) {
    offset = opline->op2.zv;
    switch ((int )offset->type) {
    case 2: 
    tmp___7 = zend_dval_to_lval(offset->value.dval);
    hval = (unsigned long )tmp___7;
    goto num_index;
    case 1: 
    case 3: 
    hval = (unsigned long )offset->value.lval;
    num_index: 
    _zend_hash_index_update_or_next_insert(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, hval, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    case 6: 
    if (1) {
      hval = ((zend_literal *)offset)->hash_value;
    } else {
      while (1) {
        tmp___8 = (char const   *)offset->value.str.val;
        if ((int const   )*tmp___8 == 45) {
          tmp___8 ++;
        } else {

        }
        if ((int const   )*tmp___8 >= 48) {
          if ((int const   )*tmp___8 <= 57) {
            end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
            if ((int const   )*end != 0) {
              break;
            } else {
              if ((int const   )*tmp___8 == 48) {
                if (offset->value.str.len + 1 > 2) {
                  break;
                } else {
                  goto _L___2;
                }
              } else {
                _L___2: /* CIL Label */ 
                if (end - tmp___8 > 10) {
                  break;
                } else {
                  if (end - tmp___8 == 10) {
                    if ((int const   )*tmp___8 > 50) {
                      break;
                    } else {

                    }
                  } else {

                  }
                }
              }
            }
            hval = (unsigned long )((int const   )*tmp___8 - 48);
            while (1) {
              tmp___8 ++;
              if ((unsigned int )tmp___8 != (unsigned int )end) {
                if ((int const   )*tmp___8 >= 48) {
                  if ((int const   )*tmp___8 <= 57) {

                  } else {
                    break;
                  }
                } else {
                  break;
                }
              } else {
                break;
              }
              hval = hval * 10UL + (ulong )((int const   )*tmp___8 - 48);
            }
            if ((unsigned int )tmp___8 == (unsigned int )end) {
              if ((int )*(offset->value.str.val) == 45) {
                if (hval - 1UL > 2147483647UL) {
                  break;
                } else {

                }
                hval = (unsigned long )(- ((long )hval));
              } else {
                if (hval > 2147483647UL) {
                  break;
                } else {

                }
              }
              goto num_index;
            } else {

            }
          } else {

          }
        } else {

        }
        break;
      }
      if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
        if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
          hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
        } else {
          tmp___9 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___9;
        }
      } else {
        tmp___9 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
        hval = (unsigned long )tmp___9;
      }
    }
    _zend_hash_quick_add_or_update(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    case 0: 
    _zend_hash_add_or_update(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, "", sizeof(""), (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    default: 
    zend_error(1 << 1L, "Illegal offset type");
    i_zval_ptr_dtor(expr_ptr);
    break;
    }
  } else {
    _zend_hash_index_update_or_next_insert(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, 0UL, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1 << 2);
  }
  if (1 << 4 == 1 << 2) {
    goto _L___3;
  } else {
    if (1 << 4 == 1 << 4) {
      _L___3: /* CIL Label */ 
      if (opline->extended_value) {

      } else {

      }
    } else {

    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_ARRAY_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  int tmp ;

  {
  opline = execute_data->opline;
  _array_init(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, 0U);
  if (1 << 4 == 1 << 3) {
    (execute_data->opline) ++;
    return (0);
  } else {
    tmp = ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CONST_HANDLER(execute_data);
    return (tmp);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_UNSET_VAR_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval tmp ;
  zval *varname ;
  HashTable *target_symbol_table ;
  zend_compiled_variable *cv ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_literal *tmp___1 ;
  ulong hash_value ;
  ulong tmp___2 ;

  {
  opline = execute_data->opline;
  if (1 << 4 == 1 << 4) {
    if (1 == 1 << 3) {
      if (opline->extended_value & 8388608UL) {
        if (executor_globals.active_symbol_table) {
          cv = (executor_globals.active_op_array)->vars + opline->op1.var;
          zend_delete_variable(execute_data->prev_execute_data, executor_globals.active_symbol_table, cv->name, cv->name_len + 1, cv->hash_value);
          *(execute_data->CVs + opline->op1.var) = (zval **)((void *)0);
        } else {
          if (*(execute_data->CVs + opline->op1.var)) {
            i_zval_ptr_dtor(*(*(execute_data->CVs + opline->op1.var)));
            *(execute_data->CVs + opline->op1.var) = (zval **)((void *)0);
          } else {

          }
        }
        (execute_data->opline) ++;
        return (0);
      } else {

      }
    } else {

    }
  } else {

  }
  varname = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  if (1 << 4 != 1) {
    if ((int )varname->type != 6) {
      while (1) {
        tmp.value = varname->value;
        tmp.type = varname->type;
        break;
      }
      _zval_copy_ctor(& tmp);
      if ((int )tmp.type != 6) {
        _convert_to_string(& tmp);
      } else {

      }
      varname = & tmp;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if (1 << 4 == 1 << 2) {
      zval_addref_p(varname);
    } else {
      if (1 << 4 == 1 << 4) {
        zval_addref_p(varname);
      } else {

      }
    }
  }
  if (1 != 1 << 3) {
    if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
      ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
    } else {
      tmp___0 = zend_fetch_class_by_name((char const   *)(opline->op2.zv)->value.str.val, (unsigned int )(opline->op2.zv)->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), 0);
      ce = (zend_class_entry *)tmp___0;
      while (1) {
        *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
        break;
      }
    }
    if (1 << 4 == 1) {
      tmp___1 = opline->op1.literal;
    } else {
      tmp___1 = (zend_literal *)((void *)0);
    }
    zend_std_unset_static_property(ce, (char const   *)varname->value.str.val, varname->value.str.len, (struct _zend_literal  const  *)tmp___1);
  } else {
    tmp___2 = zend_inline_hash_func((char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1));
    hash_value = tmp___2;
    target_symbol_table = zend_get_target_symbol_table((int )(opline->extended_value & 1879048192UL));
    zend_delete_variable(execute_data, target_symbol_table, (char const   *)varname->value.str.val, varname->value.str.len + 1, hash_value);
  }
  if (1 << 4 != 1) {
    if ((unsigned int )varname == (unsigned int )(& tmp)) {
      _zval_dtor(& tmp);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if (1 << 4 == 1 << 2) {
      i_zval_ptr_dtor(varname);
    } else {
      if (1 << 4 == 1 << 4) {
        i_zval_ptr_dtor(varname);
      } else {

      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_UNSET_DIM_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **container ;
  zval *offset ;
  ulong hval ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  HashTable *ht ;
  long tmp___2 ;
  register char const   *tmp___3 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___4 ;
  long tmp___5 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 4) {
    if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
      tmp___1 = zval_isref_p(*container);
      if (tmp___1) {

      } else {
        while (1) {
          tmp___0 = zval_refcount_p(*container);
          if (tmp___0 > 1U) {
            zval_delref_p(*container);
            while (1) {
              tmp = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*container)->value;
                new_zv->type = (*container)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *container = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
    } else {

    }
  } else {

  }
  offset = opline->op2.zv;
  if (1 << 4 != 1 << 2) {
    goto _L___0;
  } else {
    if (container) {
      _L___0: /* CIL Label */ 
      switch ((int )(*container)->type) {
      case 4: 
      ht = (*container)->value.ht;
      switch ((int )offset->type) {
      case 2: 
      tmp___2 = zend_dval_to_lval(offset->value.dval);
      hval = (unsigned long )tmp___2;
      goto num_index_dim;
      case 7: 
      case 3: 
      case 1: 
      hval = (unsigned long )offset->value.lval;
      zend_hash_del_key_or_index(ht, (char const   *)((void *)0), 0U, hval, 1);
      break;
      case 6: 
      if (1 == 1 << 4) {
        zval_addref_p(offset);
      } else {
        if (1 == 1 << 2) {
          zval_addref_p(offset);
        } else {

        }
      }
      if (1) {
        hval = ((zend_literal *)offset)->hash_value;
      } else {
        while (1) {
          tmp___3 = (char const   *)offset->value.str.val;
          if ((int const   )*tmp___3 == 45) {
            tmp___3 ++;
          } else {

          }
          if ((int const   )*tmp___3 >= 48) {
            if ((int const   )*tmp___3 <= 57) {
              end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
              if ((int const   )*end != 0) {
                break;
              } else {
                if ((int const   )*tmp___3 == 48) {
                  if (offset->value.str.len + 1 > 2) {
                    break;
                  } else {
                    goto _L;
                  }
                } else {
                  _L: /* CIL Label */ 
                  if (end - tmp___3 > 10) {
                    break;
                  } else {
                    if (end - tmp___3 == 10) {
                      if ((int const   )*tmp___3 > 50) {
                        break;
                      } else {

                      }
                    } else {

                    }
                  }
                }
              }
              hval = (unsigned long )((int const   )*tmp___3 - 48);
              while (1) {
                tmp___3 ++;
                if ((unsigned int )tmp___3 != (unsigned int )end) {
                  if ((int const   )*tmp___3 >= 48) {
                    if ((int const   )*tmp___3 <= 57) {

                    } else {
                      break;
                    }
                  } else {
                    break;
                  }
                } else {
                  break;
                }
                hval = hval * 10UL + (ulong )((int const   )*tmp___3 - 48);
              }
              if ((unsigned int )tmp___3 == (unsigned int )end) {
                if ((int )*(offset->value.str.val) == 45) {
                  if (hval - 1UL > 2147483647UL) {
                    break;
                  } else {

                  }
                  hval = (unsigned long )(- ((long )hval));
                } else {
                  if (hval > 2147483647UL) {
                    break;
                  } else {

                  }
                }
                goto num_index_dim;
              } else {

              }
            } else {

            }
          } else {

          }
          break;
        }
        if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
          if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
            hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
          } else {
            tmp___4 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
            hval = (unsigned long )tmp___4;
          }
        } else {
          tmp___4 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___4;
        }
      }
      if ((unsigned int )ht == (unsigned int )(& executor_globals.symbol_table)) {
        zend_delete_global_variable_ex((char const   *)offset->value.str.val, offset->value.str.len, hval);
      } else {
        zend_hash_del_key_or_index(ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, 2);
      }
      if (1 == 1 << 4) {
        i_zval_ptr_dtor(offset);
      } else {
        if (1 == 1 << 2) {
          i_zval_ptr_dtor(offset);
        } else {

        }
      }
      break;
      num_index_dim: 
      zend_hash_del_key_or_index(ht, (char const   *)((void *)0), 0U, hval, 1);
      if (1 == 1 << 4) {
        i_zval_ptr_dtor(offset);
      } else {
        if (1 == 1 << 2) {
          i_zval_ptr_dtor(offset);
        } else {

        }
      }
      break;
      case 0: 
      zend_hash_del_key_or_index(ht, "", sizeof(""), 0UL, 0);
      break;
      default: 
      zend_error(1 << 1L, "Illegal offset type in unset");
      break;
      }
      break;
      case 5: 
      tmp___5 = __builtin_expect((long )((unsigned int )((*container)->value.obj.handlers)->unset_dimension == (unsigned int )((void *)0)), 0L);
      if (tmp___5) {
        zend_error_noreturn(1, "Cannot use object as array");
      } else {

      }
      (*(((*container)->value.obj.handlers)->unset_dimension))(*container, offset);
      break;
      case 6: 
      zend_error_noreturn(1, "Cannot unset string offsets");
      return (0);
      default: ;
      break;
      }
    } else {

    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_UNSET_OBJ_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **container ;
  zval *offset ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data->CVs, opline->op1.var);
  offset = opline->op2.zv;
  if (1 << 4 != 1 << 2) {
    goto _L;
  } else {
    if (container) {
      _L: /* CIL Label */ 
      if (1 << 4 == 1 << 4) {
        if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
          tmp___1 = zval_isref_p(*container);
          if (tmp___1) {

          } else {
            while (1) {
              tmp___0 = zval_refcount_p(*container);
              if (tmp___0 > 1U) {
                zval_delref_p(*container);
                while (1) {
                  tmp = _emalloc(sizeof(zval_gc_info ));
                  new_zv = (zval *)tmp;
                  ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                  break;
                }
                while (1) {
                  while (1) {
                    new_zv->value = (*container)->value;
                    new_zv->type = (*container)->type;
                    break;
                  }
                  zval_set_refcount_p(new_zv, 1U);
                  zval_unset_isref_p(new_zv);
                  break;
                }
                *container = new_zv;
                _zval_copy_ctor(new_zv);
              } else {

              }
              break;
            }
          }
        } else {

        }
      } else {

      }
      if ((int )(*container)->type == 5) {
        if (((*container)->value.obj.handlers)->unset_property) {
          (*(((*container)->value.obj.handlers)->unset_property))(*container, offset, (struct _zend_literal  const  *)opline->op2.literal);
        } else {
          zend_error(1 << 3L, "Trying to unset property of non-object");
        }
      } else {

      }
    } else {

    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ISSET_ISEMPTY_VAR_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **value ;
  zend_bool isset ;
  zend_compiled_variable *cv ;
  int __attribute__((__visibility__("default")))  tmp ;
  HashTable *target_symbol_table ;
  zval tmp___0 ;
  zval *varname ;
  zval *tmp___1 ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_literal *tmp___3 ;
  zval __attribute__((__visibility__("default")))  **tmp___4 ;
  int __attribute__((__visibility__("default")))  tmp___5 ;
  zval *__z ;
  zval *__z___0 ;
  zval *__z___1 ;
  zval *__z___2 ;
  int tmp___6 ;

  {
  opline = execute_data->opline;
  isset = (zend_bool )1;
  if (1 << 4 == 1 << 4) {
    if (1 == 1 << 3) {
      if (opline->extended_value & 8388608UL) {
        if (*(execute_data->CVs + opline->op1.var)) {
          value = *(execute_data->CVs + opline->op1.var);
        } else {
          if (executor_globals.active_symbol_table) {
            cv = (executor_globals.active_op_array)->vars + opline->op1.var;
            tmp = zend_hash_quick_find((HashTable const   *)executor_globals.active_symbol_table, cv->name, (unsigned int )(cv->name_len + 1), cv->hash_value, (void **)(& value));
            if (tmp == (int __attribute__((__visibility__("default")))  )-1) {
              isset = (unsigned char)0;
            } else {

            }
          } else {
            isset = (unsigned char)0;
          }
        }
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    _L: /* CIL Label */ 
    tmp___1 = _get_zval_ptr_cv_BP_VAR_IS(execute_data->CVs, opline->op1.var);
    varname = tmp___1;
    if (1 << 4 != 1) {
      if ((int )varname->type != 6) {
        while (1) {
          tmp___0.value = varname->value;
          tmp___0.type = varname->type;
          break;
        }
        _zval_copy_ctor(& tmp___0);
        if ((int )tmp___0.type != 6) {
          _convert_to_string(& tmp___0);
        } else {

        }
        varname = & tmp___0;
      } else {

      }
    } else {

    }
    if (1 != 1 << 3) {
      if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
        ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
      } else {
        tmp___2 = zend_fetch_class_by_name((char const   *)(opline->op2.zv)->value.str.val, (unsigned int )(opline->op2.zv)->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), 0);
        ce = (zend_class_entry *)tmp___2;
        while (1) {
          *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
          break;
        }
      }
      if (1 << 4 == 1) {
        tmp___3 = opline->op1.literal;
      } else {
        tmp___3 = (zend_literal *)((void *)0);
      }
      tmp___4 = zend_std_get_static_property(ce, (char const   *)varname->value.str.val, varname->value.str.len, (unsigned char)1, (struct _zend_literal  const  *)tmp___3);
      value = (zval **)tmp___4;
      if (! value) {
        isset = (unsigned char)0;
      } else {

      }
    } else {
      target_symbol_table = zend_get_target_symbol_table((int )(opline->extended_value & 1879048192UL));
      tmp___5 = zend_hash_find((HashTable const   *)target_symbol_table, (char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1), (void **)(& value));
      if (tmp___5 == (int __attribute__((__visibility__("default")))  )-1) {
        isset = (unsigned char)0;
      } else {

      }
    }
    if (1 << 4 != 1) {
      if ((unsigned int )varname == (unsigned int )(& tmp___0)) {
        _zval_dtor(& tmp___0);
      } else {

      }
    } else {

    }
  }
  if (opline->extended_value & 33554432UL) {
    if (isset) {
      if ((int )(*value)->type != 0) {
        while (1) {
          __z = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
          __z->value.lval = 1L;
          __z->type = (unsigned char)3;
          break;
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      while (1) {
        __z___0 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
        __z___0->value.lval = 0L;
        __z___0->type = (unsigned char)3;
        break;
      }
    }
  } else {
    if (! isset) {
      goto _L___2;
    } else {
      tmp___6 = i_zend_is_true(*value);
      if (tmp___6) {
        while (1) {
          __z___2 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
          __z___2->value.lval = 0L;
          __z___2->type = (unsigned char)3;
          break;
        }
      } else {
        _L___2: /* CIL Label */ 
        while (1) {
          __z___1 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
          __z___1->value.lval = 1L;
          __z___1->type = (unsigned char)3;
          break;
        }
      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_CONST)(int prop_dim , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **container ;
  zval **value ;
  int result ;
  ulong hval ;
  zval *offset ;
  HashTable *ht ;
  int isset ;
  long tmp ;
  int __attribute__((__visibility__("default")))  tmp___0 ;
  register char const   *tmp___1 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___2 ;
  int __attribute__((__visibility__("default")))  tmp___3 ;
  int __attribute__((__visibility__("default")))  tmp___4 ;
  int tmp___5 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;
  zval tmp___7 ;

  {
  opline = execute_data->opline;
  value = (zval **)((void *)0);
  result = 0;
  container = _get_zval_ptr_ptr_cv_BP_VAR_IS(execute_data->CVs, opline->op1.var);
  offset = opline->op2.zv;
  if ((int )(*container)->type == 4) {
    if (! prop_dim) {
      isset = 0;
      ht = (*container)->value.ht;
      switch ((int )offset->type) {
      case 2: 
      tmp = zend_dval_to_lval(offset->value.dval);
      hval = (unsigned long )tmp;
      goto num_index_prop;
      case 7: 
      case 3: 
      case 1: 
      hval = (unsigned long )offset->value.lval;
      num_index_prop: 
      tmp___0 = zend_hash_index_find((HashTable const   *)ht, hval, (void **)(& value));
      if (tmp___0 == (int __attribute__((__visibility__("default")))  )0) {
        isset = 1;
      } else {

      }
      break;
      case 6: 
      if (1) {
        hval = ((zend_literal *)offset)->hash_value;
      } else {
        if (! prop_dim) {
          while (1) {
            tmp___1 = (char const   *)offset->value.str.val;
            if ((int const   )*tmp___1 == 45) {
              tmp___1 ++;
            } else {

            }
            if ((int const   )*tmp___1 >= 48) {
              if ((int const   )*tmp___1 <= 57) {
                end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
                if ((int const   )*end != 0) {
                  break;
                } else {
                  if ((int const   )*tmp___1 == 48) {
                    if (offset->value.str.len + 1 > 2) {
                      break;
                    } else {
                      goto _L;
                    }
                  } else {
                    _L: /* CIL Label */ 
                    if (end - tmp___1 > 10) {
                      break;
                    } else {
                      if (end - tmp___1 == 10) {
                        if ((int const   )*tmp___1 > 50) {
                          break;
                        } else {

                        }
                      } else {

                      }
                    }
                  }
                }
                hval = (unsigned long )((int const   )*tmp___1 - 48);
                while (1) {
                  tmp___1 ++;
                  if ((unsigned int )tmp___1 != (unsigned int )end) {
                    if ((int const   )*tmp___1 >= 48) {
                      if ((int const   )*tmp___1 <= 57) {

                      } else {
                        break;
                      }
                    } else {
                      break;
                    }
                  } else {
                    break;
                  }
                  hval = hval * 10UL + (ulong )((int const   )*tmp___1 - 48);
                }
                if ((unsigned int )tmp___1 == (unsigned int )end) {
                  if ((int )*(offset->value.str.val) == 45) {
                    if (hval - 1UL > 2147483647UL) {
                      break;
                    } else {

                    }
                    hval = (unsigned long )(- ((long )hval));
                  } else {
                    if (hval > 2147483647UL) {
                      break;
                    } else {

                    }
                  }
                  goto num_index_prop;
                } else {

                }
              } else {

              }
            } else {

            }
            break;
          }
        } else {

        }
        if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
          if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
            hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
          } else {
            tmp___2 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
            hval = (unsigned long )tmp___2;
          }
        } else {
          tmp___2 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___2;
        }
      }
      tmp___3 = zend_hash_quick_find((HashTable const   *)ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, (void **)(& value));
      if (tmp___3 == (int __attribute__((__visibility__("default")))  )0) {
        isset = 1;
      } else {

      }
      break;
      case 0: 
      tmp___4 = zend_hash_find((HashTable const   *)ht, "", sizeof(""), (void **)(& value));
      if (tmp___4 == (int __attribute__((__visibility__("default")))  )0) {
        isset = 1;
      } else {

      }
      break;
      default: 
      zend_error(1 << 1L, "Illegal offset type in isset or empty");
      break;
      }
      if (opline->extended_value & 33554432UL) {
        if (isset) {
          if ((int )(*value)->type == 0) {
            result = 0;
          } else {
            result = isset;
          }
        } else {
          result = isset;
        }
      } else {
        if (! isset) {
          result = 0;
        } else {
          tmp___5 = i_zend_is_true(*value);
          if (tmp___5) {
            result = 1;
          } else {
            result = 0;
          }
        }
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if ((int )(*container)->type == 5) {
      if (prop_dim) {
        if (((*container)->value.obj.handlers)->has_property) {
          result = (*(((*container)->value.obj.handlers)->has_property))(*container, offset, (opline->extended_value & 16777216UL) != 0UL, (struct _zend_literal  const  *)opline->op2.literal);
        } else {
          zend_error(1 << 3L, "Trying to check property of non-object");
          result = 0;
        }
      } else {
        if (((*container)->value.obj.handlers)->has_dimension) {
          result = (*(((*container)->value.obj.handlers)->has_dimension))(*container, offset, (opline->extended_value & 16777216UL) != 0UL);
        } else {
          zend_error(1 << 3L, "Trying to check element of non-array");
          result = 0;
        }
      }
    } else {
      if ((int )(*container)->type == 6) {
        if (! prop_dim) {
          if ((int )offset->type != 1) {
            while (1) {
              tmp___7.value = offset->value;
              tmp___7.type = offset->type;
              break;
            }
            _zval_copy_ctor(& tmp___7);
            convert_to_long(& tmp___7);
            offset = & tmp___7;
          } else {

          }
          if ((int )offset->type == 1) {
            if (opline->extended_value & 33554432UL) {
              if (offset->value.lval >= 0L) {
                if (offset->value.lval < (long )(*container)->value.str.len) {
                  result = 1;
                } else {

                }
              } else {

              }
            } else {
              if (offset->value.lval >= 0L) {
                if (offset->value.lval < (long )(*container)->value.str.len) {
                  if ((int )*((*container)->value.str.val + offset->value.lval) != 48) {
                    result = 1;
                  } else {

                  }
                } else {

                }
              } else {

              }
            }
          } else {

          }
        } else {

        }
      } else {

      }
    }
  }
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.type = (unsigned char)3;
  if (opline->extended_value & 33554432UL) {
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.lval = (long )result;
  } else {
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.lval = (long )(! result);
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_CONST(0, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CONST_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_CONST(1, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  fast_add_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SUB_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  fast_sub_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_MUL_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  fast_mul_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_DIV_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  fast_div_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_MOD_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  fast_mod_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SL_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  shift_left_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SR_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  shift_right_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_CONCAT_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  concat_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_IDENTICAL_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  is_identical_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_NOT_IDENTICAL_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *result ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  is_identical_function(result, tmp___0, tmp);
  result->value.lval = (long )(! result->value.lval);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_EQUAL_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  zval *tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
    tmp___1 = fast_equal_function(result, tmp___0, tmp);
    __z->value.lval = (long )(tmp___1 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_NOT_EQUAL_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  zval *tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
    tmp___1 = fast_not_equal_function(result, tmp___0, tmp);
    __z->value.lval = (long )(tmp___1 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_SMALLER_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  zval *tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
    tmp___1 = fast_is_smaller_function(result, tmp___0, tmp);
    __z->value.lval = (long )(tmp___1 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  zval *tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
    tmp___1 = fast_is_smaller_or_equal_function(result, tmp___0, tmp);
    __z->value.lval = (long )(tmp___1 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_OR_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  bitwise_or_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_AND_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  bitwise_and_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_XOR_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  bitwise_xor_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BOOL_XOR_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  boolean_xor_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_binary_assign_op_obj_helper_SPEC_CV_TMP)(int (*binary_op)(zval *result , zval *op1 , zval *op2 ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zend_free_op free_op_data1 ;
  zval **object_ptr ;
  zval **tmp ;
  zval *object ;
  zval *property ;
  zval *tmp___0 ;
  zval *value ;
  zval *tmp___1 ;
  int have_get_ptr ;
  long tmp___2 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___3 ;
  zval **zptr ;
  zend_literal *tmp___4 ;
  zval **tmp___5 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;
  zend_uint tmp___7 ;
  zend_bool tmp___8 ;
  zval *z ;
  zend_literal *tmp___9 ;
  zval *value___0 ;
  zval *tmp___10 ;
  zend_uint tmp___11 ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___12 ;
  zend_uint tmp___13 ;
  zend_bool tmp___14 ;
  zend_literal *tmp___15 ;
  long tmp___16 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var);
  object_ptr = tmp;
  tmp___0 = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  property = tmp___0;
  tmp___1 = _get_zval_ptr((int )(opline + 1)->op1_type, (znode_op const   *)(& (opline + 1)->op1), (temp_variable const   *)execute_data->Ts, & free_op_data1, 0);
  value = tmp___1;
  have_get_ptr = 0;
  if (1 << 4 == 1 << 2) {
    tmp___2 = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___2) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  make_real_object(object_ptr);
  object = *object_ptr;
  tmp___16 = __builtin_expect((long )((int )object->type != 5), 0L);
  if (tmp___16) {
    zend_error(1 << 1L, "Attempt to assign property of non-object");
    _zval_dtor(free_op2.var);
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = & executor_globals.uninitialized_zval;
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
    } else {

    }
  } else {
    while (1) {
      while (1) {
        tmp___3 = _emalloc(sizeof(zval_gc_info ));
        _tmp = (zval *)tmp___3;
        ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      while (1) {
        while (1) {
          _tmp->value = property->value;
          _tmp->type = property->type;
          break;
        }
        zval_set_refcount_p(_tmp, 1U);
        zval_unset_isref_p(_tmp);
        break;
      }
      property = _tmp;
      break;
    }
    if (opline->extended_value == 136UL) {
      if ((object->value.obj.handlers)->get_property_ptr_ptr) {
        if (1 << 1 == 1) {
          tmp___4 = opline->op2.literal;
        } else {
          tmp___4 = (zend_literal *)((void *)0);
        }
        tmp___5 = (*((object->value.obj.handlers)->get_property_ptr_ptr))(object, property, (struct _zend_literal  const  *)tmp___4);
        zptr = tmp___5;
        if ((unsigned int )zptr != (unsigned int )((void *)0)) {
          tmp___8 = zval_isref_p(*zptr);
          if (tmp___8) {

          } else {
            while (1) {
              tmp___7 = zval_refcount_p(*zptr);
              if (tmp___7 > 1U) {
                zval_delref_p(*zptr);
                while (1) {
                  tmp___6 = _emalloc(sizeof(zval_gc_info ));
                  new_zv = (zval *)tmp___6;
                  ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                  break;
                }
                while (1) {
                  while (1) {
                    new_zv->value = (*zptr)->value;
                    new_zv->type = (*zptr)->type;
                    break;
                  }
                  zval_set_refcount_p(new_zv, 1U);
                  zval_unset_isref_p(new_zv);
                  break;
                }
                *zptr = new_zv;
                _zval_copy_ctor(new_zv);
              } else {

              }
              break;
            }
          }
          have_get_ptr = 1;
          (*binary_op)(*zptr, *zptr, value);
          if (! ((int )opline->result_type & (1 << 5))) {
            zval_addref_p(*zptr);
            ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = *zptr;
            ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
          } else {

          }
        } else {

        }
      } else {

      }
    } else {

    }
    if (! have_get_ptr) {
      z = (zval *)((void *)0);
      if (opline->extended_value == 136UL) {
        if ((object->value.obj.handlers)->read_property) {
          if (1 << 1 == 1) {
            tmp___9 = opline->op2.literal;
          } else {
            tmp___9 = (zend_literal *)((void *)0);
          }
          z = (*((object->value.obj.handlers)->read_property))(object, property, 0, (struct _zend_literal  const  *)tmp___9);
        } else {

        }
      } else {
        if ((object->value.obj.handlers)->read_dimension) {
          z = (*((object->value.obj.handlers)->read_dimension))(object, property, 0);
        } else {

        }
      }
      if (z) {
        if ((int )z->type == 5) {
          if ((z->value.obj.handlers)->get) {
            tmp___10 = (*((z->value.obj.handlers)->get))(z);
            value___0 = tmp___10;
            tmp___11 = zval_refcount_p(z);
            if (tmp___11 == 0U) {
              if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                gc_remove_zval_from_buffer(z);
              } else {

              }
              _zval_dtor(z);
              while (1) {
                if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                  gc_remove_zval_from_buffer(z);
                } else {

                }
                _efree((void *)z);
                break;
              }
            } else {

            }
            z = value___0;
          } else {

          }
        } else {

        }
        zval_addref_p(z);
        tmp___14 = zval_isref_p(z);
        if (tmp___14) {

        } else {
          while (1) {
            tmp___13 = zval_refcount_p(z);
            if (tmp___13 > 1U) {
              zval_delref_p(z);
              while (1) {
                tmp___12 = _emalloc(sizeof(zval_gc_info ));
                new_zv___0 = (zval *)tmp___12;
                ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv___0->value = z->value;
                  new_zv___0->type = z->type;
                  break;
                }
                zval_set_refcount_p(new_zv___0, 1U);
                zval_unset_isref_p(new_zv___0);
                break;
              }
              z = new_zv___0;
              _zval_copy_ctor(new_zv___0);
            } else {

            }
            break;
          }
        }
        (*binary_op)(z, z, value);
        if (opline->extended_value == 136UL) {
          if (1 << 1 == 1) {
            tmp___15 = opline->op2.literal;
          } else {
            tmp___15 = (zend_literal *)((void *)0);
          }
          (*((object->value.obj.handlers)->write_property))(object, property, z, (struct _zend_literal  const  *)tmp___15);
        } else {
          (*((object->value.obj.handlers)->write_dimension))(object, property, z);
        }
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(z);
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = z;
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
        } else {

        }
        i_zval_ptr_dtor(z);
      } else {
        zend_error(1 << 1L, "Attempt to assign property of non-object");
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = & executor_globals.uninitialized_zval;
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
        } else {

        }
      }
    } else {

    }
    i_zval_ptr_dtor(property);
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
  }
  (execute_data->opline) ++;
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_binary_assign_op_helper_SPEC_CV_TMP)(int (*binary_op)(zval *result , zval *op1 , zval *op2 ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zend_free_op free_op_data2 ;
  zend_free_op free_op_data1 ;
  zval **var_ptr ;
  zval *value ;
  int tmp ;
  zval **container ;
  zval **tmp___0 ;
  int tmp___1 ;
  zval *dim ;
  zval *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  temp_variable *__t ;
  long tmp___6 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___7 ;
  zend_uint tmp___8 ;
  zend_bool tmp___9 ;
  zval *objval ;
  zval *tmp___10 ;
  long tmp___11 ;
  temp_variable *__t___0 ;

  {
  opline = execute_data->opline;
  switch ((int )opline->extended_value) {
  case 136: 
  tmp = zend_binary_assign_op_obj_helper_SPEC_CV_TMP(binary_op, execute_data);
  return (tmp);
  break;
  case 147: 
  tmp___0 = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var);
  container = tmp___0;
  if (1 << 4 == 1 << 2) {
    tmp___4 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___4) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    tmp___3 = __builtin_expect((long )((int )(*container)->type == 5), 0L);
    if (tmp___3) {
      if (1 << 4 == 1 << 2) {
        zval_addref_p(*container);
      } else {

      }
      tmp___1 = zend_binary_assign_op_obj_helper_SPEC_CV_TMP(binary_op, execute_data);
      return (tmp___1);
    } else {
      tmp___2 = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
      dim = tmp___2;
      zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var), container, dim, 1 << 1, 2);
      value = _get_zval_ptr((int )(opline + 1)->op1_type, (znode_op const   *)(& (opline + 1)->op1), (temp_variable const   *)execute_data->Ts, & free_op_data1, 0);
      var_ptr = _get_zval_ptr_ptr_var((opline + 1)->op2.var, (temp_variable const   *)execute_data->Ts, & free_op_data2);
    }
  }
  break;
  default: 
  value = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var);
  break;
  }
  tmp___5 = __builtin_expect((long )((unsigned int )var_ptr == (unsigned int )((void *)0)), 0L);
  if (tmp___5) {
    zend_error_noreturn(1, "Cannot use assign-op operators with overloaded objects nor string offsets");
  } else {

  }
  tmp___6 = __builtin_expect((long )((unsigned int )*var_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
  if (tmp___6) {
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      while (1) {
        __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t->var.ptr = & executor_globals.uninitialized_zval;
        __t->var.ptr_ptr = & __t->var.ptr;
        break;
      }
    } else {

    }
    _zval_dtor(free_op2.var);
    if (opline->extended_value == 147UL) {
      (execute_data->opline) ++;
    } else {

    }
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  tmp___9 = zval_isref_p(*var_ptr);
  if (tmp___9) {

  } else {
    while (1) {
      tmp___8 = zval_refcount_p(*var_ptr);
      if (tmp___8 > 1U) {
        zval_delref_p(*var_ptr);
        while (1) {
          tmp___7 = _emalloc(sizeof(zval_gc_info ));
          new_zv = (zval *)tmp___7;
          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            new_zv->value = (*var_ptr)->value;
            new_zv->type = (*var_ptr)->type;
            break;
          }
          zval_set_refcount_p(new_zv, 1U);
          zval_unset_isref_p(new_zv);
          break;
        }
        *var_ptr = new_zv;
        _zval_copy_ctor(new_zv);
      } else {

      }
      break;
    }
  }
  tmp___11 = __builtin_expect((long )((int )(*var_ptr)->type == 5), 0L);
  if (tmp___11) {
    if (((*var_ptr)->value.obj.handlers)->get) {
      if (((*var_ptr)->value.obj.handlers)->set) {
        tmp___10 = (*(((*var_ptr)->value.obj.handlers)->get))(*var_ptr);
        objval = tmp___10;
        zval_addref_p(objval);
        (*binary_op)(objval, objval, value);
        (*(((*var_ptr)->value.obj.handlers)->set))(var_ptr, objval);
        i_zval_ptr_dtor(objval);
      } else {
        (*binary_op)(*var_ptr, *var_ptr, value);
      }
    } else {
      (*binary_op)(*var_ptr, *var_ptr, value);
    }
  } else {
    (*binary_op)(*var_ptr, *var_ptr, value);
  }
  if (! ((int )opline->result_type & (1 << 5))) {
    zval_addref_p(*var_ptr);
    while (1) {
      __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
      __t___0->var.ptr = *var_ptr;
      __t___0->var.ptr_ptr = & __t___0->var.ptr;
      break;
    }
  } else {

  }
  _zval_dtor(free_op2.var);
  if (opline->extended_value == 147UL) {
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
    if (free_op_data2.var) {
      i_zval_ptr_dtor(free_op_data2.var);
    } else {

    }
    (execute_data->opline) ++;
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_ADD_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_TMP((int (*)(zval *result , zval *op1 , zval *op2 ))(& add_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SUB_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_TMP((int (*)(zval *result , zval *op1 , zval *op2 ))(& sub_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_MUL_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_TMP((int (*)(zval *result , zval *op1 , zval *op2 ))(& mul_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_DIV_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_TMP((int (*)(zval *result , zval *op1 , zval *op2 ))(& div_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_MOD_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_TMP((int (*)(zval *result , zval *op1 , zval *op2 ))(& mod_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SL_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_TMP((int (*)(zval *result , zval *op1 , zval *op2 ))(& shift_left_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SR_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_TMP((int (*)(zval *result , zval *op1 , zval *op2 ))(& shift_right_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_CONCAT_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_TMP((int (*)(zval *result , zval *op1 , zval *op2 ))(& concat_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_OR_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_TMP((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_or_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_AND_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_TMP((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_and_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_XOR_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_TMP((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_xor_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) zend_pre_incdec_property_helper_SPEC_CV_TMP)(int (*incdec_op)(zval * ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval **object_ptr ;
  zval *object ;
  zval *property ;
  zval **retval ;
  int have_get_ptr ;
  long tmp ;
  long tmp___0 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zval **zptr ;
  zend_literal *tmp___2 ;
  zval **tmp___3 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_uint tmp___5 ;
  zend_bool tmp___6 ;
  zval *z ;
  zend_literal *tmp___7 ;
  zval *tmp___8 ;
  zval *value ;
  zval *tmp___9 ;
  zend_uint tmp___10 ;
  long tmp___11 ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___12 ;
  zend_uint tmp___13 ;
  zend_bool tmp___14 ;
  zend_literal *tmp___15 ;

  {
  opline = execute_data->opline;
  have_get_ptr = 0;
  object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var);
  property = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  retval = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
  if (1 << 4 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot increment/decrement overloaded objects nor string offsets");
    } else {

    }
  } else {

  }
  make_real_object(object_ptr);
  object = *object_ptr;
  tmp___0 = __builtin_expect((long )((int )object->type != 5), 0L);
  if (tmp___0) {
    zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
    _zval_dtor(free_op2.var);
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      *retval = & executor_globals.uninitialized_zval;
    } else {

    }
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  while (1) {
    while (1) {
      tmp___1 = _emalloc(sizeof(zval_gc_info ));
      _tmp = (zval *)tmp___1;
      ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
      break;
    }
    while (1) {
      while (1) {
        _tmp->value = property->value;
        _tmp->type = property->type;
        break;
      }
      zval_set_refcount_p(_tmp, 1U);
      zval_unset_isref_p(_tmp);
      break;
    }
    property = _tmp;
    break;
  }
  if ((object->value.obj.handlers)->get_property_ptr_ptr) {
    if (1 << 1 == 1) {
      tmp___2 = opline->op2.literal;
    } else {
      tmp___2 = (zend_literal *)((void *)0);
    }
    tmp___3 = (*((object->value.obj.handlers)->get_property_ptr_ptr))(object, property, (struct _zend_literal  const  *)tmp___2);
    zptr = tmp___3;
    if ((unsigned int )zptr != (unsigned int )((void *)0)) {
      tmp___6 = zval_isref_p(*zptr);
      if (tmp___6) {

      } else {
        while (1) {
          tmp___5 = zval_refcount_p(*zptr);
          if (tmp___5 > 1U) {
            zval_delref_p(*zptr);
            while (1) {
              tmp___4 = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp___4;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*zptr)->value;
                new_zv->type = (*zptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *zptr = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
      have_get_ptr = 1;
      (*incdec_op)(*zptr);
      if (! ((int )opline->result_type & (1 << 5))) {
        *retval = *zptr;
        zval_addref_p(*retval);
      } else {

      }
    } else {

    }
  } else {

  }
  if (! have_get_ptr) {
    if ((object->value.obj.handlers)->read_property) {
      if ((object->value.obj.handlers)->write_property) {
        if (1 << 1 == 1) {
          tmp___7 = opline->op2.literal;
        } else {
          tmp___7 = (zend_literal *)((void *)0);
        }
        tmp___8 = (*((object->value.obj.handlers)->read_property))(object, property, 0, (struct _zend_literal  const  *)tmp___7);
        z = tmp___8;
        tmp___11 = __builtin_expect((long )((int )z->type == 5), 0L);
        if (tmp___11) {
          if ((z->value.obj.handlers)->get) {
            tmp___9 = (*((z->value.obj.handlers)->get))(z);
            value = tmp___9;
            tmp___10 = zval_refcount_p(z);
            if (tmp___10 == 0U) {
              if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                gc_remove_zval_from_buffer(z);
              } else {

              }
              _zval_dtor(z);
              while (1) {
                if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                  gc_remove_zval_from_buffer(z);
                } else {

                }
                _efree((void *)z);
                break;
              }
            } else {

            }
            z = value;
          } else {

          }
        } else {

        }
        zval_addref_p(z);
        tmp___14 = zval_isref_p(z);
        if (tmp___14) {

        } else {
          while (1) {
            tmp___13 = zval_refcount_p(z);
            if (tmp___13 > 1U) {
              zval_delref_p(z);
              while (1) {
                tmp___12 = _emalloc(sizeof(zval_gc_info ));
                new_zv___0 = (zval *)tmp___12;
                ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv___0->value = z->value;
                  new_zv___0->type = z->type;
                  break;
                }
                zval_set_refcount_p(new_zv___0, 1U);
                zval_unset_isref_p(new_zv___0);
                break;
              }
              z = new_zv___0;
              _zval_copy_ctor(new_zv___0);
            } else {

            }
            break;
          }
        }
        (*incdec_op)(z);
        *retval = z;
        if (1 << 1 == 1) {
          tmp___15 = opline->op2.literal;
        } else {
          tmp___15 = (zend_literal *)((void *)0);
        }
        (*((object->value.obj.handlers)->write_property))(object, property, z, (struct _zend_literal  const  *)tmp___15);
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(*retval);
        } else {

        }
        i_zval_ptr_dtor(z);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
      if (! ((int )opline->result_type & (1 << 5))) {
        zval_addref_p(& executor_globals.uninitialized_zval);
        *retval = & executor_globals.uninitialized_zval;
      } else {

      }
    }
  } else {

  }
  i_zval_ptr_dtor(property);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_PRE_INC_OBJ_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_pre_incdec_property_helper_SPEC_CV_TMP((int (*)(zval * ))(& increment_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_PRE_DEC_OBJ_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_pre_incdec_property_helper_SPEC_CV_TMP((int (*)(zval * ))(& decrement_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) zend_post_incdec_property_helper_SPEC_CV_TMP)(int (*incdec_op)(zval * ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval **object_ptr ;
  zval *object ;
  zval *property ;
  zval *retval ;
  int have_get_ptr ;
  long tmp ;
  long tmp___0 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zval **zptr ;
  zend_literal *tmp___2 ;
  zval **tmp___3 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_uint tmp___5 ;
  zend_bool tmp___6 ;
  zval *z ;
  zend_literal *tmp___7 ;
  zval *tmp___8 ;
  zval *z_copy ;
  zval *value ;
  zval *tmp___9 ;
  zend_uint tmp___10 ;
  long tmp___11 ;
  void __attribute__((__visibility__("default")))  *tmp___12 ;
  zend_literal *tmp___13 ;

  {
  opline = execute_data->opline;
  have_get_ptr = 0;
  object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var);
  property = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  retval = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  if (1 << 4 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot increment/decrement overloaded objects nor string offsets");
    } else {

    }
  } else {

  }
  make_real_object(object_ptr);
  object = *object_ptr;
  tmp___0 = __builtin_expect((long )((int )object->type != 5), 0L);
  if (tmp___0) {
    zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
    _zval_dtor(free_op2.var);
    retval->type = (unsigned char)0;
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  while (1) {
    while (1) {
      tmp___1 = _emalloc(sizeof(zval_gc_info ));
      _tmp = (zval *)tmp___1;
      ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
      break;
    }
    while (1) {
      while (1) {
        _tmp->value = property->value;
        _tmp->type = property->type;
        break;
      }
      zval_set_refcount_p(_tmp, 1U);
      zval_unset_isref_p(_tmp);
      break;
    }
    property = _tmp;
    break;
  }
  if ((object->value.obj.handlers)->get_property_ptr_ptr) {
    if (1 << 1 == 1) {
      tmp___2 = opline->op2.literal;
    } else {
      tmp___2 = (zend_literal *)((void *)0);
    }
    tmp___3 = (*((object->value.obj.handlers)->get_property_ptr_ptr))(object, property, (struct _zend_literal  const  *)tmp___2);
    zptr = tmp___3;
    if ((unsigned int )zptr != (unsigned int )((void *)0)) {
      have_get_ptr = 1;
      tmp___6 = zval_isref_p(*zptr);
      if (tmp___6) {

      } else {
        while (1) {
          tmp___5 = zval_refcount_p(*zptr);
          if (tmp___5 > 1U) {
            zval_delref_p(*zptr);
            while (1) {
              tmp___4 = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp___4;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*zptr)->value;
                new_zv->type = (*zptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *zptr = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
      while (1) {
        retval->value = (*zptr)->value;
        retval->type = (*zptr)->type;
        break;
      }
      _zval_copy_ctor(retval);
      (*incdec_op)(*zptr);
    } else {

    }
  } else {

  }
  if (! have_get_ptr) {
    if ((object->value.obj.handlers)->read_property) {
      if ((object->value.obj.handlers)->write_property) {
        if (1 << 1 == 1) {
          tmp___7 = opline->op2.literal;
        } else {
          tmp___7 = (zend_literal *)((void *)0);
        }
        tmp___8 = (*((object->value.obj.handlers)->read_property))(object, property, 0, (struct _zend_literal  const  *)tmp___7);
        z = tmp___8;
        tmp___11 = __builtin_expect((long )((int )z->type == 5), 0L);
        if (tmp___11) {
          if ((z->value.obj.handlers)->get) {
            tmp___9 = (*((z->value.obj.handlers)->get))(z);
            value = tmp___9;
            tmp___10 = zval_refcount_p(z);
            if (tmp___10 == 0U) {
              if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                gc_remove_zval_from_buffer(z);
              } else {

              }
              _zval_dtor(z);
              while (1) {
                if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                  gc_remove_zval_from_buffer(z);
                } else {

                }
                _efree((void *)z);
                break;
              }
            } else {

            }
            z = value;
          } else {

          }
        } else {

        }
        while (1) {
          retval->value = z->value;
          retval->type = z->type;
          break;
        }
        _zval_copy_ctor(retval);
        while (1) {
          tmp___12 = _emalloc(sizeof(zval_gc_info ));
          z_copy = (zval *)tmp___12;
          ((zval_gc_info *)z_copy)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            z_copy->value = z->value;
            z_copy->type = z->type;
            break;
          }
          zval_set_refcount_p(z_copy, 1U);
          zval_unset_isref_p(z_copy);
          break;
        }
        _zval_copy_ctor(z_copy);
        (*incdec_op)(z_copy);
        zval_addref_p(z);
        if (1 << 1 == 1) {
          tmp___13 = opline->op2.literal;
        } else {
          tmp___13 = (zend_literal *)((void *)0);
        }
        (*((object->value.obj.handlers)->write_property))(object, property, z_copy, (struct _zend_literal  const  *)tmp___13);
        i_zval_ptr_dtor(z_copy);
        i_zval_ptr_dtor(z);
      } else {
        zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
        retval->type = (unsigned char)0;
      }
    } else {
      zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
      retval->type = (unsigned char)0;
    }
  } else {

  }
  i_zval_ptr_dtor(property);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_POST_INC_OBJ_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_post_incdec_property_helper_SPEC_CV_TMP((int (*)(zval * ))(& increment_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_POST_DEC_OBJ_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_post_incdec_property_helper_SPEC_CV_TMP((int (*)(zval * ))(& decrement_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_R_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval **container ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  if (opline->extended_value & 134217728UL) {
    if (1 << 4 != 1 << 4) {
      if (((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr) {
        zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr));
      } else {

      }
    } else {

    }
  } else {

  }
  container = _get_zval_ptr_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  zend_fetch_dimension_address_read((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, tmp, 1 << 1, 0);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_W_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval **container ;
  long tmp ;
  zval *tmp___0 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zend_uint tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___6 ;
  zval **retval_ptr ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___7 ;
  zend_uint tmp___8 ;
  zend_bool tmp___9 ;
  long tmp___10 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  tmp___0 = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, tmp___0, 1 << 1, 1);
  _zval_dtor(free_op2.var);
  if (1 << 4 == 1 << 2) {
    if (0) {
      tmp___5 = zval_refcount_p(free_op1.var);
      if (tmp___5 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___6 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___6 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___3 = zval_isref_p(__t->var.ptr);
                if (tmp___3) {

                } else {
                  tmp___4 = zval_refcount_p(__t->var.ptr);
                  if (tmp___4 > 2U) {
                    while (1) {
                      tmp___2 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___2 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___1 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___1;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  tmp___10 = __builtin_expect((long )(opline->extended_value != 0UL), 0L);
  if (tmp___10) {
    retval_ptr = ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr;
    if (retval_ptr) {
      zval_delref_p(*retval_ptr);
      tmp___9 = zval_isref_p(*retval_ptr);
      if (tmp___9) {

      } else {
        while (1) {
          tmp___8 = zval_refcount_p(*retval_ptr);
          if (tmp___8 > 1U) {
            zval_delref_p(*retval_ptr);
            while (1) {
              tmp___7 = _emalloc(sizeof(zval_gc_info ));
              new_zv___0 = (zval *)tmp___7;
              ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv___0->value = (*retval_ptr)->value;
                new_zv___0->type = (*retval_ptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv___0, 1U);
              zval_unset_isref_p(new_zv___0);
              break;
            }
            *retval_ptr = new_zv___0;
            _zval_copy_ctor(new_zv___0);
          } else {

          }
          break;
        }
        zval_set_isref_p(*retval_ptr);
      }
      zval_addref_p(*retval_ptr);
    } else {

    }
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_RW_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval **container ;
  long tmp ;
  zval *tmp___0 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zend_uint tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___6 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  tmp___0 = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, tmp___0, 1 << 1, 2);
  _zval_dtor(free_op2.var);
  if (1 << 4 == 1 << 2) {
    if (0) {
      tmp___5 = zval_refcount_p(free_op1.var);
      if (tmp___5 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___6 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___6 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___3 = zval_isref_p(__t->var.ptr);
                if (tmp___3) {

                } else {
                  tmp___4 = zval_refcount_p(__t->var.ptr);
                  if (tmp___4 > 2U) {
                    while (1) {
                      tmp___2 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___2 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___1 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___1;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_IS_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval **container ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_cv_BP_VAR_IS(execute_data->CVs, opline->op1.var);
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  zend_fetch_dimension_address_read((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, tmp, 1 << 1, 3);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval **container ;
  long tmp ;
  zval *tmp___0 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zend_uint tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___6 ;
  zval *tmp___7 ;
  unsigned int tmp___8 ;

  {
  opline = execute_data->opline;
  if (execute_data->fbc) {
    if ((execute_data->fbc)->common.arg_info) {
      if ((opline->extended_value & 1048575UL) <= (unsigned long )(execute_data->fbc)->common.num_args) {
        tmp___8 = (unsigned int )((int )((execute_data->fbc)->common.arg_info + ((opline->extended_value & 1048575UL) - 1UL))->pass_by_reference & 3);
      } else {
        tmp___8 = (execute_data->fbc)->common.fn_flags & 50331648U;
      }
    } else {
      tmp___8 = (execute_data->fbc)->common.fn_flags & 50331648U;
    }
    if (tmp___8) {
      container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var);
      if (1 << 4 == 1 << 2) {
        tmp = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
        if (tmp) {
          zend_error_noreturn(1, "Cannot use string offset as an array");
        } else {

        }
      } else {

      }
      tmp___0 = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
      zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, tmp___0, 1 << 1, 1);
      if (1 << 4 == 1 << 2) {
        if (0) {
          tmp___5 = zval_refcount_p(free_op1.var);
          if (tmp___5 == 1U) {
            if ((int )(free_op1.var)->type != 5) {
              goto _L;
            } else {
              tmp___6 = zend_objects_store_get_refcount(free_op1.var);
              if (tmp___6 == (zend_uint __attribute__((__visibility__("default")))  )1) {
                _L: /* CIL Label */ 
                while (1) {
                  __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
                  if (__t->var.ptr_ptr) {
                    __t->var.ptr = *(__t->var.ptr_ptr);
                    __t->var.ptr_ptr = & __t->var.ptr;
                    tmp___3 = zval_isref_p(__t->var.ptr);
                    if (tmp___3) {

                    } else {
                      tmp___4 = zval_refcount_p(__t->var.ptr);
                      if (tmp___4 > 2U) {
                        while (1) {
                          tmp___2 = zval_refcount_p(*(__t->var.ptr_ptr));
                          if (tmp___2 > 1U) {
                            zval_delref_p(*(__t->var.ptr_ptr));
                            while (1) {
                              tmp___1 = _emalloc(sizeof(zval_gc_info ));
                              new_zv = (zval *)tmp___1;
                              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                              break;
                            }
                            while (1) {
                              while (1) {
                                new_zv->value = (*(__t->var.ptr_ptr))->value;
                                new_zv->type = (*(__t->var.ptr_ptr))->type;
                                break;
                              }
                              zval_set_refcount_p(new_zv, 1U);
                              zval_unset_isref_p(new_zv);
                              break;
                            }
                            *(__t->var.ptr_ptr) = new_zv;
                            _zval_copy_ctor(new_zv);
                          } else {

                          }
                          break;
                        }
                      } else {

                      }
                    }
                  } else {

                  }
                  break;
                }
              } else {

              }
            }
          } else {

          }
        } else {

        }
      } else {

      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if (1 << 1 == 1 << 3) {
      zend_error_noreturn(1, "Cannot use [] for reading");
    } else {

    }
    container = _get_zval_ptr_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
    tmp___7 = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    zend_fetch_dimension_address_read((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, tmp___7, 1 << 1, 0);
  }
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_UNSET_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval **container ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  long tmp___2 ;
  zval *tmp___3 ;
  temp_variable *__t ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_uint tmp___5 ;
  zend_bool tmp___6 ;
  zend_uint tmp___7 ;
  zend_uint tmp___8 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___9 ;
  zend_free_op free_res ;
  zval **retval_ptr ;
  zval *new_zv___1 ;
  void __attribute__((__visibility__("default")))  *tmp___10 ;
  zend_uint tmp___11 ;
  zend_bool tmp___12 ;
  long tmp___13 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 4) {
    if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
      tmp___1 = zval_isref_p(*container);
      if (tmp___1) {

      } else {
        while (1) {
          tmp___0 = zval_refcount_p(*container);
          if (tmp___0 > 1U) {
            zval_delref_p(*container);
            while (1) {
              tmp = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*container)->value;
                new_zv->type = (*container)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *container = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
    } else {

    }
  } else {

  }
  if (1 << 4 == 1 << 2) {
    tmp___2 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___2) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  tmp___3 = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, tmp___3, 1 << 1, 6);
  _zval_dtor(free_op2.var);
  if (1 << 4 == 1 << 2) {
    if (0) {
      tmp___8 = zval_refcount_p(free_op1.var);
      if (tmp___8 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___9 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___9 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___6 = zval_isref_p(__t->var.ptr);
                if (tmp___6) {

                } else {
                  tmp___7 = zval_refcount_p(__t->var.ptr);
                  if (tmp___7 > 2U) {
                    while (1) {
                      tmp___5 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___5 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___4 = _emalloc(sizeof(zval_gc_info ));
                          new_zv___0 = (zval *)tmp___4;
                          ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv___0->value = (*(__t->var.ptr_ptr))->value;
                            new_zv___0->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv___0, 1U);
                          zval_unset_isref_p(new_zv___0);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv___0;
                        _zval_copy_ctor(new_zv___0);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  tmp___13 = __builtin_expect((long )((unsigned int )((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr == (unsigned int )((void *)0)), 0L);
  if (tmp___13) {
    zend_error_noreturn(1, "Cannot unset string offsets");
  } else {
    retval_ptr = ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr;
    zend_pzval_unlock_func(*retval_ptr, & free_res, 1);
    if ((unsigned int )retval_ptr != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
      tmp___12 = zval_isref_p(*retval_ptr);
      if (tmp___12) {

      } else {
        while (1) {
          tmp___11 = zval_refcount_p(*retval_ptr);
          if (tmp___11 > 1U) {
            zval_delref_p(*retval_ptr);
            while (1) {
              tmp___10 = _emalloc(sizeof(zval_gc_info ));
              new_zv___1 = (zval *)tmp___10;
              ((zval_gc_info *)new_zv___1)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv___1->value = (*retval_ptr)->value;
                new_zv___1->type = (*retval_ptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv___1, 1U);
              zval_unset_isref_p(new_zv___1);
              break;
            }
            *retval_ptr = new_zv___1;
            _zval_copy_ctor(new_zv___1);
          } else {

          }
          break;
        }
      }
    } else {

    }
    zval_addref_p(*retval_ptr);
    if (free_res.var) {
      i_zval_ptr_dtor(free_res.var);
    } else {

    }
    (execute_data->opline) ++;
    return (0);
  }
}
}
static int ( __attribute__((__fastcall__)) zend_fetch_property_address_read_helper_SPEC_CV_TMP)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *container ;
  zend_free_op free_op2 ;
  zval *offset ;
  temp_variable *__t ;
  zval *retval ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_literal *tmp___0 ;
  temp_variable *__t___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  offset = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___1 = __builtin_expect((long )((int )container->type != 5), 0L);
  if (tmp___1) {
    goto _L;
  } else {
    tmp___2 = __builtin_expect((long )((unsigned int )(container->value.obj.handlers)->read_property == (unsigned int )((void *)0)), 0L);
    if (tmp___2) {
      _L: /* CIL Label */ 
      zend_error(1 << 3L, "Trying to get property of non-object");
      zval_addref_p(& executor_globals.uninitialized_zval);
      while (1) {
        __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t->var.ptr = & executor_globals.uninitialized_zval;
        __t->var.ptr_ptr = & __t->var.ptr;
        break;
      }
      _zval_dtor(free_op2.var);
    } else {
      while (1) {
        while (1) {
          tmp = _emalloc(sizeof(zval_gc_info ));
          _tmp = (zval *)tmp;
          ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            _tmp->value = offset->value;
            _tmp->type = offset->type;
            break;
          }
          zval_set_refcount_p(_tmp, 1U);
          zval_unset_isref_p(_tmp);
          break;
        }
        offset = _tmp;
        break;
      }
      if (1 << 1 == 1) {
        tmp___0 = opline->op2.literal;
      } else {
        tmp___0 = (zend_literal *)((void *)0);
      }
      retval = (*((container->value.obj.handlers)->read_property))(container, offset, 0, (struct _zend_literal  const  *)tmp___0);
      zval_addref_p(retval);
      while (1) {
        __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t___0->var.ptr = retval;
        __t___0->var.ptr_ptr = & __t___0->var.ptr;
        break;
      }
      i_zval_ptr_dtor(offset);
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_R_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_property_address_read_helper_SPEC_CV_TMP(execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_W_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *property ;
  zval **container ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zend_literal *tmp___1 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_uint tmp___3 ;
  zend_bool tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint tmp___6 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___7 ;
  zval **retval_ptr ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___8 ;
  zend_uint tmp___9 ;
  zend_bool tmp___10 ;

  {
  opline = execute_data->opline;
  property = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if (1 << 4 == 1 << 2) {
    if (opline->extended_value & 134217728UL) {
      zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr));
      ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr = *(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr);
    } else {

    }
  } else {

  }
  while (1) {
    while (1) {
      tmp = _emalloc(sizeof(zval_gc_info ));
      _tmp = (zval *)tmp;
      ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
      break;
    }
    while (1) {
      while (1) {
        _tmp->value = property->value;
        _tmp->type = property->type;
        break;
      }
      zval_set_refcount_p(_tmp, 1U);
      zval_unset_isref_p(_tmp);
      break;
    }
    property = _tmp;
    break;
  }
  container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  if (1 << 1 == 1) {
    tmp___1 = opline->op2.literal;
  } else {
    tmp___1 = (zend_literal *)((void *)0);
  }
  zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)tmp___1, 1);
  i_zval_ptr_dtor(property);
  if (1 << 4 == 1 << 2) {
    if (0) {
      tmp___6 = zval_refcount_p(free_op1.var);
      if (tmp___6 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___7 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___7 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___4 = zval_isref_p(__t->var.ptr);
                if (tmp___4) {

                } else {
                  tmp___5 = zval_refcount_p(__t->var.ptr);
                  if (tmp___5 > 2U) {
                    while (1) {
                      tmp___3 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___3 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___2 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___2;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  if (opline->extended_value & 67108864UL) {
    retval_ptr = ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr;
    zval_delref_p(*retval_ptr);
    tmp___10 = zval_isref_p(*retval_ptr);
    if (tmp___10) {

    } else {
      while (1) {
        tmp___9 = zval_refcount_p(*retval_ptr);
        if (tmp___9 > 1U) {
          zval_delref_p(*retval_ptr);
          while (1) {
            tmp___8 = _emalloc(sizeof(zval_gc_info ));
            new_zv___0 = (zval *)tmp___8;
            ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv___0->value = (*retval_ptr)->value;
              new_zv___0->type = (*retval_ptr)->type;
              break;
            }
            zval_set_refcount_p(new_zv___0, 1U);
            zval_unset_isref_p(new_zv___0);
            break;
          }
          *retval_ptr = new_zv___0;
          _zval_copy_ctor(new_zv___0);
        } else {

        }
        break;
      }
      zval_set_isref_p(*retval_ptr);
    }
    zval_addref_p(*retval_ptr);
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = *(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr);
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_RW_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *property ;
  zval **container ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zend_literal *tmp___1 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_uint tmp___3 ;
  zend_bool tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint tmp___6 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___7 ;

  {
  opline = execute_data->opline;
  property = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var);
  while (1) {
    while (1) {
      tmp = _emalloc(sizeof(zval_gc_info ));
      _tmp = (zval *)tmp;
      ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
      break;
    }
    while (1) {
      while (1) {
        _tmp->value = property->value;
        _tmp->type = property->type;
        break;
      }
      zval_set_refcount_p(_tmp, 1U);
      zval_unset_isref_p(_tmp);
      break;
    }
    property = _tmp;
    break;
  }
  if (1 << 4 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  if (1 << 1 == 1) {
    tmp___1 = opline->op2.literal;
  } else {
    tmp___1 = (zend_literal *)((void *)0);
  }
  zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)tmp___1, 2);
  i_zval_ptr_dtor(property);
  if (1 << 4 == 1 << 2) {
    if (0) {
      tmp___6 = zval_refcount_p(free_op1.var);
      if (tmp___6 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___7 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___7 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___4 = zval_isref_p(__t->var.ptr);
                if (tmp___4) {

                } else {
                  tmp___5 = zval_refcount_p(__t->var.ptr);
                  if (tmp___5 > 2U) {
                    while (1) {
                      tmp___3 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___3 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___2 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___2;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_IS_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *container ;
  zend_free_op free_op2 ;
  zval *offset ;
  temp_variable *__t ;
  zval *retval ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_literal *tmp___0 ;
  temp_variable *__t___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_cv_BP_VAR_IS(execute_data->CVs, opline->op1.var);
  offset = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___1 = __builtin_expect((long )((int )container->type != 5), 0L);
  if (tmp___1) {
    goto _L;
  } else {
    tmp___2 = __builtin_expect((long )((unsigned int )(container->value.obj.handlers)->read_property == (unsigned int )((void *)0)), 0L);
    if (tmp___2) {
      _L: /* CIL Label */ 
      zval_addref_p(& executor_globals.uninitialized_zval);
      while (1) {
        __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t->var.ptr = & executor_globals.uninitialized_zval;
        __t->var.ptr_ptr = & __t->var.ptr;
        break;
      }
      _zval_dtor(free_op2.var);
    } else {
      while (1) {
        while (1) {
          tmp = _emalloc(sizeof(zval_gc_info ));
          _tmp = (zval *)tmp;
          ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            _tmp->value = offset->value;
            _tmp->type = offset->type;
            break;
          }
          zval_set_refcount_p(_tmp, 1U);
          zval_unset_isref_p(_tmp);
          break;
        }
        offset = _tmp;
        break;
      }
      if (1 << 1 == 1) {
        tmp___0 = opline->op2.literal;
      } else {
        tmp___0 = (zend_literal *)((void *)0);
      }
      retval = (*((container->value.obj.handlers)->read_property))(container, offset, 3, (struct _zend_literal  const  *)tmp___0);
      zval_addref_p(retval);
      while (1) {
        __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t___0->var.ptr = retval;
        __t___0->var.ptr_ptr = & __t___0->var.ptr;
        break;
      }
      i_zval_ptr_dtor(offset);
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *property ;
  zval **container ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zend_literal *tmp___1 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_uint tmp___3 ;
  zend_bool tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint tmp___6 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;

  {
  opline = execute_data->opline;
  if (execute_data->fbc) {
    if ((execute_data->fbc)->common.arg_info) {
      if ((opline->extended_value & 1048575UL) <= (unsigned long )(execute_data->fbc)->common.num_args) {
        tmp___9 = (unsigned int )((int )((execute_data->fbc)->common.arg_info + ((opline->extended_value & 1048575UL) - 1UL))->pass_by_reference & 3);
      } else {
        tmp___9 = (execute_data->fbc)->common.fn_flags & 50331648U;
      }
    } else {
      tmp___9 = (execute_data->fbc)->common.fn_flags & 50331648U;
    }
    if (tmp___9) {
      property = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
      container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var);
      while (1) {
        while (1) {
          tmp = _emalloc(sizeof(zval_gc_info ));
          _tmp = (zval *)tmp;
          ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            _tmp->value = property->value;
            _tmp->type = property->type;
            break;
          }
          zval_set_refcount_p(_tmp, 1U);
          zval_unset_isref_p(_tmp);
          break;
        }
        property = _tmp;
        break;
      }
      if (1 << 4 == 1 << 2) {
        tmp___0 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
        if (tmp___0) {
          zend_error_noreturn(1, "Cannot use string offset as an object");
        } else {

        }
      } else {

      }
      if (1 << 1 == 1) {
        tmp___1 = opline->op2.literal;
      } else {
        tmp___1 = (zend_literal *)((void *)0);
      }
      zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)tmp___1, 1);
      i_zval_ptr_dtor(property);
      if (1 << 4 == 1 << 2) {
        if (0) {
          tmp___6 = zval_refcount_p(free_op1.var);
          if (tmp___6 == 1U) {
            if ((int )(free_op1.var)->type != 5) {
              goto _L;
            } else {
              tmp___7 = zend_objects_store_get_refcount(free_op1.var);
              if (tmp___7 == (zend_uint __attribute__((__visibility__("default")))  )1) {
                _L: /* CIL Label */ 
                while (1) {
                  __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
                  if (__t->var.ptr_ptr) {
                    __t->var.ptr = *(__t->var.ptr_ptr);
                    __t->var.ptr_ptr = & __t->var.ptr;
                    tmp___4 = zval_isref_p(__t->var.ptr);
                    if (tmp___4) {

                    } else {
                      tmp___5 = zval_refcount_p(__t->var.ptr);
                      if (tmp___5 > 2U) {
                        while (1) {
                          tmp___3 = zval_refcount_p(*(__t->var.ptr_ptr));
                          if (tmp___3 > 1U) {
                            zval_delref_p(*(__t->var.ptr_ptr));
                            while (1) {
                              tmp___2 = _emalloc(sizeof(zval_gc_info ));
                              new_zv = (zval *)tmp___2;
                              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                              break;
                            }
                            while (1) {
                              while (1) {
                                new_zv->value = (*(__t->var.ptr_ptr))->value;
                                new_zv->type = (*(__t->var.ptr_ptr))->type;
                                break;
                              }
                              zval_set_refcount_p(new_zv, 1U);
                              zval_unset_isref_p(new_zv);
                              break;
                            }
                            *(__t->var.ptr_ptr) = new_zv;
                            _zval_copy_ctor(new_zv);
                          } else {

                          }
                          break;
                        }
                      } else {

                      }
                    }
                  } else {

                  }
                  break;
                }
              } else {

              }
            }
          } else {

          }
        } else {

        }
      } else {

      }
      (execute_data->opline) ++;
      return (0);
    } else {
      tmp___8 = zend_fetch_property_address_read_helper_SPEC_CV_TMP(execute_data);
      return (tmp___8);
    }
  } else {
    tmp___8 = zend_fetch_property_address_read_helper_SPEC_CV_TMP(execute_data);
    return (tmp___8);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_UNSET_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zend_free_op free_res ;
  zval **container ;
  zval *property ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  long tmp___3 ;
  zend_literal *tmp___4 ;
  temp_variable *__t ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  zend_uint tmp___6 ;
  zend_bool tmp___7 ;
  zend_uint tmp___8 ;
  zend_uint tmp___9 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___10 ;
  zval *new_zv___1 ;
  void __attribute__((__visibility__("default")))  *tmp___11 ;
  zend_uint tmp___12 ;
  zend_bool tmp___13 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data->CVs, opline->op1.var);
  property = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if (1 << 4 == 1 << 4) {
    if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
      tmp___1 = zval_isref_p(*container);
      if (tmp___1) {

      } else {
        while (1) {
          tmp___0 = zval_refcount_p(*container);
          if (tmp___0 > 1U) {
            zval_delref_p(*container);
            while (1) {
              tmp = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*container)->value;
                new_zv->type = (*container)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *container = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
    } else {

    }
  } else {

  }
  while (1) {
    while (1) {
      tmp___2 = _emalloc(sizeof(zval_gc_info ));
      _tmp = (zval *)tmp___2;
      ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
      break;
    }
    while (1) {
      while (1) {
        _tmp->value = property->value;
        _tmp->type = property->type;
        break;
      }
      zval_set_refcount_p(_tmp, 1U);
      zval_unset_isref_p(_tmp);
      break;
    }
    property = _tmp;
    break;
  }
  if (1 << 4 == 1 << 2) {
    tmp___3 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___3) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  if (1 << 1 == 1) {
    tmp___4 = opline->op2.literal;
  } else {
    tmp___4 = (zend_literal *)((void *)0);
  }
  zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)tmp___4, 6);
  i_zval_ptr_dtor(property);
  if (1 << 4 == 1 << 2) {
    if (0) {
      tmp___9 = zval_refcount_p(free_op1.var);
      if (tmp___9 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___10 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___10 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___7 = zval_isref_p(__t->var.ptr);
                if (tmp___7) {

                } else {
                  tmp___8 = zval_refcount_p(__t->var.ptr);
                  if (tmp___8 > 2U) {
                    while (1) {
                      tmp___6 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___6 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___5 = _emalloc(sizeof(zval_gc_info ));
                          new_zv___0 = (zval *)tmp___5;
                          ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv___0->value = (*(__t->var.ptr_ptr))->value;
                            new_zv___0->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv___0, 1U);
                          zval_unset_isref_p(new_zv___0);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv___0;
                        _zval_copy_ctor(new_zv___0);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  zend_pzval_unlock_func(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr), & free_res, 1);
  if ((unsigned int )((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
    tmp___13 = zval_isref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
    if (tmp___13) {

    } else {
      while (1) {
        tmp___12 = zval_refcount_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
        if (tmp___12 > 1U) {
          zval_delref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
          while (1) {
            tmp___11 = _emalloc(sizeof(zval_gc_info ));
            new_zv___1 = (zval *)tmp___11;
            ((zval_gc_info *)new_zv___1)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv___1->value = (*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr))->value;
              new_zv___1->type = (*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr))->type;
              break;
            }
            zval_set_refcount_p(new_zv___1, 1U);
            zval_unset_isref_p(new_zv___1);
            break;
          }
          *(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr) = new_zv___1;
          _zval_copy_ctor(new_zv___1);
        } else {

        }
        break;
      }
    }
  } else {

  }
  zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
  if (free_res.var) {
    i_zval_ptr_dtor(free_res.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_OBJ_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval **object_ptr ;
  zval *property_name ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zend_literal *tmp___1 ;
  zval **tmp___2 ;

  {
  opline = execute_data->opline;
  object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var);
  property_name = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  while (1) {
    while (1) {
      tmp = _emalloc(sizeof(zval_gc_info ));
      _tmp = (zval *)tmp;
      ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
      break;
    }
    while (1) {
      while (1) {
        _tmp->value = property_name->value;
        _tmp->type = property_name->type;
        break;
      }
      zval_set_refcount_p(_tmp, 1U);
      zval_unset_isref_p(_tmp);
      break;
    }
    property_name = _tmp;
    break;
  }
  if (1 << 4 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  if (1 << 1 == 1) {
    tmp___1 = opline->op2.literal;
  } else {
    tmp___1 = (zend_literal *)((void *)0);
  }
  if (! ((int )opline->result_type & (1 << 5))) {
    tmp___2 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
  } else {
    tmp___2 = (zval **)((void *)0);
  }
  zend_assign_to_object(tmp___2, object_ptr, property_name, (int )(opline + 1)->op1_type, & (opline + 1)->op1, (temp_variable const   *)execute_data->Ts, 136, (zend_literal const   *)tmp___1);
  i_zval_ptr_dtor(property_name);
  (execute_data->opline) ++;
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_DIM_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **object_ptr ;
  long tmp ;
  zend_free_op free_op2 ;
  zval *property_name ;
  zval *tmp___0 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_literal *tmp___2 ;
  zval **tmp___3 ;
  zend_free_op free_op2___0 ;
  zend_free_op free_op_data1 ;
  zend_free_op free_op_data2 ;
  zval *value ;
  zval *dim ;
  zval *tmp___4 ;
  zval **variable_ptr_ptr ;
  zval *retval ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  char const   *__s ;
  int __l ;
  zval *__z ;
  char __attribute__((__visibility__("default")))  *tmp___6 ;
  temp_variable *__t ;
  temp_variable *__t___0 ;
  int tmp___7 ;
  temp_variable *__t___1 ;
  temp_variable *__t___2 ;
  long tmp___8 ;
  long tmp___9 ;

  {
  opline = execute_data->opline;
  object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  if ((int )(*object_ptr)->type == 5) {
    tmp___0 = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    property_name = tmp___0;
    while (1) {
      while (1) {
        tmp___1 = _emalloc(sizeof(zval_gc_info ));
        _tmp = (zval *)tmp___1;
        ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      while (1) {
        while (1) {
          _tmp->value = property_name->value;
          _tmp->type = property_name->type;
          break;
        }
        zval_set_refcount_p(_tmp, 1U);
        zval_unset_isref_p(_tmp);
        break;
      }
      property_name = _tmp;
      break;
    }
    if (1 << 1 == 1) {
      tmp___2 = opline->op2.literal;
    } else {
      tmp___2 = (zend_literal *)((void *)0);
    }
    if (! ((int )opline->result_type & (1 << 5))) {
      tmp___3 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
    } else {
      tmp___3 = (zval **)((void *)0);
    }
    zend_assign_to_object(tmp___3, object_ptr, property_name, (int )(opline + 1)->op1_type, & (opline + 1)->op1, (temp_variable const   *)execute_data->Ts, 147, (zend_literal const   *)tmp___2);
    i_zval_ptr_dtor(property_name);
  } else {
    tmp___4 = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2___0);
    dim = tmp___4;
    zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var), object_ptr, dim, 1 << 1, 1);
    _zval_dtor(free_op2___0.var);
    value = _get_zval_ptr((int )(opline + 1)->op1_type, (znode_op const   *)(& (opline + 1)->op1), (temp_variable const   *)execute_data->Ts, & free_op_data1, 0);
    variable_ptr_ptr = _get_zval_ptr_ptr_var((opline + 1)->op2.var, (temp_variable const   *)execute_data->Ts, & free_op_data2);
    tmp___9 = __builtin_expect((long )((unsigned int )variable_ptr_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___9) {
      tmp___7 = zend_assign_to_string_offset((temp_variable const   *)((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var)), (zval const   *)value, (int )(opline + 1)->op1_type);
      if (tmp___7) {
        if (! ((int )opline->result_type & (1 << 5))) {
          while (1) {
            tmp___5 = _emalloc(sizeof(zval_gc_info ));
            retval = (zval *)tmp___5;
            ((zval_gc_info *)retval)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            __s = (char const   *)((((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var))->str_offset.str)->value.str.val + ((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var))->str_offset.offset);
            __l = 1;
            __z = retval;
            __z->value.str.len = __l;
            tmp___6 = _estrndup(__s, (unsigned int )__l);
            __z->value.str.val = (char *)tmp___6;
            __z->type = (unsigned char)6;
            break;
          }
          retval->refcount__gc = 1U;
          retval->is_ref__gc = (unsigned char)0;
          while (1) {
            __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t->var.ptr = retval;
            __t->var.ptr_ptr = & __t->var.ptr;
            break;
          }
        } else {

        }
      } else {
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          while (1) {
            __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___0->var.ptr = & executor_globals.uninitialized_zval;
            __t___0->var.ptr_ptr = & __t___0->var.ptr;
            break;
          }
        } else {

        }
      }
    } else {
      tmp___8 = __builtin_expect((long )((unsigned int )*variable_ptr_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
      if (tmp___8) {
        if ((unsigned long )free_op_data1.var & 1UL) {
          _zval_dtor(value);
        } else {

        }
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          while (1) {
            __t___1 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___1->var.ptr = & executor_globals.uninitialized_zval;
            __t___1->var.ptr_ptr = & __t___1->var.ptr;
            break;
          }
        } else {

        }
      } else {
        if ((int )(opline + 1)->op1_type == 1 << 1) {
          value = zend_assign_tmp_to_variable(variable_ptr_ptr, value);
        } else {
          if ((int )(opline + 1)->op1_type == 1) {
            value = zend_assign_const_to_variable(variable_ptr_ptr, value);
          } else {
            value = zend_assign_to_variable(variable_ptr_ptr, value);
          }
        }
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(value);
          while (1) {
            __t___2 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___2->var.ptr = value;
            __t___2->var.ptr_ptr = & __t___2->var.ptr;
            break;
          }
        } else {

        }
      }
    }
    if (free_op_data2.var) {
      i_zval_ptr_dtor(free_op_data2.var);
    } else {

    }
    if ((unsigned int )free_op_data1.var != (unsigned int )((void *)0)) {
      if (((unsigned long )free_op_data1.var & 1UL) == 0UL) {
        i_zval_ptr_dtor(free_op_data1.var);
      } else {

      }
    } else {

    }
  }
  (execute_data->opline) ++;
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *value ;
  zval **variable_ptr_ptr ;
  zval *retval ;
  void __attribute__((__visibility__("default")))  *tmp ;
  char const   *__s ;
  int __l ;
  zval *__z ;
  char __attribute__((__visibility__("default")))  *tmp___0 ;
  temp_variable *__t ;
  temp_variable *__t___0 ;
  int tmp___1 ;
  temp_variable *__t___1 ;
  temp_variable *__t___2 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  opline = execute_data->opline;
  value = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  variable_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 2) {
    tmp___3 = __builtin_expect((long )((unsigned int )variable_ptr_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___3) {
      tmp___1 = zend_assign_to_string_offset((temp_variable const   *)((temp_variable *)((char *)execute_data->Ts + opline->op1.var)), (zval const   *)value, 1 << 1);
      if (tmp___1) {
        if (! ((int )opline->result_type & (1 << 5))) {
          while (1) {
            tmp = _emalloc(sizeof(zval_gc_info ));
            retval = (zval *)tmp;
            ((zval_gc_info *)retval)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            __s = (char const   *)((((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->str_offset.str)->value.str.val + ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->str_offset.offset);
            __l = 1;
            __z = retval;
            __z->value.str.len = __l;
            tmp___0 = _estrndup(__s, (unsigned int )__l);
            __z->value.str.val = (char *)tmp___0;
            __z->type = (unsigned char)6;
            break;
          }
          retval->refcount__gc = 1U;
          retval->is_ref__gc = (unsigned char)0;
          while (1) {
            __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t->var.ptr = retval;
            __t->var.ptr_ptr = & __t->var.ptr;
            break;
          }
        } else {

        }
      } else {
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          while (1) {
            __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___0->var.ptr = & executor_globals.uninitialized_zval;
            __t___0->var.ptr_ptr = & __t___0->var.ptr;
            break;
          }
        } else {

        }
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if (1 << 4 == 1 << 2) {
      tmp___2 = __builtin_expect((long )((unsigned int )*variable_ptr_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
      if (tmp___2) {
        _zval_dtor(value);
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          while (1) {
            __t___1 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___1->var.ptr = & executor_globals.uninitialized_zval;
            __t___1->var.ptr_ptr = & __t___1->var.ptr;
            break;
          }
        } else {

        }
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      if (1 << 1 == 1 << 1) {
        value = zend_assign_tmp_to_variable(variable_ptr_ptr, value);
      } else {
        if (1 << 1 == 1) {
          value = zend_assign_const_to_variable(variable_ptr_ptr, value);
        } else {
          value = zend_assign_to_variable(variable_ptr_ptr, value);
        }
      }
      if (! ((int )opline->result_type & (1 << 5))) {
        zval_addref_p(value);
        while (1) {
          __t___2 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
          __t___2->var.ptr = value;
          __t___2->var.ptr_ptr = & __t___2->var.ptr;
          break;
        }
      } else {

      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_METHOD_CALL_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *function_name ;
  char *function_name_strval ;
  int function_name_strlen ;
  zend_free_op free_op2 ;
  long tmp ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  zval *object ;
  long tmp___1 ;
  zend_literal *tmp___2 ;
  zend_class_entry *tmp___3 ;
  zend_class_entry *tmp___4 ;
  char const   *tmp___5 ;
  zend_class_entry *tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  zend_function *tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  zval *this_ptr ;
  void __attribute__((__visibility__("default")))  *tmp___13 ;
  zend_bool tmp___14 ;

  {
  opline = execute_data->opline;
  zend_ptr_stack_3_push(& executor_globals.arg_types_stack, (void *)execute_data->fbc, (void *)execute_data->object, (void *)execute_data->called_scope);
  function_name = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if (1 << 1 != 1) {
    tmp = __builtin_expect((long )((int )function_name->type != 6), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Method name must be a string");
    } else {

    }
  } else {

  }
  function_name_strval = function_name->value.str.val;
  function_name_strlen = function_name->value.str.len;
  execute_data->object = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  tmp___11 = __builtin_expect((long )((unsigned int )execute_data->object != (unsigned int )((void *)0)), 1L);
  if (tmp___11) {
    tmp___12 = __builtin_expect((long )((int )(execute_data->object)->type == 5), 1L);
    if (tmp___12) {
      tmp___0 = zend_get_class_entry((zval const   *)execute_data->object);
      execute_data->called_scope = (zend_class_entry *)tmp___0;
      if (1 << 1 != 1) {
        goto _L;
      } else {
        if ((unsigned int )*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) == (unsigned int )execute_data->called_scope) {
          tmp___10 = (zend_function *)*((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U));
        } else {
          tmp___10 = (zend_function *)((void *)0);
        }
        execute_data->fbc = tmp___10;
        if ((unsigned int )tmp___10 == (unsigned int )((void *)0)) {
          _L: /* CIL Label */ 
          object = execute_data->object;
          tmp___1 = __builtin_expect((long )((unsigned int )((execute_data->object)->value.obj.handlers)->get_method == (unsigned int )((void *)0)), 0L);
          if (tmp___1) {
            zend_error_noreturn(1, "Object does not support method calls");
          } else {

          }
          if (1 << 1 == 1) {
            tmp___2 = opline->op2.literal + 1;
          } else {
            tmp___2 = (zend_literal *)((void *)0);
          }
          execute_data->fbc = (*(((execute_data->object)->value.obj.handlers)->get_method))(& execute_data->object, function_name_strval, function_name_strlen, (struct _zend_literal  const  *)tmp___2);
          tmp___7 = __builtin_expect((long )((unsigned int )execute_data->fbc == (unsigned int )((void *)0)), 0L);
          if (tmp___7) {
            if (execute_data->object) {
              if ((int )(execute_data->object)->type == 5) {
                if ((unsigned int )((execute_data->object)->value.obj.handlers)->get_class_entry != (unsigned int )((void *)0)) {
                  tmp___6 = (*(((execute_data->object)->value.obj.handlers)->get_class_entry))((zval const   *)execute_data->object);
                  if (tmp___6) {
                    tmp___4 = (*(((execute_data->object)->value.obj.handlers)->get_class_entry))((zval const   *)execute_data->object);
                    tmp___5 = tmp___4->name;
                  } else {
                    tmp___5 = "";
                  }
                } else {
                  tmp___5 = "";
                }
              } else {
                tmp___5 = "";
              }
            } else {
              tmp___5 = "";
            }
            zend_error_noreturn(1, "Call to undefined method %s::%s()", tmp___5, function_name_strval);
          } else {

          }
          if (1 << 1 == 1) {
            tmp___8 = __builtin_expect((long )(((execute_data->fbc)->common.fn_flags & 6291456U) == 0U), 1L);
            if (tmp___8) {
              tmp___9 = __builtin_expect((long )((unsigned int )execute_data->object == (unsigned int )object), 1L);
              if (tmp___9) {
                while (1) {
                  *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)execute_data->called_scope;
                  *((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U)) = (void *)execute_data->fbc;
                  break;
                }
              } else {

              }
            } else {

            }
          } else {

          }
        } else {

        }
      }
    } else {
      zend_error_noreturn(1, "Call to a member function %s() on a non-object", function_name_strval);
    }
  } else {
    zend_error_noreturn(1, "Call to a member function %s() on a non-object", function_name_strval);
  }
  if (((execute_data->fbc)->common.fn_flags & 1U) != 0U) {
    execute_data->object = (zval *)((void *)0);
  } else {
    tmp___14 = zval_isref_p(execute_data->object);
    if (tmp___14) {
      while (1) {
        tmp___13 = _emalloc(sizeof(zval_gc_info ));
        this_ptr = (zval *)tmp___13;
        ((zval_gc_info *)this_ptr)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      while (1) {
        while (1) {
          this_ptr->value = (execute_data->object)->value;
          this_ptr->type = (execute_data->object)->type;
          break;
        }
        zval_set_refcount_p(this_ptr, 1U);
        zval_unset_isref_p(this_ptr);
        break;
      }
      _zval_copy_ctor(this_ptr);
      execute_data->object = this_ptr;
    } else {
      zval_addref_p(execute_data->object);
    }
  }
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_CASE_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  if (1 << 4 == 1 << 2) {
    zval_addref_p(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr);
  } else {

  }
  tmp = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  is_equal_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  _zval_dtor(free_op2.var);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *expr_ptr ;
  zval **expr_ptr_ptr ;
  zval **tmp ;
  long tmp___0 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zval *new_expr ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zval *new_expr___0 ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  zend_bool tmp___6 ;
  zend_free_op free_op2 ;
  zval *offset ;
  zval *tmp___7 ;
  ulong hval ;
  long tmp___8 ;
  register char const   *tmp___9 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___10 ;

  {
  opline = execute_data->opline;
  if (1 << 4 == 1 << 2) {
    goto _L___1;
  } else {
    if (1 << 4 == 1 << 4) {
      _L___1: /* CIL Label */ 
      if (opline->extended_value) {
        tmp = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var);
        expr_ptr_ptr = tmp;
        if (1 << 4 == 1 << 2) {
          tmp___0 = __builtin_expect((long )((unsigned int )expr_ptr_ptr == (unsigned int )((void *)0)), 0L);
          if (tmp___0) {
            zend_error_noreturn(1, "Cannot create references to/from string offsets");
          } else {

          }
        } else {

        }
        tmp___3 = zval_isref_p(*expr_ptr_ptr);
        if (tmp___3) {

        } else {
          while (1) {
            tmp___2 = zval_refcount_p(*expr_ptr_ptr);
            if (tmp___2 > 1U) {
              zval_delref_p(*expr_ptr_ptr);
              while (1) {
                tmp___1 = _emalloc(sizeof(zval_gc_info ));
                new_zv = (zval *)tmp___1;
                ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv->value = (*expr_ptr_ptr)->value;
                  new_zv->type = (*expr_ptr_ptr)->type;
                  break;
                }
                zval_set_refcount_p(new_zv, 1U);
                zval_unset_isref_p(new_zv);
                break;
              }
              *expr_ptr_ptr = new_zv;
              _zval_copy_ctor(new_zv);
            } else {

            }
            break;
          }
          zval_set_isref_p(*expr_ptr_ptr);
        }
        expr_ptr = *expr_ptr_ptr;
        zval_addref_p(expr_ptr);
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      expr_ptr = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
      if (1 << 4 == 1) {
        goto _L;
      } else {
        tmp___6 = zval_isref_p(expr_ptr);
        if (tmp___6) {
          _L: /* CIL Label */ 
          while (1) {
            tmp___5 = _emalloc(sizeof(zval_gc_info ));
            new_expr___0 = (zval *)tmp___5;
            ((zval_gc_info *)new_expr___0)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_expr___0->value = expr_ptr->value;
              new_expr___0->type = expr_ptr->type;
              break;
            }
            zval_set_refcount_p(new_expr___0, 1U);
            zval_unset_isref_p(new_expr___0);
            break;
          }
          expr_ptr = new_expr___0;
          _zval_copy_ctor(expr_ptr);
        } else {
          zval_addref_p(expr_ptr);
        }
      }
    }
  }
  if (1 << 1 != 1 << 3) {
    tmp___7 = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    offset = tmp___7;
    switch ((int )offset->type) {
    case 2: 
    tmp___8 = zend_dval_to_lval(offset->value.dval);
    hval = (unsigned long )tmp___8;
    goto num_index;
    case 1: 
    case 3: 
    hval = (unsigned long )offset->value.lval;
    num_index: 
    _zend_hash_index_update_or_next_insert(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, hval, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    case 6: 
    if (1 << 1 == 1) {
      hval = ((zend_literal *)offset)->hash_value;
    } else {
      while (1) {
        tmp___9 = (char const   *)offset->value.str.val;
        if ((int const   )*tmp___9 == 45) {
          tmp___9 ++;
        } else {

        }
        if ((int const   )*tmp___9 >= 48) {
          if ((int const   )*tmp___9 <= 57) {
            end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
            if ((int const   )*end != 0) {
              break;
            } else {
              if ((int const   )*tmp___9 == 48) {
                if (offset->value.str.len + 1 > 2) {
                  break;
                } else {
                  goto _L___2;
                }
              } else {
                _L___2: /* CIL Label */ 
                if (end - tmp___9 > 10) {
                  break;
                } else {
                  if (end - tmp___9 == 10) {
                    if ((int const   )*tmp___9 > 50) {
                      break;
                    } else {

                    }
                  } else {

                  }
                }
              }
            }
            hval = (unsigned long )((int const   )*tmp___9 - 48);
            while (1) {
              tmp___9 ++;
              if ((unsigned int )tmp___9 != (unsigned int )end) {
                if ((int const   )*tmp___9 >= 48) {
                  if ((int const   )*tmp___9 <= 57) {

                  } else {
                    break;
                  }
                } else {
                  break;
                }
              } else {
                break;
              }
              hval = hval * 10UL + (ulong )((int const   )*tmp___9 - 48);
            }
            if ((unsigned int )tmp___9 == (unsigned int )end) {
              if ((int )*(offset->value.str.val) == 45) {
                if (hval - 1UL > 2147483647UL) {
                  break;
                } else {

                }
                hval = (unsigned long )(- ((long )hval));
              } else {
                if (hval > 2147483647UL) {
                  break;
                } else {

                }
              }
              goto num_index;
            } else {

            }
          } else {

          }
        } else {

        }
        break;
      }
      if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
        if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
          hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
        } else {
          tmp___10 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___10;
        }
      } else {
        tmp___10 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
        hval = (unsigned long )tmp___10;
      }
    }
    _zend_hash_quick_add_or_update(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    case 0: 
    _zend_hash_add_or_update(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, "", sizeof(""), (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    default: 
    zend_error(1 << 1L, "Illegal offset type");
    i_zval_ptr_dtor(expr_ptr);
    break;
    }
    _zval_dtor(free_op2.var);
  } else {
    _zend_hash_index_update_or_next_insert(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, 0UL, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1 << 2);
  }
  if (1 << 4 == 1 << 2) {
    goto _L___3;
  } else {
    if (1 << 4 == 1 << 4) {
      _L___3: /* CIL Label */ 
      if (opline->extended_value) {

      } else {

      }
    } else {

    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_ARRAY_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  int tmp ;

  {
  opline = execute_data->opline;
  _array_init(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, 0U);
  if (1 << 4 == 1 << 3) {
    (execute_data->opline) ++;
    return (0);
  } else {
    tmp = ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_TMP_HANDLER(execute_data);
    return (tmp);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_UNSET_DIM_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval **container ;
  zval *offset ;
  ulong hval ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  HashTable *ht ;
  long tmp___2 ;
  register char const   *tmp___3 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___4 ;
  long tmp___5 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 4) {
    if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
      tmp___1 = zval_isref_p(*container);
      if (tmp___1) {

      } else {
        while (1) {
          tmp___0 = zval_refcount_p(*container);
          if (tmp___0 > 1U) {
            zval_delref_p(*container);
            while (1) {
              tmp = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*container)->value;
                new_zv->type = (*container)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *container = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
    } else {

    }
  } else {

  }
  offset = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if (1 << 4 != 1 << 2) {
    goto _L___0;
  } else {
    if (container) {
      _L___0: /* CIL Label */ 
      switch ((int )(*container)->type) {
      case 4: 
      ht = (*container)->value.ht;
      switch ((int )offset->type) {
      case 2: 
      tmp___2 = zend_dval_to_lval(offset->value.dval);
      hval = (unsigned long )tmp___2;
      goto num_index_dim;
      case 7: 
      case 3: 
      case 1: 
      hval = (unsigned long )offset->value.lval;
      zend_hash_del_key_or_index(ht, (char const   *)((void *)0), 0U, hval, 1);
      break;
      case 6: 
      if (1 << 1 == 1 << 4) {
        zval_addref_p(offset);
      } else {
        if (1 << 1 == 1 << 2) {
          zval_addref_p(offset);
        } else {

        }
      }
      if (1 << 1 == 1) {
        hval = ((zend_literal *)offset)->hash_value;
      } else {
        while (1) {
          tmp___3 = (char const   *)offset->value.str.val;
          if ((int const   )*tmp___3 == 45) {
            tmp___3 ++;
          } else {

          }
          if ((int const   )*tmp___3 >= 48) {
            if ((int const   )*tmp___3 <= 57) {
              end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
              if ((int const   )*end != 0) {
                break;
              } else {
                if ((int const   )*tmp___3 == 48) {
                  if (offset->value.str.len + 1 > 2) {
                    break;
                  } else {
                    goto _L;
                  }
                } else {
                  _L: /* CIL Label */ 
                  if (end - tmp___3 > 10) {
                    break;
                  } else {
                    if (end - tmp___3 == 10) {
                      if ((int const   )*tmp___3 > 50) {
                        break;
                      } else {

                      }
                    } else {

                    }
                  }
                }
              }
              hval = (unsigned long )((int const   )*tmp___3 - 48);
              while (1) {
                tmp___3 ++;
                if ((unsigned int )tmp___3 != (unsigned int )end) {
                  if ((int const   )*tmp___3 >= 48) {
                    if ((int const   )*tmp___3 <= 57) {

                    } else {
                      break;
                    }
                  } else {
                    break;
                  }
                } else {
                  break;
                }
                hval = hval * 10UL + (ulong )((int const   )*tmp___3 - 48);
              }
              if ((unsigned int )tmp___3 == (unsigned int )end) {
                if ((int )*(offset->value.str.val) == 45) {
                  if (hval - 1UL > 2147483647UL) {
                    break;
                  } else {

                  }
                  hval = (unsigned long )(- ((long )hval));
                } else {
                  if (hval > 2147483647UL) {
                    break;
                  } else {

                  }
                }
                goto num_index_dim;
              } else {

              }
            } else {

            }
          } else {

          }
          break;
        }
        if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
          if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
            hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
          } else {
            tmp___4 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
            hval = (unsigned long )tmp___4;
          }
        } else {
          tmp___4 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___4;
        }
      }
      if ((unsigned int )ht == (unsigned int )(& executor_globals.symbol_table)) {
        zend_delete_global_variable_ex((char const   *)offset->value.str.val, offset->value.str.len, hval);
      } else {
        zend_hash_del_key_or_index(ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, 2);
      }
      if (1 << 1 == 1 << 4) {
        i_zval_ptr_dtor(offset);
      } else {
        if (1 << 1 == 1 << 2) {
          i_zval_ptr_dtor(offset);
        } else {

        }
      }
      break;
      num_index_dim: 
      zend_hash_del_key_or_index(ht, (char const   *)((void *)0), 0U, hval, 1);
      if (1 << 1 == 1 << 4) {
        i_zval_ptr_dtor(offset);
      } else {
        if (1 << 1 == 1 << 2) {
          i_zval_ptr_dtor(offset);
        } else {

        }
      }
      break;
      case 0: 
      zend_hash_del_key_or_index(ht, "", sizeof(""), 0UL, 0);
      break;
      default: 
      zend_error(1 << 1L, "Illegal offset type in unset");
      break;
      }
      _zval_dtor(free_op2.var);
      break;
      case 5: 
      tmp___5 = __builtin_expect((long )((unsigned int )((*container)->value.obj.handlers)->unset_dimension == (unsigned int )((void *)0)), 0L);
      if (tmp___5) {
        zend_error_noreturn(1, "Cannot use object as array");
      } else {

      }
      while (1) {
        while (1) {
          tmp___6 = _emalloc(sizeof(zval_gc_info ));
          _tmp = (zval *)tmp___6;
          ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            _tmp->value = offset->value;
            _tmp->type = offset->type;
            break;
          }
          zval_set_refcount_p(_tmp, 1U);
          zval_unset_isref_p(_tmp);
          break;
        }
        offset = _tmp;
        break;
      }
      (*(((*container)->value.obj.handlers)->unset_dimension))(*container, offset);
      i_zval_ptr_dtor(offset);
      break;
      case 6: 
      zend_error_noreturn(1, "Cannot unset string offsets");
      return (0);
      default: 
      _zval_dtor(free_op2.var);
      break;
      }
    } else {
      _zval_dtor(free_op2.var);
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_UNSET_OBJ_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval **container ;
  zval *offset ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_literal *tmp___3 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data->CVs, opline->op1.var);
  offset = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if (1 << 4 != 1 << 2) {
    goto _L;
  } else {
    if (container) {
      _L: /* CIL Label */ 
      if (1 << 4 == 1 << 4) {
        if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
          tmp___1 = zval_isref_p(*container);
          if (tmp___1) {

          } else {
            while (1) {
              tmp___0 = zval_refcount_p(*container);
              if (tmp___0 > 1U) {
                zval_delref_p(*container);
                while (1) {
                  tmp = _emalloc(sizeof(zval_gc_info ));
                  new_zv = (zval *)tmp;
                  ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                  break;
                }
                while (1) {
                  while (1) {
                    new_zv->value = (*container)->value;
                    new_zv->type = (*container)->type;
                    break;
                  }
                  zval_set_refcount_p(new_zv, 1U);
                  zval_unset_isref_p(new_zv);
                  break;
                }
                *container = new_zv;
                _zval_copy_ctor(new_zv);
              } else {

              }
              break;
            }
          }
        } else {

        }
      } else {

      }
      if ((int )(*container)->type == 5) {
        while (1) {
          while (1) {
            tmp___2 = _emalloc(sizeof(zval_gc_info ));
            _tmp = (zval *)tmp___2;
            ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              _tmp->value = offset->value;
              _tmp->type = offset->type;
              break;
            }
            zval_set_refcount_p(_tmp, 1U);
            zval_unset_isref_p(_tmp);
            break;
          }
          offset = _tmp;
          break;
        }
        if (((*container)->value.obj.handlers)->unset_property) {
          if (1 << 1 == 1) {
            tmp___3 = opline->op2.literal;
          } else {
            tmp___3 = (zend_literal *)((void *)0);
          }
          (*(((*container)->value.obj.handlers)->unset_property))(*container, offset, (struct _zend_literal  const  *)tmp___3);
        } else {
          zend_error(1 << 3L, "Trying to unset property of non-object");
        }
        i_zval_ptr_dtor(offset);
      } else {
        _zval_dtor(free_op2.var);
      }
    } else {
      _zval_dtor(free_op2.var);
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_TMP)(int prop_dim , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval **container ;
  zval **value ;
  int result ;
  ulong hval ;
  zval *offset ;
  HashTable *ht ;
  int isset ;
  long tmp ;
  int __attribute__((__visibility__("default")))  tmp___0 ;
  register char const   *tmp___1 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___2 ;
  int __attribute__((__visibility__("default")))  tmp___3 ;
  int __attribute__((__visibility__("default")))  tmp___4 ;
  int tmp___5 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;
  zend_literal *tmp___7 ;
  zval tmp___8 ;

  {
  opline = execute_data->opline;
  value = (zval **)((void *)0);
  result = 0;
  container = _get_zval_ptr_ptr_cv_BP_VAR_IS(execute_data->CVs, opline->op1.var);
  offset = _get_zval_ptr_tmp(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if ((int )(*container)->type == 4) {
    if (! prop_dim) {
      isset = 0;
      ht = (*container)->value.ht;
      switch ((int )offset->type) {
      case 2: 
      tmp = zend_dval_to_lval(offset->value.dval);
      hval = (unsigned long )tmp;
      goto num_index_prop;
      case 7: 
      case 3: 
      case 1: 
      hval = (unsigned long )offset->value.lval;
      num_index_prop: 
      tmp___0 = zend_hash_index_find((HashTable const   *)ht, hval, (void **)(& value));
      if (tmp___0 == (int __attribute__((__visibility__("default")))  )0) {
        isset = 1;
      } else {

      }
      break;
      case 6: 
      if (1 << 1 == 1) {
        hval = ((zend_literal *)offset)->hash_value;
      } else {
        if (! prop_dim) {
          while (1) {
            tmp___1 = (char const   *)offset->value.str.val;
            if ((int const   )*tmp___1 == 45) {
              tmp___1 ++;
            } else {

            }
            if ((int const   )*tmp___1 >= 48) {
              if ((int const   )*tmp___1 <= 57) {
                end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
                if ((int const   )*end != 0) {
                  break;
                } else {
                  if ((int const   )*tmp___1 == 48) {
                    if (offset->value.str.len + 1 > 2) {
                      break;
                    } else {
                      goto _L;
                    }
                  } else {
                    _L: /* CIL Label */ 
                    if (end - tmp___1 > 10) {
                      break;
                    } else {
                      if (end - tmp___1 == 10) {
                        if ((int const   )*tmp___1 > 50) {
                          break;
                        } else {

                        }
                      } else {

                      }
                    }
                  }
                }
                hval = (unsigned long )((int const   )*tmp___1 - 48);
                while (1) {
                  tmp___1 ++;
                  if ((unsigned int )tmp___1 != (unsigned int )end) {
                    if ((int const   )*tmp___1 >= 48) {
                      if ((int const   )*tmp___1 <= 57) {

                      } else {
                        break;
                      }
                    } else {
                      break;
                    }
                  } else {
                    break;
                  }
                  hval = hval * 10UL + (ulong )((int const   )*tmp___1 - 48);
                }
                if ((unsigned int )tmp___1 == (unsigned int )end) {
                  if ((int )*(offset->value.str.val) == 45) {
                    if (hval - 1UL > 2147483647UL) {
                      break;
                    } else {

                    }
                    hval = (unsigned long )(- ((long )hval));
                  } else {
                    if (hval > 2147483647UL) {
                      break;
                    } else {

                    }
                  }
                  goto num_index_prop;
                } else {

                }
              } else {

              }
            } else {

            }
            break;
          }
        } else {

        }
        if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
          if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
            hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
          } else {
            tmp___2 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
            hval = (unsigned long )tmp___2;
          }
        } else {
          tmp___2 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___2;
        }
      }
      tmp___3 = zend_hash_quick_find((HashTable const   *)ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, (void **)(& value));
      if (tmp___3 == (int __attribute__((__visibility__("default")))  )0) {
        isset = 1;
      } else {

      }
      break;
      case 0: 
      tmp___4 = zend_hash_find((HashTable const   *)ht, "", sizeof(""), (void **)(& value));
      if (tmp___4 == (int __attribute__((__visibility__("default")))  )0) {
        isset = 1;
      } else {

      }
      break;
      default: 
      zend_error(1 << 1L, "Illegal offset type in isset or empty");
      break;
      }
      if (opline->extended_value & 33554432UL) {
        if (isset) {
          if ((int )(*value)->type == 0) {
            result = 0;
          } else {
            result = isset;
          }
        } else {
          result = isset;
        }
      } else {
        if (! isset) {
          result = 0;
        } else {
          tmp___5 = i_zend_is_true(*value);
          if (tmp___5) {
            result = 1;
          } else {
            result = 0;
          }
        }
      }
      _zval_dtor(free_op2.var);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if ((int )(*container)->type == 5) {
      while (1) {
        while (1) {
          tmp___6 = _emalloc(sizeof(zval_gc_info ));
          _tmp = (zval *)tmp___6;
          ((zval_gc_info *)_tmp)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            _tmp->value = offset->value;
            _tmp->type = offset->type;
            break;
          }
          zval_set_refcount_p(_tmp, 1U);
          zval_unset_isref_p(_tmp);
          break;
        }
        offset = _tmp;
        break;
      }
      if (prop_dim) {
        if (((*container)->value.obj.handlers)->has_property) {
          if (1 << 1 == 1) {
            tmp___7 = opline->op2.literal;
          } else {
            tmp___7 = (zend_literal *)((void *)0);
          }
          result = (*(((*container)->value.obj.handlers)->has_property))(*container, offset, (opline->extended_value & 16777216UL) != 0UL, (struct _zend_literal  const  *)tmp___7);
        } else {
          zend_error(1 << 3L, "Trying to check property of non-object");
          result = 0;
        }
      } else {
        if (((*container)->value.obj.handlers)->has_dimension) {
          result = (*(((*container)->value.obj.handlers)->has_dimension))(*container, offset, (opline->extended_value & 16777216UL) != 0UL);
        } else {
          zend_error(1 << 3L, "Trying to check element of non-array");
          result = 0;
        }
      }
      i_zval_ptr_dtor(offset);
    } else {
      if ((int )(*container)->type == 6) {
        if (! prop_dim) {
          if ((int )offset->type != 1) {
            while (1) {
              tmp___8.value = offset->value;
              tmp___8.type = offset->type;
              break;
            }
            _zval_copy_ctor(& tmp___8);
            convert_to_long(& tmp___8);
            offset = & tmp___8;
          } else {

          }
          if ((int )offset->type == 1) {
            if (opline->extended_value & 33554432UL) {
              if (offset->value.lval >= 0L) {
                if (offset->value.lval < (long )(*container)->value.str.len) {
                  result = 1;
                } else {

                }
              } else {

              }
            } else {
              if (offset->value.lval >= 0L) {
                if (offset->value.lval < (long )(*container)->value.str.len) {
                  if ((int )*((*container)->value.str.val + offset->value.lval) != 48) {
                    result = 1;
                  } else {

                  }
                } else {

                }
              } else {

              }
            }
          } else {

          }
          _zval_dtor(free_op2.var);
        } else {
          _zval_dtor(free_op2.var);
        }
      } else {
        _zval_dtor(free_op2.var);
      }
    }
  }
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.type = (unsigned char)3;
  if (opline->extended_value & 33554432UL) {
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.lval = (long )result;
  } else {
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.lval = (long )(! result);
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_TMP(0, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_TMP_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_TMP(1, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  fast_add_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SUB_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  fast_sub_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_MUL_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  fast_mul_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_DIV_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  fast_div_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_MOD_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  fast_mod_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SL_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  shift_left_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SR_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  shift_right_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_CONCAT_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  concat_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_IDENTICAL_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  is_identical_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_NOT_IDENTICAL_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *result ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  is_identical_function(result, tmp___0, tmp);
  result->value.lval = (long )(! result->value.lval);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_EQUAL_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  zval *tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
    tmp___1 = fast_equal_function(result, tmp___0, tmp);
    __z->value.lval = (long )(tmp___1 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_NOT_EQUAL_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  zval *tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
    tmp___1 = fast_not_equal_function(result, tmp___0, tmp);
    __z->value.lval = (long )(tmp___1 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_SMALLER_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  zval *tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
    tmp___1 = fast_is_smaller_function(result, tmp___0, tmp);
    __z->value.lval = (long )(tmp___1 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  zval *tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
    tmp___1 = fast_is_smaller_or_equal_function(result, tmp___0, tmp);
    __z->value.lval = (long )(tmp___1 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_OR_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  bitwise_or_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_AND_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  bitwise_and_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_XOR_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  bitwise_xor_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BOOL_XOR_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  boolean_xor_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_binary_assign_op_obj_helper_SPEC_CV_VAR)(int (*binary_op)(zval *result , zval *op1 , zval *op2 ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zend_free_op free_op_data1 ;
  zval **object_ptr ;
  zval **tmp ;
  zval *object ;
  zval *property ;
  zval *tmp___0 ;
  zval *value ;
  zval *tmp___1 ;
  int have_get_ptr ;
  long tmp___2 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___3 ;
  zval **zptr ;
  zend_literal *tmp___4 ;
  zval **tmp___5 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;
  zend_uint tmp___7 ;
  zend_bool tmp___8 ;
  zval *z ;
  zend_literal *tmp___9 ;
  zval *value___0 ;
  zval *tmp___10 ;
  zend_uint tmp___11 ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___12 ;
  zend_uint tmp___13 ;
  zend_bool tmp___14 ;
  zend_literal *tmp___15 ;
  long tmp___16 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var);
  object_ptr = tmp;
  tmp___0 = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  property = tmp___0;
  tmp___1 = _get_zval_ptr((int )(opline + 1)->op1_type, (znode_op const   *)(& (opline + 1)->op1), (temp_variable const   *)execute_data->Ts, & free_op_data1, 0);
  value = tmp___1;
  have_get_ptr = 0;
  if (1 << 4 == 1 << 2) {
    tmp___2 = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___2) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  make_real_object(object_ptr);
  object = *object_ptr;
  tmp___16 = __builtin_expect((long )((int )object->type != 5), 0L);
  if (tmp___16) {
    zend_error(1 << 1L, "Attempt to assign property of non-object");
    if (free_op2.var) {
      i_zval_ptr_dtor(free_op2.var);
    } else {

    }
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = & executor_globals.uninitialized_zval;
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
    } else {

    }
  } else {
    if (opline->extended_value == 136UL) {
      if ((object->value.obj.handlers)->get_property_ptr_ptr) {
        if (1 << 2 == 1) {
          tmp___4 = opline->op2.literal;
        } else {
          tmp___4 = (zend_literal *)((void *)0);
        }
        tmp___5 = (*((object->value.obj.handlers)->get_property_ptr_ptr))(object, property, (struct _zend_literal  const  *)tmp___4);
        zptr = tmp___5;
        if ((unsigned int )zptr != (unsigned int )((void *)0)) {
          tmp___8 = zval_isref_p(*zptr);
          if (tmp___8) {

          } else {
            while (1) {
              tmp___7 = zval_refcount_p(*zptr);
              if (tmp___7 > 1U) {
                zval_delref_p(*zptr);
                while (1) {
                  tmp___6 = _emalloc(sizeof(zval_gc_info ));
                  new_zv = (zval *)tmp___6;
                  ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                  break;
                }
                while (1) {
                  while (1) {
                    new_zv->value = (*zptr)->value;
                    new_zv->type = (*zptr)->type;
                    break;
                  }
                  zval_set_refcount_p(new_zv, 1U);
                  zval_unset_isref_p(new_zv);
                  break;
                }
                *zptr = new_zv;
                _zval_copy_ctor(new_zv);
              } else {

              }
              break;
            }
          }
          have_get_ptr = 1;
          (*binary_op)(*zptr, *zptr, value);
          if (! ((int )opline->result_type & (1 << 5))) {
            zval_addref_p(*zptr);
            ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = *zptr;
            ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
          } else {

          }
        } else {

        }
      } else {

      }
    } else {

    }
    if (! have_get_ptr) {
      z = (zval *)((void *)0);
      if (opline->extended_value == 136UL) {
        if ((object->value.obj.handlers)->read_property) {
          if (1 << 2 == 1) {
            tmp___9 = opline->op2.literal;
          } else {
            tmp___9 = (zend_literal *)((void *)0);
          }
          z = (*((object->value.obj.handlers)->read_property))(object, property, 0, (struct _zend_literal  const  *)tmp___9);
        } else {

        }
      } else {
        if ((object->value.obj.handlers)->read_dimension) {
          z = (*((object->value.obj.handlers)->read_dimension))(object, property, 0);
        } else {

        }
      }
      if (z) {
        if ((int )z->type == 5) {
          if ((z->value.obj.handlers)->get) {
            tmp___10 = (*((z->value.obj.handlers)->get))(z);
            value___0 = tmp___10;
            tmp___11 = zval_refcount_p(z);
            if (tmp___11 == 0U) {
              if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                gc_remove_zval_from_buffer(z);
              } else {

              }
              _zval_dtor(z);
              while (1) {
                if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                  gc_remove_zval_from_buffer(z);
                } else {

                }
                _efree((void *)z);
                break;
              }
            } else {

            }
            z = value___0;
          } else {

          }
        } else {

        }
        zval_addref_p(z);
        tmp___14 = zval_isref_p(z);
        if (tmp___14) {

        } else {
          while (1) {
            tmp___13 = zval_refcount_p(z);
            if (tmp___13 > 1U) {
              zval_delref_p(z);
              while (1) {
                tmp___12 = _emalloc(sizeof(zval_gc_info ));
                new_zv___0 = (zval *)tmp___12;
                ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv___0->value = z->value;
                  new_zv___0->type = z->type;
                  break;
                }
                zval_set_refcount_p(new_zv___0, 1U);
                zval_unset_isref_p(new_zv___0);
                break;
              }
              z = new_zv___0;
              _zval_copy_ctor(new_zv___0);
            } else {

            }
            break;
          }
        }
        (*binary_op)(z, z, value);
        if (opline->extended_value == 136UL) {
          if (1 << 2 == 1) {
            tmp___15 = opline->op2.literal;
          } else {
            tmp___15 = (zend_literal *)((void *)0);
          }
          (*((object->value.obj.handlers)->write_property))(object, property, z, (struct _zend_literal  const  *)tmp___15);
        } else {
          (*((object->value.obj.handlers)->write_dimension))(object, property, z);
        }
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(z);
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = z;
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
        } else {

        }
        i_zval_ptr_dtor(z);
      } else {
        zend_error(1 << 1L, "Attempt to assign property of non-object");
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = & executor_globals.uninitialized_zval;
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
        } else {

        }
      }
    } else {

    }
    if (free_op2.var) {
      i_zval_ptr_dtor(free_op2.var);
    } else {

    }
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
  }
  (execute_data->opline) ++;
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_binary_assign_op_helper_SPEC_CV_VAR)(int (*binary_op)(zval *result , zval *op1 , zval *op2 ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zend_free_op free_op_data2 ;
  zend_free_op free_op_data1 ;
  zval **var_ptr ;
  zval *value ;
  int tmp ;
  zval **container ;
  zval **tmp___0 ;
  int tmp___1 ;
  zval *dim ;
  zval *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  temp_variable *__t ;
  long tmp___6 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___7 ;
  zend_uint tmp___8 ;
  zend_bool tmp___9 ;
  zval *objval ;
  zval *tmp___10 ;
  long tmp___11 ;
  temp_variable *__t___0 ;

  {
  opline = execute_data->opline;
  switch ((int )opline->extended_value) {
  case 136: 
  tmp = zend_binary_assign_op_obj_helper_SPEC_CV_VAR(binary_op, execute_data);
  return (tmp);
  break;
  case 147: 
  tmp___0 = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var);
  container = tmp___0;
  if (1 << 4 == 1 << 2) {
    tmp___4 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___4) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    tmp___3 = __builtin_expect((long )((int )(*container)->type == 5), 0L);
    if (tmp___3) {
      if (1 << 4 == 1 << 2) {
        zval_addref_p(*container);
      } else {

      }
      tmp___1 = zend_binary_assign_op_obj_helper_SPEC_CV_VAR(binary_op, execute_data);
      return (tmp___1);
    } else {
      tmp___2 = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
      dim = tmp___2;
      zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var), container, dim, 1 << 2, 2);
      value = _get_zval_ptr((int )(opline + 1)->op1_type, (znode_op const   *)(& (opline + 1)->op1), (temp_variable const   *)execute_data->Ts, & free_op_data1, 0);
      var_ptr = _get_zval_ptr_ptr_var((opline + 1)->op2.var, (temp_variable const   *)execute_data->Ts, & free_op_data2);
    }
  }
  break;
  default: 
  value = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var);
  break;
  }
  tmp___5 = __builtin_expect((long )((unsigned int )var_ptr == (unsigned int )((void *)0)), 0L);
  if (tmp___5) {
    zend_error_noreturn(1, "Cannot use assign-op operators with overloaded objects nor string offsets");
  } else {

  }
  tmp___6 = __builtin_expect((long )((unsigned int )*var_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
  if (tmp___6) {
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      while (1) {
        __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t->var.ptr = & executor_globals.uninitialized_zval;
        __t->var.ptr_ptr = & __t->var.ptr;
        break;
      }
    } else {

    }
    if (free_op2.var) {
      i_zval_ptr_dtor(free_op2.var);
    } else {

    }
    if (opline->extended_value == 147UL) {
      (execute_data->opline) ++;
    } else {

    }
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  tmp___9 = zval_isref_p(*var_ptr);
  if (tmp___9) {

  } else {
    while (1) {
      tmp___8 = zval_refcount_p(*var_ptr);
      if (tmp___8 > 1U) {
        zval_delref_p(*var_ptr);
        while (1) {
          tmp___7 = _emalloc(sizeof(zval_gc_info ));
          new_zv = (zval *)tmp___7;
          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            new_zv->value = (*var_ptr)->value;
            new_zv->type = (*var_ptr)->type;
            break;
          }
          zval_set_refcount_p(new_zv, 1U);
          zval_unset_isref_p(new_zv);
          break;
        }
        *var_ptr = new_zv;
        _zval_copy_ctor(new_zv);
      } else {

      }
      break;
    }
  }
  tmp___11 = __builtin_expect((long )((int )(*var_ptr)->type == 5), 0L);
  if (tmp___11) {
    if (((*var_ptr)->value.obj.handlers)->get) {
      if (((*var_ptr)->value.obj.handlers)->set) {
        tmp___10 = (*(((*var_ptr)->value.obj.handlers)->get))(*var_ptr);
        objval = tmp___10;
        zval_addref_p(objval);
        (*binary_op)(objval, objval, value);
        (*(((*var_ptr)->value.obj.handlers)->set))(var_ptr, objval);
        i_zval_ptr_dtor(objval);
      } else {
        (*binary_op)(*var_ptr, *var_ptr, value);
      }
    } else {
      (*binary_op)(*var_ptr, *var_ptr, value);
    }
  } else {
    (*binary_op)(*var_ptr, *var_ptr, value);
  }
  if (! ((int )opline->result_type & (1 << 5))) {
    zval_addref_p(*var_ptr);
    while (1) {
      __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
      __t___0->var.ptr = *var_ptr;
      __t___0->var.ptr_ptr = & __t___0->var.ptr;
      break;
    }
  } else {

  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  if (opline->extended_value == 147UL) {
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
    if (free_op_data2.var) {
      i_zval_ptr_dtor(free_op_data2.var);
    } else {

    }
    (execute_data->opline) ++;
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_ADD_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_VAR((int (*)(zval *result , zval *op1 , zval *op2 ))(& add_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SUB_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_VAR((int (*)(zval *result , zval *op1 , zval *op2 ))(& sub_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_MUL_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_VAR((int (*)(zval *result , zval *op1 , zval *op2 ))(& mul_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_DIV_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_VAR((int (*)(zval *result , zval *op1 , zval *op2 ))(& div_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_MOD_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_VAR((int (*)(zval *result , zval *op1 , zval *op2 ))(& mod_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SL_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_VAR((int (*)(zval *result , zval *op1 , zval *op2 ))(& shift_left_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SR_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_VAR((int (*)(zval *result , zval *op1 , zval *op2 ))(& shift_right_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_CONCAT_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_VAR((int (*)(zval *result , zval *op1 , zval *op2 ))(& concat_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_OR_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_VAR((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_or_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_AND_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_VAR((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_and_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_XOR_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_VAR((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_xor_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) zend_pre_incdec_property_helper_SPEC_CV_VAR)(int (*incdec_op)(zval * ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval **object_ptr ;
  zval *object ;
  zval *property ;
  zval **retval ;
  int have_get_ptr ;
  long tmp ;
  long tmp___0 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zval **zptr ;
  zend_literal *tmp___2 ;
  zval **tmp___3 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_uint tmp___5 ;
  zend_bool tmp___6 ;
  zval *z ;
  zend_literal *tmp___7 ;
  zval *tmp___8 ;
  zval *value ;
  zval *tmp___9 ;
  zend_uint tmp___10 ;
  long tmp___11 ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___12 ;
  zend_uint tmp___13 ;
  zend_bool tmp___14 ;
  zend_literal *tmp___15 ;

  {
  opline = execute_data->opline;
  have_get_ptr = 0;
  object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var);
  property = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  retval = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
  if (1 << 4 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot increment/decrement overloaded objects nor string offsets");
    } else {

    }
  } else {

  }
  make_real_object(object_ptr);
  object = *object_ptr;
  tmp___0 = __builtin_expect((long )((int )object->type != 5), 0L);
  if (tmp___0) {
    zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
    if (free_op2.var) {
      i_zval_ptr_dtor(free_op2.var);
    } else {

    }
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      *retval = & executor_globals.uninitialized_zval;
    } else {

    }
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  if ((object->value.obj.handlers)->get_property_ptr_ptr) {
    if (1 << 2 == 1) {
      tmp___2 = opline->op2.literal;
    } else {
      tmp___2 = (zend_literal *)((void *)0);
    }
    tmp___3 = (*((object->value.obj.handlers)->get_property_ptr_ptr))(object, property, (struct _zend_literal  const  *)tmp___2);
    zptr = tmp___3;
    if ((unsigned int )zptr != (unsigned int )((void *)0)) {
      tmp___6 = zval_isref_p(*zptr);
      if (tmp___6) {

      } else {
        while (1) {
          tmp___5 = zval_refcount_p(*zptr);
          if (tmp___5 > 1U) {
            zval_delref_p(*zptr);
            while (1) {
              tmp___4 = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp___4;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*zptr)->value;
                new_zv->type = (*zptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *zptr = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
      have_get_ptr = 1;
      (*incdec_op)(*zptr);
      if (! ((int )opline->result_type & (1 << 5))) {
        *retval = *zptr;
        zval_addref_p(*retval);
      } else {

      }
    } else {

    }
  } else {

  }
  if (! have_get_ptr) {
    if ((object->value.obj.handlers)->read_property) {
      if ((object->value.obj.handlers)->write_property) {
        if (1 << 2 == 1) {
          tmp___7 = opline->op2.literal;
        } else {
          tmp___7 = (zend_literal *)((void *)0);
        }
        tmp___8 = (*((object->value.obj.handlers)->read_property))(object, property, 0, (struct _zend_literal  const  *)tmp___7);
        z = tmp___8;
        tmp___11 = __builtin_expect((long )((int )z->type == 5), 0L);
        if (tmp___11) {
          if ((z->value.obj.handlers)->get) {
            tmp___9 = (*((z->value.obj.handlers)->get))(z);
            value = tmp___9;
            tmp___10 = zval_refcount_p(z);
            if (tmp___10 == 0U) {
              if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                gc_remove_zval_from_buffer(z);
              } else {

              }
              _zval_dtor(z);
              while (1) {
                if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                  gc_remove_zval_from_buffer(z);
                } else {

                }
                _efree((void *)z);
                break;
              }
            } else {

            }
            z = value;
          } else {

          }
        } else {

        }
        zval_addref_p(z);
        tmp___14 = zval_isref_p(z);
        if (tmp___14) {

        } else {
          while (1) {
            tmp___13 = zval_refcount_p(z);
            if (tmp___13 > 1U) {
              zval_delref_p(z);
              while (1) {
                tmp___12 = _emalloc(sizeof(zval_gc_info ));
                new_zv___0 = (zval *)tmp___12;
                ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv___0->value = z->value;
                  new_zv___0->type = z->type;
                  break;
                }
                zval_set_refcount_p(new_zv___0, 1U);
                zval_unset_isref_p(new_zv___0);
                break;
              }
              z = new_zv___0;
              _zval_copy_ctor(new_zv___0);
            } else {

            }
            break;
          }
        }
        (*incdec_op)(z);
        *retval = z;
        if (1 << 2 == 1) {
          tmp___15 = opline->op2.literal;
        } else {
          tmp___15 = (zend_literal *)((void *)0);
        }
        (*((object->value.obj.handlers)->write_property))(object, property, z, (struct _zend_literal  const  *)tmp___15);
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(*retval);
        } else {

        }
        i_zval_ptr_dtor(z);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
      if (! ((int )opline->result_type & (1 << 5))) {
        zval_addref_p(& executor_globals.uninitialized_zval);
        *retval = & executor_globals.uninitialized_zval;
      } else {

      }
    }
  } else {

  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_PRE_INC_OBJ_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_pre_incdec_property_helper_SPEC_CV_VAR((int (*)(zval * ))(& increment_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_PRE_DEC_OBJ_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_pre_incdec_property_helper_SPEC_CV_VAR((int (*)(zval * ))(& decrement_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) zend_post_incdec_property_helper_SPEC_CV_VAR)(int (*incdec_op)(zval * ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval **object_ptr ;
  zval *object ;
  zval *property ;
  zval *retval ;
  int have_get_ptr ;
  long tmp ;
  long tmp___0 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zval **zptr ;
  zend_literal *tmp___2 ;
  zval **tmp___3 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_uint tmp___5 ;
  zend_bool tmp___6 ;
  zval *z ;
  zend_literal *tmp___7 ;
  zval *tmp___8 ;
  zval *z_copy ;
  zval *value ;
  zval *tmp___9 ;
  zend_uint tmp___10 ;
  long tmp___11 ;
  void __attribute__((__visibility__("default")))  *tmp___12 ;
  zend_literal *tmp___13 ;

  {
  opline = execute_data->opline;
  have_get_ptr = 0;
  object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var);
  property = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  retval = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  if (1 << 4 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot increment/decrement overloaded objects nor string offsets");
    } else {

    }
  } else {

  }
  make_real_object(object_ptr);
  object = *object_ptr;
  tmp___0 = __builtin_expect((long )((int )object->type != 5), 0L);
  if (tmp___0) {
    zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
    if (free_op2.var) {
      i_zval_ptr_dtor(free_op2.var);
    } else {

    }
    retval->type = (unsigned char)0;
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  if ((object->value.obj.handlers)->get_property_ptr_ptr) {
    if (1 << 2 == 1) {
      tmp___2 = opline->op2.literal;
    } else {
      tmp___2 = (zend_literal *)((void *)0);
    }
    tmp___3 = (*((object->value.obj.handlers)->get_property_ptr_ptr))(object, property, (struct _zend_literal  const  *)tmp___2);
    zptr = tmp___3;
    if ((unsigned int )zptr != (unsigned int )((void *)0)) {
      have_get_ptr = 1;
      tmp___6 = zval_isref_p(*zptr);
      if (tmp___6) {

      } else {
        while (1) {
          tmp___5 = zval_refcount_p(*zptr);
          if (tmp___5 > 1U) {
            zval_delref_p(*zptr);
            while (1) {
              tmp___4 = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp___4;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*zptr)->value;
                new_zv->type = (*zptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *zptr = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
      while (1) {
        retval->value = (*zptr)->value;
        retval->type = (*zptr)->type;
        break;
      }
      _zval_copy_ctor(retval);
      (*incdec_op)(*zptr);
    } else {

    }
  } else {

  }
  if (! have_get_ptr) {
    if ((object->value.obj.handlers)->read_property) {
      if ((object->value.obj.handlers)->write_property) {
        if (1 << 2 == 1) {
          tmp___7 = opline->op2.literal;
        } else {
          tmp___7 = (zend_literal *)((void *)0);
        }
        tmp___8 = (*((object->value.obj.handlers)->read_property))(object, property, 0, (struct _zend_literal  const  *)tmp___7);
        z = tmp___8;
        tmp___11 = __builtin_expect((long )((int )z->type == 5), 0L);
        if (tmp___11) {
          if ((z->value.obj.handlers)->get) {
            tmp___9 = (*((z->value.obj.handlers)->get))(z);
            value = tmp___9;
            tmp___10 = zval_refcount_p(z);
            if (tmp___10 == 0U) {
              if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                gc_remove_zval_from_buffer(z);
              } else {

              }
              _zval_dtor(z);
              while (1) {
                if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                  gc_remove_zval_from_buffer(z);
                } else {

                }
                _efree((void *)z);
                break;
              }
            } else {

            }
            z = value;
          } else {

          }
        } else {

        }
        while (1) {
          retval->value = z->value;
          retval->type = z->type;
          break;
        }
        _zval_copy_ctor(retval);
        while (1) {
          tmp___12 = _emalloc(sizeof(zval_gc_info ));
          z_copy = (zval *)tmp___12;
          ((zval_gc_info *)z_copy)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            z_copy->value = z->value;
            z_copy->type = z->type;
            break;
          }
          zval_set_refcount_p(z_copy, 1U);
          zval_unset_isref_p(z_copy);
          break;
        }
        _zval_copy_ctor(z_copy);
        (*incdec_op)(z_copy);
        zval_addref_p(z);
        if (1 << 2 == 1) {
          tmp___13 = opline->op2.literal;
        } else {
          tmp___13 = (zend_literal *)((void *)0);
        }
        (*((object->value.obj.handlers)->write_property))(object, property, z_copy, (struct _zend_literal  const  *)tmp___13);
        i_zval_ptr_dtor(z_copy);
        i_zval_ptr_dtor(z);
      } else {
        zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
        retval->type = (unsigned char)0;
      }
    } else {
      zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
      retval->type = (unsigned char)0;
    }
  } else {

  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_POST_INC_OBJ_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_post_incdec_property_helper_SPEC_CV_VAR((int (*)(zval * ))(& increment_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_POST_DEC_OBJ_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_post_incdec_property_helper_SPEC_CV_VAR((int (*)(zval * ))(& decrement_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) zend_fetch_var_address_helper_SPEC_CV_VAR)(int type , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *varname ;
  zval **retval ;
  zval tmp_varname ;
  HashTable *target_symbol_table ;
  ulong hash_value ;
  long tmp ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_literal *tmp___1 ;
  zval __attribute__((__visibility__("default")))  **tmp___2 ;
  ulong __attribute__((__visibility__("default")))  tmp___3 ;
  int __attribute__((__visibility__("default")))  tmp___4 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  zend_uint tmp___6 ;
  zend_bool tmp___7 ;
  temp_variable *__t ;
  zend_free_op free_res ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___8 ;
  zend_uint tmp___9 ;
  zend_bool tmp___10 ;

  {
  opline = execute_data->opline;
  varname = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  if (1 << 4 != 1) {
    tmp = __builtin_expect((long )((int )varname->type != 6), 0L);
    if (tmp) {
      while (1) {
        tmp_varname.value = varname->value;
        tmp_varname.type = varname->type;
        break;
      }
      _zval_copy_ctor(& tmp_varname);
      zval_set_refcount_p(& tmp_varname, 1U);
      zval_unset_isref_p(& tmp_varname);
      if ((int )tmp_varname.type != 6) {
        _convert_to_string(& tmp_varname);
      } else {

      }
      varname = & tmp_varname;
    } else {

    }
  } else {

  }
  if (1 << 2 != 1 << 3) {
    if (1 << 2 == 1) {
      if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
        ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
      } else {
        tmp___0 = zend_fetch_class_by_name((char const   *)(opline->op2.zv)->value.str.val, (unsigned int )(opline->op2.zv)->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), 0);
        ce = (zend_class_entry *)tmp___0;
        while (1) {
          *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
          break;
        }
      }
    } else {
      ce = ((temp_variable *)((char *)execute_data->Ts + opline->op2.var))->class_entry;
    }
    if (1 << 4 == 1) {
      tmp___1 = opline->op1.literal;
    } else {
      tmp___1 = (zend_literal *)((void *)0);
    }
    tmp___2 = zend_std_get_static_property(ce, (char const   *)varname->value.str.val, varname->value.str.len, (unsigned char)0, (struct _zend_literal  const  *)tmp___1);
    retval = (zval **)tmp___2;
  } else {
    target_symbol_table = zend_get_target_symbol_table((int )(opline->extended_value & 1879048192UL));
    if (1 << 4 == 1) {
      hash_value = ((zend_literal *)varname)->hash_value;
    } else {
      if ((unsigned int )varname->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
        if ((unsigned int )varname->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
          hash_value = ((Bucket *)(varname->value.str.val - sizeof(Bucket )))->h;
        } else {
          tmp___3 = zend_hash_func((char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1));
          hash_value = (unsigned long )tmp___3;
        }
      } else {
        tmp___3 = zend_hash_func((char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1));
        hash_value = (unsigned long )tmp___3;
      }
    }
    tmp___4 = zend_hash_quick_find((HashTable const   *)target_symbol_table, (char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1), hash_value, (void **)(& retval));
    if (tmp___4 == (int __attribute__((__visibility__("default")))  )-1) {
      switch (type) {
      case 0: 
      case 6: 
      zend_error(1 << 3L, "Undefined variable: %s", varname->value.str.val);
      case 3: 
      retval = & executor_globals.uninitialized_zval_ptr;
      break;
      case 2: 
      zend_error(1 << 3L, "Undefined variable: %s", varname->value.str.val);
      case 1: 
      zval_addref_p(& executor_globals.uninitialized_zval);
      _zend_hash_quick_add_or_update(target_symbol_table, (char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1), hash_value, (void *)(& executor_globals.uninitialized_zval_ptr), sizeof(zval *), (void **)(& retval), 1);
      break;
      }
    } else {

    }
    switch ((int )(opline->extended_value & 1879048192UL)) {
    case 0x00000000: 
    if (1 << 4 != 1 << 1) {

    } else {

    }
    break;
    case 0x10000000: 
    break;
    case 0x20000000: 
    zval_update_constant(retval, (void *)1);
    break;
    case 0x40000000: 
    if (1 << 4 == 1 << 2) {
      if (! free_op1.var) {
        zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr));
      } else {

      }
    } else {

    }
    break;
    }
  }
  if (1 << 4 != 1) {
    if ((unsigned int )varname == (unsigned int )(& tmp_varname)) {
      _zval_dtor(& tmp_varname);
    } else {

    }
  } else {

  }
  if (opline->extended_value & 67108864UL) {
    tmp___7 = zval_isref_p(*retval);
    if (tmp___7) {

    } else {
      while (1) {
        tmp___6 = zval_refcount_p(*retval);
        if (tmp___6 > 1U) {
          zval_delref_p(*retval);
          while (1) {
            tmp___5 = _emalloc(sizeof(zval_gc_info ));
            new_zv = (zval *)tmp___5;
            ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv->value = (*retval)->value;
              new_zv->type = (*retval)->type;
              break;
            }
            zval_set_refcount_p(new_zv, 1U);
            zval_unset_isref_p(new_zv);
            break;
          }
          *retval = new_zv;
          _zval_copy_ctor(new_zv);
        } else {

        }
        break;
      }
      zval_set_isref_p(*retval);
    }
  } else {

  }
  zval_addref_p(*retval);
  switch (type) {
  case 0: 
  case 3: 
  while (1) {
    __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
    __t->var.ptr = *retval;
    __t->var.ptr_ptr = & __t->var.ptr;
    break;
  }
  break;
  case 6: 
  zend_pzval_unlock_func(*retval, & free_res, 1);
  if ((unsigned int )retval != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
    tmp___10 = zval_isref_p(*retval);
    if (tmp___10) {

    } else {
      while (1) {
        tmp___9 = zval_refcount_p(*retval);
        if (tmp___9 > 1U) {
          zval_delref_p(*retval);
          while (1) {
            tmp___8 = _emalloc(sizeof(zval_gc_info ));
            new_zv___0 = (zval *)tmp___8;
            ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv___0->value = (*retval)->value;
              new_zv___0->type = (*retval)->type;
              break;
            }
            zval_set_refcount_p(new_zv___0, 1U);
            zval_unset_isref_p(new_zv___0);
            break;
          }
          *retval = new_zv___0;
          _zval_copy_ctor(new_zv___0);
        } else {

        }
        break;
      }
    }
  } else {

  }
  zval_addref_p(*retval);
  if (free_res.var) {
    i_zval_ptr_dtor(free_res.var);
  } else {

  }
  default: 
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = retval;
  break;
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_R_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_CV_VAR(0, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_W_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_CV_VAR(1, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_RW_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_CV_VAR(2, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_FUNC_ARG_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  unsigned int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
  opline = execute_data->opline;
  if (execute_data->fbc) {
    if ((execute_data->fbc)->common.arg_info) {
      if ((opline->extended_value & 1048575UL) <= (unsigned long )(execute_data->fbc)->common.num_args) {
        tmp___1 = (unsigned int )((int )((execute_data->fbc)->common.arg_info + ((opline->extended_value & 1048575UL) - 1UL))->pass_by_reference & 3);
      } else {
        tmp___1 = (execute_data->fbc)->common.fn_flags & 50331648U;
      }
    } else {
      tmp___1 = (execute_data->fbc)->common.fn_flags & 50331648U;
    }
    if (tmp___1) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___2 = zend_fetch_var_address_helper_SPEC_CV_VAR(tmp___0, execute_data);
  return (tmp___2);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_UNSET_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_CV_VAR(6, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_IS_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_CV_VAR(3, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_R_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval **container ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  if (opline->extended_value & 134217728UL) {
    if (1 << 4 != 1 << 4) {
      if (((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr) {
        zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr));
      } else {

      }
    } else {

    }
  } else {

  }
  container = _get_zval_ptr_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  zend_fetch_dimension_address_read((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, tmp, 1 << 2, 0);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_W_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval **container ;
  long tmp ;
  zval *tmp___0 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zend_uint tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___6 ;
  zval **retval_ptr ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___7 ;
  zend_uint tmp___8 ;
  zend_bool tmp___9 ;
  long tmp___10 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  tmp___0 = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, tmp___0, 1 << 2, 1);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  if (1 << 4 == 1 << 2) {
    if (0) {
      tmp___5 = zval_refcount_p(free_op1.var);
      if (tmp___5 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___6 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___6 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___3 = zval_isref_p(__t->var.ptr);
                if (tmp___3) {

                } else {
                  tmp___4 = zval_refcount_p(__t->var.ptr);
                  if (tmp___4 > 2U) {
                    while (1) {
                      tmp___2 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___2 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___1 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___1;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  tmp___10 = __builtin_expect((long )(opline->extended_value != 0UL), 0L);
  if (tmp___10) {
    retval_ptr = ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr;
    if (retval_ptr) {
      zval_delref_p(*retval_ptr);
      tmp___9 = zval_isref_p(*retval_ptr);
      if (tmp___9) {

      } else {
        while (1) {
          tmp___8 = zval_refcount_p(*retval_ptr);
          if (tmp___8 > 1U) {
            zval_delref_p(*retval_ptr);
            while (1) {
              tmp___7 = _emalloc(sizeof(zval_gc_info ));
              new_zv___0 = (zval *)tmp___7;
              ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv___0->value = (*retval_ptr)->value;
                new_zv___0->type = (*retval_ptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv___0, 1U);
              zval_unset_isref_p(new_zv___0);
              break;
            }
            *retval_ptr = new_zv___0;
            _zval_copy_ctor(new_zv___0);
          } else {

          }
          break;
        }
        zval_set_isref_p(*retval_ptr);
      }
      zval_addref_p(*retval_ptr);
    } else {

    }
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_RW_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval **container ;
  long tmp ;
  zval *tmp___0 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zend_uint tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___6 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  tmp___0 = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, tmp___0, 1 << 2, 2);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  if (1 << 4 == 1 << 2) {
    if (0) {
      tmp___5 = zval_refcount_p(free_op1.var);
      if (tmp___5 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___6 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___6 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___3 = zval_isref_p(__t->var.ptr);
                if (tmp___3) {

                } else {
                  tmp___4 = zval_refcount_p(__t->var.ptr);
                  if (tmp___4 > 2U) {
                    while (1) {
                      tmp___2 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___2 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___1 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___1;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_IS_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval **container ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_cv_BP_VAR_IS(execute_data->CVs, opline->op1.var);
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  zend_fetch_dimension_address_read((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, tmp, 1 << 2, 3);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval **container ;
  long tmp ;
  zval *tmp___0 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zend_uint tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___6 ;
  zval *tmp___7 ;
  unsigned int tmp___8 ;

  {
  opline = execute_data->opline;
  if (execute_data->fbc) {
    if ((execute_data->fbc)->common.arg_info) {
      if ((opline->extended_value & 1048575UL) <= (unsigned long )(execute_data->fbc)->common.num_args) {
        tmp___8 = (unsigned int )((int )((execute_data->fbc)->common.arg_info + ((opline->extended_value & 1048575UL) - 1UL))->pass_by_reference & 3);
      } else {
        tmp___8 = (execute_data->fbc)->common.fn_flags & 50331648U;
      }
    } else {
      tmp___8 = (execute_data->fbc)->common.fn_flags & 50331648U;
    }
    if (tmp___8) {
      container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var);
      if (1 << 4 == 1 << 2) {
        tmp = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
        if (tmp) {
          zend_error_noreturn(1, "Cannot use string offset as an array");
        } else {

        }
      } else {

      }
      tmp___0 = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
      zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, tmp___0, 1 << 2, 1);
      if (1 << 4 == 1 << 2) {
        if (0) {
          tmp___5 = zval_refcount_p(free_op1.var);
          if (tmp___5 == 1U) {
            if ((int )(free_op1.var)->type != 5) {
              goto _L;
            } else {
              tmp___6 = zend_objects_store_get_refcount(free_op1.var);
              if (tmp___6 == (zend_uint __attribute__((__visibility__("default")))  )1) {
                _L: /* CIL Label */ 
                while (1) {
                  __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
                  if (__t->var.ptr_ptr) {
                    __t->var.ptr = *(__t->var.ptr_ptr);
                    __t->var.ptr_ptr = & __t->var.ptr;
                    tmp___3 = zval_isref_p(__t->var.ptr);
                    if (tmp___3) {

                    } else {
                      tmp___4 = zval_refcount_p(__t->var.ptr);
                      if (tmp___4 > 2U) {
                        while (1) {
                          tmp___2 = zval_refcount_p(*(__t->var.ptr_ptr));
                          if (tmp___2 > 1U) {
                            zval_delref_p(*(__t->var.ptr_ptr));
                            while (1) {
                              tmp___1 = _emalloc(sizeof(zval_gc_info ));
                              new_zv = (zval *)tmp___1;
                              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                              break;
                            }
                            while (1) {
                              while (1) {
                                new_zv->value = (*(__t->var.ptr_ptr))->value;
                                new_zv->type = (*(__t->var.ptr_ptr))->type;
                                break;
                              }
                              zval_set_refcount_p(new_zv, 1U);
                              zval_unset_isref_p(new_zv);
                              break;
                            }
                            *(__t->var.ptr_ptr) = new_zv;
                            _zval_copy_ctor(new_zv);
                          } else {

                          }
                          break;
                        }
                      } else {

                      }
                    }
                  } else {

                  }
                  break;
                }
              } else {

              }
            }
          } else {

          }
        } else {

        }
      } else {

      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if (1 << 2 == 1 << 3) {
      zend_error_noreturn(1, "Cannot use [] for reading");
    } else {

    }
    container = _get_zval_ptr_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
    tmp___7 = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    zend_fetch_dimension_address_read((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, tmp___7, 1 << 2, 0);
  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_UNSET_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval **container ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  long tmp___2 ;
  zval *tmp___3 ;
  temp_variable *__t ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_uint tmp___5 ;
  zend_bool tmp___6 ;
  zend_uint tmp___7 ;
  zend_uint tmp___8 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___9 ;
  zend_free_op free_res ;
  zval **retval_ptr ;
  zval *new_zv___1 ;
  void __attribute__((__visibility__("default")))  *tmp___10 ;
  zend_uint tmp___11 ;
  zend_bool tmp___12 ;
  long tmp___13 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 4) {
    if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
      tmp___1 = zval_isref_p(*container);
      if (tmp___1) {

      } else {
        while (1) {
          tmp___0 = zval_refcount_p(*container);
          if (tmp___0 > 1U) {
            zval_delref_p(*container);
            while (1) {
              tmp = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*container)->value;
                new_zv->type = (*container)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *container = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
    } else {

    }
  } else {

  }
  if (1 << 4 == 1 << 2) {
    tmp___2 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___2) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  tmp___3 = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, tmp___3, 1 << 2, 6);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  if (1 << 4 == 1 << 2) {
    if (0) {
      tmp___8 = zval_refcount_p(free_op1.var);
      if (tmp___8 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___9 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___9 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___6 = zval_isref_p(__t->var.ptr);
                if (tmp___6) {

                } else {
                  tmp___7 = zval_refcount_p(__t->var.ptr);
                  if (tmp___7 > 2U) {
                    while (1) {
                      tmp___5 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___5 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___4 = _emalloc(sizeof(zval_gc_info ));
                          new_zv___0 = (zval *)tmp___4;
                          ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv___0->value = (*(__t->var.ptr_ptr))->value;
                            new_zv___0->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv___0, 1U);
                          zval_unset_isref_p(new_zv___0);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv___0;
                        _zval_copy_ctor(new_zv___0);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  tmp___13 = __builtin_expect((long )((unsigned int )((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr == (unsigned int )((void *)0)), 0L);
  if (tmp___13) {
    zend_error_noreturn(1, "Cannot unset string offsets");
  } else {
    retval_ptr = ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr;
    zend_pzval_unlock_func(*retval_ptr, & free_res, 1);
    if ((unsigned int )retval_ptr != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
      tmp___12 = zval_isref_p(*retval_ptr);
      if (tmp___12) {

      } else {
        while (1) {
          tmp___11 = zval_refcount_p(*retval_ptr);
          if (tmp___11 > 1U) {
            zval_delref_p(*retval_ptr);
            while (1) {
              tmp___10 = _emalloc(sizeof(zval_gc_info ));
              new_zv___1 = (zval *)tmp___10;
              ((zval_gc_info *)new_zv___1)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv___1->value = (*retval_ptr)->value;
                new_zv___1->type = (*retval_ptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv___1, 1U);
              zval_unset_isref_p(new_zv___1);
              break;
            }
            *retval_ptr = new_zv___1;
            _zval_copy_ctor(new_zv___1);
          } else {

          }
          break;
        }
      }
    } else {

    }
    zval_addref_p(*retval_ptr);
    if (free_res.var) {
      i_zval_ptr_dtor(free_res.var);
    } else {

    }
    (execute_data->opline) ++;
    return (0);
  }
}
}
static int ( __attribute__((__fastcall__)) zend_fetch_property_address_read_helper_SPEC_CV_VAR)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *container ;
  zend_free_op free_op2 ;
  zval *offset ;
  temp_variable *__t ;
  zval *retval ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_literal *tmp___0 ;
  temp_variable *__t___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  offset = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___1 = __builtin_expect((long )((int )container->type != 5), 0L);
  if (tmp___1) {
    goto _L;
  } else {
    tmp___2 = __builtin_expect((long )((unsigned int )(container->value.obj.handlers)->read_property == (unsigned int )((void *)0)), 0L);
    if (tmp___2) {
      _L: /* CIL Label */ 
      zend_error(1 << 3L, "Trying to get property of non-object");
      zval_addref_p(& executor_globals.uninitialized_zval);
      while (1) {
        __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t->var.ptr = & executor_globals.uninitialized_zval;
        __t->var.ptr_ptr = & __t->var.ptr;
        break;
      }
      if (free_op2.var) {
        i_zval_ptr_dtor(free_op2.var);
      } else {

      }
    } else {
      if (1 << 2 == 1) {
        tmp___0 = opline->op2.literal;
      } else {
        tmp___0 = (zend_literal *)((void *)0);
      }
      retval = (*((container->value.obj.handlers)->read_property))(container, offset, 0, (struct _zend_literal  const  *)tmp___0);
      zval_addref_p(retval);
      while (1) {
        __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t___0->var.ptr = retval;
        __t___0->var.ptr_ptr = & __t___0->var.ptr;
        break;
      }
      if (free_op2.var) {
        i_zval_ptr_dtor(free_op2.var);
      } else {

      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_R_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_property_address_read_helper_SPEC_CV_VAR(execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_W_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *property ;
  zval **container ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zend_literal *tmp___1 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_uint tmp___3 ;
  zend_bool tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint tmp___6 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___7 ;
  zval **retval_ptr ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___8 ;
  zend_uint tmp___9 ;
  zend_bool tmp___10 ;

  {
  opline = execute_data->opline;
  property = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if (1 << 4 == 1 << 2) {
    if (opline->extended_value & 134217728UL) {
      zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr));
      ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr = *(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr);
    } else {

    }
  } else {

  }
  container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  if (1 << 2 == 1) {
    tmp___1 = opline->op2.literal;
  } else {
    tmp___1 = (zend_literal *)((void *)0);
  }
  zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)tmp___1, 1);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  if (1 << 4 == 1 << 2) {
    if (0) {
      tmp___6 = zval_refcount_p(free_op1.var);
      if (tmp___6 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___7 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___7 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___4 = zval_isref_p(__t->var.ptr);
                if (tmp___4) {

                } else {
                  tmp___5 = zval_refcount_p(__t->var.ptr);
                  if (tmp___5 > 2U) {
                    while (1) {
                      tmp___3 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___3 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___2 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___2;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  if (opline->extended_value & 67108864UL) {
    retval_ptr = ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr;
    zval_delref_p(*retval_ptr);
    tmp___10 = zval_isref_p(*retval_ptr);
    if (tmp___10) {

    } else {
      while (1) {
        tmp___9 = zval_refcount_p(*retval_ptr);
        if (tmp___9 > 1U) {
          zval_delref_p(*retval_ptr);
          while (1) {
            tmp___8 = _emalloc(sizeof(zval_gc_info ));
            new_zv___0 = (zval *)tmp___8;
            ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv___0->value = (*retval_ptr)->value;
              new_zv___0->type = (*retval_ptr)->type;
              break;
            }
            zval_set_refcount_p(new_zv___0, 1U);
            zval_unset_isref_p(new_zv___0);
            break;
          }
          *retval_ptr = new_zv___0;
          _zval_copy_ctor(new_zv___0);
        } else {

        }
        break;
      }
      zval_set_isref_p(*retval_ptr);
    }
    zval_addref_p(*retval_ptr);
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = *(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr);
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_RW_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *property ;
  zval **container ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zend_literal *tmp___1 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_uint tmp___3 ;
  zend_bool tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint tmp___6 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___7 ;

  {
  opline = execute_data->opline;
  property = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  if (1 << 2 == 1) {
    tmp___1 = opline->op2.literal;
  } else {
    tmp___1 = (zend_literal *)((void *)0);
  }
  zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)tmp___1, 2);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  if (1 << 4 == 1 << 2) {
    if (0) {
      tmp___6 = zval_refcount_p(free_op1.var);
      if (tmp___6 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___7 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___7 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___4 = zval_isref_p(__t->var.ptr);
                if (tmp___4) {

                } else {
                  tmp___5 = zval_refcount_p(__t->var.ptr);
                  if (tmp___5 > 2U) {
                    while (1) {
                      tmp___3 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___3 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___2 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___2;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_IS_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *container ;
  zend_free_op free_op2 ;
  zval *offset ;
  temp_variable *__t ;
  zval *retval ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_literal *tmp___0 ;
  temp_variable *__t___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_cv_BP_VAR_IS(execute_data->CVs, opline->op1.var);
  offset = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___1 = __builtin_expect((long )((int )container->type != 5), 0L);
  if (tmp___1) {
    goto _L;
  } else {
    tmp___2 = __builtin_expect((long )((unsigned int )(container->value.obj.handlers)->read_property == (unsigned int )((void *)0)), 0L);
    if (tmp___2) {
      _L: /* CIL Label */ 
      zval_addref_p(& executor_globals.uninitialized_zval);
      while (1) {
        __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t->var.ptr = & executor_globals.uninitialized_zval;
        __t->var.ptr_ptr = & __t->var.ptr;
        break;
      }
      if (free_op2.var) {
        i_zval_ptr_dtor(free_op2.var);
      } else {

      }
    } else {
      if (1 << 2 == 1) {
        tmp___0 = opline->op2.literal;
      } else {
        tmp___0 = (zend_literal *)((void *)0);
      }
      retval = (*((container->value.obj.handlers)->read_property))(container, offset, 3, (struct _zend_literal  const  *)tmp___0);
      zval_addref_p(retval);
      while (1) {
        __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t___0->var.ptr = retval;
        __t___0->var.ptr_ptr = & __t___0->var.ptr;
        break;
      }
      if (free_op2.var) {
        i_zval_ptr_dtor(free_op2.var);
      } else {

      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zval *property ;
  zval **container ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zend_literal *tmp___1 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_uint tmp___3 ;
  zend_bool tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint tmp___6 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;

  {
  opline = execute_data->opline;
  if (execute_data->fbc) {
    if ((execute_data->fbc)->common.arg_info) {
      if ((opline->extended_value & 1048575UL) <= (unsigned long )(execute_data->fbc)->common.num_args) {
        tmp___9 = (unsigned int )((int )((execute_data->fbc)->common.arg_info + ((opline->extended_value & 1048575UL) - 1UL))->pass_by_reference & 3);
      } else {
        tmp___9 = (execute_data->fbc)->common.fn_flags & 50331648U;
      }
    } else {
      tmp___9 = (execute_data->fbc)->common.fn_flags & 50331648U;
    }
    if (tmp___9) {
      property = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
      container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var);
      if (1 << 4 == 1 << 2) {
        tmp___0 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
        if (tmp___0) {
          zend_error_noreturn(1, "Cannot use string offset as an object");
        } else {

        }
      } else {

      }
      if (1 << 2 == 1) {
        tmp___1 = opline->op2.literal;
      } else {
        tmp___1 = (zend_literal *)((void *)0);
      }
      zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)tmp___1, 1);
      if (free_op2.var) {
        i_zval_ptr_dtor(free_op2.var);
      } else {

      }
      if (1 << 4 == 1 << 2) {
        if (0) {
          tmp___6 = zval_refcount_p(free_op1.var);
          if (tmp___6 == 1U) {
            if ((int )(free_op1.var)->type != 5) {
              goto _L;
            } else {
              tmp___7 = zend_objects_store_get_refcount(free_op1.var);
              if (tmp___7 == (zend_uint __attribute__((__visibility__("default")))  )1) {
                _L: /* CIL Label */ 
                while (1) {
                  __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
                  if (__t->var.ptr_ptr) {
                    __t->var.ptr = *(__t->var.ptr_ptr);
                    __t->var.ptr_ptr = & __t->var.ptr;
                    tmp___4 = zval_isref_p(__t->var.ptr);
                    if (tmp___4) {

                    } else {
                      tmp___5 = zval_refcount_p(__t->var.ptr);
                      if (tmp___5 > 2U) {
                        while (1) {
                          tmp___3 = zval_refcount_p(*(__t->var.ptr_ptr));
                          if (tmp___3 > 1U) {
                            zval_delref_p(*(__t->var.ptr_ptr));
                            while (1) {
                              tmp___2 = _emalloc(sizeof(zval_gc_info ));
                              new_zv = (zval *)tmp___2;
                              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                              break;
                            }
                            while (1) {
                              while (1) {
                                new_zv->value = (*(__t->var.ptr_ptr))->value;
                                new_zv->type = (*(__t->var.ptr_ptr))->type;
                                break;
                              }
                              zval_set_refcount_p(new_zv, 1U);
                              zval_unset_isref_p(new_zv);
                              break;
                            }
                            *(__t->var.ptr_ptr) = new_zv;
                            _zval_copy_ctor(new_zv);
                          } else {

                          }
                          break;
                        }
                      } else {

                      }
                    }
                  } else {

                  }
                  break;
                }
              } else {

              }
            }
          } else {

          }
        } else {

        }
      } else {

      }
      (execute_data->opline) ++;
      return (0);
    } else {
      tmp___8 = zend_fetch_property_address_read_helper_SPEC_CV_VAR(execute_data);
      return (tmp___8);
    }
  } else {
    tmp___8 = zend_fetch_property_address_read_helper_SPEC_CV_VAR(execute_data);
    return (tmp___8);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_UNSET_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_op2 ;
  zend_free_op free_res ;
  zval **container ;
  zval *property ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  long tmp___3 ;
  zend_literal *tmp___4 ;
  temp_variable *__t ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  zend_uint tmp___6 ;
  zend_bool tmp___7 ;
  zend_uint tmp___8 ;
  zend_uint tmp___9 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___10 ;
  zval *new_zv___1 ;
  void __attribute__((__visibility__("default")))  *tmp___11 ;
  zend_uint tmp___12 ;
  zend_bool tmp___13 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data->CVs, opline->op1.var);
  property = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if (1 << 4 == 1 << 4) {
    if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
      tmp___1 = zval_isref_p(*container);
      if (tmp___1) {

      } else {
        while (1) {
          tmp___0 = zval_refcount_p(*container);
          if (tmp___0 > 1U) {
            zval_delref_p(*container);
            while (1) {
              tmp = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*container)->value;
                new_zv->type = (*container)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *container = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
    } else {

    }
  } else {

  }
  if (1 << 4 == 1 << 2) {
    tmp___3 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___3) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  if (1 << 2 == 1) {
    tmp___4 = opline->op2.literal;
  } else {
    tmp___4 = (zend_literal *)((void *)0);
  }
  zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)tmp___4, 6);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  if (1 << 4 == 1 << 2) {
    if (0) {
      tmp___9 = zval_refcount_p(free_op1.var);
      if (tmp___9 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___10 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___10 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___7 = zval_isref_p(__t->var.ptr);
                if (tmp___7) {

                } else {
                  tmp___8 = zval_refcount_p(__t->var.ptr);
                  if (tmp___8 > 2U) {
                    while (1) {
                      tmp___6 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___6 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___5 = _emalloc(sizeof(zval_gc_info ));
                          new_zv___0 = (zval *)tmp___5;
                          ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv___0->value = (*(__t->var.ptr_ptr))->value;
                            new_zv___0->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv___0, 1U);
                          zval_unset_isref_p(new_zv___0);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv___0;
                        _zval_copy_ctor(new_zv___0);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  zend_pzval_unlock_func(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr), & free_res, 1);
  if ((unsigned int )((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
    tmp___13 = zval_isref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
    if (tmp___13) {

    } else {
      while (1) {
        tmp___12 = zval_refcount_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
        if (tmp___12 > 1U) {
          zval_delref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
          while (1) {
            tmp___11 = _emalloc(sizeof(zval_gc_info ));
            new_zv___1 = (zval *)tmp___11;
            ((zval_gc_info *)new_zv___1)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv___1->value = (*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr))->value;
              new_zv___1->type = (*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr))->type;
              break;
            }
            zval_set_refcount_p(new_zv___1, 1U);
            zval_unset_isref_p(new_zv___1);
            break;
          }
          *(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr) = new_zv___1;
          _zval_copy_ctor(new_zv___1);
        } else {

        }
        break;
      }
    }
  } else {

  }
  zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
  if (free_res.var) {
    i_zval_ptr_dtor(free_res.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_OBJ_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval **object_ptr ;
  zval *property_name ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zend_literal *tmp___1 ;
  zval **tmp___2 ;

  {
  opline = execute_data->opline;
  object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var);
  property_name = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if (1 << 4 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  if (1 << 2 == 1) {
    tmp___1 = opline->op2.literal;
  } else {
    tmp___1 = (zend_literal *)((void *)0);
  }
  if (! ((int )opline->result_type & (1 << 5))) {
    tmp___2 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
  } else {
    tmp___2 = (zval **)((void *)0);
  }
  zend_assign_to_object(tmp___2, object_ptr, property_name, (int )(opline + 1)->op1_type, & (opline + 1)->op1, (temp_variable const   *)execute_data->Ts, 136, (zend_literal const   *)tmp___1);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_DIM_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **object_ptr ;
  long tmp ;
  zend_free_op free_op2 ;
  zval *property_name ;
  zval *tmp___0 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_literal *tmp___2 ;
  zval **tmp___3 ;
  zend_free_op free_op2___0 ;
  zend_free_op free_op_data1 ;
  zend_free_op free_op_data2 ;
  zval *value ;
  zval *dim ;
  zval *tmp___4 ;
  zval **variable_ptr_ptr ;
  zval *retval ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  char const   *__s ;
  int __l ;
  zval *__z ;
  char __attribute__((__visibility__("default")))  *tmp___6 ;
  temp_variable *__t ;
  temp_variable *__t___0 ;
  int tmp___7 ;
  temp_variable *__t___1 ;
  temp_variable *__t___2 ;
  long tmp___8 ;
  long tmp___9 ;

  {
  opline = execute_data->opline;
  object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  if ((int )(*object_ptr)->type == 5) {
    tmp___0 = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    property_name = tmp___0;
    if (1 << 2 == 1) {
      tmp___2 = opline->op2.literal;
    } else {
      tmp___2 = (zend_literal *)((void *)0);
    }
    if (! ((int )opline->result_type & (1 << 5))) {
      tmp___3 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
    } else {
      tmp___3 = (zval **)((void *)0);
    }
    zend_assign_to_object(tmp___3, object_ptr, property_name, (int )(opline + 1)->op1_type, & (opline + 1)->op1, (temp_variable const   *)execute_data->Ts, 147, (zend_literal const   *)tmp___2);
    if (free_op2.var) {
      i_zval_ptr_dtor(free_op2.var);
    } else {

    }
  } else {
    tmp___4 = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2___0);
    dim = tmp___4;
    zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var), object_ptr, dim, 1 << 2, 1);
    if (free_op2___0.var) {
      i_zval_ptr_dtor(free_op2___0.var);
    } else {

    }
    value = _get_zval_ptr((int )(opline + 1)->op1_type, (znode_op const   *)(& (opline + 1)->op1), (temp_variable const   *)execute_data->Ts, & free_op_data1, 0);
    variable_ptr_ptr = _get_zval_ptr_ptr_var((opline + 1)->op2.var, (temp_variable const   *)execute_data->Ts, & free_op_data2);
    tmp___9 = __builtin_expect((long )((unsigned int )variable_ptr_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___9) {
      tmp___7 = zend_assign_to_string_offset((temp_variable const   *)((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var)), (zval const   *)value, (int )(opline + 1)->op1_type);
      if (tmp___7) {
        if (! ((int )opline->result_type & (1 << 5))) {
          while (1) {
            tmp___5 = _emalloc(sizeof(zval_gc_info ));
            retval = (zval *)tmp___5;
            ((zval_gc_info *)retval)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            __s = (char const   *)((((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var))->str_offset.str)->value.str.val + ((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var))->str_offset.offset);
            __l = 1;
            __z = retval;
            __z->value.str.len = __l;
            tmp___6 = _estrndup(__s, (unsigned int )__l);
            __z->value.str.val = (char *)tmp___6;
            __z->type = (unsigned char)6;
            break;
          }
          retval->refcount__gc = 1U;
          retval->is_ref__gc = (unsigned char)0;
          while (1) {
            __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t->var.ptr = retval;
            __t->var.ptr_ptr = & __t->var.ptr;
            break;
          }
        } else {

        }
      } else {
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          while (1) {
            __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___0->var.ptr = & executor_globals.uninitialized_zval;
            __t___0->var.ptr_ptr = & __t___0->var.ptr;
            break;
          }
        } else {

        }
      }
    } else {
      tmp___8 = __builtin_expect((long )((unsigned int )*variable_ptr_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
      if (tmp___8) {
        if ((unsigned long )free_op_data1.var & 1UL) {
          _zval_dtor(value);
        } else {

        }
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          while (1) {
            __t___1 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___1->var.ptr = & executor_globals.uninitialized_zval;
            __t___1->var.ptr_ptr = & __t___1->var.ptr;
            break;
          }
        } else {

        }
      } else {
        if ((int )(opline + 1)->op1_type == 1 << 1) {
          value = zend_assign_tmp_to_variable(variable_ptr_ptr, value);
        } else {
          if ((int )(opline + 1)->op1_type == 1) {
            value = zend_assign_const_to_variable(variable_ptr_ptr, value);
          } else {
            value = zend_assign_to_variable(variable_ptr_ptr, value);
          }
        }
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(value);
          while (1) {
            __t___2 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___2->var.ptr = value;
            __t___2->var.ptr_ptr = & __t___2->var.ptr;
            break;
          }
        } else {

        }
      }
    }
    if (free_op_data2.var) {
      i_zval_ptr_dtor(free_op_data2.var);
    } else {

    }
    if ((unsigned int )free_op_data1.var != (unsigned int )((void *)0)) {
      if (((unsigned long )free_op_data1.var & 1UL) == 0UL) {
        i_zval_ptr_dtor(free_op_data1.var);
      } else {

      }
    } else {

    }
  }
  (execute_data->opline) ++;
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *value ;
  zval **variable_ptr_ptr ;
  zval *retval ;
  void __attribute__((__visibility__("default")))  *tmp ;
  char const   *__s ;
  int __l ;
  zval *__z ;
  char __attribute__((__visibility__("default")))  *tmp___0 ;
  temp_variable *__t ;
  temp_variable *__t___0 ;
  int tmp___1 ;
  temp_variable *__t___1 ;
  temp_variable *__t___2 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  opline = execute_data->opline;
  value = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  variable_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 2) {
    tmp___3 = __builtin_expect((long )((unsigned int )variable_ptr_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___3) {
      tmp___1 = zend_assign_to_string_offset((temp_variable const   *)((temp_variable *)((char *)execute_data->Ts + opline->op1.var)), (zval const   *)value, 1 << 2);
      if (tmp___1) {
        if (! ((int )opline->result_type & (1 << 5))) {
          while (1) {
            tmp = _emalloc(sizeof(zval_gc_info ));
            retval = (zval *)tmp;
            ((zval_gc_info *)retval)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            __s = (char const   *)((((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->str_offset.str)->value.str.val + ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->str_offset.offset);
            __l = 1;
            __z = retval;
            __z->value.str.len = __l;
            tmp___0 = _estrndup(__s, (unsigned int )__l);
            __z->value.str.val = (char *)tmp___0;
            __z->type = (unsigned char)6;
            break;
          }
          retval->refcount__gc = 1U;
          retval->is_ref__gc = (unsigned char)0;
          while (1) {
            __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t->var.ptr = retval;
            __t->var.ptr_ptr = & __t->var.ptr;
            break;
          }
        } else {

        }
      } else {
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          while (1) {
            __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___0->var.ptr = & executor_globals.uninitialized_zval;
            __t___0->var.ptr_ptr = & __t___0->var.ptr;
            break;
          }
        } else {

        }
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if (1 << 4 == 1 << 2) {
      tmp___2 = __builtin_expect((long )((unsigned int )*variable_ptr_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
      if (tmp___2) {
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          while (1) {
            __t___1 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___1->var.ptr = & executor_globals.uninitialized_zval;
            __t___1->var.ptr_ptr = & __t___1->var.ptr;
            break;
          }
        } else {

        }
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      if (1 << 2 == 1 << 1) {
        value = zend_assign_tmp_to_variable(variable_ptr_ptr, value);
      } else {
        if (1 << 2 == 1) {
          value = zend_assign_const_to_variable(variable_ptr_ptr, value);
        } else {
          value = zend_assign_to_variable(variable_ptr_ptr, value);
        }
      }
      if (! ((int )opline->result_type & (1 << 5))) {
        zval_addref_p(value);
        while (1) {
          __t___2 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
          __t___2->var.ptr = value;
          __t___2->var.ptr_ptr = & __t___2->var.ptr;
          break;
        }
      } else {

      }
    }
  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_REF_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval **variable_ptr_ptr ;
  zval **value_ptr_ptr ;
  long tmp ;
  int tmp___0 ;
  zend_bool tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  temp_variable *__t ;

  {
  opline = execute_data->opline;
  value_ptr_ptr = _get_zval_ptr_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if (1 << 2 == 1 << 2) {
    if (value_ptr_ptr) {
      tmp___1 = zval_isref_p(*value_ptr_ptr);
      if (tmp___1) {
        goto _L___2;
      } else {
        if (opline->extended_value == 1UL) {
          if (! ((temp_variable *)((char *)execute_data->Ts + opline->op2.var))->var.fcall_returned_reference) {
            if ((unsigned int )free_op2.var == (unsigned int )((void *)0)) {
              zval_addref_p(*value_ptr_ptr);
            } else {

            }
            zend_error(1 << 11L, "Only variables should be assigned by reference");
            tmp = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
            if (tmp) {
              if (free_op2.var) {
                i_zval_ptr_dtor(free_op2.var);
              } else {

              }
              return (0);
            } else {

            }
            tmp___0 = ZEND_ASSIGN_SPEC_CV_VAR_HANDLER(execute_data);
            return (tmp___0);
          } else {
            goto _L___2;
          }
        } else {
          goto _L___2;
        }
      }
    } else {
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
    _L___1: /* CIL Label */ 
    _L___0: /* CIL Label */ 
    _L: /* CIL Label */ 
    if (1 << 2 == 1 << 2) {
      if (opline->extended_value == (ulong )(1 << 1)) {
        zval_addref_p(*value_ptr_ptr);
      } else {

      }
    } else {

    }
  }
  if (1 << 4 == 1 << 2) {
    tmp___2 = __builtin_expect((long )((unsigned int )((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr == (unsigned int )(& ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr)), 0L);
    if (tmp___2) {
      zend_error_noreturn(1, "Cannot assign by reference to overloaded object");
    } else {

    }
  } else {

  }
  variable_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var);
  if (1 << 2 == 1 << 2) {
    tmp___3 = __builtin_expect((long )((unsigned int )value_ptr_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___3) {
      zend_error_noreturn(1, "Cannot create references to/from string offsets nor overloaded objects");
    } else {
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    if (1 << 4 == 1 << 2) {
      tmp___4 = __builtin_expect((long )((unsigned int )variable_ptr_ptr == (unsigned int )((void *)0)), 0L);
      if (tmp___4) {
        zend_error_noreturn(1, "Cannot create references to/from string offsets nor overloaded objects");
      } else {

      }
    } else {

    }
  }
  zend_assign_to_variable_reference(variable_ptr_ptr, value_ptr_ptr);
  if (1 << 2 == 1 << 2) {
    if (opline->extended_value == (ulong )(1 << 1)) {
      zval_delref_p(*variable_ptr_ptr);
    } else {

    }
  } else {

  }
  if (! ((int )opline->result_type & (1 << 5))) {
    zval_addref_p(*variable_ptr_ptr);
    while (1) {
      __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
      __t->var.ptr = *variable_ptr_ptr;
      __t->var.ptr_ptr = & __t->var.ptr;
      break;
    }
  } else {

  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_METHOD_CALL_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *function_name ;
  char *function_name_strval ;
  int function_name_strlen ;
  zend_free_op free_op2 ;
  long tmp ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  zval *object ;
  long tmp___1 ;
  zend_literal *tmp___2 ;
  zend_class_entry *tmp___3 ;
  zend_class_entry *tmp___4 ;
  char const   *tmp___5 ;
  zend_class_entry *tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  zend_function *tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  zval *this_ptr ;
  void __attribute__((__visibility__("default")))  *tmp___13 ;
  zend_bool tmp___14 ;

  {
  opline = execute_data->opline;
  zend_ptr_stack_3_push(& executor_globals.arg_types_stack, (void *)execute_data->fbc, (void *)execute_data->object, (void *)execute_data->called_scope);
  function_name = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if (1 << 2 != 1) {
    tmp = __builtin_expect((long )((int )function_name->type != 6), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Method name must be a string");
    } else {

    }
  } else {

  }
  function_name_strval = function_name->value.str.val;
  function_name_strlen = function_name->value.str.len;
  execute_data->object = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  tmp___11 = __builtin_expect((long )((unsigned int )execute_data->object != (unsigned int )((void *)0)), 1L);
  if (tmp___11) {
    tmp___12 = __builtin_expect((long )((int )(execute_data->object)->type == 5), 1L);
    if (tmp___12) {
      tmp___0 = zend_get_class_entry((zval const   *)execute_data->object);
      execute_data->called_scope = (zend_class_entry *)tmp___0;
      if (1 << 2 != 1) {
        goto _L;
      } else {
        if ((unsigned int )*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) == (unsigned int )execute_data->called_scope) {
          tmp___10 = (zend_function *)*((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U));
        } else {
          tmp___10 = (zend_function *)((void *)0);
        }
        execute_data->fbc = tmp___10;
        if ((unsigned int )tmp___10 == (unsigned int )((void *)0)) {
          _L: /* CIL Label */ 
          object = execute_data->object;
          tmp___1 = __builtin_expect((long )((unsigned int )((execute_data->object)->value.obj.handlers)->get_method == (unsigned int )((void *)0)), 0L);
          if (tmp___1) {
            zend_error_noreturn(1, "Object does not support method calls");
          } else {

          }
          if (1 << 2 == 1) {
            tmp___2 = opline->op2.literal + 1;
          } else {
            tmp___2 = (zend_literal *)((void *)0);
          }
          execute_data->fbc = (*(((execute_data->object)->value.obj.handlers)->get_method))(& execute_data->object, function_name_strval, function_name_strlen, (struct _zend_literal  const  *)tmp___2);
          tmp___7 = __builtin_expect((long )((unsigned int )execute_data->fbc == (unsigned int )((void *)0)), 0L);
          if (tmp___7) {
            if (execute_data->object) {
              if ((int )(execute_data->object)->type == 5) {
                if ((unsigned int )((execute_data->object)->value.obj.handlers)->get_class_entry != (unsigned int )((void *)0)) {
                  tmp___6 = (*(((execute_data->object)->value.obj.handlers)->get_class_entry))((zval const   *)execute_data->object);
                  if (tmp___6) {
                    tmp___4 = (*(((execute_data->object)->value.obj.handlers)->get_class_entry))((zval const   *)execute_data->object);
                    tmp___5 = tmp___4->name;
                  } else {
                    tmp___5 = "";
                  }
                } else {
                  tmp___5 = "";
                }
              } else {
                tmp___5 = "";
              }
            } else {
              tmp___5 = "";
            }
            zend_error_noreturn(1, "Call to undefined method %s::%s()", tmp___5, function_name_strval);
          } else {

          }
          if (1 << 2 == 1) {
            tmp___8 = __builtin_expect((long )(((execute_data->fbc)->common.fn_flags & 6291456U) == 0U), 1L);
            if (tmp___8) {
              tmp___9 = __builtin_expect((long )((unsigned int )execute_data->object == (unsigned int )object), 1L);
              if (tmp___9) {
                while (1) {
                  *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)execute_data->called_scope;
                  *((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U)) = (void *)execute_data->fbc;
                  break;
                }
              } else {

              }
            } else {

            }
          } else {

          }
        } else {

        }
      }
    } else {
      zend_error_noreturn(1, "Call to a member function %s() on a non-object", function_name_strval);
    }
  } else {
    zend_error_noreturn(1, "Call to a member function %s() on a non-object", function_name_strval);
  }
  if (((execute_data->fbc)->common.fn_flags & 1U) != 0U) {
    execute_data->object = (zval *)((void *)0);
  } else {
    tmp___14 = zval_isref_p(execute_data->object);
    if (tmp___14) {
      while (1) {
        tmp___13 = _emalloc(sizeof(zval_gc_info ));
        this_ptr = (zval *)tmp___13;
        ((zval_gc_info *)this_ptr)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      while (1) {
        while (1) {
          this_ptr->value = (execute_data->object)->value;
          this_ptr->type = (execute_data->object)->type;
          break;
        }
        zval_set_refcount_p(this_ptr, 1U);
        zval_unset_isref_p(this_ptr);
        break;
      }
      _zval_copy_ctor(this_ptr);
      execute_data->object = this_ptr;
    } else {
      zval_addref_p(execute_data->object);
    }
  }
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_CASE_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  if (1 << 4 == 1 << 2) {
    zval_addref_p(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr);
  } else {

  }
  tmp = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  is_equal_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  if (free_op2.var) {
    i_zval_ptr_dtor(free_op2.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *expr_ptr ;
  zval **expr_ptr_ptr ;
  zval **tmp ;
  long tmp___0 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zval *new_expr ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zval *new_expr___0 ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  zend_bool tmp___6 ;
  zend_free_op free_op2 ;
  zval *offset ;
  zval *tmp___7 ;
  ulong hval ;
  long tmp___8 ;
  register char const   *tmp___9 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___10 ;

  {
  opline = execute_data->opline;
  if (1 << 4 == 1 << 2) {
    goto _L___1;
  } else {
    if (1 << 4 == 1 << 4) {
      _L___1: /* CIL Label */ 
      if (opline->extended_value) {
        tmp = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var);
        expr_ptr_ptr = tmp;
        if (1 << 4 == 1 << 2) {
          tmp___0 = __builtin_expect((long )((unsigned int )expr_ptr_ptr == (unsigned int )((void *)0)), 0L);
          if (tmp___0) {
            zend_error_noreturn(1, "Cannot create references to/from string offsets");
          } else {

          }
        } else {

        }
        tmp___3 = zval_isref_p(*expr_ptr_ptr);
        if (tmp___3) {

        } else {
          while (1) {
            tmp___2 = zval_refcount_p(*expr_ptr_ptr);
            if (tmp___2 > 1U) {
              zval_delref_p(*expr_ptr_ptr);
              while (1) {
                tmp___1 = _emalloc(sizeof(zval_gc_info ));
                new_zv = (zval *)tmp___1;
                ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv->value = (*expr_ptr_ptr)->value;
                  new_zv->type = (*expr_ptr_ptr)->type;
                  break;
                }
                zval_set_refcount_p(new_zv, 1U);
                zval_unset_isref_p(new_zv);
                break;
              }
              *expr_ptr_ptr = new_zv;
              _zval_copy_ctor(new_zv);
            } else {

            }
            break;
          }
          zval_set_isref_p(*expr_ptr_ptr);
        }
        expr_ptr = *expr_ptr_ptr;
        zval_addref_p(expr_ptr);
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      expr_ptr = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
      if (1 << 4 == 1) {
        goto _L;
      } else {
        tmp___6 = zval_isref_p(expr_ptr);
        if (tmp___6) {
          _L: /* CIL Label */ 
          while (1) {
            tmp___5 = _emalloc(sizeof(zval_gc_info ));
            new_expr___0 = (zval *)tmp___5;
            ((zval_gc_info *)new_expr___0)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_expr___0->value = expr_ptr->value;
              new_expr___0->type = expr_ptr->type;
              break;
            }
            zval_set_refcount_p(new_expr___0, 1U);
            zval_unset_isref_p(new_expr___0);
            break;
          }
          expr_ptr = new_expr___0;
          _zval_copy_ctor(expr_ptr);
        } else {
          zval_addref_p(expr_ptr);
        }
      }
    }
  }
  if (1 << 2 != 1 << 3) {
    tmp___7 = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
    offset = tmp___7;
    switch ((int )offset->type) {
    case 2: 
    tmp___8 = zend_dval_to_lval(offset->value.dval);
    hval = (unsigned long )tmp___8;
    goto num_index;
    case 1: 
    case 3: 
    hval = (unsigned long )offset->value.lval;
    num_index: 
    _zend_hash_index_update_or_next_insert(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, hval, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    case 6: 
    if (1 << 2 == 1) {
      hval = ((zend_literal *)offset)->hash_value;
    } else {
      while (1) {
        tmp___9 = (char const   *)offset->value.str.val;
        if ((int const   )*tmp___9 == 45) {
          tmp___9 ++;
        } else {

        }
        if ((int const   )*tmp___9 >= 48) {
          if ((int const   )*tmp___9 <= 57) {
            end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
            if ((int const   )*end != 0) {
              break;
            } else {
              if ((int const   )*tmp___9 == 48) {
                if (offset->value.str.len + 1 > 2) {
                  break;
                } else {
                  goto _L___2;
                }
              } else {
                _L___2: /* CIL Label */ 
                if (end - tmp___9 > 10) {
                  break;
                } else {
                  if (end - tmp___9 == 10) {
                    if ((int const   )*tmp___9 > 50) {
                      break;
                    } else {

                    }
                  } else {

                  }
                }
              }
            }
            hval = (unsigned long )((int const   )*tmp___9 - 48);
            while (1) {
              tmp___9 ++;
              if ((unsigned int )tmp___9 != (unsigned int )end) {
                if ((int const   )*tmp___9 >= 48) {
                  if ((int const   )*tmp___9 <= 57) {

                  } else {
                    break;
                  }
                } else {
                  break;
                }
              } else {
                break;
              }
              hval = hval * 10UL + (ulong )((int const   )*tmp___9 - 48);
            }
            if ((unsigned int )tmp___9 == (unsigned int )end) {
              if ((int )*(offset->value.str.val) == 45) {
                if (hval - 1UL > 2147483647UL) {
                  break;
                } else {

                }
                hval = (unsigned long )(- ((long )hval));
              } else {
                if (hval > 2147483647UL) {
                  break;
                } else {

                }
              }
              goto num_index;
            } else {

            }
          } else {

          }
        } else {

        }
        break;
      }
      if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
        if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
          hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
        } else {
          tmp___10 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___10;
        }
      } else {
        tmp___10 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
        hval = (unsigned long )tmp___10;
      }
    }
    _zend_hash_quick_add_or_update(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    case 0: 
    _zend_hash_add_or_update(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, "", sizeof(""), (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    default: 
    zend_error(1 << 1L, "Illegal offset type");
    i_zval_ptr_dtor(expr_ptr);
    break;
    }
    if (free_op2.var) {
      i_zval_ptr_dtor(free_op2.var);
    } else {

    }
  } else {
    _zend_hash_index_update_or_next_insert(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, 0UL, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1 << 2);
  }
  if (1 << 4 == 1 << 2) {
    goto _L___3;
  } else {
    if (1 << 4 == 1 << 4) {
      _L___3: /* CIL Label */ 
      if (opline->extended_value) {

      } else {

      }
    } else {

    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_ARRAY_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  int tmp ;

  {
  opline = execute_data->opline;
  _array_init(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, 0U);
  if (1 << 4 == 1 << 3) {
    (execute_data->opline) ++;
    return (0);
  } else {
    tmp = ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_VAR_HANDLER(execute_data);
    return (tmp);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_UNSET_VAR_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval tmp ;
  zval *varname ;
  HashTable *target_symbol_table ;
  zend_compiled_variable *cv ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_literal *tmp___1 ;
  ulong hash_value ;
  ulong tmp___2 ;

  {
  opline = execute_data->opline;
  if (1 << 4 == 1 << 4) {
    if (1 << 2 == 1 << 3) {
      if (opline->extended_value & 8388608UL) {
        if (executor_globals.active_symbol_table) {
          cv = (executor_globals.active_op_array)->vars + opline->op1.var;
          zend_delete_variable(execute_data->prev_execute_data, executor_globals.active_symbol_table, cv->name, cv->name_len + 1, cv->hash_value);
          *(execute_data->CVs + opline->op1.var) = (zval **)((void *)0);
        } else {
          if (*(execute_data->CVs + opline->op1.var)) {
            i_zval_ptr_dtor(*(*(execute_data->CVs + opline->op1.var)));
            *(execute_data->CVs + opline->op1.var) = (zval **)((void *)0);
          } else {

          }
        }
        (execute_data->opline) ++;
        return (0);
      } else {

      }
    } else {

    }
  } else {

  }
  varname = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  if (1 << 4 != 1) {
    if ((int )varname->type != 6) {
      while (1) {
        tmp.value = varname->value;
        tmp.type = varname->type;
        break;
      }
      _zval_copy_ctor(& tmp);
      if ((int )tmp.type != 6) {
        _convert_to_string(& tmp);
      } else {

      }
      varname = & tmp;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if (1 << 4 == 1 << 2) {
      zval_addref_p(varname);
    } else {
      if (1 << 4 == 1 << 4) {
        zval_addref_p(varname);
      } else {

      }
    }
  }
  if (1 << 2 != 1 << 3) {
    if (1 << 2 == 1) {
      if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
        ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
      } else {
        tmp___0 = zend_fetch_class_by_name((char const   *)(opline->op2.zv)->value.str.val, (unsigned int )(opline->op2.zv)->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), 0);
        ce = (zend_class_entry *)tmp___0;
        while (1) {
          *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
          break;
        }
      }
    } else {
      ce = ((temp_variable *)((char *)execute_data->Ts + opline->op2.var))->class_entry;
    }
    if (1 << 4 == 1) {
      tmp___1 = opline->op1.literal;
    } else {
      tmp___1 = (zend_literal *)((void *)0);
    }
    zend_std_unset_static_property(ce, (char const   *)varname->value.str.val, varname->value.str.len, (struct _zend_literal  const  *)tmp___1);
  } else {
    tmp___2 = zend_inline_hash_func((char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1));
    hash_value = tmp___2;
    target_symbol_table = zend_get_target_symbol_table((int )(opline->extended_value & 1879048192UL));
    zend_delete_variable(execute_data, target_symbol_table, (char const   *)varname->value.str.val, varname->value.str.len + 1, hash_value);
  }
  if (1 << 4 != 1) {
    if ((unsigned int )varname == (unsigned int )(& tmp)) {
      _zval_dtor(& tmp);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if (1 << 4 == 1 << 2) {
      i_zval_ptr_dtor(varname);
    } else {
      if (1 << 4 == 1 << 4) {
        i_zval_ptr_dtor(varname);
      } else {

      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_UNSET_DIM_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval **container ;
  zval *offset ;
  ulong hval ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  HashTable *ht ;
  long tmp___2 ;
  register char const   *tmp___3 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___4 ;
  long tmp___5 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 4) {
    if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
      tmp___1 = zval_isref_p(*container);
      if (tmp___1) {

      } else {
        while (1) {
          tmp___0 = zval_refcount_p(*container);
          if (tmp___0 > 1U) {
            zval_delref_p(*container);
            while (1) {
              tmp = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*container)->value;
                new_zv->type = (*container)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *container = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
    } else {

    }
  } else {

  }
  offset = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if (1 << 4 != 1 << 2) {
    goto _L___0;
  } else {
    if (container) {
      _L___0: /* CIL Label */ 
      switch ((int )(*container)->type) {
      case 4: 
      ht = (*container)->value.ht;
      switch ((int )offset->type) {
      case 2: 
      tmp___2 = zend_dval_to_lval(offset->value.dval);
      hval = (unsigned long )tmp___2;
      goto num_index_dim;
      case 7: 
      case 3: 
      case 1: 
      hval = (unsigned long )offset->value.lval;
      zend_hash_del_key_or_index(ht, (char const   *)((void *)0), 0U, hval, 1);
      break;
      case 6: 
      if (1 << 2 == 1 << 4) {
        zval_addref_p(offset);
      } else {
        if (1 << 2 == 1 << 2) {
          zval_addref_p(offset);
        } else {

        }
      }
      if (1 << 2 == 1) {
        hval = ((zend_literal *)offset)->hash_value;
      } else {
        while (1) {
          tmp___3 = (char const   *)offset->value.str.val;
          if ((int const   )*tmp___3 == 45) {
            tmp___3 ++;
          } else {

          }
          if ((int const   )*tmp___3 >= 48) {
            if ((int const   )*tmp___3 <= 57) {
              end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
              if ((int const   )*end != 0) {
                break;
              } else {
                if ((int const   )*tmp___3 == 48) {
                  if (offset->value.str.len + 1 > 2) {
                    break;
                  } else {
                    goto _L;
                  }
                } else {
                  _L: /* CIL Label */ 
                  if (end - tmp___3 > 10) {
                    break;
                  } else {
                    if (end - tmp___3 == 10) {
                      if ((int const   )*tmp___3 > 50) {
                        break;
                      } else {

                      }
                    } else {

                    }
                  }
                }
              }
              hval = (unsigned long )((int const   )*tmp___3 - 48);
              while (1) {
                tmp___3 ++;
                if ((unsigned int )tmp___3 != (unsigned int )end) {
                  if ((int const   )*tmp___3 >= 48) {
                    if ((int const   )*tmp___3 <= 57) {

                    } else {
                      break;
                    }
                  } else {
                    break;
                  }
                } else {
                  break;
                }
                hval = hval * 10UL + (ulong )((int const   )*tmp___3 - 48);
              }
              if ((unsigned int )tmp___3 == (unsigned int )end) {
                if ((int )*(offset->value.str.val) == 45) {
                  if (hval - 1UL > 2147483647UL) {
                    break;
                  } else {

                  }
                  hval = (unsigned long )(- ((long )hval));
                } else {
                  if (hval > 2147483647UL) {
                    break;
                  } else {

                  }
                }
                goto num_index_dim;
              } else {

              }
            } else {

            }
          } else {

          }
          break;
        }
        if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
          if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
            hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
          } else {
            tmp___4 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
            hval = (unsigned long )tmp___4;
          }
        } else {
          tmp___4 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___4;
        }
      }
      if ((unsigned int )ht == (unsigned int )(& executor_globals.symbol_table)) {
        zend_delete_global_variable_ex((char const   *)offset->value.str.val, offset->value.str.len, hval);
      } else {
        zend_hash_del_key_or_index(ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, 2);
      }
      if (1 << 2 == 1 << 4) {
        i_zval_ptr_dtor(offset);
      } else {
        if (1 << 2 == 1 << 2) {
          i_zval_ptr_dtor(offset);
        } else {

        }
      }
      break;
      num_index_dim: 
      zend_hash_del_key_or_index(ht, (char const   *)((void *)0), 0U, hval, 1);
      if (1 << 2 == 1 << 4) {
        i_zval_ptr_dtor(offset);
      } else {
        if (1 << 2 == 1 << 2) {
          i_zval_ptr_dtor(offset);
        } else {

        }
      }
      break;
      case 0: 
      zend_hash_del_key_or_index(ht, "", sizeof(""), 0UL, 0);
      break;
      default: 
      zend_error(1 << 1L, "Illegal offset type in unset");
      break;
      }
      if (free_op2.var) {
        i_zval_ptr_dtor(free_op2.var);
      } else {

      }
      break;
      case 5: 
      tmp___5 = __builtin_expect((long )((unsigned int )((*container)->value.obj.handlers)->unset_dimension == (unsigned int )((void *)0)), 0L);
      if (tmp___5) {
        zend_error_noreturn(1, "Cannot use object as array");
      } else {

      }
      (*(((*container)->value.obj.handlers)->unset_dimension))(*container, offset);
      if (free_op2.var) {
        i_zval_ptr_dtor(free_op2.var);
      } else {

      }
      break;
      case 6: 
      zend_error_noreturn(1, "Cannot unset string offsets");
      return (0);
      default: ;
      if (free_op2.var) {
        i_zval_ptr_dtor(free_op2.var);
      } else {

      }
      break;
      }
    } else {
      if (free_op2.var) {
        i_zval_ptr_dtor(free_op2.var);
      } else {

      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_UNSET_OBJ_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval **container ;
  zval *offset ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_literal *tmp___3 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data->CVs, opline->op1.var);
  offset = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if (1 << 4 != 1 << 2) {
    goto _L;
  } else {
    if (container) {
      _L: /* CIL Label */ 
      if (1 << 4 == 1 << 4) {
        if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
          tmp___1 = zval_isref_p(*container);
          if (tmp___1) {

          } else {
            while (1) {
              tmp___0 = zval_refcount_p(*container);
              if (tmp___0 > 1U) {
                zval_delref_p(*container);
                while (1) {
                  tmp = _emalloc(sizeof(zval_gc_info ));
                  new_zv = (zval *)tmp;
                  ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                  break;
                }
                while (1) {
                  while (1) {
                    new_zv->value = (*container)->value;
                    new_zv->type = (*container)->type;
                    break;
                  }
                  zval_set_refcount_p(new_zv, 1U);
                  zval_unset_isref_p(new_zv);
                  break;
                }
                *container = new_zv;
                _zval_copy_ctor(new_zv);
              } else {

              }
              break;
            }
          }
        } else {

        }
      } else {

      }
      if ((int )(*container)->type == 5) {
        if (((*container)->value.obj.handlers)->unset_property) {
          if (1 << 2 == 1) {
            tmp___3 = opline->op2.literal;
          } else {
            tmp___3 = (zend_literal *)((void *)0);
          }
          (*(((*container)->value.obj.handlers)->unset_property))(*container, offset, (struct _zend_literal  const  *)tmp___3);
        } else {
          zend_error(1 << 3L, "Trying to unset property of non-object");
        }
        if (free_op2.var) {
          i_zval_ptr_dtor(free_op2.var);
        } else {

        }
      } else {
        if (free_op2.var) {
          i_zval_ptr_dtor(free_op2.var);
        } else {

        }
      }
    } else {
      if (free_op2.var) {
        i_zval_ptr_dtor(free_op2.var);
      } else {

      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ISSET_ISEMPTY_VAR_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **value ;
  zend_bool isset ;
  zend_compiled_variable *cv ;
  int __attribute__((__visibility__("default")))  tmp ;
  HashTable *target_symbol_table ;
  zval tmp___0 ;
  zval *varname ;
  zval *tmp___1 ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_literal *tmp___3 ;
  zval __attribute__((__visibility__("default")))  **tmp___4 ;
  int __attribute__((__visibility__("default")))  tmp___5 ;
  zval *__z ;
  zval *__z___0 ;
  zval *__z___1 ;
  zval *__z___2 ;
  int tmp___6 ;

  {
  opline = execute_data->opline;
  isset = (zend_bool )1;
  if (1 << 4 == 1 << 4) {
    if (1 << 2 == 1 << 3) {
      if (opline->extended_value & 8388608UL) {
        if (*(execute_data->CVs + opline->op1.var)) {
          value = *(execute_data->CVs + opline->op1.var);
        } else {
          if (executor_globals.active_symbol_table) {
            cv = (executor_globals.active_op_array)->vars + opline->op1.var;
            tmp = zend_hash_quick_find((HashTable const   *)executor_globals.active_symbol_table, cv->name, (unsigned int )(cv->name_len + 1), cv->hash_value, (void **)(& value));
            if (tmp == (int __attribute__((__visibility__("default")))  )-1) {
              isset = (unsigned char)0;
            } else {

            }
          } else {
            isset = (unsigned char)0;
          }
        }
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    _L: /* CIL Label */ 
    tmp___1 = _get_zval_ptr_cv_BP_VAR_IS(execute_data->CVs, opline->op1.var);
    varname = tmp___1;
    if (1 << 4 != 1) {
      if ((int )varname->type != 6) {
        while (1) {
          tmp___0.value = varname->value;
          tmp___0.type = varname->type;
          break;
        }
        _zval_copy_ctor(& tmp___0);
        if ((int )tmp___0.type != 6) {
          _convert_to_string(& tmp___0);
        } else {

        }
        varname = & tmp___0;
      } else {

      }
    } else {

    }
    if (1 << 2 != 1 << 3) {
      if (1 << 2 == 1) {
        if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
          ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
        } else {
          tmp___2 = zend_fetch_class_by_name((char const   *)(opline->op2.zv)->value.str.val, (unsigned int )(opline->op2.zv)->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), 0);
          ce = (zend_class_entry *)tmp___2;
          while (1) {
            *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
            break;
          }
        }
      } else {
        ce = ((temp_variable *)((char *)execute_data->Ts + opline->op2.var))->class_entry;
      }
      if (1 << 4 == 1) {
        tmp___3 = opline->op1.literal;
      } else {
        tmp___3 = (zend_literal *)((void *)0);
      }
      tmp___4 = zend_std_get_static_property(ce, (char const   *)varname->value.str.val, varname->value.str.len, (unsigned char)1, (struct _zend_literal  const  *)tmp___3);
      value = (zval **)tmp___4;
      if (! value) {
        isset = (unsigned char)0;
      } else {

      }
    } else {
      target_symbol_table = zend_get_target_symbol_table((int )(opline->extended_value & 1879048192UL));
      tmp___5 = zend_hash_find((HashTable const   *)target_symbol_table, (char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1), (void **)(& value));
      if (tmp___5 == (int __attribute__((__visibility__("default")))  )-1) {
        isset = (unsigned char)0;
      } else {

      }
    }
    if (1 << 4 != 1) {
      if ((unsigned int )varname == (unsigned int )(& tmp___0)) {
        _zval_dtor(& tmp___0);
      } else {

      }
    } else {

    }
  }
  if (opline->extended_value & 33554432UL) {
    if (isset) {
      if ((int )(*value)->type != 0) {
        while (1) {
          __z = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
          __z->value.lval = 1L;
          __z->type = (unsigned char)3;
          break;
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      while (1) {
        __z___0 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
        __z___0->value.lval = 0L;
        __z___0->type = (unsigned char)3;
        break;
      }
    }
  } else {
    if (! isset) {
      goto _L___2;
    } else {
      tmp___6 = i_zend_is_true(*value);
      if (tmp___6) {
        while (1) {
          __z___2 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
          __z___2->value.lval = 0L;
          __z___2->type = (unsigned char)3;
          break;
        }
      } else {
        _L___2: /* CIL Label */ 
        while (1) {
          __z___1 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
          __z___1->value.lval = 1L;
          __z___1->type = (unsigned char)3;
          break;
        }
      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_VAR)(int prop_dim , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval **container ;
  zval **value ;
  int result ;
  ulong hval ;
  zval *offset ;
  HashTable *ht ;
  int isset ;
  long tmp ;
  int __attribute__((__visibility__("default")))  tmp___0 ;
  register char const   *tmp___1 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___2 ;
  int __attribute__((__visibility__("default")))  tmp___3 ;
  int __attribute__((__visibility__("default")))  tmp___4 ;
  int tmp___5 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;
  zend_literal *tmp___7 ;
  zval tmp___8 ;

  {
  opline = execute_data->opline;
  value = (zval **)((void *)0);
  result = 0;
  container = _get_zval_ptr_ptr_cv_BP_VAR_IS(execute_data->CVs, opline->op1.var);
  offset = _get_zval_ptr_var(opline->op2.var, (temp_variable const   *)execute_data->Ts, & free_op2);
  if ((int )(*container)->type == 4) {
    if (! prop_dim) {
      isset = 0;
      ht = (*container)->value.ht;
      switch ((int )offset->type) {
      case 2: 
      tmp = zend_dval_to_lval(offset->value.dval);
      hval = (unsigned long )tmp;
      goto num_index_prop;
      case 7: 
      case 3: 
      case 1: 
      hval = (unsigned long )offset->value.lval;
      num_index_prop: 
      tmp___0 = zend_hash_index_find((HashTable const   *)ht, hval, (void **)(& value));
      if (tmp___0 == (int __attribute__((__visibility__("default")))  )0) {
        isset = 1;
      } else {

      }
      break;
      case 6: 
      if (1 << 2 == 1) {
        hval = ((zend_literal *)offset)->hash_value;
      } else {
        if (! prop_dim) {
          while (1) {
            tmp___1 = (char const   *)offset->value.str.val;
            if ((int const   )*tmp___1 == 45) {
              tmp___1 ++;
            } else {

            }
            if ((int const   )*tmp___1 >= 48) {
              if ((int const   )*tmp___1 <= 57) {
                end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
                if ((int const   )*end != 0) {
                  break;
                } else {
                  if ((int const   )*tmp___1 == 48) {
                    if (offset->value.str.len + 1 > 2) {
                      break;
                    } else {
                      goto _L;
                    }
                  } else {
                    _L: /* CIL Label */ 
                    if (end - tmp___1 > 10) {
                      break;
                    } else {
                      if (end - tmp___1 == 10) {
                        if ((int const   )*tmp___1 > 50) {
                          break;
                        } else {

                        }
                      } else {

                      }
                    }
                  }
                }
                hval = (unsigned long )((int const   )*tmp___1 - 48);
                while (1) {
                  tmp___1 ++;
                  if ((unsigned int )tmp___1 != (unsigned int )end) {
                    if ((int const   )*tmp___1 >= 48) {
                      if ((int const   )*tmp___1 <= 57) {

                      } else {
                        break;
                      }
                    } else {
                      break;
                    }
                  } else {
                    break;
                  }
                  hval = hval * 10UL + (ulong )((int const   )*tmp___1 - 48);
                }
                if ((unsigned int )tmp___1 == (unsigned int )end) {
                  if ((int )*(offset->value.str.val) == 45) {
                    if (hval - 1UL > 2147483647UL) {
                      break;
                    } else {

                    }
                    hval = (unsigned long )(- ((long )hval));
                  } else {
                    if (hval > 2147483647UL) {
                      break;
                    } else {

                    }
                  }
                  goto num_index_prop;
                } else {

                }
              } else {

              }
            } else {

            }
            break;
          }
        } else {

        }
        if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
          if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
            hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
          } else {
            tmp___2 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
            hval = (unsigned long )tmp___2;
          }
        } else {
          tmp___2 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___2;
        }
      }
      tmp___3 = zend_hash_quick_find((HashTable const   *)ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, (void **)(& value));
      if (tmp___3 == (int __attribute__((__visibility__("default")))  )0) {
        isset = 1;
      } else {

      }
      break;
      case 0: 
      tmp___4 = zend_hash_find((HashTable const   *)ht, "", sizeof(""), (void **)(& value));
      if (tmp___4 == (int __attribute__((__visibility__("default")))  )0) {
        isset = 1;
      } else {

      }
      break;
      default: 
      zend_error(1 << 1L, "Illegal offset type in isset or empty");
      break;
      }
      if (opline->extended_value & 33554432UL) {
        if (isset) {
          if ((int )(*value)->type == 0) {
            result = 0;
          } else {
            result = isset;
          }
        } else {
          result = isset;
        }
      } else {
        if (! isset) {
          result = 0;
        } else {
          tmp___5 = i_zend_is_true(*value);
          if (tmp___5) {
            result = 1;
          } else {
            result = 0;
          }
        }
      }
      if (free_op2.var) {
        i_zval_ptr_dtor(free_op2.var);
      } else {

      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    if ((int )(*container)->type == 5) {
      if (prop_dim) {
        if (((*container)->value.obj.handlers)->has_property) {
          if (1 << 2 == 1) {
            tmp___7 = opline->op2.literal;
          } else {
            tmp___7 = (zend_literal *)((void *)0);
          }
          result = (*(((*container)->value.obj.handlers)->has_property))(*container, offset, (opline->extended_value & 16777216UL) != 0UL, (struct _zend_literal  const  *)tmp___7);
        } else {
          zend_error(1 << 3L, "Trying to check property of non-object");
          result = 0;
        }
      } else {
        if (((*container)->value.obj.handlers)->has_dimension) {
          result = (*(((*container)->value.obj.handlers)->has_dimension))(*container, offset, (opline->extended_value & 16777216UL) != 0UL);
        } else {
          zend_error(1 << 3L, "Trying to check element of non-array");
          result = 0;
        }
      }
      if (free_op2.var) {
        i_zval_ptr_dtor(free_op2.var);
      } else {

      }
    } else {
      if ((int )(*container)->type == 6) {
        if (! prop_dim) {
          if ((int )offset->type != 1) {
            while (1) {
              tmp___8.value = offset->value;
              tmp___8.type = offset->type;
              break;
            }
            _zval_copy_ctor(& tmp___8);
            convert_to_long(& tmp___8);
            offset = & tmp___8;
          } else {

          }
          if ((int )offset->type == 1) {
            if (opline->extended_value & 33554432UL) {
              if (offset->value.lval >= 0L) {
                if (offset->value.lval < (long )(*container)->value.str.len) {
                  result = 1;
                } else {

                }
              } else {

              }
            } else {
              if (offset->value.lval >= 0L) {
                if (offset->value.lval < (long )(*container)->value.str.len) {
                  if ((int )*((*container)->value.str.val + offset->value.lval) != 48) {
                    result = 1;
                  } else {

                  }
                } else {

                }
              } else {

              }
            }
          } else {

          }
          if (free_op2.var) {
            i_zval_ptr_dtor(free_op2.var);
          } else {

          }
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        if (free_op2.var) {
          i_zval_ptr_dtor(free_op2.var);
        } else {

        }
      }
    }
  }
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.type = (unsigned char)3;
  if (opline->extended_value & 33554432UL) {
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.lval = (long )result;
  } else {
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.lval = (long )(! result);
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_VAR(0, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_VAR_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_VAR(1, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) zend_binary_assign_op_obj_helper_SPEC_CV_UNUSED)(int (*binary_op)(zval *result , zval *op1 , zval *op2 ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op_data1 ;
  zval **object_ptr ;
  zval **tmp ;
  zval *object ;
  zval *property ;
  zval *value ;
  zval *tmp___0 ;
  int have_get_ptr ;
  long tmp___1 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zval **zptr ;
  zend_literal *tmp___3 ;
  zval **tmp___4 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  zend_uint tmp___6 ;
  zend_bool tmp___7 ;
  zval *z ;
  zend_literal *tmp___8 ;
  zval *value___0 ;
  zval *tmp___9 ;
  zend_uint tmp___10 ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___11 ;
  zend_uint tmp___12 ;
  zend_bool tmp___13 ;
  zend_literal *tmp___14 ;
  long tmp___15 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var);
  object_ptr = tmp;
  property = (zval *)((void *)0);
  tmp___0 = _get_zval_ptr((int )(opline + 1)->op1_type, (znode_op const   *)(& (opline + 1)->op1), (temp_variable const   *)execute_data->Ts, & free_op_data1, 0);
  value = tmp___0;
  have_get_ptr = 0;
  if (1 << 4 == 1 << 2) {
    tmp___1 = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___1) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  make_real_object(object_ptr);
  object = *object_ptr;
  tmp___15 = __builtin_expect((long )((int )object->type != 5), 0L);
  if (tmp___15) {
    zend_error(1 << 1L, "Attempt to assign property of non-object");
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = & executor_globals.uninitialized_zval;
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
    } else {

    }
  } else {
    if (opline->extended_value == 136UL) {
      if ((object->value.obj.handlers)->get_property_ptr_ptr) {
        if (1 << 3 == 1) {
          tmp___3 = opline->op2.literal;
        } else {
          tmp___3 = (zend_literal *)((void *)0);
        }
        tmp___4 = (*((object->value.obj.handlers)->get_property_ptr_ptr))(object, property, (struct _zend_literal  const  *)tmp___3);
        zptr = tmp___4;
        if ((unsigned int )zptr != (unsigned int )((void *)0)) {
          tmp___7 = zval_isref_p(*zptr);
          if (tmp___7) {

          } else {
            while (1) {
              tmp___6 = zval_refcount_p(*zptr);
              if (tmp___6 > 1U) {
                zval_delref_p(*zptr);
                while (1) {
                  tmp___5 = _emalloc(sizeof(zval_gc_info ));
                  new_zv = (zval *)tmp___5;
                  ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                  break;
                }
                while (1) {
                  while (1) {
                    new_zv->value = (*zptr)->value;
                    new_zv->type = (*zptr)->type;
                    break;
                  }
                  zval_set_refcount_p(new_zv, 1U);
                  zval_unset_isref_p(new_zv);
                  break;
                }
                *zptr = new_zv;
                _zval_copy_ctor(new_zv);
              } else {

              }
              break;
            }
          }
          have_get_ptr = 1;
          (*binary_op)(*zptr, *zptr, value);
          if (! ((int )opline->result_type & (1 << 5))) {
            zval_addref_p(*zptr);
            ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = *zptr;
            ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
          } else {

          }
        } else {

        }
      } else {

      }
    } else {

    }
    if (! have_get_ptr) {
      z = (zval *)((void *)0);
      if (opline->extended_value == 136UL) {
        if ((object->value.obj.handlers)->read_property) {
          if (1 << 3 == 1) {
            tmp___8 = opline->op2.literal;
          } else {
            tmp___8 = (zend_literal *)((void *)0);
          }
          z = (*((object->value.obj.handlers)->read_property))(object, property, 0, (struct _zend_literal  const  *)tmp___8);
        } else {

        }
      } else {
        if ((object->value.obj.handlers)->read_dimension) {
          z = (*((object->value.obj.handlers)->read_dimension))(object, property, 0);
        } else {

        }
      }
      if (z) {
        if ((int )z->type == 5) {
          if ((z->value.obj.handlers)->get) {
            tmp___9 = (*((z->value.obj.handlers)->get))(z);
            value___0 = tmp___9;
            tmp___10 = zval_refcount_p(z);
            if (tmp___10 == 0U) {
              if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                gc_remove_zval_from_buffer(z);
              } else {

              }
              _zval_dtor(z);
              while (1) {
                if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                  gc_remove_zval_from_buffer(z);
                } else {

                }
                _efree((void *)z);
                break;
              }
            } else {

            }
            z = value___0;
          } else {

          }
        } else {

        }
        zval_addref_p(z);
        tmp___13 = zval_isref_p(z);
        if (tmp___13) {

        } else {
          while (1) {
            tmp___12 = zval_refcount_p(z);
            if (tmp___12 > 1U) {
              zval_delref_p(z);
              while (1) {
                tmp___11 = _emalloc(sizeof(zval_gc_info ));
                new_zv___0 = (zval *)tmp___11;
                ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv___0->value = z->value;
                  new_zv___0->type = z->type;
                  break;
                }
                zval_set_refcount_p(new_zv___0, 1U);
                zval_unset_isref_p(new_zv___0);
                break;
              }
              z = new_zv___0;
              _zval_copy_ctor(new_zv___0);
            } else {

            }
            break;
          }
        }
        (*binary_op)(z, z, value);
        if (opline->extended_value == 136UL) {
          if (1 << 3 == 1) {
            tmp___14 = opline->op2.literal;
          } else {
            tmp___14 = (zend_literal *)((void *)0);
          }
          (*((object->value.obj.handlers)->write_property))(object, property, z, (struct _zend_literal  const  *)tmp___14);
        } else {
          (*((object->value.obj.handlers)->write_dimension))(object, property, z);
        }
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(z);
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = z;
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
        } else {

        }
        i_zval_ptr_dtor(z);
      } else {
        zend_error(1 << 1L, "Attempt to assign property of non-object");
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = & executor_globals.uninitialized_zval;
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
        } else {

        }
      }
    } else {

    }
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
  }
  (execute_data->opline) ++;
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_binary_assign_op_helper_SPEC_CV_UNUSED)(int (*binary_op)(zval *result , zval *op1 , zval *op2 ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op_data2 ;
  zend_free_op free_op_data1 ;
  zval **var_ptr ;
  zval *value ;
  int tmp ;
  zval **container ;
  zval **tmp___0 ;
  int tmp___1 ;
  zval *dim ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  temp_variable *__t ;
  long tmp___5 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;
  zend_uint tmp___7 ;
  zend_bool tmp___8 ;
  zval *objval ;
  zval *tmp___9 ;
  long tmp___10 ;
  temp_variable *__t___0 ;

  {
  opline = execute_data->opline;
  switch ((int )opline->extended_value) {
  case 136: 
  tmp = zend_binary_assign_op_obj_helper_SPEC_CV_UNUSED(binary_op, execute_data);
  return (tmp);
  break;
  case 147: 
  tmp___0 = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var);
  container = tmp___0;
  if (1 << 4 == 1 << 2) {
    tmp___3 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___3) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    tmp___2 = __builtin_expect((long )((int )(*container)->type == 5), 0L);
    if (tmp___2) {
      if (1 << 4 == 1 << 2) {
        zval_addref_p(*container);
      } else {

      }
      tmp___1 = zend_binary_assign_op_obj_helper_SPEC_CV_UNUSED(binary_op, execute_data);
      return (tmp___1);
    } else {
      dim = (zval *)((void *)0);
      zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var), container, dim, 1 << 3, 2);
      value = _get_zval_ptr((int )(opline + 1)->op1_type, (znode_op const   *)(& (opline + 1)->op1), (temp_variable const   *)execute_data->Ts, & free_op_data1, 0);
      var_ptr = _get_zval_ptr_ptr_var((opline + 1)->op2.var, (temp_variable const   *)execute_data->Ts, & free_op_data2);
    }
  }
  break;
  default: 
  value = (zval *)((void *)0);
  var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var);
  break;
  }
  tmp___4 = __builtin_expect((long )((unsigned int )var_ptr == (unsigned int )((void *)0)), 0L);
  if (tmp___4) {
    zend_error_noreturn(1, "Cannot use assign-op operators with overloaded objects nor string offsets");
  } else {

  }
  tmp___5 = __builtin_expect((long )((unsigned int )*var_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
  if (tmp___5) {
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      while (1) {
        __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t->var.ptr = & executor_globals.uninitialized_zval;
        __t->var.ptr_ptr = & __t->var.ptr;
        break;
      }
    } else {

    }
    if (opline->extended_value == 147UL) {
      (execute_data->opline) ++;
    } else {

    }
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  tmp___8 = zval_isref_p(*var_ptr);
  if (tmp___8) {

  } else {
    while (1) {
      tmp___7 = zval_refcount_p(*var_ptr);
      if (tmp___7 > 1U) {
        zval_delref_p(*var_ptr);
        while (1) {
          tmp___6 = _emalloc(sizeof(zval_gc_info ));
          new_zv = (zval *)tmp___6;
          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            new_zv->value = (*var_ptr)->value;
            new_zv->type = (*var_ptr)->type;
            break;
          }
          zval_set_refcount_p(new_zv, 1U);
          zval_unset_isref_p(new_zv);
          break;
        }
        *var_ptr = new_zv;
        _zval_copy_ctor(new_zv);
      } else {

      }
      break;
    }
  }
  tmp___10 = __builtin_expect((long )((int )(*var_ptr)->type == 5), 0L);
  if (tmp___10) {
    if (((*var_ptr)->value.obj.handlers)->get) {
      if (((*var_ptr)->value.obj.handlers)->set) {
        tmp___9 = (*(((*var_ptr)->value.obj.handlers)->get))(*var_ptr);
        objval = tmp___9;
        zval_addref_p(objval);
        (*binary_op)(objval, objval, value);
        (*(((*var_ptr)->value.obj.handlers)->set))(var_ptr, objval);
        i_zval_ptr_dtor(objval);
      } else {
        (*binary_op)(*var_ptr, *var_ptr, value);
      }
    } else {
      (*binary_op)(*var_ptr, *var_ptr, value);
    }
  } else {
    (*binary_op)(*var_ptr, *var_ptr, value);
  }
  if (! ((int )opline->result_type & (1 << 5))) {
    zval_addref_p(*var_ptr);
    while (1) {
      __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
      __t___0->var.ptr = *var_ptr;
      __t___0->var.ptr_ptr = & __t___0->var.ptr;
      break;
    }
  } else {

  }
  if (opline->extended_value == 147UL) {
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
    if (free_op_data2.var) {
      i_zval_ptr_dtor(free_op_data2.var);
    } else {

    }
    (execute_data->opline) ++;
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_ADD_SPEC_CV_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_UNUSED((int (*)(zval *result , zval *op1 , zval *op2 ))(& add_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SUB_SPEC_CV_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_UNUSED((int (*)(zval *result , zval *op1 , zval *op2 ))(& sub_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_MUL_SPEC_CV_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_UNUSED((int (*)(zval *result , zval *op1 , zval *op2 ))(& mul_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_DIV_SPEC_CV_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_UNUSED((int (*)(zval *result , zval *op1 , zval *op2 ))(& div_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_MOD_SPEC_CV_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_UNUSED((int (*)(zval *result , zval *op1 , zval *op2 ))(& mod_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SL_SPEC_CV_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_UNUSED((int (*)(zval *result , zval *op1 , zval *op2 ))(& shift_left_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SR_SPEC_CV_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_UNUSED((int (*)(zval *result , zval *op1 , zval *op2 ))(& shift_right_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_CONCAT_SPEC_CV_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_UNUSED((int (*)(zval *result , zval *op1 , zval *op2 ))(& concat_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_OR_SPEC_CV_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_UNUSED((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_or_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_AND_SPEC_CV_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_UNUSED((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_and_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_XOR_SPEC_CV_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_UNUSED((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_xor_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) zend_fetch_var_address_helper_SPEC_CV_UNUSED)(int type , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *varname ;
  zval **retval ;
  zval tmp_varname ;
  HashTable *target_symbol_table ;
  ulong hash_value ;
  long tmp ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_literal *tmp___1 ;
  zval __attribute__((__visibility__("default")))  **tmp___2 ;
  ulong __attribute__((__visibility__("default")))  tmp___3 ;
  int __attribute__((__visibility__("default")))  tmp___4 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  zend_uint tmp___6 ;
  zend_bool tmp___7 ;
  temp_variable *__t ;
  zend_free_op free_res ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___8 ;
  zend_uint tmp___9 ;
  zend_bool tmp___10 ;

  {
  opline = execute_data->opline;
  varname = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  if (1 << 4 != 1) {
    tmp = __builtin_expect((long )((int )varname->type != 6), 0L);
    if (tmp) {
      while (1) {
        tmp_varname.value = varname->value;
        tmp_varname.type = varname->type;
        break;
      }
      _zval_copy_ctor(& tmp_varname);
      zval_set_refcount_p(& tmp_varname, 1U);
      zval_unset_isref_p(& tmp_varname);
      if ((int )tmp_varname.type != 6) {
        _convert_to_string(& tmp_varname);
      } else {

      }
      varname = & tmp_varname;
    } else {

    }
  } else {

  }
  if (1 << 3 != 1 << 3) {
    if (1 << 3 == 1) {
      if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
        ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
      } else {
        tmp___0 = zend_fetch_class_by_name((char const   *)(opline->op2.zv)->value.str.val, (unsigned int )(opline->op2.zv)->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), 0);
        ce = (zend_class_entry *)tmp___0;
        while (1) {
          *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
          break;
        }
      }
    } else {
      ce = ((temp_variable *)((char *)execute_data->Ts + opline->op2.var))->class_entry;
    }
    if (1 << 4 == 1) {
      tmp___1 = opline->op1.literal;
    } else {
      tmp___1 = (zend_literal *)((void *)0);
    }
    tmp___2 = zend_std_get_static_property(ce, (char const   *)varname->value.str.val, varname->value.str.len, (unsigned char)0, (struct _zend_literal  const  *)tmp___1);
    retval = (zval **)tmp___2;
  } else {
    target_symbol_table = zend_get_target_symbol_table((int )(opline->extended_value & 1879048192UL));
    if (1 << 4 == 1) {
      hash_value = ((zend_literal *)varname)->hash_value;
    } else {
      if ((unsigned int )varname->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
        if ((unsigned int )varname->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
          hash_value = ((Bucket *)(varname->value.str.val - sizeof(Bucket )))->h;
        } else {
          tmp___3 = zend_hash_func((char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1));
          hash_value = (unsigned long )tmp___3;
        }
      } else {
        tmp___3 = zend_hash_func((char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1));
        hash_value = (unsigned long )tmp___3;
      }
    }
    tmp___4 = zend_hash_quick_find((HashTable const   *)target_symbol_table, (char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1), hash_value, (void **)(& retval));
    if (tmp___4 == (int __attribute__((__visibility__("default")))  )-1) {
      switch (type) {
      case 0: 
      case 6: 
      zend_error(1 << 3L, "Undefined variable: %s", varname->value.str.val);
      case 3: 
      retval = & executor_globals.uninitialized_zval_ptr;
      break;
      case 2: 
      zend_error(1 << 3L, "Undefined variable: %s", varname->value.str.val);
      case 1: 
      zval_addref_p(& executor_globals.uninitialized_zval);
      _zend_hash_quick_add_or_update(target_symbol_table, (char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1), hash_value, (void *)(& executor_globals.uninitialized_zval_ptr), sizeof(zval *), (void **)(& retval), 1);
      break;
      }
    } else {

    }
    switch ((int )(opline->extended_value & 1879048192UL)) {
    case 0x00000000: 
    if (1 << 4 != 1 << 1) {

    } else {

    }
    break;
    case 0x10000000: 
    break;
    case 0x20000000: 
    zval_update_constant(retval, (void *)1);
    break;
    case 0x40000000: 
    if (1 << 4 == 1 << 2) {
      if (! free_op1.var) {
        zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr));
      } else {

      }
    } else {

    }
    break;
    }
  }
  if (1 << 4 != 1) {
    if ((unsigned int )varname == (unsigned int )(& tmp_varname)) {
      _zval_dtor(& tmp_varname);
    } else {

    }
  } else {

  }
  if (opline->extended_value & 67108864UL) {
    tmp___7 = zval_isref_p(*retval);
    if (tmp___7) {

    } else {
      while (1) {
        tmp___6 = zval_refcount_p(*retval);
        if (tmp___6 > 1U) {
          zval_delref_p(*retval);
          while (1) {
            tmp___5 = _emalloc(sizeof(zval_gc_info ));
            new_zv = (zval *)tmp___5;
            ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv->value = (*retval)->value;
              new_zv->type = (*retval)->type;
              break;
            }
            zval_set_refcount_p(new_zv, 1U);
            zval_unset_isref_p(new_zv);
            break;
          }
          *retval = new_zv;
          _zval_copy_ctor(new_zv);
        } else {

        }
        break;
      }
      zval_set_isref_p(*retval);
    }
  } else {

  }
  zval_addref_p(*retval);
  switch (type) {
  case 0: 
  case 3: 
  while (1) {
    __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
    __t->var.ptr = *retval;
    __t->var.ptr_ptr = & __t->var.ptr;
    break;
  }
  break;
  case 6: 
  zend_pzval_unlock_func(*retval, & free_res, 1);
  if ((unsigned int )retval != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
    tmp___10 = zval_isref_p(*retval);
    if (tmp___10) {

    } else {
      while (1) {
        tmp___9 = zval_refcount_p(*retval);
        if (tmp___9 > 1U) {
          zval_delref_p(*retval);
          while (1) {
            tmp___8 = _emalloc(sizeof(zval_gc_info ));
            new_zv___0 = (zval *)tmp___8;
            ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv___0->value = (*retval)->value;
              new_zv___0->type = (*retval)->type;
              break;
            }
            zval_set_refcount_p(new_zv___0, 1U);
            zval_unset_isref_p(new_zv___0);
            break;
          }
          *retval = new_zv___0;
          _zval_copy_ctor(new_zv___0);
        } else {

        }
        break;
      }
    }
  } else {

  }
  zval_addref_p(*retval);
  if (free_res.var) {
    i_zval_ptr_dtor(free_res.var);
  } else {

  }
  default: 
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = retval;
  break;
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_R_SPEC_CV_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_CV_UNUSED(0, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_W_SPEC_CV_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_CV_UNUSED(1, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_RW_SPEC_CV_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_CV_UNUSED(2, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_FUNC_ARG_SPEC_CV_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  unsigned int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
  opline = execute_data->opline;
  if (execute_data->fbc) {
    if ((execute_data->fbc)->common.arg_info) {
      if ((opline->extended_value & 1048575UL) <= (unsigned long )(execute_data->fbc)->common.num_args) {
        tmp___1 = (unsigned int )((int )((execute_data->fbc)->common.arg_info + ((opline->extended_value & 1048575UL) - 1UL))->pass_by_reference & 3);
      } else {
        tmp___1 = (execute_data->fbc)->common.fn_flags & 50331648U;
      }
    } else {
      tmp___1 = (execute_data->fbc)->common.fn_flags & 50331648U;
    }
    if (tmp___1) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  tmp___2 = zend_fetch_var_address_helper_SPEC_CV_UNUSED(tmp___0, execute_data);
  return (tmp___2);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_UNSET_SPEC_CV_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_CV_UNUSED(6, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_IS_SPEC_CV_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_var_address_helper_SPEC_CV_UNUSED(3, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_W_SPEC_CV_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **container ;
  long tmp ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_uint tmp___1 ;
  zend_bool tmp___2 ;
  zend_uint tmp___3 ;
  zend_uint tmp___4 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___5 ;
  zval **retval_ptr ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;
  zend_uint tmp___7 ;
  zend_bool tmp___8 ;
  long tmp___9 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, (zval *)((void *)0), 1 << 3, 1);
  if (1 << 4 == 1 << 2) {
    if (0) {
      tmp___4 = zval_refcount_p(free_op1.var);
      if (tmp___4 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___5 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___5 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___2 = zval_isref_p(__t->var.ptr);
                if (tmp___2) {

                } else {
                  tmp___3 = zval_refcount_p(__t->var.ptr);
                  if (tmp___3 > 2U) {
                    while (1) {
                      tmp___1 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___1 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___0 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___0;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  tmp___9 = __builtin_expect((long )(opline->extended_value != 0UL), 0L);
  if (tmp___9) {
    retval_ptr = ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr;
    if (retval_ptr) {
      zval_delref_p(*retval_ptr);
      tmp___8 = zval_isref_p(*retval_ptr);
      if (tmp___8) {

      } else {
        while (1) {
          tmp___7 = zval_refcount_p(*retval_ptr);
          if (tmp___7 > 1U) {
            zval_delref_p(*retval_ptr);
            while (1) {
              tmp___6 = _emalloc(sizeof(zval_gc_info ));
              new_zv___0 = (zval *)tmp___6;
              ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv___0->value = (*retval_ptr)->value;
                new_zv___0->type = (*retval_ptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv___0, 1U);
              zval_unset_isref_p(new_zv___0);
              break;
            }
            *retval_ptr = new_zv___0;
            _zval_copy_ctor(new_zv___0);
          } else {

          }
          break;
        }
        zval_set_isref_p(*retval_ptr);
      }
      zval_addref_p(*retval_ptr);
    } else {

    }
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_RW_SPEC_CV_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **container ;
  long tmp ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_uint tmp___1 ;
  zend_bool tmp___2 ;
  zend_uint tmp___3 ;
  zend_uint tmp___4 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___5 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, (zval *)((void *)0), 1 << 3, 2);
  if (1 << 4 == 1 << 2) {
    if (0) {
      tmp___4 = zval_refcount_p(free_op1.var);
      if (tmp___4 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___5 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___5 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___2 = zval_isref_p(__t->var.ptr);
                if (tmp___2) {

                } else {
                  tmp___3 = zval_refcount_p(__t->var.ptr);
                  if (tmp___3 > 2U) {
                    while (1) {
                      tmp___1 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___1 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___0 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___0;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **container ;
  long tmp ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_uint tmp___1 ;
  zend_bool tmp___2 ;
  zend_uint tmp___3 ;
  zend_uint tmp___4 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___5 ;
  unsigned int tmp___6 ;

  {
  opline = execute_data->opline;
  if (execute_data->fbc) {
    if ((execute_data->fbc)->common.arg_info) {
      if ((opline->extended_value & 1048575UL) <= (unsigned long )(execute_data->fbc)->common.num_args) {
        tmp___6 = (unsigned int )((int )((execute_data->fbc)->common.arg_info + ((opline->extended_value & 1048575UL) - 1UL))->pass_by_reference & 3);
      } else {
        tmp___6 = (execute_data->fbc)->common.fn_flags & 50331648U;
      }
    } else {
      tmp___6 = (execute_data->fbc)->common.fn_flags & 50331648U;
    }
    if (tmp___6) {
      container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var);
      if (1 << 4 == 1 << 2) {
        tmp = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
        if (tmp) {
          zend_error_noreturn(1, "Cannot use string offset as an array");
        } else {

        }
      } else {

      }
      zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, (zval *)((void *)0), 1 << 3, 1);
      if (1 << 4 == 1 << 2) {
        if (0) {
          tmp___4 = zval_refcount_p(free_op1.var);
          if (tmp___4 == 1U) {
            if ((int )(free_op1.var)->type != 5) {
              goto _L;
            } else {
              tmp___5 = zend_objects_store_get_refcount(free_op1.var);
              if (tmp___5 == (zend_uint __attribute__((__visibility__("default")))  )1) {
                _L: /* CIL Label */ 
                while (1) {
                  __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
                  if (__t->var.ptr_ptr) {
                    __t->var.ptr = *(__t->var.ptr_ptr);
                    __t->var.ptr_ptr = & __t->var.ptr;
                    tmp___2 = zval_isref_p(__t->var.ptr);
                    if (tmp___2) {

                    } else {
                      tmp___3 = zval_refcount_p(__t->var.ptr);
                      if (tmp___3 > 2U) {
                        while (1) {
                          tmp___1 = zval_refcount_p(*(__t->var.ptr_ptr));
                          if (tmp___1 > 1U) {
                            zval_delref_p(*(__t->var.ptr_ptr));
                            while (1) {
                              tmp___0 = _emalloc(sizeof(zval_gc_info ));
                              new_zv = (zval *)tmp___0;
                              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                              break;
                            }
                            while (1) {
                              while (1) {
                                new_zv->value = (*(__t->var.ptr_ptr))->value;
                                new_zv->type = (*(__t->var.ptr_ptr))->type;
                                break;
                              }
                              zval_set_refcount_p(new_zv, 1U);
                              zval_unset_isref_p(new_zv);
                              break;
                            }
                            *(__t->var.ptr_ptr) = new_zv;
                            _zval_copy_ctor(new_zv);
                          } else {

                          }
                          break;
                        }
                      } else {

                      }
                    }
                  } else {

                  }
                  break;
                }
              } else {

              }
            }
          } else {

          }
        } else {

        }
      } else {

      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if (1 << 3 == 1 << 3) {
      zend_error_noreturn(1, "Cannot use [] for reading");
    } else {

    }
    container = _get_zval_ptr_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
    zend_fetch_dimension_address_read((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, (zval *)((void *)0), 1 << 3, 0);
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_DIM_SPEC_CV_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **object_ptr ;
  long tmp ;
  zval *property_name ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_literal *tmp___1 ;
  zval **tmp___2 ;
  zend_free_op free_op_data1 ;
  zend_free_op free_op_data2 ;
  zval *value ;
  zval *dim ;
  zval **variable_ptr_ptr ;
  zval *retval ;
  void __attribute__((__visibility__("default")))  *tmp___3 ;
  char const   *__s ;
  int __l ;
  zval *__z ;
  char __attribute__((__visibility__("default")))  *tmp___4 ;
  temp_variable *__t ;
  temp_variable *__t___0 ;
  int tmp___5 ;
  temp_variable *__t___1 ;
  temp_variable *__t___2 ;
  long tmp___6 ;
  long tmp___7 ;

  {
  opline = execute_data->opline;
  object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  if ((int )(*object_ptr)->type == 5) {
    property_name = (zval *)((void *)0);
    if (1 << 3 == 1) {
      tmp___1 = opline->op2.literal;
    } else {
      tmp___1 = (zend_literal *)((void *)0);
    }
    if (! ((int )opline->result_type & (1 << 5))) {
      tmp___2 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
    } else {
      tmp___2 = (zval **)((void *)0);
    }
    zend_assign_to_object(tmp___2, object_ptr, property_name, (int )(opline + 1)->op1_type, & (opline + 1)->op1, (temp_variable const   *)execute_data->Ts, 147, (zend_literal const   *)tmp___1);
  } else {
    dim = (zval *)((void *)0);
    zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var), object_ptr, dim, 1 << 3, 1);
    value = _get_zval_ptr((int )(opline + 1)->op1_type, (znode_op const   *)(& (opline + 1)->op1), (temp_variable const   *)execute_data->Ts, & free_op_data1, 0);
    variable_ptr_ptr = _get_zval_ptr_ptr_var((opline + 1)->op2.var, (temp_variable const   *)execute_data->Ts, & free_op_data2);
    tmp___7 = __builtin_expect((long )((unsigned int )variable_ptr_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___7) {
      tmp___5 = zend_assign_to_string_offset((temp_variable const   *)((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var)), (zval const   *)value, (int )(opline + 1)->op1_type);
      if (tmp___5) {
        if (! ((int )opline->result_type & (1 << 5))) {
          while (1) {
            tmp___3 = _emalloc(sizeof(zval_gc_info ));
            retval = (zval *)tmp___3;
            ((zval_gc_info *)retval)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            __s = (char const   *)((((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var))->str_offset.str)->value.str.val + ((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var))->str_offset.offset);
            __l = 1;
            __z = retval;
            __z->value.str.len = __l;
            tmp___4 = _estrndup(__s, (unsigned int )__l);
            __z->value.str.val = (char *)tmp___4;
            __z->type = (unsigned char)6;
            break;
          }
          retval->refcount__gc = 1U;
          retval->is_ref__gc = (unsigned char)0;
          while (1) {
            __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t->var.ptr = retval;
            __t->var.ptr_ptr = & __t->var.ptr;
            break;
          }
        } else {

        }
      } else {
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          while (1) {
            __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___0->var.ptr = & executor_globals.uninitialized_zval;
            __t___0->var.ptr_ptr = & __t___0->var.ptr;
            break;
          }
        } else {

        }
      }
    } else {
      tmp___6 = __builtin_expect((long )((unsigned int )*variable_ptr_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
      if (tmp___6) {
        if ((unsigned long )free_op_data1.var & 1UL) {
          _zval_dtor(value);
        } else {

        }
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          while (1) {
            __t___1 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___1->var.ptr = & executor_globals.uninitialized_zval;
            __t___1->var.ptr_ptr = & __t___1->var.ptr;
            break;
          }
        } else {

        }
      } else {
        if ((int )(opline + 1)->op1_type == 1 << 1) {
          value = zend_assign_tmp_to_variable(variable_ptr_ptr, value);
        } else {
          if ((int )(opline + 1)->op1_type == 1) {
            value = zend_assign_const_to_variable(variable_ptr_ptr, value);
          } else {
            value = zend_assign_to_variable(variable_ptr_ptr, value);
          }
        }
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(value);
          while (1) {
            __t___2 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___2->var.ptr = value;
            __t___2->var.ptr_ptr = & __t___2->var.ptr;
            break;
          }
        } else {

        }
      }
    }
    if (free_op_data2.var) {
      i_zval_ptr_dtor(free_op_data2.var);
    } else {

    }
    if ((unsigned int )free_op_data1.var != (unsigned int )((void *)0)) {
      if (((unsigned long )free_op_data1.var & 1UL) == 0UL) {
        i_zval_ptr_dtor(free_op_data1.var);
      } else {

      }
    } else {

    }
  }
  (execute_data->opline) ++;
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *expr_ptr ;
  zval **expr_ptr_ptr ;
  zval **tmp ;
  long tmp___0 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zval *new_expr ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zval *new_expr___0 ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  zend_bool tmp___6 ;
  zval *offset ;
  ulong hval ;
  long tmp___7 ;
  register char const   *tmp___8 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___9 ;

  {
  opline = execute_data->opline;
  if (1 << 4 == 1 << 2) {
    goto _L___1;
  } else {
    if (1 << 4 == 1 << 4) {
      _L___1: /* CIL Label */ 
      if (opline->extended_value) {
        tmp = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var);
        expr_ptr_ptr = tmp;
        if (1 << 4 == 1 << 2) {
          tmp___0 = __builtin_expect((long )((unsigned int )expr_ptr_ptr == (unsigned int )((void *)0)), 0L);
          if (tmp___0) {
            zend_error_noreturn(1, "Cannot create references to/from string offsets");
          } else {

          }
        } else {

        }
        tmp___3 = zval_isref_p(*expr_ptr_ptr);
        if (tmp___3) {

        } else {
          while (1) {
            tmp___2 = zval_refcount_p(*expr_ptr_ptr);
            if (tmp___2 > 1U) {
              zval_delref_p(*expr_ptr_ptr);
              while (1) {
                tmp___1 = _emalloc(sizeof(zval_gc_info ));
                new_zv = (zval *)tmp___1;
                ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv->value = (*expr_ptr_ptr)->value;
                  new_zv->type = (*expr_ptr_ptr)->type;
                  break;
                }
                zval_set_refcount_p(new_zv, 1U);
                zval_unset_isref_p(new_zv);
                break;
              }
              *expr_ptr_ptr = new_zv;
              _zval_copy_ctor(new_zv);
            } else {

            }
            break;
          }
          zval_set_isref_p(*expr_ptr_ptr);
        }
        expr_ptr = *expr_ptr_ptr;
        zval_addref_p(expr_ptr);
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      expr_ptr = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
      if (1 << 4 == 1) {
        goto _L;
      } else {
        tmp___6 = zval_isref_p(expr_ptr);
        if (tmp___6) {
          _L: /* CIL Label */ 
          while (1) {
            tmp___5 = _emalloc(sizeof(zval_gc_info ));
            new_expr___0 = (zval *)tmp___5;
            ((zval_gc_info *)new_expr___0)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_expr___0->value = expr_ptr->value;
              new_expr___0->type = expr_ptr->type;
              break;
            }
            zval_set_refcount_p(new_expr___0, 1U);
            zval_unset_isref_p(new_expr___0);
            break;
          }
          expr_ptr = new_expr___0;
          _zval_copy_ctor(expr_ptr);
        } else {
          zval_addref_p(expr_ptr);
        }
      }
    }
  }
  if (1 << 3 != 1 << 3) {
    offset = (zval *)((void *)0);
    switch ((int )offset->type) {
    case 2: 
    tmp___7 = zend_dval_to_lval(offset->value.dval);
    hval = (unsigned long )tmp___7;
    goto num_index;
    case 1: 
    case 3: 
    hval = (unsigned long )offset->value.lval;
    num_index: 
    _zend_hash_index_update_or_next_insert(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, hval, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    case 6: 
    if (1 << 3 == 1) {
      hval = ((zend_literal *)offset)->hash_value;
    } else {
      while (1) {
        tmp___8 = (char const   *)offset->value.str.val;
        if ((int const   )*tmp___8 == 45) {
          tmp___8 ++;
        } else {

        }
        if ((int const   )*tmp___8 >= 48) {
          if ((int const   )*tmp___8 <= 57) {
            end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
            if ((int const   )*end != 0) {
              break;
            } else {
              if ((int const   )*tmp___8 == 48) {
                if (offset->value.str.len + 1 > 2) {
                  break;
                } else {
                  goto _L___2;
                }
              } else {
                _L___2: /* CIL Label */ 
                if (end - tmp___8 > 10) {
                  break;
                } else {
                  if (end - tmp___8 == 10) {
                    if ((int const   )*tmp___8 > 50) {
                      break;
                    } else {

                    }
                  } else {

                  }
                }
              }
            }
            hval = (unsigned long )((int const   )*tmp___8 - 48);
            while (1) {
              tmp___8 ++;
              if ((unsigned int )tmp___8 != (unsigned int )end) {
                if ((int const   )*tmp___8 >= 48) {
                  if ((int const   )*tmp___8 <= 57) {

                  } else {
                    break;
                  }
                } else {
                  break;
                }
              } else {
                break;
              }
              hval = hval * 10UL + (ulong )((int const   )*tmp___8 - 48);
            }
            if ((unsigned int )tmp___8 == (unsigned int )end) {
              if ((int )*(offset->value.str.val) == 45) {
                if (hval - 1UL > 2147483647UL) {
                  break;
                } else {

                }
                hval = (unsigned long )(- ((long )hval));
              } else {
                if (hval > 2147483647UL) {
                  break;
                } else {

                }
              }
              goto num_index;
            } else {

            }
          } else {

          }
        } else {

        }
        break;
      }
      if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
        if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
          hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
        } else {
          tmp___9 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___9;
        }
      } else {
        tmp___9 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
        hval = (unsigned long )tmp___9;
      }
    }
    _zend_hash_quick_add_or_update(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    case 0: 
    _zend_hash_add_or_update(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, "", sizeof(""), (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    default: 
    zend_error(1 << 1L, "Illegal offset type");
    i_zval_ptr_dtor(expr_ptr);
    break;
    }
  } else {
    _zend_hash_index_update_or_next_insert(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, 0UL, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1 << 2);
  }
  if (1 << 4 == 1 << 2) {
    goto _L___3;
  } else {
    if (1 << 4 == 1 << 4) {
      _L___3: /* CIL Label */ 
      if (opline->extended_value) {

      } else {

      }
    } else {

    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_ARRAY_SPEC_CV_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  int tmp ;

  {
  opline = execute_data->opline;
  _array_init(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, 0U);
  if (1 << 4 == 1 << 3) {
    (execute_data->opline) ++;
    return (0);
  } else {
    tmp = ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_UNUSED_HANDLER(execute_data);
    return (tmp);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_UNSET_VAR_SPEC_CV_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval tmp ;
  zval *varname ;
  HashTable *target_symbol_table ;
  zend_compiled_variable *cv ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  zend_literal *tmp___1 ;
  ulong hash_value ;
  ulong tmp___2 ;

  {
  opline = execute_data->opline;
  if (1 << 4 == 1 << 4) {
    if (1 << 3 == 1 << 3) {
      if (opline->extended_value & 8388608UL) {
        if (executor_globals.active_symbol_table) {
          cv = (executor_globals.active_op_array)->vars + opline->op1.var;
          zend_delete_variable(execute_data->prev_execute_data, executor_globals.active_symbol_table, cv->name, cv->name_len + 1, cv->hash_value);
          *(execute_data->CVs + opline->op1.var) = (zval **)((void *)0);
        } else {
          if (*(execute_data->CVs + opline->op1.var)) {
            i_zval_ptr_dtor(*(*(execute_data->CVs + opline->op1.var)));
            *(execute_data->CVs + opline->op1.var) = (zval **)((void *)0);
          } else {

          }
        }
        (execute_data->opline) ++;
        return (0);
      } else {

      }
    } else {

    }
  } else {

  }
  varname = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  if (1 << 4 != 1) {
    if ((int )varname->type != 6) {
      while (1) {
        tmp.value = varname->value;
        tmp.type = varname->type;
        break;
      }
      _zval_copy_ctor(& tmp);
      if ((int )tmp.type != 6) {
        _convert_to_string(& tmp);
      } else {

      }
      varname = & tmp;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if (1 << 4 == 1 << 2) {
      zval_addref_p(varname);
    } else {
      if (1 << 4 == 1 << 4) {
        zval_addref_p(varname);
      } else {

      }
    }
  }
  if (1 << 3 != 1 << 3) {
    if (1 << 3 == 1) {
      if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
        ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
      } else {
        tmp___0 = zend_fetch_class_by_name((char const   *)(opline->op2.zv)->value.str.val, (unsigned int )(opline->op2.zv)->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), 0);
        ce = (zend_class_entry *)tmp___0;
        while (1) {
          *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
          break;
        }
      }
    } else {
      ce = ((temp_variable *)((char *)execute_data->Ts + opline->op2.var))->class_entry;
    }
    if (1 << 4 == 1) {
      tmp___1 = opline->op1.literal;
    } else {
      tmp___1 = (zend_literal *)((void *)0);
    }
    zend_std_unset_static_property(ce, (char const   *)varname->value.str.val, varname->value.str.len, (struct _zend_literal  const  *)tmp___1);
  } else {
    tmp___2 = zend_inline_hash_func((char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1));
    hash_value = tmp___2;
    target_symbol_table = zend_get_target_symbol_table((int )(opline->extended_value & 1879048192UL));
    zend_delete_variable(execute_data, target_symbol_table, (char const   *)varname->value.str.val, varname->value.str.len + 1, hash_value);
  }
  if (1 << 4 != 1) {
    if ((unsigned int )varname == (unsigned int )(& tmp)) {
      _zval_dtor(& tmp);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if (1 << 4 == 1 << 2) {
      i_zval_ptr_dtor(varname);
    } else {
      if (1 << 4 == 1 << 4) {
        i_zval_ptr_dtor(varname);
      } else {

      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ISSET_ISEMPTY_VAR_SPEC_CV_UNUSED_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **value ;
  zend_bool isset ;
  zend_compiled_variable *cv ;
  int __attribute__((__visibility__("default")))  tmp ;
  HashTable *target_symbol_table ;
  zval tmp___0 ;
  zval *varname ;
  zval *tmp___1 ;
  zend_class_entry *ce ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_literal *tmp___3 ;
  zval __attribute__((__visibility__("default")))  **tmp___4 ;
  int __attribute__((__visibility__("default")))  tmp___5 ;
  zval *__z ;
  zval *__z___0 ;
  zval *__z___1 ;
  zval *__z___2 ;
  int tmp___6 ;

  {
  opline = execute_data->opline;
  isset = (zend_bool )1;
  if (1 << 4 == 1 << 4) {
    if (1 << 3 == 1 << 3) {
      if (opline->extended_value & 8388608UL) {
        if (*(execute_data->CVs + opline->op1.var)) {
          value = *(execute_data->CVs + opline->op1.var);
        } else {
          if (executor_globals.active_symbol_table) {
            cv = (executor_globals.active_op_array)->vars + opline->op1.var;
            tmp = zend_hash_quick_find((HashTable const   *)executor_globals.active_symbol_table, cv->name, (unsigned int )(cv->name_len + 1), cv->hash_value, (void **)(& value));
            if (tmp == (int __attribute__((__visibility__("default")))  )-1) {
              isset = (unsigned char)0;
            } else {

            }
          } else {
            isset = (unsigned char)0;
          }
        }
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    _L: /* CIL Label */ 
    tmp___1 = _get_zval_ptr_cv_BP_VAR_IS(execute_data->CVs, opline->op1.var);
    varname = tmp___1;
    if (1 << 4 != 1) {
      if ((int )varname->type != 6) {
        while (1) {
          tmp___0.value = varname->value;
          tmp___0.type = varname->type;
          break;
        }
        _zval_copy_ctor(& tmp___0);
        if ((int )tmp___0.type != 6) {
          _convert_to_string(& tmp___0);
        } else {

        }
        varname = & tmp___0;
      } else {

      }
    } else {

    }
    if (1 << 3 != 1 << 3) {
      if (1 << 3 == 1) {
        if (*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot)) {
          ce = (zend_class_entry *)*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot);
        } else {
          tmp___2 = zend_fetch_class_by_name((char const   *)(opline->op2.zv)->value.str.val, (unsigned int )(opline->op2.zv)->value.str.len, (zend_literal const   *)(opline->op2.literal + 1), 0);
          ce = (zend_class_entry *)tmp___2;
          while (1) {
            *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)ce;
            break;
          }
        }
      } else {
        ce = ((temp_variable *)((char *)execute_data->Ts + opline->op2.var))->class_entry;
      }
      if (1 << 4 == 1) {
        tmp___3 = opline->op1.literal;
      } else {
        tmp___3 = (zend_literal *)((void *)0);
      }
      tmp___4 = zend_std_get_static_property(ce, (char const   *)varname->value.str.val, varname->value.str.len, (unsigned char)1, (struct _zend_literal  const  *)tmp___3);
      value = (zval **)tmp___4;
      if (! value) {
        isset = (unsigned char)0;
      } else {

      }
    } else {
      target_symbol_table = zend_get_target_symbol_table((int )(opline->extended_value & 1879048192UL));
      tmp___5 = zend_hash_find((HashTable const   *)target_symbol_table, (char const   *)varname->value.str.val, (unsigned int )(varname->value.str.len + 1), (void **)(& value));
      if (tmp___5 == (int __attribute__((__visibility__("default")))  )-1) {
        isset = (unsigned char)0;
      } else {

      }
    }
    if (1 << 4 != 1) {
      if ((unsigned int )varname == (unsigned int )(& tmp___0)) {
        _zval_dtor(& tmp___0);
      } else {

      }
    } else {

    }
  }
  if (opline->extended_value & 33554432UL) {
    if (isset) {
      if ((int )(*value)->type != 0) {
        while (1) {
          __z = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
          __z->value.lval = 1L;
          __z->type = (unsigned char)3;
          break;
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      while (1) {
        __z___0 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
        __z___0->value.lval = 0L;
        __z___0->type = (unsigned char)3;
        break;
      }
    }
  } else {
    if (! isset) {
      goto _L___2;
    } else {
      tmp___6 = i_zend_is_true(*value);
      if (tmp___6) {
        while (1) {
          __z___2 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
          __z___2->value.lval = 0L;
          __z___2->type = (unsigned char)3;
          break;
        }
      } else {
        _L___2: /* CIL Label */ 
        while (1) {
          __z___1 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
          __z___1->value.lval = 1L;
          __z___1->type = (unsigned char)3;
          break;
        }
      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  fast_add_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SUB_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  fast_sub_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_MUL_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  fast_mul_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_DIV_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  fast_div_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_MOD_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  fast_mod_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SL_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  shift_left_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_SR_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  shift_right_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_CONCAT_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  concat_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_IDENTICAL_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  is_identical_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_NOT_IDENTICAL_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *result ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  is_identical_function(result, tmp___0, tmp);
  result->value.lval = (long )(! result->value.lval);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_EQUAL_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  zval *tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
    tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
    tmp___1 = fast_equal_function(result, tmp___0, tmp);
    __z->value.lval = (long )(tmp___1 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_NOT_EQUAL_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  zval *tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
    tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
    tmp___1 = fast_not_equal_function(result, tmp___0, tmp);
    __z->value.lval = (long )(tmp___1 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_SMALLER_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  zval *tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
    tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
    tmp___1 = fast_is_smaller_function(result, tmp___0, tmp);
    __z->value.lval = (long )(tmp___1 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *result ;
  zval *__z ;
  zval *tmp ;
  zval *tmp___0 ;
  int tmp___1 ;

  {
  opline = execute_data->opline;
  result = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  while (1) {
    __z = result;
    tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
    tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
    tmp___1 = fast_is_smaller_or_equal_function(result, tmp___0, tmp);
    __z->value.lval = (long )(tmp___1 != 0);
    __z->type = (unsigned char)3;
    break;
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_OR_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  bitwise_or_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_AND_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  bitwise_and_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BW_XOR_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  bitwise_xor_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_BOOL_XOR_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  boolean_xor_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_binary_assign_op_obj_helper_SPEC_CV_CV)(int (*binary_op)(zval *result , zval *op1 , zval *op2 ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op_data1 ;
  zval **object_ptr ;
  zval **tmp ;
  zval *object ;
  zval *property ;
  zval *tmp___0 ;
  zval *value ;
  zval *tmp___1 ;
  int have_get_ptr ;
  long tmp___2 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___3 ;
  zval **zptr ;
  zend_literal *tmp___4 ;
  zval **tmp___5 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;
  zend_uint tmp___7 ;
  zend_bool tmp___8 ;
  zval *z ;
  zend_literal *tmp___9 ;
  zval *value___0 ;
  zval *tmp___10 ;
  zend_uint tmp___11 ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___12 ;
  zend_uint tmp___13 ;
  zend_bool tmp___14 ;
  zend_literal *tmp___15 ;
  long tmp___16 ;

  {
  opline = execute_data->opline;
  tmp = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var);
  object_ptr = tmp;
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  property = tmp___0;
  tmp___1 = _get_zval_ptr((int )(opline + 1)->op1_type, (znode_op const   *)(& (opline + 1)->op1), (temp_variable const   *)execute_data->Ts, & free_op_data1, 0);
  value = tmp___1;
  have_get_ptr = 0;
  if (1 << 4 == 1 << 2) {
    tmp___2 = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___2) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  make_real_object(object_ptr);
  object = *object_ptr;
  tmp___16 = __builtin_expect((long )((int )object->type != 5), 0L);
  if (tmp___16) {
    zend_error(1 << 1L, "Attempt to assign property of non-object");
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = & executor_globals.uninitialized_zval;
      ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
    } else {

    }
  } else {
    if (opline->extended_value == 136UL) {
      if ((object->value.obj.handlers)->get_property_ptr_ptr) {
        if (1 << 4 == 1) {
          tmp___4 = opline->op2.literal;
        } else {
          tmp___4 = (zend_literal *)((void *)0);
        }
        tmp___5 = (*((object->value.obj.handlers)->get_property_ptr_ptr))(object, property, (struct _zend_literal  const  *)tmp___4);
        zptr = tmp___5;
        if ((unsigned int )zptr != (unsigned int )((void *)0)) {
          tmp___8 = zval_isref_p(*zptr);
          if (tmp___8) {

          } else {
            while (1) {
              tmp___7 = zval_refcount_p(*zptr);
              if (tmp___7 > 1U) {
                zval_delref_p(*zptr);
                while (1) {
                  tmp___6 = _emalloc(sizeof(zval_gc_info ));
                  new_zv = (zval *)tmp___6;
                  ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                  break;
                }
                while (1) {
                  while (1) {
                    new_zv->value = (*zptr)->value;
                    new_zv->type = (*zptr)->type;
                    break;
                  }
                  zval_set_refcount_p(new_zv, 1U);
                  zval_unset_isref_p(new_zv);
                  break;
                }
                *zptr = new_zv;
                _zval_copy_ctor(new_zv);
              } else {

              }
              break;
            }
          }
          have_get_ptr = 1;
          (*binary_op)(*zptr, *zptr, value);
          if (! ((int )opline->result_type & (1 << 5))) {
            zval_addref_p(*zptr);
            ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = *zptr;
            ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
          } else {

          }
        } else {

        }
      } else {

      }
    } else {

    }
    if (! have_get_ptr) {
      z = (zval *)((void *)0);
      if (opline->extended_value == 136UL) {
        if ((object->value.obj.handlers)->read_property) {
          if (1 << 4 == 1) {
            tmp___9 = opline->op2.literal;
          } else {
            tmp___9 = (zend_literal *)((void *)0);
          }
          z = (*((object->value.obj.handlers)->read_property))(object, property, 0, (struct _zend_literal  const  *)tmp___9);
        } else {

        }
      } else {
        if ((object->value.obj.handlers)->read_dimension) {
          z = (*((object->value.obj.handlers)->read_dimension))(object, property, 0);
        } else {

        }
      }
      if (z) {
        if ((int )z->type == 5) {
          if ((z->value.obj.handlers)->get) {
            tmp___10 = (*((z->value.obj.handlers)->get))(z);
            value___0 = tmp___10;
            tmp___11 = zval_refcount_p(z);
            if (tmp___11 == 0U) {
              if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                gc_remove_zval_from_buffer(z);
              } else {

              }
              _zval_dtor(z);
              while (1) {
                if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                  gc_remove_zval_from_buffer(z);
                } else {

                }
                _efree((void *)z);
                break;
              }
            } else {

            }
            z = value___0;
          } else {

          }
        } else {

        }
        zval_addref_p(z);
        tmp___14 = zval_isref_p(z);
        if (tmp___14) {

        } else {
          while (1) {
            tmp___13 = zval_refcount_p(z);
            if (tmp___13 > 1U) {
              zval_delref_p(z);
              while (1) {
                tmp___12 = _emalloc(sizeof(zval_gc_info ));
                new_zv___0 = (zval *)tmp___12;
                ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv___0->value = z->value;
                  new_zv___0->type = z->type;
                  break;
                }
                zval_set_refcount_p(new_zv___0, 1U);
                zval_unset_isref_p(new_zv___0);
                break;
              }
              z = new_zv___0;
              _zval_copy_ctor(new_zv___0);
            } else {

            }
            break;
          }
        }
        (*binary_op)(z, z, value);
        if (opline->extended_value == 136UL) {
          if (1 << 4 == 1) {
            tmp___15 = opline->op2.literal;
          } else {
            tmp___15 = (zend_literal *)((void *)0);
          }
          (*((object->value.obj.handlers)->write_property))(object, property, z, (struct _zend_literal  const  *)tmp___15);
        } else {
          (*((object->value.obj.handlers)->write_dimension))(object, property, z);
        }
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(z);
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = z;
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
        } else {

        }
        i_zval_ptr_dtor(z);
      } else {
        zend_error(1 << 1L, "Attempt to assign property of non-object");
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = & executor_globals.uninitialized_zval;
          ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = (zval **)((void *)0);
        } else {

        }
      }
    } else {

    }
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
  }
  (execute_data->opline) ++;
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_binary_assign_op_helper_SPEC_CV_CV)(int (*binary_op)(zval *result , zval *op1 , zval *op2 ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op_data2 ;
  zend_free_op free_op_data1 ;
  zval **var_ptr ;
  zval *value ;
  int tmp ;
  zval **container ;
  zval **tmp___0 ;
  int tmp___1 ;
  zval *dim ;
  zval *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  temp_variable *__t ;
  long tmp___6 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___7 ;
  zend_uint tmp___8 ;
  zend_bool tmp___9 ;
  zval *objval ;
  zval *tmp___10 ;
  long tmp___11 ;
  temp_variable *__t___0 ;

  {
  opline = execute_data->opline;
  switch ((int )opline->extended_value) {
  case 136: 
  tmp = zend_binary_assign_op_obj_helper_SPEC_CV_CV(binary_op, execute_data);
  return (tmp);
  break;
  case 147: 
  tmp___0 = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var);
  container = tmp___0;
  if (1 << 4 == 1 << 2) {
    tmp___4 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___4) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    tmp___3 = __builtin_expect((long )((int )(*container)->type == 5), 0L);
    if (tmp___3) {
      if (1 << 4 == 1 << 2) {
        zval_addref_p(*container);
      } else {

      }
      tmp___1 = zend_binary_assign_op_obj_helper_SPEC_CV_CV(binary_op, execute_data);
      return (tmp___1);
    } else {
      tmp___2 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
      dim = tmp___2;
      zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var), container, dim, 1 << 4, 2);
      value = _get_zval_ptr((int )(opline + 1)->op1_type, (znode_op const   *)(& (opline + 1)->op1), (temp_variable const   *)execute_data->Ts, & free_op_data1, 0);
      var_ptr = _get_zval_ptr_ptr_var((opline + 1)->op2.var, (temp_variable const   *)execute_data->Ts, & free_op_data2);
    }
  }
  break;
  default: 
  value = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var);
  break;
  }
  tmp___5 = __builtin_expect((long )((unsigned int )var_ptr == (unsigned int )((void *)0)), 0L);
  if (tmp___5) {
    zend_error_noreturn(1, "Cannot use assign-op operators with overloaded objects nor string offsets");
  } else {

  }
  tmp___6 = __builtin_expect((long )((unsigned int )*var_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
  if (tmp___6) {
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      while (1) {
        __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t->var.ptr = & executor_globals.uninitialized_zval;
        __t->var.ptr_ptr = & __t->var.ptr;
        break;
      }
    } else {

    }
    if (opline->extended_value == 147UL) {
      (execute_data->opline) ++;
    } else {

    }
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  tmp___9 = zval_isref_p(*var_ptr);
  if (tmp___9) {

  } else {
    while (1) {
      tmp___8 = zval_refcount_p(*var_ptr);
      if (tmp___8 > 1U) {
        zval_delref_p(*var_ptr);
        while (1) {
          tmp___7 = _emalloc(sizeof(zval_gc_info ));
          new_zv = (zval *)tmp___7;
          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            new_zv->value = (*var_ptr)->value;
            new_zv->type = (*var_ptr)->type;
            break;
          }
          zval_set_refcount_p(new_zv, 1U);
          zval_unset_isref_p(new_zv);
          break;
        }
        *var_ptr = new_zv;
        _zval_copy_ctor(new_zv);
      } else {

      }
      break;
    }
  }
  tmp___11 = __builtin_expect((long )((int )(*var_ptr)->type == 5), 0L);
  if (tmp___11) {
    if (((*var_ptr)->value.obj.handlers)->get) {
      if (((*var_ptr)->value.obj.handlers)->set) {
        tmp___10 = (*(((*var_ptr)->value.obj.handlers)->get))(*var_ptr);
        objval = tmp___10;
        zval_addref_p(objval);
        (*binary_op)(objval, objval, value);
        (*(((*var_ptr)->value.obj.handlers)->set))(var_ptr, objval);
        i_zval_ptr_dtor(objval);
      } else {
        (*binary_op)(*var_ptr, *var_ptr, value);
      }
    } else {
      (*binary_op)(*var_ptr, *var_ptr, value);
    }
  } else {
    (*binary_op)(*var_ptr, *var_ptr, value);
  }
  if (! ((int )opline->result_type & (1 << 5))) {
    zval_addref_p(*var_ptr);
    while (1) {
      __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
      __t___0->var.ptr = *var_ptr;
      __t___0->var.ptr_ptr = & __t___0->var.ptr;
      break;
    }
  } else {

  }
  if (opline->extended_value == 147UL) {
    if (free_op_data1.var) {
      if ((unsigned long )free_op_data1.var & 1UL) {
        _zval_dtor((zval *)((unsigned long )free_op_data1.var & 4294967294UL));
      } else {
        i_zval_ptr_dtor(free_op_data1.var);
      }
    } else {

    }
    if (free_op_data2.var) {
      i_zval_ptr_dtor(free_op_data2.var);
    } else {

    }
    (execute_data->opline) ++;
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_ADD_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_CV((int (*)(zval *result , zval *op1 , zval *op2 ))(& add_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SUB_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_CV((int (*)(zval *result , zval *op1 , zval *op2 ))(& sub_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_MUL_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_CV((int (*)(zval *result , zval *op1 , zval *op2 ))(& mul_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_DIV_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_CV((int (*)(zval *result , zval *op1 , zval *op2 ))(& div_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_MOD_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_CV((int (*)(zval *result , zval *op1 , zval *op2 ))(& mod_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SL_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_CV((int (*)(zval *result , zval *op1 , zval *op2 ))(& shift_left_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SR_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_CV((int (*)(zval *result , zval *op1 , zval *op2 ))(& shift_right_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_CONCAT_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_CV((int (*)(zval *result , zval *op1 , zval *op2 ))(& concat_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_OR_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_CV((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_or_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_AND_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_CV((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_and_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_BW_XOR_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_binary_assign_op_helper_SPEC_CV_CV((int (*)(zval *result , zval *op1 , zval *op2 ))(& bitwise_xor_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) zend_pre_incdec_property_helper_SPEC_CV_CV)(int (*incdec_op)(zval * ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **object_ptr ;
  zval *object ;
  zval *property ;
  zval **retval ;
  int have_get_ptr ;
  long tmp ;
  long tmp___0 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zval **zptr ;
  zend_literal *tmp___2 ;
  zval **tmp___3 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_uint tmp___5 ;
  zend_bool tmp___6 ;
  zval *z ;
  zend_literal *tmp___7 ;
  zval *tmp___8 ;
  zval *value ;
  zval *tmp___9 ;
  zend_uint tmp___10 ;
  long tmp___11 ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___12 ;
  zend_uint tmp___13 ;
  zend_bool tmp___14 ;
  zend_literal *tmp___15 ;

  {
  opline = execute_data->opline;
  have_get_ptr = 0;
  object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var);
  property = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  retval = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
  if (1 << 4 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot increment/decrement overloaded objects nor string offsets");
    } else {

    }
  } else {

  }
  make_real_object(object_ptr);
  object = *object_ptr;
  tmp___0 = __builtin_expect((long )((int )object->type != 5), 0L);
  if (tmp___0) {
    zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
    if (! ((int )opline->result_type & (1 << 5))) {
      zval_addref_p(& executor_globals.uninitialized_zval);
      *retval = & executor_globals.uninitialized_zval;
    } else {

    }
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  if ((object->value.obj.handlers)->get_property_ptr_ptr) {
    if (1 << 4 == 1) {
      tmp___2 = opline->op2.literal;
    } else {
      tmp___2 = (zend_literal *)((void *)0);
    }
    tmp___3 = (*((object->value.obj.handlers)->get_property_ptr_ptr))(object, property, (struct _zend_literal  const  *)tmp___2);
    zptr = tmp___3;
    if ((unsigned int )zptr != (unsigned int )((void *)0)) {
      tmp___6 = zval_isref_p(*zptr);
      if (tmp___6) {

      } else {
        while (1) {
          tmp___5 = zval_refcount_p(*zptr);
          if (tmp___5 > 1U) {
            zval_delref_p(*zptr);
            while (1) {
              tmp___4 = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp___4;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*zptr)->value;
                new_zv->type = (*zptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *zptr = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
      have_get_ptr = 1;
      (*incdec_op)(*zptr);
      if (! ((int )opline->result_type & (1 << 5))) {
        *retval = *zptr;
        zval_addref_p(*retval);
      } else {

      }
    } else {

    }
  } else {

  }
  if (! have_get_ptr) {
    if ((object->value.obj.handlers)->read_property) {
      if ((object->value.obj.handlers)->write_property) {
        if (1 << 4 == 1) {
          tmp___7 = opline->op2.literal;
        } else {
          tmp___7 = (zend_literal *)((void *)0);
        }
        tmp___8 = (*((object->value.obj.handlers)->read_property))(object, property, 0, (struct _zend_literal  const  *)tmp___7);
        z = tmp___8;
        tmp___11 = __builtin_expect((long )((int )z->type == 5), 0L);
        if (tmp___11) {
          if ((z->value.obj.handlers)->get) {
            tmp___9 = (*((z->value.obj.handlers)->get))(z);
            value = tmp___9;
            tmp___10 = zval_refcount_p(z);
            if (tmp___10 == 0U) {
              if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                gc_remove_zval_from_buffer(z);
              } else {

              }
              _zval_dtor(z);
              while (1) {
                if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                  gc_remove_zval_from_buffer(z);
                } else {

                }
                _efree((void *)z);
                break;
              }
            } else {

            }
            z = value;
          } else {

          }
        } else {

        }
        zval_addref_p(z);
        tmp___14 = zval_isref_p(z);
        if (tmp___14) {

        } else {
          while (1) {
            tmp___13 = zval_refcount_p(z);
            if (tmp___13 > 1U) {
              zval_delref_p(z);
              while (1) {
                tmp___12 = _emalloc(sizeof(zval_gc_info ));
                new_zv___0 = (zval *)tmp___12;
                ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv___0->value = z->value;
                  new_zv___0->type = z->type;
                  break;
                }
                zval_set_refcount_p(new_zv___0, 1U);
                zval_unset_isref_p(new_zv___0);
                break;
              }
              z = new_zv___0;
              _zval_copy_ctor(new_zv___0);
            } else {

            }
            break;
          }
        }
        (*incdec_op)(z);
        *retval = z;
        if (1 << 4 == 1) {
          tmp___15 = opline->op2.literal;
        } else {
          tmp___15 = (zend_literal *)((void *)0);
        }
        (*((object->value.obj.handlers)->write_property))(object, property, z, (struct _zend_literal  const  *)tmp___15);
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(*retval);
        } else {

        }
        i_zval_ptr_dtor(z);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
      if (! ((int )opline->result_type & (1 << 5))) {
        zval_addref_p(& executor_globals.uninitialized_zval);
        *retval = & executor_globals.uninitialized_zval;
      } else {

      }
    }
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_PRE_INC_OBJ_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_pre_incdec_property_helper_SPEC_CV_CV((int (*)(zval * ))(& increment_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_PRE_DEC_OBJ_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_pre_incdec_property_helper_SPEC_CV_CV((int (*)(zval * ))(& decrement_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) zend_post_incdec_property_helper_SPEC_CV_CV)(int (*incdec_op)(zval * ) , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **object_ptr ;
  zval *object ;
  zval *property ;
  zval *retval ;
  int have_get_ptr ;
  long tmp ;
  long tmp___0 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zval **zptr ;
  zend_literal *tmp___2 ;
  zval **tmp___3 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_uint tmp___5 ;
  zend_bool tmp___6 ;
  zval *z ;
  zend_literal *tmp___7 ;
  zval *tmp___8 ;
  zval *z_copy ;
  zval *value ;
  zval *tmp___9 ;
  zend_uint tmp___10 ;
  long tmp___11 ;
  void __attribute__((__visibility__("default")))  *tmp___12 ;
  zend_literal *tmp___13 ;

  {
  opline = execute_data->opline;
  have_get_ptr = 0;
  object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var);
  property = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  retval = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var;
  if (1 << 4 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot increment/decrement overloaded objects nor string offsets");
    } else {

    }
  } else {

  }
  make_real_object(object_ptr);
  object = *object_ptr;
  tmp___0 = __builtin_expect((long )((int )object->type != 5), 0L);
  if (tmp___0) {
    zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
    retval->type = (unsigned char)0;
    (execute_data->opline) ++;
    return (0);
  } else {

  }
  if ((object->value.obj.handlers)->get_property_ptr_ptr) {
    if (1 << 4 == 1) {
      tmp___2 = opline->op2.literal;
    } else {
      tmp___2 = (zend_literal *)((void *)0);
    }
    tmp___3 = (*((object->value.obj.handlers)->get_property_ptr_ptr))(object, property, (struct _zend_literal  const  *)tmp___2);
    zptr = tmp___3;
    if ((unsigned int )zptr != (unsigned int )((void *)0)) {
      have_get_ptr = 1;
      tmp___6 = zval_isref_p(*zptr);
      if (tmp___6) {

      } else {
        while (1) {
          tmp___5 = zval_refcount_p(*zptr);
          if (tmp___5 > 1U) {
            zval_delref_p(*zptr);
            while (1) {
              tmp___4 = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp___4;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*zptr)->value;
                new_zv->type = (*zptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *zptr = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
      while (1) {
        retval->value = (*zptr)->value;
        retval->type = (*zptr)->type;
        break;
      }
      _zval_copy_ctor(retval);
      (*incdec_op)(*zptr);
    } else {

    }
  } else {

  }
  if (! have_get_ptr) {
    if ((object->value.obj.handlers)->read_property) {
      if ((object->value.obj.handlers)->write_property) {
        if (1 << 4 == 1) {
          tmp___7 = opline->op2.literal;
        } else {
          tmp___7 = (zend_literal *)((void *)0);
        }
        tmp___8 = (*((object->value.obj.handlers)->read_property))(object, property, 0, (struct _zend_literal  const  *)tmp___7);
        z = tmp___8;
        tmp___11 = __builtin_expect((long )((int )z->type == 5), 0L);
        if (tmp___11) {
          if ((z->value.obj.handlers)->get) {
            tmp___9 = (*((z->value.obj.handlers)->get))(z);
            value = tmp___9;
            tmp___10 = zval_refcount_p(z);
            if (tmp___10 == 0U) {
              if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                gc_remove_zval_from_buffer(z);
              } else {

              }
              _zval_dtor(z);
              while (1) {
                if ((gc_root_buffer *)((unsigned long )((zval_gc_info *)z)->u.buffered & 4294967292UL)) {
                  gc_remove_zval_from_buffer(z);
                } else {

                }
                _efree((void *)z);
                break;
              }
            } else {

            }
            z = value;
          } else {

          }
        } else {

        }
        while (1) {
          retval->value = z->value;
          retval->type = z->type;
          break;
        }
        _zval_copy_ctor(retval);
        while (1) {
          tmp___12 = _emalloc(sizeof(zval_gc_info ));
          z_copy = (zval *)tmp___12;
          ((zval_gc_info *)z_copy)->u.buffered = (gc_root_buffer *)((void *)0);
          break;
        }
        while (1) {
          while (1) {
            z_copy->value = z->value;
            z_copy->type = z->type;
            break;
          }
          zval_set_refcount_p(z_copy, 1U);
          zval_unset_isref_p(z_copy);
          break;
        }
        _zval_copy_ctor(z_copy);
        (*incdec_op)(z_copy);
        zval_addref_p(z);
        if (1 << 4 == 1) {
          tmp___13 = opline->op2.literal;
        } else {
          tmp___13 = (zend_literal *)((void *)0);
        }
        (*((object->value.obj.handlers)->write_property))(object, property, z_copy, (struct _zend_literal  const  *)tmp___13);
        i_zval_ptr_dtor(z_copy);
        i_zval_ptr_dtor(z);
      } else {
        zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
        retval->type = (unsigned char)0;
      }
    } else {
      zend_error(1 << 1L, "Attempt to increment/decrement property of non-object");
      retval->type = (unsigned char)0;
    }
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_POST_INC_OBJ_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_post_incdec_property_helper_SPEC_CV_CV((int (*)(zval * ))(& increment_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_POST_DEC_OBJ_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_post_incdec_property_helper_SPEC_CV_CV((int (*)(zval * ))(& decrement_function), execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_R_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **container ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  if (opline->extended_value & 134217728UL) {
    if (1 << 4 != 1 << 4) {
      if (((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr) {
        zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr));
      } else {

      }
    } else {

    }
  } else {

  }
  container = _get_zval_ptr_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  zend_fetch_dimension_address_read((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, tmp, 1 << 4, 0);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_W_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **container ;
  long tmp ;
  zval *tmp___0 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zend_uint tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___6 ;
  zval **retval_ptr ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___7 ;
  zend_uint tmp___8 ;
  zend_bool tmp___9 ;
  long tmp___10 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, tmp___0, 1 << 4, 1);
  if (1 << 4 == 1 << 2) {
    if (0) {
      tmp___5 = zval_refcount_p(free_op1.var);
      if (tmp___5 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___6 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___6 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___3 = zval_isref_p(__t->var.ptr);
                if (tmp___3) {

                } else {
                  tmp___4 = zval_refcount_p(__t->var.ptr);
                  if (tmp___4 > 2U) {
                    while (1) {
                      tmp___2 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___2 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___1 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___1;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  tmp___10 = __builtin_expect((long )(opline->extended_value != 0UL), 0L);
  if (tmp___10) {
    retval_ptr = ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr;
    if (retval_ptr) {
      zval_delref_p(*retval_ptr);
      tmp___9 = zval_isref_p(*retval_ptr);
      if (tmp___9) {

      } else {
        while (1) {
          tmp___8 = zval_refcount_p(*retval_ptr);
          if (tmp___8 > 1U) {
            zval_delref_p(*retval_ptr);
            while (1) {
              tmp___7 = _emalloc(sizeof(zval_gc_info ));
              new_zv___0 = (zval *)tmp___7;
              ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv___0->value = (*retval_ptr)->value;
                new_zv___0->type = (*retval_ptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv___0, 1U);
              zval_unset_isref_p(new_zv___0);
              break;
            }
            *retval_ptr = new_zv___0;
            _zval_copy_ctor(new_zv___0);
          } else {

          }
          break;
        }
        zval_set_isref_p(*retval_ptr);
      }
      zval_addref_p(*retval_ptr);
    } else {

    }
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_RW_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **container ;
  long tmp ;
  zval *tmp___0 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zend_uint tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___6 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, tmp___0, 1 << 4, 2);
  if (1 << 4 == 1 << 2) {
    if (0) {
      tmp___5 = zval_refcount_p(free_op1.var);
      if (tmp___5 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___6 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___6 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___3 = zval_isref_p(__t->var.ptr);
                if (tmp___3) {

                } else {
                  tmp___4 = zval_refcount_p(__t->var.ptr);
                  if (tmp___4 > 2U) {
                    while (1) {
                      tmp___2 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___2 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___1 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___1;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_IS_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **container ;
  zval *tmp ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_cv_BP_VAR_IS(execute_data->CVs, opline->op1.var);
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  zend_fetch_dimension_address_read((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, tmp, 1 << 4, 3);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **container ;
  long tmp ;
  zval *tmp___0 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zend_uint tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___6 ;
  zval *tmp___7 ;
  unsigned int tmp___8 ;

  {
  opline = execute_data->opline;
  if (execute_data->fbc) {
    if ((execute_data->fbc)->common.arg_info) {
      if ((opline->extended_value & 1048575UL) <= (unsigned long )(execute_data->fbc)->common.num_args) {
        tmp___8 = (unsigned int )((int )((execute_data->fbc)->common.arg_info + ((opline->extended_value & 1048575UL) - 1UL))->pass_by_reference & 3);
      } else {
        tmp___8 = (execute_data->fbc)->common.fn_flags & 50331648U;
      }
    } else {
      tmp___8 = (execute_data->fbc)->common.fn_flags & 50331648U;
    }
    if (tmp___8) {
      container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var);
      if (1 << 4 == 1 << 2) {
        tmp = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
        if (tmp) {
          zend_error_noreturn(1, "Cannot use string offset as an array");
        } else {

        }
      } else {

      }
      tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
      zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, tmp___0, 1 << 4, 1);
      if (1 << 4 == 1 << 2) {
        if (0) {
          tmp___5 = zval_refcount_p(free_op1.var);
          if (tmp___5 == 1U) {
            if ((int )(free_op1.var)->type != 5) {
              goto _L;
            } else {
              tmp___6 = zend_objects_store_get_refcount(free_op1.var);
              if (tmp___6 == (zend_uint __attribute__((__visibility__("default")))  )1) {
                _L: /* CIL Label */ 
                while (1) {
                  __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
                  if (__t->var.ptr_ptr) {
                    __t->var.ptr = *(__t->var.ptr_ptr);
                    __t->var.ptr_ptr = & __t->var.ptr;
                    tmp___3 = zval_isref_p(__t->var.ptr);
                    if (tmp___3) {

                    } else {
                      tmp___4 = zval_refcount_p(__t->var.ptr);
                      if (tmp___4 > 2U) {
                        while (1) {
                          tmp___2 = zval_refcount_p(*(__t->var.ptr_ptr));
                          if (tmp___2 > 1U) {
                            zval_delref_p(*(__t->var.ptr_ptr));
                            while (1) {
                              tmp___1 = _emalloc(sizeof(zval_gc_info ));
                              new_zv = (zval *)tmp___1;
                              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                              break;
                            }
                            while (1) {
                              while (1) {
                                new_zv->value = (*(__t->var.ptr_ptr))->value;
                                new_zv->type = (*(__t->var.ptr_ptr))->type;
                                break;
                              }
                              zval_set_refcount_p(new_zv, 1U);
                              zval_unset_isref_p(new_zv);
                              break;
                            }
                            *(__t->var.ptr_ptr) = new_zv;
                            _zval_copy_ctor(new_zv);
                          } else {

                          }
                          break;
                        }
                      } else {

                      }
                    }
                  } else {

                  }
                  break;
                }
              } else {

              }
            }
          } else {

          }
        } else {

        }
      } else {

      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if (1 << 4 == 1 << 3) {
      zend_error_noreturn(1, "Cannot use [] for reading");
    } else {

    }
    container = _get_zval_ptr_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
    tmp___7 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
    zend_fetch_dimension_address_read((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, tmp___7, 1 << 4, 0);
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_DIM_UNSET_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval **container ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  long tmp___2 ;
  zval *tmp___3 ;
  temp_variable *__t ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zend_uint tmp___5 ;
  zend_bool tmp___6 ;
  zend_uint tmp___7 ;
  zend_uint tmp___8 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___9 ;
  zend_free_op free_res ;
  zval **retval_ptr ;
  zval *new_zv___1 ;
  void __attribute__((__visibility__("default")))  *tmp___10 ;
  zend_uint tmp___11 ;
  zend_bool tmp___12 ;
  long tmp___13 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 4) {
    if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
      tmp___1 = zval_isref_p(*container);
      if (tmp___1) {

      } else {
        while (1) {
          tmp___0 = zval_refcount_p(*container);
          if (tmp___0 > 1U) {
            zval_delref_p(*container);
            while (1) {
              tmp = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*container)->value;
                new_zv->type = (*container)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *container = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
    } else {

    }
  } else {

  }
  if (1 << 4 == 1 << 2) {
    tmp___2 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___2) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  tmp___3 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, tmp___3, 1 << 4, 6);
  if (1 << 4 == 1 << 2) {
    if (0) {
      tmp___8 = zval_refcount_p(free_op1.var);
      if (tmp___8 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___9 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___9 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___6 = zval_isref_p(__t->var.ptr);
                if (tmp___6) {

                } else {
                  tmp___7 = zval_refcount_p(__t->var.ptr);
                  if (tmp___7 > 2U) {
                    while (1) {
                      tmp___5 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___5 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___4 = _emalloc(sizeof(zval_gc_info ));
                          new_zv___0 = (zval *)tmp___4;
                          ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv___0->value = (*(__t->var.ptr_ptr))->value;
                            new_zv___0->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv___0, 1U);
                          zval_unset_isref_p(new_zv___0);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv___0;
                        _zval_copy_ctor(new_zv___0);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  tmp___13 = __builtin_expect((long )((unsigned int )((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr == (unsigned int )((void *)0)), 0L);
  if (tmp___13) {
    zend_error_noreturn(1, "Cannot unset string offsets");
  } else {
    retval_ptr = ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr;
    zend_pzval_unlock_func(*retval_ptr, & free_res, 1);
    if ((unsigned int )retval_ptr != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
      tmp___12 = zval_isref_p(*retval_ptr);
      if (tmp___12) {

      } else {
        while (1) {
          tmp___11 = zval_refcount_p(*retval_ptr);
          if (tmp___11 > 1U) {
            zval_delref_p(*retval_ptr);
            while (1) {
              tmp___10 = _emalloc(sizeof(zval_gc_info ));
              new_zv___1 = (zval *)tmp___10;
              ((zval_gc_info *)new_zv___1)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv___1->value = (*retval_ptr)->value;
                new_zv___1->type = (*retval_ptr)->type;
                break;
              }
              zval_set_refcount_p(new_zv___1, 1U);
              zval_unset_isref_p(new_zv___1);
              break;
            }
            *retval_ptr = new_zv___1;
            _zval_copy_ctor(new_zv___1);
          } else {

          }
          break;
        }
      }
    } else {

    }
    zval_addref_p(*retval_ptr);
    if (free_res.var) {
      i_zval_ptr_dtor(free_res.var);
    } else {

    }
    (execute_data->opline) ++;
    return (0);
  }
}
}
static int ( __attribute__((__fastcall__)) zend_fetch_property_address_read_helper_SPEC_CV_CV)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *container ;
  zval *offset ;
  temp_variable *__t ;
  zval *retval ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_literal *tmp___0 ;
  temp_variable *__t___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  offset = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___1 = __builtin_expect((long )((int )container->type != 5), 0L);
  if (tmp___1) {
    goto _L;
  } else {
    tmp___2 = __builtin_expect((long )((unsigned int )(container->value.obj.handlers)->read_property == (unsigned int )((void *)0)), 0L);
    if (tmp___2) {
      _L: /* CIL Label */ 
      zend_error(1 << 3L, "Trying to get property of non-object");
      zval_addref_p(& executor_globals.uninitialized_zval);
      while (1) {
        __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t->var.ptr = & executor_globals.uninitialized_zval;
        __t->var.ptr_ptr = & __t->var.ptr;
        break;
      }
    } else {
      if (1 << 4 == 1) {
        tmp___0 = opline->op2.literal;
      } else {
        tmp___0 = (zend_literal *)((void *)0);
      }
      retval = (*((container->value.obj.handlers)->read_property))(container, offset, 0, (struct _zend_literal  const  *)tmp___0);
      zval_addref_p(retval);
      while (1) {
        __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t___0->var.ptr = retval;
        __t___0->var.ptr_ptr = & __t___0->var.ptr;
        break;
      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_R_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_fetch_property_address_read_helper_SPEC_CV_CV(execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_W_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *property ;
  zval **container ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zend_literal *tmp___1 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_uint tmp___3 ;
  zend_bool tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint tmp___6 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___7 ;
  zval **retval_ptr ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___8 ;
  zend_uint tmp___9 ;
  zend_bool tmp___10 ;

  {
  opline = execute_data->opline;
  property = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  if (1 << 4 == 1 << 2) {
    if (opline->extended_value & 134217728UL) {
      zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr));
      ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr = *(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr);
    } else {

    }
  } else {

  }
  container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  if (1 << 4 == 1) {
    tmp___1 = opline->op2.literal;
  } else {
    tmp___1 = (zend_literal *)((void *)0);
  }
  zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)tmp___1, 1);
  if (1 << 4 == 1 << 2) {
    if (0) {
      tmp___6 = zval_refcount_p(free_op1.var);
      if (tmp___6 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___7 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___7 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___4 = zval_isref_p(__t->var.ptr);
                if (tmp___4) {

                } else {
                  tmp___5 = zval_refcount_p(__t->var.ptr);
                  if (tmp___5 > 2U) {
                    while (1) {
                      tmp___3 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___3 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___2 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___2;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  if (opline->extended_value & 67108864UL) {
    retval_ptr = ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr;
    zval_delref_p(*retval_ptr);
    tmp___10 = zval_isref_p(*retval_ptr);
    if (tmp___10) {

    } else {
      while (1) {
        tmp___9 = zval_refcount_p(*retval_ptr);
        if (tmp___9 > 1U) {
          zval_delref_p(*retval_ptr);
          while (1) {
            tmp___8 = _emalloc(sizeof(zval_gc_info ));
            new_zv___0 = (zval *)tmp___8;
            ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv___0->value = (*retval_ptr)->value;
              new_zv___0->type = (*retval_ptr)->type;
              break;
            }
            zval_set_refcount_p(new_zv___0, 1U);
            zval_unset_isref_p(new_zv___0);
            break;
          }
          *retval_ptr = new_zv___0;
          _zval_copy_ctor(new_zv___0);
        } else {

        }
        break;
      }
      zval_set_isref_p(*retval_ptr);
    }
    zval_addref_p(*retval_ptr);
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr = *(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr);
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_RW_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *property ;
  zval **container ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zend_literal *tmp___1 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_uint tmp___3 ;
  zend_bool tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint tmp___6 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___7 ;

  {
  opline = execute_data->opline;
  property = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  if (1 << 4 == 1) {
    tmp___1 = opline->op2.literal;
  } else {
    tmp___1 = (zend_literal *)((void *)0);
  }
  zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)tmp___1, 2);
  if (1 << 4 == 1 << 2) {
    if (0) {
      tmp___6 = zval_refcount_p(free_op1.var);
      if (tmp___6 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___7 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___7 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___4 = zval_isref_p(__t->var.ptr);
                if (tmp___4) {

                } else {
                  tmp___5 = zval_refcount_p(__t->var.ptr);
                  if (tmp___5 > 2U) {
                    while (1) {
                      tmp___3 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___3 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___2 = _emalloc(sizeof(zval_gc_info ));
                          new_zv = (zval *)tmp___2;
                          ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv->value = (*(__t->var.ptr_ptr))->value;
                            new_zv->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv, 1U);
                          zval_unset_isref_p(new_zv);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv;
                        _zval_copy_ctor(new_zv);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_IS_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *container ;
  zval *offset ;
  temp_variable *__t ;
  zval *retval ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_literal *tmp___0 ;
  temp_variable *__t___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_cv_BP_VAR_IS(execute_data->CVs, opline->op1.var);
  offset = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___1 = __builtin_expect((long )((int )container->type != 5), 0L);
  if (tmp___1) {
    goto _L;
  } else {
    tmp___2 = __builtin_expect((long )((unsigned int )(container->value.obj.handlers)->read_property == (unsigned int )((void *)0)), 0L);
    if (tmp___2) {
      _L: /* CIL Label */ 
      zval_addref_p(& executor_globals.uninitialized_zval);
      while (1) {
        __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t->var.ptr = & executor_globals.uninitialized_zval;
        __t->var.ptr_ptr = & __t->var.ptr;
        break;
      }
    } else {
      if (1 << 4 == 1) {
        tmp___0 = opline->op2.literal;
      } else {
        tmp___0 = (zend_literal *)((void *)0);
      }
      retval = (*((container->value.obj.handlers)->read_property))(container, offset, 3, (struct _zend_literal  const  *)tmp___0);
      zval_addref_p(retval);
      while (1) {
        __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
        __t___0->var.ptr = retval;
        __t___0->var.ptr_ptr = & __t___0->var.ptr;
        break;
      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zval *property ;
  zval **container ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zend_literal *tmp___1 ;
  temp_variable *__t ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_uint tmp___3 ;
  zend_bool tmp___4 ;
  zend_uint tmp___5 ;
  zend_uint tmp___6 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;

  {
  opline = execute_data->opline;
  if (execute_data->fbc) {
    if ((execute_data->fbc)->common.arg_info) {
      if ((opline->extended_value & 1048575UL) <= (unsigned long )(execute_data->fbc)->common.num_args) {
        tmp___9 = (unsigned int )((int )((execute_data->fbc)->common.arg_info + ((opline->extended_value & 1048575UL) - 1UL))->pass_by_reference & 3);
      } else {
        tmp___9 = (execute_data->fbc)->common.fn_flags & 50331648U;
      }
    } else {
      tmp___9 = (execute_data->fbc)->common.fn_flags & 50331648U;
    }
    if (tmp___9) {
      property = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
      container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var);
      if (1 << 4 == 1 << 2) {
        tmp___0 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
        if (tmp___0) {
          zend_error_noreturn(1, "Cannot use string offset as an object");
        } else {

        }
      } else {

      }
      if (1 << 4 == 1) {
        tmp___1 = opline->op2.literal;
      } else {
        tmp___1 = (zend_literal *)((void *)0);
      }
      zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)tmp___1, 1);
      if (1 << 4 == 1 << 2) {
        if (0) {
          tmp___6 = zval_refcount_p(free_op1.var);
          if (tmp___6 == 1U) {
            if ((int )(free_op1.var)->type != 5) {
              goto _L;
            } else {
              tmp___7 = zend_objects_store_get_refcount(free_op1.var);
              if (tmp___7 == (zend_uint __attribute__((__visibility__("default")))  )1) {
                _L: /* CIL Label */ 
                while (1) {
                  __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
                  if (__t->var.ptr_ptr) {
                    __t->var.ptr = *(__t->var.ptr_ptr);
                    __t->var.ptr_ptr = & __t->var.ptr;
                    tmp___4 = zval_isref_p(__t->var.ptr);
                    if (tmp___4) {

                    } else {
                      tmp___5 = zval_refcount_p(__t->var.ptr);
                      if (tmp___5 > 2U) {
                        while (1) {
                          tmp___3 = zval_refcount_p(*(__t->var.ptr_ptr));
                          if (tmp___3 > 1U) {
                            zval_delref_p(*(__t->var.ptr_ptr));
                            while (1) {
                              tmp___2 = _emalloc(sizeof(zval_gc_info ));
                              new_zv = (zval *)tmp___2;
                              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                              break;
                            }
                            while (1) {
                              while (1) {
                                new_zv->value = (*(__t->var.ptr_ptr))->value;
                                new_zv->type = (*(__t->var.ptr_ptr))->type;
                                break;
                              }
                              zval_set_refcount_p(new_zv, 1U);
                              zval_unset_isref_p(new_zv);
                              break;
                            }
                            *(__t->var.ptr_ptr) = new_zv;
                            _zval_copy_ctor(new_zv);
                          } else {

                          }
                          break;
                        }
                      } else {

                      }
                    }
                  } else {

                  }
                  break;
                }
              } else {

              }
            }
          } else {

          }
        } else {

        }
      } else {

      }
      (execute_data->opline) ++;
      return (0);
    } else {
      tmp___8 = zend_fetch_property_address_read_helper_SPEC_CV_CV(execute_data);
      return (tmp___8);
    }
  } else {
    tmp___8 = zend_fetch_property_address_read_helper_SPEC_CV_CV(execute_data);
    return (tmp___8);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_FETCH_OBJ_UNSET_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op1 ;
  zend_free_op free_res ;
  zval **container ;
  zval *property ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  long tmp___3 ;
  zend_literal *tmp___4 ;
  temp_variable *__t ;
  zval *new_zv___0 ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  zend_uint tmp___6 ;
  zend_bool tmp___7 ;
  zend_uint tmp___8 ;
  zend_uint tmp___9 ;
  zend_uint __attribute__((__visibility__("default")))  tmp___10 ;
  zval *new_zv___1 ;
  void __attribute__((__visibility__("default")))  *tmp___11 ;
  zend_uint tmp___12 ;
  zend_bool tmp___13 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data->CVs, opline->op1.var);
  property = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  if (1 << 4 == 1 << 4) {
    if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
      tmp___1 = zval_isref_p(*container);
      if (tmp___1) {

      } else {
        while (1) {
          tmp___0 = zval_refcount_p(*container);
          if (tmp___0 > 1U) {
            zval_delref_p(*container);
            while (1) {
              tmp = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*container)->value;
                new_zv->type = (*container)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *container = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
    } else {

    }
  } else {

  }
  if (1 << 4 == 1 << 2) {
    tmp___3 = __builtin_expect((long )((unsigned int )container == (unsigned int )((void *)0)), 0L);
    if (tmp___3) {
      zend_error_noreturn(1, "Cannot use string offset as an object");
    } else {

    }
  } else {

  }
  if (1 << 4 == 1) {
    tmp___4 = opline->op2.literal;
  } else {
    tmp___4 = (zend_literal *)((void *)0);
  }
  zend_fetch_property_address((temp_variable *)((char *)execute_data->Ts + opline->result.var), container, property, (zend_literal const   *)tmp___4, 6);
  if (1 << 4 == 1 << 2) {
    if (0) {
      tmp___9 = zval_refcount_p(free_op1.var);
      if (tmp___9 == 1U) {
        if ((int )(free_op1.var)->type != 5) {
          goto _L;
        } else {
          tmp___10 = zend_objects_store_get_refcount(free_op1.var);
          if (tmp___10 == (zend_uint __attribute__((__visibility__("default")))  )1) {
            _L: /* CIL Label */ 
            while (1) {
              __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
              if (__t->var.ptr_ptr) {
                __t->var.ptr = *(__t->var.ptr_ptr);
                __t->var.ptr_ptr = & __t->var.ptr;
                tmp___7 = zval_isref_p(__t->var.ptr);
                if (tmp___7) {

                } else {
                  tmp___8 = zval_refcount_p(__t->var.ptr);
                  if (tmp___8 > 2U) {
                    while (1) {
                      tmp___6 = zval_refcount_p(*(__t->var.ptr_ptr));
                      if (tmp___6 > 1U) {
                        zval_delref_p(*(__t->var.ptr_ptr));
                        while (1) {
                          tmp___5 = _emalloc(sizeof(zval_gc_info ));
                          new_zv___0 = (zval *)tmp___5;
                          ((zval_gc_info *)new_zv___0)->u.buffered = (gc_root_buffer *)((void *)0);
                          break;
                        }
                        while (1) {
                          while (1) {
                            new_zv___0->value = (*(__t->var.ptr_ptr))->value;
                            new_zv___0->type = (*(__t->var.ptr_ptr))->type;
                            break;
                          }
                          zval_set_refcount_p(new_zv___0, 1U);
                          zval_unset_isref_p(new_zv___0);
                          break;
                        }
                        *(__t->var.ptr_ptr) = new_zv___0;
                        _zval_copy_ctor(new_zv___0);
                      } else {

                      }
                      break;
                    }
                  } else {

                  }
                }
              } else {

              }
              break;
            }
          } else {

          }
        }
      } else {

      }
    } else {

    }
  } else {

  }
  zend_pzval_unlock_func(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr), & free_res, 1);
  if ((unsigned int )((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
    tmp___13 = zval_isref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
    if (tmp___13) {

    } else {
      while (1) {
        tmp___12 = zval_refcount_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
        if (tmp___12 > 1U) {
          zval_delref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
          while (1) {
            tmp___11 = _emalloc(sizeof(zval_gc_info ));
            new_zv___1 = (zval *)tmp___11;
            ((zval_gc_info *)new_zv___1)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_zv___1->value = (*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr))->value;
              new_zv___1->type = (*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr))->type;
              break;
            }
            zval_set_refcount_p(new_zv___1, 1U);
            zval_unset_isref_p(new_zv___1);
            break;
          }
          *(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr) = new_zv___1;
          _zval_copy_ctor(new_zv___1);
        } else {

        }
        break;
      }
    }
  } else {

  }
  zval_addref_p(*(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr_ptr));
  if (free_res.var) {
    i_zval_ptr_dtor(free_res.var);
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_OBJ_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **object_ptr ;
  zval *property_name ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp ;
  long tmp___0 ;
  zend_literal *tmp___1 ;
  zval **tmp___2 ;

  {
  opline = execute_data->opline;
  object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var);
  property_name = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  if (1 << 4 == 1 << 2) {
    tmp___0 = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___0) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  if (1 << 4 == 1) {
    tmp___1 = opline->op2.literal;
  } else {
    tmp___1 = (zend_literal *)((void *)0);
  }
  if (! ((int )opline->result_type & (1 << 5))) {
    tmp___2 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
  } else {
    tmp___2 = (zval **)((void *)0);
  }
  zend_assign_to_object(tmp___2, object_ptr, property_name, (int )(opline + 1)->op1_type, & (opline + 1)->op1, (temp_variable const   *)execute_data->Ts, 136, (zend_literal const   *)tmp___1);
  (execute_data->opline) ++;
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_DIM_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **object_ptr ;
  long tmp ;
  zval *property_name ;
  zval *tmp___0 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_literal *tmp___2 ;
  zval **tmp___3 ;
  zend_free_op free_op_data1 ;
  zend_free_op free_op_data2 ;
  zval *value ;
  zval *dim ;
  zval *tmp___4 ;
  zval **variable_ptr_ptr ;
  zval *retval ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  char const   *__s ;
  int __l ;
  zval *__z ;
  char __attribute__((__visibility__("default")))  *tmp___6 ;
  temp_variable *__t ;
  temp_variable *__t___0 ;
  int tmp___7 ;
  temp_variable *__t___1 ;
  temp_variable *__t___2 ;
  long tmp___8 ;
  long tmp___9 ;

  {
  opline = execute_data->opline;
  object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 2) {
    tmp = __builtin_expect((long )((unsigned int )object_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Cannot use string offset as an array");
    } else {

    }
  } else {

  }
  if ((int )(*object_ptr)->type == 5) {
    tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
    property_name = tmp___0;
    if (1 << 4 == 1) {
      tmp___2 = opline->op2.literal;
    } else {
      tmp___2 = (zend_literal *)((void *)0);
    }
    if (! ((int )opline->result_type & (1 << 5))) {
      tmp___3 = & ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->var.ptr;
    } else {
      tmp___3 = (zval **)((void *)0);
    }
    zend_assign_to_object(tmp___3, object_ptr, property_name, (int )(opline + 1)->op1_type, & (opline + 1)->op1, (temp_variable const   *)execute_data->Ts, 147, (zend_literal const   *)tmp___2);
  } else {
    tmp___4 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
    dim = tmp___4;
    zend_fetch_dimension_address((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var), object_ptr, dim, 1 << 4, 1);
    value = _get_zval_ptr((int )(opline + 1)->op1_type, (znode_op const   *)(& (opline + 1)->op1), (temp_variable const   *)execute_data->Ts, & free_op_data1, 0);
    variable_ptr_ptr = _get_zval_ptr_ptr_var((opline + 1)->op2.var, (temp_variable const   *)execute_data->Ts, & free_op_data2);
    tmp___9 = __builtin_expect((long )((unsigned int )variable_ptr_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___9) {
      tmp___7 = zend_assign_to_string_offset((temp_variable const   *)((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var)), (zval const   *)value, (int )(opline + 1)->op1_type);
      if (tmp___7) {
        if (! ((int )opline->result_type & (1 << 5))) {
          while (1) {
            tmp___5 = _emalloc(sizeof(zval_gc_info ));
            retval = (zval *)tmp___5;
            ((zval_gc_info *)retval)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            __s = (char const   *)((((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var))->str_offset.str)->value.str.val + ((temp_variable *)((char *)execute_data->Ts + (opline + 1)->op2.var))->str_offset.offset);
            __l = 1;
            __z = retval;
            __z->value.str.len = __l;
            tmp___6 = _estrndup(__s, (unsigned int )__l);
            __z->value.str.val = (char *)tmp___6;
            __z->type = (unsigned char)6;
            break;
          }
          retval->refcount__gc = 1U;
          retval->is_ref__gc = (unsigned char)0;
          while (1) {
            __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t->var.ptr = retval;
            __t->var.ptr_ptr = & __t->var.ptr;
            break;
          }
        } else {

        }
      } else {
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          while (1) {
            __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___0->var.ptr = & executor_globals.uninitialized_zval;
            __t___0->var.ptr_ptr = & __t___0->var.ptr;
            break;
          }
        } else {

        }
      }
    } else {
      tmp___8 = __builtin_expect((long )((unsigned int )*variable_ptr_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
      if (tmp___8) {
        if ((unsigned long )free_op_data1.var & 1UL) {
          _zval_dtor(value);
        } else {

        }
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          while (1) {
            __t___1 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___1->var.ptr = & executor_globals.uninitialized_zval;
            __t___1->var.ptr_ptr = & __t___1->var.ptr;
            break;
          }
        } else {

        }
      } else {
        if ((int )(opline + 1)->op1_type == 1 << 1) {
          value = zend_assign_tmp_to_variable(variable_ptr_ptr, value);
        } else {
          if ((int )(opline + 1)->op1_type == 1) {
            value = zend_assign_const_to_variable(variable_ptr_ptr, value);
          } else {
            value = zend_assign_to_variable(variable_ptr_ptr, value);
          }
        }
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(value);
          while (1) {
            __t___2 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___2->var.ptr = value;
            __t___2->var.ptr_ptr = & __t___2->var.ptr;
            break;
          }
        } else {

        }
      }
    }
    if (free_op_data2.var) {
      i_zval_ptr_dtor(free_op_data2.var);
    } else {

    }
    if ((unsigned int )free_op_data1.var != (unsigned int )((void *)0)) {
      if (((unsigned long )free_op_data1.var & 1UL) == 0UL) {
        i_zval_ptr_dtor(free_op_data1.var);
      } else {

      }
    } else {

    }
  }
  (execute_data->opline) ++;
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *value ;
  zval **variable_ptr_ptr ;
  zval *retval ;
  void __attribute__((__visibility__("default")))  *tmp ;
  char const   *__s ;
  int __l ;
  zval *__z ;
  char __attribute__((__visibility__("default")))  *tmp___0 ;
  temp_variable *__t ;
  temp_variable *__t___0 ;
  int tmp___1 ;
  temp_variable *__t___1 ;
  temp_variable *__t___2 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  opline = execute_data->opline;
  value = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  variable_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 2) {
    tmp___3 = __builtin_expect((long )((unsigned int )variable_ptr_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___3) {
      tmp___1 = zend_assign_to_string_offset((temp_variable const   *)((temp_variable *)((char *)execute_data->Ts + opline->op1.var)), (zval const   *)value, 1 << 4);
      if (tmp___1) {
        if (! ((int )opline->result_type & (1 << 5))) {
          while (1) {
            tmp = _emalloc(sizeof(zval_gc_info ));
            retval = (zval *)tmp;
            ((zval_gc_info *)retval)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            __s = (char const   *)((((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->str_offset.str)->value.str.val + ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->str_offset.offset);
            __l = 1;
            __z = retval;
            __z->value.str.len = __l;
            tmp___0 = _estrndup(__s, (unsigned int )__l);
            __z->value.str.val = (char *)tmp___0;
            __z->type = (unsigned char)6;
            break;
          }
          retval->refcount__gc = 1U;
          retval->is_ref__gc = (unsigned char)0;
          while (1) {
            __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t->var.ptr = retval;
            __t->var.ptr_ptr = & __t->var.ptr;
            break;
          }
        } else {

        }
      } else {
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          while (1) {
            __t___0 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___0->var.ptr = & executor_globals.uninitialized_zval;
            __t___0->var.ptr_ptr = & __t___0->var.ptr;
            break;
          }
        } else {

        }
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if (1 << 4 == 1 << 2) {
      tmp___2 = __builtin_expect((long )((unsigned int )*variable_ptr_ptr == (unsigned int )(& executor_globals.error_zval)), 0L);
      if (tmp___2) {
        if (! ((int )opline->result_type & (1 << 5))) {
          zval_addref_p(& executor_globals.uninitialized_zval);
          while (1) {
            __t___1 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
            __t___1->var.ptr = & executor_globals.uninitialized_zval;
            __t___1->var.ptr_ptr = & __t___1->var.ptr;
            break;
          }
        } else {

        }
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      if (1 << 4 == 1 << 1) {
        value = zend_assign_tmp_to_variable(variable_ptr_ptr, value);
      } else {
        if (1 << 4 == 1) {
          value = zend_assign_const_to_variable(variable_ptr_ptr, value);
        } else {
          value = zend_assign_to_variable(variable_ptr_ptr, value);
        }
      }
      if (! ((int )opline->result_type & (1 << 5))) {
        zval_addref_p(value);
        while (1) {
          __t___2 = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
          __t___2->var.ptr = value;
          __t___2->var.ptr_ptr = & __t___2->var.ptr;
          break;
        }
      } else {

      }
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ASSIGN_REF_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zend_free_op free_op2 ;
  zval **variable_ptr_ptr ;
  zval **value_ptr_ptr ;
  long tmp ;
  int tmp___0 ;
  zend_bool tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  temp_variable *__t ;

  {
  opline = execute_data->opline;
  value_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op2.var);
  if (1 << 4 == 1 << 2) {
    if (value_ptr_ptr) {
      tmp___1 = zval_isref_p(*value_ptr_ptr);
      if (tmp___1) {
        goto _L___2;
      } else {
        if (opline->extended_value == 1UL) {
          if (! ((temp_variable *)((char *)execute_data->Ts + opline->op2.var))->var.fcall_returned_reference) {
            if ((unsigned int )free_op2.var == (unsigned int )((void *)0)) {
              zval_addref_p(*value_ptr_ptr);
            } else {

            }
            zend_error(1 << 11L, "Only variables should be assigned by reference");
            tmp = __builtin_expect((long )((unsigned int )executor_globals.exception != (unsigned int )((void *)0)), 0L);
            if (tmp) {
              return (0);
            } else {

            }
            tmp___0 = ZEND_ASSIGN_SPEC_CV_CV_HANDLER(execute_data);
            return (tmp___0);
          } else {
            goto _L___2;
          }
        } else {
          goto _L___2;
        }
      }
    } else {
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
    _L___1: /* CIL Label */ 
    _L___0: /* CIL Label */ 
    _L: /* CIL Label */ 
    if (1 << 4 == 1 << 2) {
      if (opline->extended_value == (ulong )(1 << 1)) {
        zval_addref_p(*value_ptr_ptr);
      } else {

      }
    } else {

    }
  }
  if (1 << 4 == 1 << 2) {
    tmp___2 = __builtin_expect((long )((unsigned int )((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr_ptr == (unsigned int )(& ((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr)), 0L);
    if (tmp___2) {
      zend_error_noreturn(1, "Cannot assign by reference to overloaded object");
    } else {

    }
  } else {

  }
  variable_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 2) {
    tmp___3 = __builtin_expect((long )((unsigned int )value_ptr_ptr == (unsigned int )((void *)0)), 0L);
    if (tmp___3) {
      zend_error_noreturn(1, "Cannot create references to/from string offsets nor overloaded objects");
    } else {
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    if (1 << 4 == 1 << 2) {
      tmp___4 = __builtin_expect((long )((unsigned int )variable_ptr_ptr == (unsigned int )((void *)0)), 0L);
      if (tmp___4) {
        zend_error_noreturn(1, "Cannot create references to/from string offsets nor overloaded objects");
      } else {

      }
    } else {

    }
  }
  zend_assign_to_variable_reference(variable_ptr_ptr, value_ptr_ptr);
  if (1 << 4 == 1 << 2) {
    if (opline->extended_value == (ulong )(1 << 1)) {
      zval_delref_p(*variable_ptr_ptr);
    } else {

    }
  } else {

  }
  if (! ((int )opline->result_type & (1 << 5))) {
    zval_addref_p(*variable_ptr_ptr);
    while (1) {
      __t = (temp_variable *)((char *)execute_data->Ts + opline->result.var);
      __t->var.ptr = *variable_ptr_ptr;
      __t->var.ptr_ptr = & __t->var.ptr;
      break;
    }
  } else {

  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_METHOD_CALL_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *function_name ;
  char *function_name_strval ;
  int function_name_strlen ;
  long tmp ;
  zend_class_entry __attribute__((__visibility__("default")))  *tmp___0 ;
  zval *object ;
  long tmp___1 ;
  zend_literal *tmp___2 ;
  zend_class_entry *tmp___3 ;
  zend_class_entry *tmp___4 ;
  char const   *tmp___5 ;
  zend_class_entry *tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  zend_function *tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  zval *this_ptr ;
  void __attribute__((__visibility__("default")))  *tmp___13 ;
  zend_bool tmp___14 ;

  {
  opline = execute_data->opline;
  zend_ptr_stack_3_push(& executor_globals.arg_types_stack, (void *)execute_data->fbc, (void *)execute_data->object, (void *)execute_data->called_scope);
  function_name = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  if (1 << 4 != 1) {
    tmp = __builtin_expect((long )((int )function_name->type != 6), 0L);
    if (tmp) {
      zend_error_noreturn(1, "Method name must be a string");
    } else {

    }
  } else {

  }
  function_name_strval = function_name->value.str.val;
  function_name_strlen = function_name->value.str.len;
  execute_data->object = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  tmp___11 = __builtin_expect((long )((unsigned int )execute_data->object != (unsigned int )((void *)0)), 1L);
  if (tmp___11) {
    tmp___12 = __builtin_expect((long )((int )(execute_data->object)->type == 5), 1L);
    if (tmp___12) {
      tmp___0 = zend_get_class_entry((zval const   *)execute_data->object);
      execute_data->called_scope = (zend_class_entry *)tmp___0;
      if (1 << 4 != 1) {
        goto _L;
      } else {
        if ((unsigned int )*((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) == (unsigned int )execute_data->called_scope) {
          tmp___10 = (zend_function *)*((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U));
        } else {
          tmp___10 = (zend_function *)((void *)0);
        }
        execute_data->fbc = tmp___10;
        if ((unsigned int )tmp___10 == (unsigned int )((void *)0)) {
          _L: /* CIL Label */ 
          object = execute_data->object;
          tmp___1 = __builtin_expect((long )((unsigned int )((execute_data->object)->value.obj.handlers)->get_method == (unsigned int )((void *)0)), 0L);
          if (tmp___1) {
            zend_error_noreturn(1, "Object does not support method calls");
          } else {

          }
          if (1 << 4 == 1) {
            tmp___2 = opline->op2.literal + 1;
          } else {
            tmp___2 = (zend_literal *)((void *)0);
          }
          execute_data->fbc = (*(((execute_data->object)->value.obj.handlers)->get_method))(& execute_data->object, function_name_strval, function_name_strlen, (struct _zend_literal  const  *)tmp___2);
          tmp___7 = __builtin_expect((long )((unsigned int )execute_data->fbc == (unsigned int )((void *)0)), 0L);
          if (tmp___7) {
            if (execute_data->object) {
              if ((int )(execute_data->object)->type == 5) {
                if ((unsigned int )((execute_data->object)->value.obj.handlers)->get_class_entry != (unsigned int )((void *)0)) {
                  tmp___6 = (*(((execute_data->object)->value.obj.handlers)->get_class_entry))((zval const   *)execute_data->object);
                  if (tmp___6) {
                    tmp___4 = (*(((execute_data->object)->value.obj.handlers)->get_class_entry))((zval const   *)execute_data->object);
                    tmp___5 = tmp___4->name;
                  } else {
                    tmp___5 = "";
                  }
                } else {
                  tmp___5 = "";
                }
              } else {
                tmp___5 = "";
              }
            } else {
              tmp___5 = "";
            }
            zend_error_noreturn(1, "Call to undefined method %s::%s()", tmp___5, function_name_strval);
          } else {

          }
          if (1 << 4 == 1) {
            tmp___8 = __builtin_expect((long )(((execute_data->fbc)->common.fn_flags & 6291456U) == 0U), 1L);
            if (tmp___8) {
              tmp___9 = __builtin_expect((long )((unsigned int )execute_data->object == (unsigned int )object), 1L);
              if (tmp___9) {
                while (1) {
                  *((executor_globals.active_op_array)->run_time_cache + (opline->op2.literal)->cache_slot) = (void *)execute_data->called_scope;
                  *((executor_globals.active_op_array)->run_time_cache + ((opline->op2.literal)->cache_slot + 1U)) = (void *)execute_data->fbc;
                  break;
                }
              } else {

              }
            } else {

            }
          } else {

          }
        } else {

        }
      }
    } else {
      zend_error_noreturn(1, "Call to a member function %s() on a non-object", function_name_strval);
    }
  } else {
    zend_error_noreturn(1, "Call to a member function %s() on a non-object", function_name_strval);
  }
  if (((execute_data->fbc)->common.fn_flags & 1U) != 0U) {
    execute_data->object = (zval *)((void *)0);
  } else {
    tmp___14 = zval_isref_p(execute_data->object);
    if (tmp___14) {
      while (1) {
        tmp___13 = _emalloc(sizeof(zval_gc_info ));
        this_ptr = (zval *)tmp___13;
        ((zval_gc_info *)this_ptr)->u.buffered = (gc_root_buffer *)((void *)0);
        break;
      }
      while (1) {
        while (1) {
          this_ptr->value = (execute_data->object)->value;
          this_ptr->type = (execute_data->object)->type;
          break;
        }
        zval_set_refcount_p(this_ptr, 1U);
        zval_unset_isref_p(this_ptr);
        break;
      }
      _zval_copy_ctor(this_ptr);
      execute_data->object = this_ptr;
    } else {
      zval_addref_p(execute_data->object);
    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_CASE_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *tmp ;
  zval *tmp___0 ;

  {
  opline = execute_data->opline;
  if (1 << 4 == 1 << 2) {
    zval_addref_p(((temp_variable *)((char *)execute_data->Ts + opline->op1.var))->var.ptr);
  } else {

  }
  tmp = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  tmp___0 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
  is_equal_function(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, tmp___0, tmp);
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval *expr_ptr ;
  zval **expr_ptr_ptr ;
  zval **tmp ;
  long tmp___0 ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp___1 ;
  zend_uint tmp___2 ;
  zend_bool tmp___3 ;
  zval *new_expr ;
  void __attribute__((__visibility__("default")))  *tmp___4 ;
  zval *new_expr___0 ;
  void __attribute__((__visibility__("default")))  *tmp___5 ;
  zend_bool tmp___6 ;
  zval *offset ;
  zval *tmp___7 ;
  ulong hval ;
  long tmp___8 ;
  register char const   *tmp___9 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___10 ;

  {
  opline = execute_data->opline;
  if (1 << 4 == 1 << 2) {
    goto _L___1;
  } else {
    if (1 << 4 == 1 << 4) {
      _L___1: /* CIL Label */ 
      if (opline->extended_value) {
        tmp = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var);
        expr_ptr_ptr = tmp;
        if (1 << 4 == 1 << 2) {
          tmp___0 = __builtin_expect((long )((unsigned int )expr_ptr_ptr == (unsigned int )((void *)0)), 0L);
          if (tmp___0) {
            zend_error_noreturn(1, "Cannot create references to/from string offsets");
          } else {

          }
        } else {

        }
        tmp___3 = zval_isref_p(*expr_ptr_ptr);
        if (tmp___3) {

        } else {
          while (1) {
            tmp___2 = zval_refcount_p(*expr_ptr_ptr);
            if (tmp___2 > 1U) {
              zval_delref_p(*expr_ptr_ptr);
              while (1) {
                tmp___1 = _emalloc(sizeof(zval_gc_info ));
                new_zv = (zval *)tmp___1;
                ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                break;
              }
              while (1) {
                while (1) {
                  new_zv->value = (*expr_ptr_ptr)->value;
                  new_zv->type = (*expr_ptr_ptr)->type;
                  break;
                }
                zval_set_refcount_p(new_zv, 1U);
                zval_unset_isref_p(new_zv);
                break;
              }
              *expr_ptr_ptr = new_zv;
              _zval_copy_ctor(new_zv);
            } else {

            }
            break;
          }
          zval_set_isref_p(*expr_ptr_ptr);
        }
        expr_ptr = *expr_ptr_ptr;
        zval_addref_p(expr_ptr);
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      expr_ptr = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var);
      if (1 << 4 == 1) {
        goto _L;
      } else {
        tmp___6 = zval_isref_p(expr_ptr);
        if (tmp___6) {
          _L: /* CIL Label */ 
          while (1) {
            tmp___5 = _emalloc(sizeof(zval_gc_info ));
            new_expr___0 = (zval *)tmp___5;
            ((zval_gc_info *)new_expr___0)->u.buffered = (gc_root_buffer *)((void *)0);
            break;
          }
          while (1) {
            while (1) {
              new_expr___0->value = expr_ptr->value;
              new_expr___0->type = expr_ptr->type;
              break;
            }
            zval_set_refcount_p(new_expr___0, 1U);
            zval_unset_isref_p(new_expr___0);
            break;
          }
          expr_ptr = new_expr___0;
          _zval_copy_ctor(expr_ptr);
        } else {
          zval_addref_p(expr_ptr);
        }
      }
    }
  }
  if (1 << 4 != 1 << 3) {
    tmp___7 = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
    offset = tmp___7;
    switch ((int )offset->type) {
    case 2: 
    tmp___8 = zend_dval_to_lval(offset->value.dval);
    hval = (unsigned long )tmp___8;
    goto num_index;
    case 1: 
    case 3: 
    hval = (unsigned long )offset->value.lval;
    num_index: 
    _zend_hash_index_update_or_next_insert(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, hval, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    case 6: 
    if (1 << 4 == 1) {
      hval = ((zend_literal *)offset)->hash_value;
    } else {
      while (1) {
        tmp___9 = (char const   *)offset->value.str.val;
        if ((int const   )*tmp___9 == 45) {
          tmp___9 ++;
        } else {

        }
        if ((int const   )*tmp___9 >= 48) {
          if ((int const   )*tmp___9 <= 57) {
            end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
            if ((int const   )*end != 0) {
              break;
            } else {
              if ((int const   )*tmp___9 == 48) {
                if (offset->value.str.len + 1 > 2) {
                  break;
                } else {
                  goto _L___2;
                }
              } else {
                _L___2: /* CIL Label */ 
                if (end - tmp___9 > 10) {
                  break;
                } else {
                  if (end - tmp___9 == 10) {
                    if ((int const   )*tmp___9 > 50) {
                      break;
                    } else {

                    }
                  } else {

                  }
                }
              }
            }
            hval = (unsigned long )((int const   )*tmp___9 - 48);
            while (1) {
              tmp___9 ++;
              if ((unsigned int )tmp___9 != (unsigned int )end) {
                if ((int const   )*tmp___9 >= 48) {
                  if ((int const   )*tmp___9 <= 57) {

                  } else {
                    break;
                  }
                } else {
                  break;
                }
              } else {
                break;
              }
              hval = hval * 10UL + (ulong )((int const   )*tmp___9 - 48);
            }
            if ((unsigned int )tmp___9 == (unsigned int )end) {
              if ((int )*(offset->value.str.val) == 45) {
                if (hval - 1UL > 2147483647UL) {
                  break;
                } else {

                }
                hval = (unsigned long )(- ((long )hval));
              } else {
                if (hval > 2147483647UL) {
                  break;
                } else {

                }
              }
              goto num_index;
            } else {

            }
          } else {

          }
        } else {

        }
        break;
      }
      if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
        if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
          hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
        } else {
          tmp___10 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___10;
        }
      } else {
        tmp___10 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
        hval = (unsigned long )tmp___10;
      }
    }
    _zend_hash_quick_add_or_update(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    case 0: 
    _zend_hash_add_or_update(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, "", sizeof(""), (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1);
    break;
    default: 
    zend_error(1 << 1L, "Illegal offset type");
    i_zval_ptr_dtor(expr_ptr);
    break;
    }
  } else {
    _zend_hash_index_update_or_next_insert(((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.ht, 0UL, (void *)(& expr_ptr), sizeof(zval *), (void **)((void *)0), 1 << 2);
  }
  if (1 << 4 == 1 << 2) {
    goto _L___3;
  } else {
    if (1 << 4 == 1 << 4) {
      _L___3: /* CIL Label */ 
      if (opline->extended_value) {

      } else {

      }
    } else {

    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_INIT_ARRAY_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  int tmp ;

  {
  opline = execute_data->opline;
  _array_init(& ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var, 0U);
  if (1 << 4 == 1 << 3) {
    (execute_data->opline) ++;
    return (0);
  } else {
    tmp = ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CV_HANDLER(execute_data);
    return (tmp);
  }
}
}
static int ( __attribute__((__fastcall__)) ZEND_UNSET_DIM_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **container ;
  zval *offset ;
  ulong hval ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  HashTable *ht ;
  long tmp___2 ;
  register char const   *tmp___3 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___4 ;
  long tmp___5 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data->CVs, opline->op1.var);
  if (1 << 4 == 1 << 4) {
    if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
      tmp___1 = zval_isref_p(*container);
      if (tmp___1) {

      } else {
        while (1) {
          tmp___0 = zval_refcount_p(*container);
          if (tmp___0 > 1U) {
            zval_delref_p(*container);
            while (1) {
              tmp = _emalloc(sizeof(zval_gc_info ));
              new_zv = (zval *)tmp;
              ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
              break;
            }
            while (1) {
              while (1) {
                new_zv->value = (*container)->value;
                new_zv->type = (*container)->type;
                break;
              }
              zval_set_refcount_p(new_zv, 1U);
              zval_unset_isref_p(new_zv);
              break;
            }
            *container = new_zv;
            _zval_copy_ctor(new_zv);
          } else {

          }
          break;
        }
      }
    } else {

    }
  } else {

  }
  offset = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  if (1 << 4 != 1 << 2) {
    goto _L___0;
  } else {
    if (container) {
      _L___0: /* CIL Label */ 
      switch ((int )(*container)->type) {
      case 4: 
      ht = (*container)->value.ht;
      switch ((int )offset->type) {
      case 2: 
      tmp___2 = zend_dval_to_lval(offset->value.dval);
      hval = (unsigned long )tmp___2;
      goto num_index_dim;
      case 7: 
      case 3: 
      case 1: 
      hval = (unsigned long )offset->value.lval;
      zend_hash_del_key_or_index(ht, (char const   *)((void *)0), 0U, hval, 1);
      break;
      case 6: 
      if (1 << 4 == 1 << 4) {
        zval_addref_p(offset);
      } else {
        if (1 << 4 == 1 << 2) {
          zval_addref_p(offset);
        } else {

        }
      }
      if (1 << 4 == 1) {
        hval = ((zend_literal *)offset)->hash_value;
      } else {
        while (1) {
          tmp___3 = (char const   *)offset->value.str.val;
          if ((int const   )*tmp___3 == 45) {
            tmp___3 ++;
          } else {

          }
          if ((int const   )*tmp___3 >= 48) {
            if ((int const   )*tmp___3 <= 57) {
              end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
              if ((int const   )*end != 0) {
                break;
              } else {
                if ((int const   )*tmp___3 == 48) {
                  if (offset->value.str.len + 1 > 2) {
                    break;
                  } else {
                    goto _L;
                  }
                } else {
                  _L: /* CIL Label */ 
                  if (end - tmp___3 > 10) {
                    break;
                  } else {
                    if (end - tmp___3 == 10) {
                      if ((int const   )*tmp___3 > 50) {
                        break;
                      } else {

                      }
                    } else {

                    }
                  }
                }
              }
              hval = (unsigned long )((int const   )*tmp___3 - 48);
              while (1) {
                tmp___3 ++;
                if ((unsigned int )tmp___3 != (unsigned int )end) {
                  if ((int const   )*tmp___3 >= 48) {
                    if ((int const   )*tmp___3 <= 57) {

                    } else {
                      break;
                    }
                  } else {
                    break;
                  }
                } else {
                  break;
                }
                hval = hval * 10UL + (ulong )((int const   )*tmp___3 - 48);
              }
              if ((unsigned int )tmp___3 == (unsigned int )end) {
                if ((int )*(offset->value.str.val) == 45) {
                  if (hval - 1UL > 2147483647UL) {
                    break;
                  } else {

                  }
                  hval = (unsigned long )(- ((long )hval));
                } else {
                  if (hval > 2147483647UL) {
                    break;
                  } else {

                  }
                }
                goto num_index_dim;
              } else {

              }
            } else {

            }
          } else {

          }
          break;
        }
        if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
          if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
            hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
          } else {
            tmp___4 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
            hval = (unsigned long )tmp___4;
          }
        } else {
          tmp___4 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___4;
        }
      }
      if ((unsigned int )ht == (unsigned int )(& executor_globals.symbol_table)) {
        zend_delete_global_variable_ex((char const   *)offset->value.str.val, offset->value.str.len, hval);
      } else {
        zend_hash_del_key_or_index(ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, 2);
      }
      if (1 << 4 == 1 << 4) {
        i_zval_ptr_dtor(offset);
      } else {
        if (1 << 4 == 1 << 2) {
          i_zval_ptr_dtor(offset);
        } else {

        }
      }
      break;
      num_index_dim: 
      zend_hash_del_key_or_index(ht, (char const   *)((void *)0), 0U, hval, 1);
      if (1 << 4 == 1 << 4) {
        i_zval_ptr_dtor(offset);
      } else {
        if (1 << 4 == 1 << 2) {
          i_zval_ptr_dtor(offset);
        } else {

        }
      }
      break;
      case 0: 
      zend_hash_del_key_or_index(ht, "", sizeof(""), 0UL, 0);
      break;
      default: 
      zend_error(1 << 1L, "Illegal offset type in unset");
      break;
      }
      break;
      case 5: 
      tmp___5 = __builtin_expect((long )((unsigned int )((*container)->value.obj.handlers)->unset_dimension == (unsigned int )((void *)0)), 0L);
      if (tmp___5) {
        zend_error_noreturn(1, "Cannot use object as array");
      } else {

      }
      (*(((*container)->value.obj.handlers)->unset_dimension))(*container, offset);
      break;
      case 6: 
      zend_error_noreturn(1, "Cannot unset string offsets");
      return (0);
      default: ;
      break;
      }
    } else {

    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_UNSET_OBJ_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **container ;
  zval *offset ;
  zval *new_zv ;
  void __attribute__((__visibility__("default")))  *tmp ;
  zend_uint tmp___0 ;
  zend_bool tmp___1 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___2 ;
  zend_literal *tmp___3 ;

  {
  opline = execute_data->opline;
  container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data->CVs, opline->op1.var);
  offset = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  if (1 << 4 != 1 << 2) {
    goto _L;
  } else {
    if (container) {
      _L: /* CIL Label */ 
      if (1 << 4 == 1 << 4) {
        if ((unsigned int )container != (unsigned int )(& executor_globals.uninitialized_zval_ptr)) {
          tmp___1 = zval_isref_p(*container);
          if (tmp___1) {

          } else {
            while (1) {
              tmp___0 = zval_refcount_p(*container);
              if (tmp___0 > 1U) {
                zval_delref_p(*container);
                while (1) {
                  tmp = _emalloc(sizeof(zval_gc_info ));
                  new_zv = (zval *)tmp;
                  ((zval_gc_info *)new_zv)->u.buffered = (gc_root_buffer *)((void *)0);
                  break;
                }
                while (1) {
                  while (1) {
                    new_zv->value = (*container)->value;
                    new_zv->type = (*container)->type;
                    break;
                  }
                  zval_set_refcount_p(new_zv, 1U);
                  zval_unset_isref_p(new_zv);
                  break;
                }
                *container = new_zv;
                _zval_copy_ctor(new_zv);
              } else {

              }
              break;
            }
          }
        } else {

        }
      } else {

      }
      if ((int )(*container)->type == 5) {
        if (((*container)->value.obj.handlers)->unset_property) {
          if (1 << 4 == 1) {
            tmp___3 = opline->op2.literal;
          } else {
            tmp___3 = (zend_literal *)((void *)0);
          }
          (*(((*container)->value.obj.handlers)->unset_property))(*container, offset, (struct _zend_literal  const  *)tmp___3);
        } else {
          zend_error(1 << 3L, "Trying to unset property of non-object");
        }
      } else {

      }
    } else {

    }
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_CV)(int prop_dim , zend_execute_data *execute_data ) 
{ zend_op *opline ;
  zval **container ;
  zval **value ;
  int result ;
  ulong hval ;
  zval *offset ;
  HashTable *ht ;
  int isset ;
  long tmp ;
  int __attribute__((__visibility__("default")))  tmp___0 ;
  register char const   *tmp___1 ;
  char const   *end ;
  ulong __attribute__((__visibility__("default")))  tmp___2 ;
  int __attribute__((__visibility__("default")))  tmp___3 ;
  int __attribute__((__visibility__("default")))  tmp___4 ;
  int tmp___5 ;
  zval *_tmp ;
  void __attribute__((__visibility__("default")))  *tmp___6 ;
  zend_literal *tmp___7 ;
  zval tmp___8 ;

  {
  opline = execute_data->opline;
  value = (zval **)((void *)0);
  result = 0;
  container = _get_zval_ptr_ptr_cv_BP_VAR_IS(execute_data->CVs, opline->op1.var);
  offset = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var);
  if ((int )(*container)->type == 4) {
    if (! prop_dim) {
      isset = 0;
      ht = (*container)->value.ht;
      switch ((int )offset->type) {
      case 2: 
      tmp = zend_dval_to_lval(offset->value.dval);
      hval = (unsigned long )tmp;
      goto num_index_prop;
      case 7: 
      case 3: 
      case 1: 
      hval = (unsigned long )offset->value.lval;
      num_index_prop: 
      tmp___0 = zend_hash_index_find((HashTable const   *)ht, hval, (void **)(& value));
      if (tmp___0 == (int __attribute__((__visibility__("default")))  )0) {
        isset = 1;
      } else {

      }
      break;
      case 6: 
      if (1 << 4 == 1) {
        hval = ((zend_literal *)offset)->hash_value;
      } else {
        if (! prop_dim) {
          while (1) {
            tmp___1 = (char const   *)offset->value.str.val;
            if ((int const   )*tmp___1 == 45) {
              tmp___1 ++;
            } else {

            }
            if ((int const   )*tmp___1 >= 48) {
              if ((int const   )*tmp___1 <= 57) {
                end = (char const   *)(((offset->value.str.val + offset->value.str.len) + 1) - 1);
                if ((int const   )*end != 0) {
                  break;
                } else {
                  if ((int const   )*tmp___1 == 48) {
                    if (offset->value.str.len + 1 > 2) {
                      break;
                    } else {
                      goto _L;
                    }
                  } else {
                    _L: /* CIL Label */ 
                    if (end - tmp___1 > 10) {
                      break;
                    } else {
                      if (end - tmp___1 == 10) {
                        if ((int const   )*tmp___1 > 50) {
                          break;
                        } else {

                        }
                      } else {

                      }
                    }
                  }
                }
                hval = (unsigned long )((int const   )*tmp___1 - 48);
                while (1) {
                  tmp___1 ++;
                  if ((unsigned int )tmp___1 != (unsigned int )end) {
                    if ((int const   )*tmp___1 >= 48) {
                      if ((int const   )*tmp___1 <= 57) {

                      } else {
                        break;
                      }
                    } else {
                      break;
                    }
                  } else {
                    break;
                  }
                  hval = hval * 10UL + (ulong )((int const   )*tmp___1 - 48);
                }
                if ((unsigned int )tmp___1 == (unsigned int )end) {
                  if ((int )*(offset->value.str.val) == 45) {
                    if (hval - 1UL > 2147483647UL) {
                      break;
                    } else {

                    }
                    hval = (unsigned long )(- ((long )hval));
                  } else {
                    if (hval > 2147483647UL) {
                      break;
                    } else {

                    }
                  }
                  goto num_index_prop;
                } else {

                }
              } else {

              }
            } else {

            }
            break;
          }
        } else {

        }
        if ((unsigned int )offset->value.str.val >= (unsigned int )compiler_globals.interned_strings_start) {
          if ((unsigned int )offset->value.str.val < (unsigned int )compiler_globals.interned_strings_end) {
            hval = ((Bucket *)(offset->value.str.val - sizeof(Bucket )))->h;
          } else {
            tmp___2 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
            hval = (unsigned long )tmp___2;
          }
        } else {
          tmp___2 = zend_hash_func((char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1));
          hval = (unsigned long )tmp___2;
        }
      }
      tmp___3 = zend_hash_quick_find((HashTable const   *)ht, (char const   *)offset->value.str.val, (unsigned int )(offset->value.str.len + 1), hval, (void **)(& value));
      if (tmp___3 == (int __attribute__((__visibility__("default")))  )0) {
        isset = 1;
      } else {

      }
      break;
      case 0: 
      tmp___4 = zend_hash_find((HashTable const   *)ht, "", sizeof(""), (void **)(& value));
      if (tmp___4 == (int __attribute__((__visibility__("default")))  )0) {
        isset = 1;
      } else {

      }
      break;
      default: 
      zend_error(1 << 1L, "Illegal offset type in isset or empty");
      break;
      }
      if (opline->extended_value & 33554432UL) {
        if (isset) {
          if ((int )(*value)->type == 0) {
            result = 0;
          } else {
            result = isset;
          }
        } else {
          result = isset;
        }
      } else {
        if (! isset) {
          result = 0;
        } else {
          tmp___5 = i_zend_is_true(*value);
          if (tmp___5) {
            result = 1;
          } else {
            result = 0;
          }
        }
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if ((int )(*container)->type == 5) {
      if (prop_dim) {
        if (((*container)->value.obj.handlers)->has_property) {
          if (1 << 4 == 1) {
            tmp___7 = opline->op2.literal;
          } else {
            tmp___7 = (zend_literal *)((void *)0);
          }
          result = (*(((*container)->value.obj.handlers)->has_property))(*container, offset, (opline->extended_value & 16777216UL) != 0UL, (struct _zend_literal  const  *)tmp___7);
        } else {
          zend_error(1 << 3L, "Trying to check property of non-object");
          result = 0;
        }
      } else {
        if (((*container)->value.obj.handlers)->has_dimension) {
          result = (*(((*container)->value.obj.handlers)->has_dimension))(*container, offset, (opline->extended_value & 16777216UL) != 0UL);
        } else {
          zend_error(1 << 3L, "Trying to check element of non-array");
          result = 0;
        }
      }
    } else {
      if ((int )(*container)->type == 6) {
        if (! prop_dim) {
          if ((int )offset->type != 1) {
            while (1) {
              tmp___8.value = offset->value;
              tmp___8.type = offset->type;
              break;
            }
            _zval_copy_ctor(& tmp___8);
            convert_to_long(& tmp___8);
            offset = & tmp___8;
          } else {

          }
          if ((int )offset->type == 1) {
            if (opline->extended_value & 33554432UL) {
              if (offset->value.lval >= 0L) {
                if (offset->value.lval < (long )(*container)->value.str.len) {
                  result = 1;
                } else {

                }
              } else {

              }
            } else {
              if (offset->value.lval >= 0L) {
                if (offset->value.lval < (long )(*container)->value.str.len) {
                  if ((int )*((*container)->value.str.val + offset->value.lval) != 48) {
                    result = 1;
                  } else {

                  }
                } else {

                }
              } else {

              }
            }
          } else {

          }
        } else {

        }
      } else {

      }
    }
  }
  ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.type = (unsigned char)3;
  if (opline->extended_value & 33554432UL) {
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.lval = (long )result;
  } else {
    ((temp_variable *)((char *)execute_data->Ts + opline->result.var))->tmp_var.value.lval = (long )(! result);
  }
  (execute_data->opline) ++;
  return (0);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_CV(0, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CV_HANDLER)(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_CV(1, execute_data);
  return (tmp);
}
}
static int ( __attribute__((__fastcall__)) ZEND_NULL_HANDLER)(zend_execute_data *execute_data ) 
{ 

  {
  zend_error_noreturn(1, "Invalid opcode %d/%d/%d.", (execute_data->opline)->opcode, (execute_data->opline)->op1_type, (execute_data->opline)->op2_type);
}
}
void zend_init_opcodes_handlers(void) ;
static opcode_handler_t const   labels[3976]  = 
  {      (opcode_handler_t const   )(& ZEND_NOP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_NOP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_NOP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_NOP_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NOP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_NOP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_NOP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_NOP_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NOP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_NOP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_NOP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_NOP_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NOP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_NOP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_NOP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_NOP_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NOP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_NOP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_NOP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_NOP_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NOP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_NOP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_NOP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_NOP_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NOP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_SPEC_CONST_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_SPEC_CONST_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_SPEC_CONST_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_SPEC_CONST_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_SPEC_TMP_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_SPEC_TMP_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ADD_SPEC_TMP_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_SPEC_TMP_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_SPEC_VAR_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ADD_SPEC_VAR_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_SPEC_VAR_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_SPEC_CV_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_SPEC_CV_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_SUB_SPEC_CONST_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_SUB_SPEC_CONST_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_SUB_SPEC_CONST_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_SUB_SPEC_CONST_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_SUB_SPEC_TMP_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_SUB_SPEC_TMP_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_SUB_SPEC_TMP_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_SUB_SPEC_TMP_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_SUB_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_SUB_SPEC_VAR_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_SUB_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_SUB_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_SUB_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_SUB_SPEC_CV_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_SUB_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_SUB_SPEC_CV_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_MUL_SPEC_CONST_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_MUL_SPEC_CONST_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_MUL_SPEC_CONST_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_MUL_SPEC_CONST_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_MUL_SPEC_TMP_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_MUL_SPEC_TMP_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_MUL_SPEC_TMP_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_MUL_SPEC_TMP_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_MUL_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_MUL_SPEC_VAR_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_MUL_SPEC_VAR_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_MUL_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_MUL_SPEC_CV_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_MUL_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_MUL_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_MUL_SPEC_CV_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_DIV_SPEC_CONST_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_DIV_SPEC_CONST_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_DIV_SPEC_CONST_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_DIV_SPEC_CONST_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_DIV_SPEC_TMP_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_DIV_SPEC_TMP_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_DIV_SPEC_TMP_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_DIV_SPEC_TMP_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_DIV_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_DIV_SPEC_VAR_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_DIV_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_DIV_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_DIV_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_DIV_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_DIV_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_DIV_SPEC_CV_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_MOD_SPEC_CONST_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_MOD_SPEC_CONST_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_MOD_SPEC_CONST_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_MOD_SPEC_CONST_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_MOD_SPEC_TMP_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_MOD_SPEC_TMP_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_MOD_SPEC_TMP_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_MOD_SPEC_TMP_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_MOD_SPEC_VAR_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_MOD_SPEC_VAR_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_MOD_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_MOD_SPEC_VAR_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_MOD_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_MOD_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_MOD_SPEC_CV_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_MOD_SPEC_CV_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_SL_SPEC_CONST_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_SL_SPEC_CONST_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_SL_SPEC_CONST_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_SL_SPEC_CONST_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_SL_SPEC_TMP_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_SL_SPEC_TMP_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_SL_SPEC_TMP_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_SL_SPEC_TMP_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_SL_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_SL_SPEC_VAR_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_SL_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_SL_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_SL_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_SL_SPEC_CV_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_SL_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_SL_SPEC_CV_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_SR_SPEC_CONST_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_SR_SPEC_CONST_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_SR_SPEC_CONST_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_SR_SPEC_CONST_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_SR_SPEC_TMP_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_SR_SPEC_TMP_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_SR_SPEC_TMP_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_SR_SPEC_TMP_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_SR_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_SR_SPEC_VAR_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_SR_SPEC_VAR_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_SR_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_SR_SPEC_CV_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_SR_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_SR_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_SR_SPEC_CV_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_CONCAT_SPEC_CONST_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_CONCAT_SPEC_CONST_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_CONCAT_SPEC_CONST_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_CONCAT_SPEC_CONST_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_CONCAT_SPEC_TMP_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_CONCAT_SPEC_TMP_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_CONCAT_SPEC_TMP_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_CONCAT_SPEC_TMP_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_CONCAT_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_CONCAT_SPEC_VAR_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_CONCAT_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_CONCAT_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_CONCAT_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_CONCAT_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_CONCAT_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_CONCAT_SPEC_CV_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_OR_SPEC_CONST_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_OR_SPEC_CONST_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_OR_SPEC_CONST_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_OR_SPEC_CONST_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_OR_SPEC_TMP_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_OR_SPEC_TMP_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BW_OR_SPEC_TMP_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_OR_SPEC_TMP_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_OR_SPEC_VAR_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BW_OR_SPEC_VAR_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_OR_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_OR_SPEC_VAR_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_OR_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_OR_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_OR_SPEC_CV_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_OR_SPEC_CV_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_AND_SPEC_CONST_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_AND_SPEC_CONST_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BW_AND_SPEC_CONST_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_AND_SPEC_CONST_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_AND_SPEC_TMP_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BW_AND_SPEC_TMP_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_AND_SPEC_TMP_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_AND_SPEC_TMP_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BW_AND_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_AND_SPEC_VAR_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_AND_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BW_AND_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_AND_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_AND_SPEC_CV_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BW_AND_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_AND_SPEC_CV_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_XOR_SPEC_CONST_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BW_XOR_SPEC_CONST_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_XOR_SPEC_CONST_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_XOR_SPEC_CONST_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BW_XOR_SPEC_TMP_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_XOR_SPEC_TMP_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_XOR_SPEC_TMP_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BW_XOR_SPEC_TMP_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_XOR_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_XOR_SPEC_VAR_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_XOR_SPEC_VAR_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_XOR_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_XOR_SPEC_CV_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BW_XOR_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_XOR_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_XOR_SPEC_CV_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BW_NOT_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_NOT_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_NOT_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_NOT_SPEC_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BW_NOT_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_NOT_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_NOT_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_NOT_SPEC_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BW_NOT_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_NOT_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_NOT_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_NOT_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BW_NOT_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_NOT_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_NOT_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BW_NOT_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_NOT_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_NOT_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_BW_NOT_SPEC_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BW_NOT_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_BOOL_NOT_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_BOOL_NOT_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_BOOL_NOT_SPEC_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BOOL_NOT_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_BOOL_NOT_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_BOOL_NOT_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_BOOL_NOT_SPEC_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BOOL_NOT_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_BOOL_NOT_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_BOOL_NOT_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_BOOL_NOT_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BOOL_NOT_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_BOOL_NOT_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_BOOL_NOT_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_BOOL_NOT_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_BOOL_NOT_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_BOOL_NOT_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_BOOL_NOT_SPEC_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BOOL_NOT_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_BOOL_NOT_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_BOOL_XOR_SPEC_CONST_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_BOOL_XOR_SPEC_CONST_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BOOL_XOR_SPEC_CONST_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_BOOL_XOR_SPEC_CONST_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_BOOL_XOR_SPEC_TMP_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BOOL_XOR_SPEC_TMP_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_BOOL_XOR_SPEC_TMP_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_BOOL_XOR_SPEC_TMP_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BOOL_XOR_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_BOOL_XOR_SPEC_VAR_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_BOOL_XOR_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BOOL_XOR_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_BOOL_XOR_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_BOOL_XOR_SPEC_CV_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BOOL_XOR_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_BOOL_XOR_SPEC_CV_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_IDENTICAL_SPEC_CONST_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_IS_IDENTICAL_SPEC_CONST_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_IDENTICAL_SPEC_CONST_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_IDENTICAL_SPEC_CONST_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_IS_IDENTICAL_SPEC_TMP_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_IDENTICAL_SPEC_TMP_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_IDENTICAL_SPEC_TMP_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_IS_IDENTICAL_SPEC_TMP_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_IDENTICAL_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_IDENTICAL_SPEC_VAR_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_IDENTICAL_SPEC_VAR_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_IDENTICAL_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_IDENTICAL_SPEC_CV_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_IS_IDENTICAL_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_IDENTICAL_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_IDENTICAL_SPEC_CV_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_IS_NOT_IDENTICAL_SPEC_CONST_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_NOT_IDENTICAL_SPEC_CONST_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_NOT_IDENTICAL_SPEC_CONST_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_IS_NOT_IDENTICAL_SPEC_CONST_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_NOT_IDENTICAL_SPEC_TMP_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_NOT_IDENTICAL_SPEC_TMP_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_NOT_IDENTICAL_SPEC_TMP_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_NOT_IDENTICAL_SPEC_TMP_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_NOT_IDENTICAL_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_NOT_IDENTICAL_SPEC_VAR_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_IS_NOT_IDENTICAL_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_NOT_IDENTICAL_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_IS_NOT_IDENTICAL_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_NOT_IDENTICAL_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_NOT_IDENTICAL_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_IS_NOT_IDENTICAL_SPEC_CV_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_EQUAL_SPEC_CONST_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_EQUAL_SPEC_CONST_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_EQUAL_SPEC_CONST_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_EQUAL_SPEC_CONST_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_EQUAL_SPEC_TMP_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_EQUAL_SPEC_TMP_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_IS_EQUAL_SPEC_TMP_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_EQUAL_SPEC_TMP_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_EQUAL_SPEC_VAR_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_IS_EQUAL_SPEC_VAR_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_EQUAL_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_EQUAL_SPEC_VAR_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_EQUAL_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_EQUAL_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_EQUAL_SPEC_CV_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_EQUAL_SPEC_CV_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_NOT_EQUAL_SPEC_CONST_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_NOT_EQUAL_SPEC_CONST_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_IS_NOT_EQUAL_SPEC_CONST_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_NOT_EQUAL_SPEC_CONST_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_NOT_EQUAL_SPEC_TMP_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_IS_NOT_EQUAL_SPEC_TMP_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_NOT_EQUAL_SPEC_TMP_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_NOT_EQUAL_SPEC_TMP_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_IS_NOT_EQUAL_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_NOT_EQUAL_SPEC_VAR_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_NOT_EQUAL_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_IS_NOT_EQUAL_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_NOT_EQUAL_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_NOT_EQUAL_SPEC_CV_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_IS_NOT_EQUAL_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_NOT_EQUAL_SPEC_CV_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_SMALLER_SPEC_CONST_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_IS_SMALLER_SPEC_CONST_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_SMALLER_SPEC_CONST_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_SMALLER_SPEC_CONST_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_IS_SMALLER_SPEC_TMP_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_SMALLER_SPEC_TMP_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_SMALLER_SPEC_TMP_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_IS_SMALLER_SPEC_TMP_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_SMALLER_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_SMALLER_SPEC_VAR_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_SMALLER_SPEC_VAR_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_SMALLER_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_SMALLER_SPEC_CV_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_IS_SMALLER_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_SMALLER_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_SMALLER_SPEC_CV_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMP_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMP_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMP_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMP_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_SMALLER_OR_EQUAL_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_SMALLER_OR_EQUAL_SPEC_VAR_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_IS_SMALLER_OR_EQUAL_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_SMALLER_OR_EQUAL_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_CAST_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_CAST_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_CAST_SPEC_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_CAST_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_CAST_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_CAST_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_CAST_SPEC_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_CAST_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_CAST_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_CAST_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_CAST_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_CAST_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_CAST_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_CAST_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_CAST_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_CAST_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_CAST_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_CAST_SPEC_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_CAST_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_CAST_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_QM_ASSIGN_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_QM_ASSIGN_SPEC_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_QM_ASSIGN_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_QM_ASSIGN_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_QM_ASSIGN_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_QM_ASSIGN_SPEC_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_QM_ASSIGN_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_QM_ASSIGN_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_QM_ASSIGN_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_QM_ASSIGN_SPEC_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_QM_ASSIGN_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_QM_ASSIGN_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_QM_ASSIGN_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_QM_ASSIGN_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_QM_ASSIGN_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_QM_ASSIGN_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_QM_ASSIGN_SPEC_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_QM_ASSIGN_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_QM_ASSIGN_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_QM_ASSIGN_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_ADD_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_ADD_SPEC_VAR_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_ADD_SPEC_VAR_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_ADD_SPEC_VAR_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_ADD_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_ADD_SPEC_UNUSED_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_ADD_SPEC_UNUSED_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_ADD_SPEC_UNUSED_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_ADD_SPEC_UNUSED_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_ADD_SPEC_UNUSED_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_ADD_SPEC_CV_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_ADD_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_ADD_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_ADD_SPEC_CV_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_ADD_SPEC_CV_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_SUB_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_SUB_SPEC_VAR_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_SUB_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_SUB_SPEC_VAR_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_SUB_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_SUB_SPEC_UNUSED_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_SUB_SPEC_UNUSED_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_SUB_SPEC_UNUSED_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_SUB_SPEC_UNUSED_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_SUB_SPEC_UNUSED_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_SUB_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_SUB_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_SUB_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_SUB_SPEC_CV_UNUSED_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_SUB_SPEC_CV_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_MUL_SPEC_VAR_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_MUL_SPEC_VAR_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_MUL_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_MUL_SPEC_VAR_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_MUL_SPEC_VAR_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_MUL_SPEC_UNUSED_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_MUL_SPEC_UNUSED_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_MUL_SPEC_UNUSED_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_MUL_SPEC_UNUSED_UNUSED_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_MUL_SPEC_UNUSED_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_MUL_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_MUL_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_MUL_SPEC_CV_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_MUL_SPEC_CV_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_MUL_SPEC_CV_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_DIV_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_DIV_SPEC_VAR_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_DIV_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_DIV_SPEC_VAR_UNUSED_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_DIV_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_DIV_SPEC_UNUSED_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_DIV_SPEC_UNUSED_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_DIV_SPEC_UNUSED_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_DIV_SPEC_UNUSED_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_DIV_SPEC_UNUSED_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_DIV_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_DIV_SPEC_CV_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_DIV_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_DIV_SPEC_CV_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_DIV_SPEC_CV_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_MOD_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_MOD_SPEC_VAR_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_MOD_SPEC_VAR_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_MOD_SPEC_VAR_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_MOD_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_MOD_SPEC_UNUSED_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_MOD_SPEC_UNUSED_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_MOD_SPEC_UNUSED_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_MOD_SPEC_UNUSED_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_MOD_SPEC_UNUSED_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_MOD_SPEC_CV_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_MOD_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_MOD_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_MOD_SPEC_CV_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_MOD_SPEC_CV_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_SL_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_SL_SPEC_VAR_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_SL_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_SL_SPEC_VAR_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_SL_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_SL_SPEC_UNUSED_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_SL_SPEC_UNUSED_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_SL_SPEC_UNUSED_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_SL_SPEC_UNUSED_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_SL_SPEC_UNUSED_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_SL_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_SL_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_SL_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_SL_SPEC_CV_UNUSED_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_SL_SPEC_CV_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_SR_SPEC_VAR_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_SR_SPEC_VAR_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_SR_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_SR_SPEC_VAR_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_SR_SPEC_VAR_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_SR_SPEC_UNUSED_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_SR_SPEC_UNUSED_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_SR_SPEC_UNUSED_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_SR_SPEC_UNUSED_UNUSED_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_SR_SPEC_UNUSED_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_SR_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_SR_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_SR_SPEC_CV_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_SR_SPEC_CV_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_SR_SPEC_CV_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_CONCAT_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_CONCAT_SPEC_VAR_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_CONCAT_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_CONCAT_SPEC_VAR_UNUSED_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_CONCAT_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_CONCAT_SPEC_UNUSED_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_CONCAT_SPEC_UNUSED_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_CONCAT_SPEC_UNUSED_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_CONCAT_SPEC_UNUSED_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_CONCAT_SPEC_UNUSED_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_CONCAT_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_CONCAT_SPEC_CV_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_CONCAT_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_CONCAT_SPEC_CV_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_CONCAT_SPEC_CV_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_BW_OR_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_BW_OR_SPEC_VAR_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_BW_OR_SPEC_VAR_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_BW_OR_SPEC_VAR_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_BW_OR_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_BW_OR_SPEC_UNUSED_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_BW_OR_SPEC_UNUSED_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_BW_OR_SPEC_UNUSED_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_BW_OR_SPEC_UNUSED_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_BW_OR_SPEC_UNUSED_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_BW_OR_SPEC_CV_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_BW_OR_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_BW_OR_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_BW_OR_SPEC_CV_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_BW_OR_SPEC_CV_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_BW_AND_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_BW_AND_SPEC_VAR_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_BW_AND_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_BW_AND_SPEC_VAR_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_BW_AND_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_BW_AND_SPEC_UNUSED_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_BW_AND_SPEC_UNUSED_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_BW_AND_SPEC_UNUSED_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_BW_AND_SPEC_UNUSED_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_BW_AND_SPEC_UNUSED_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_BW_AND_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_BW_AND_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_BW_AND_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_BW_AND_SPEC_CV_UNUSED_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_BW_AND_SPEC_CV_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_BW_XOR_SPEC_VAR_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_BW_XOR_SPEC_VAR_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_BW_XOR_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_BW_XOR_SPEC_VAR_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_BW_XOR_SPEC_VAR_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_UNUSED_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_BW_XOR_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_BW_XOR_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_BW_XOR_SPEC_CV_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_BW_XOR_SPEC_CV_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_BW_XOR_SPEC_CV_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_PRE_INC_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_PRE_INC_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_PRE_INC_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_PRE_INC_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_PRE_INC_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_PRE_INC_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_PRE_INC_SPEC_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_PRE_INC_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_PRE_INC_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_PRE_INC_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_PRE_DEC_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_PRE_DEC_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_PRE_DEC_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_PRE_DEC_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_PRE_DEC_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_PRE_DEC_SPEC_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_PRE_DEC_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_PRE_DEC_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_PRE_DEC_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_PRE_DEC_SPEC_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_POST_INC_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_POST_INC_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_POST_INC_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_POST_INC_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_POST_INC_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_POST_INC_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_POST_INC_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_POST_INC_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_POST_INC_SPEC_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_POST_INC_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_POST_DEC_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_POST_DEC_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_POST_DEC_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_POST_DEC_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_POST_DEC_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_POST_DEC_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_POST_DEC_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_POST_DEC_SPEC_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_POST_DEC_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_POST_DEC_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_SPEC_VAR_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_SPEC_CV_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_SPEC_CV_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_REF_SPEC_VAR_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_REF_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_REF_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_REF_SPEC_CV_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ECHO_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ECHO_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ECHO_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ECHO_SPEC_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ECHO_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ECHO_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ECHO_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ECHO_SPEC_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ECHO_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ECHO_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ECHO_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_ECHO_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ECHO_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_ECHO_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_ECHO_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ECHO_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_ECHO_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_ECHO_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_ECHO_SPEC_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ECHO_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_PRINT_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_PRINT_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_PRINT_SPEC_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_PRINT_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_PRINT_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_PRINT_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_PRINT_SPEC_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_PRINT_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_PRINT_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_PRINT_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_PRINT_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_PRINT_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_PRINT_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_PRINT_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_PRINT_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_PRINT_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_PRINT_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_PRINT_SPEC_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_PRINT_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_PRINT_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_JMP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_JMP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_JMP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_JMP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_JMP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_JMP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZ_SPEC_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_JMPZ_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZ_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZ_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZ_SPEC_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_JMPZ_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZ_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZ_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZ_SPEC_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_JMPZ_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZ_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZ_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZ_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_JMPZ_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZ_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZ_SPEC_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_JMPZ_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZ_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZ_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZ_SPEC_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_JMPNZ_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPNZ_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPNZ_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPNZ_SPEC_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_JMPNZ_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPNZ_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPNZ_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPNZ_SPEC_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_JMPNZ_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPNZ_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPNZ_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPNZ_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_JMPNZ_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPNZ_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPNZ_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_JMPNZ_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPNZ_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPNZ_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPNZ_SPEC_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_JMPNZ_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZNZ_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZNZ_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZNZ_SPEC_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_JMPZNZ_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZNZ_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZNZ_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZNZ_SPEC_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_JMPZNZ_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZNZ_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZNZ_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZNZ_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_JMPZNZ_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZNZ_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZNZ_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZNZ_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZNZ_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZNZ_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZNZ_SPEC_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_JMPZNZ_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZNZ_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZ_EX_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZ_EX_SPEC_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_JMPZ_EX_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZ_EX_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZ_EX_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZ_EX_SPEC_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_JMPZ_EX_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZ_EX_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZ_EX_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZ_EX_SPEC_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_JMPZ_EX_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZ_EX_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZ_EX_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZ_EX_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_JMPZ_EX_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZ_EX_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZ_EX_SPEC_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_JMPZ_EX_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZ_EX_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPZ_EX_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPNZ_EX_SPEC_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_JMPNZ_EX_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPNZ_EX_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPNZ_EX_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPNZ_EX_SPEC_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_JMPNZ_EX_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPNZ_EX_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPNZ_EX_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPNZ_EX_SPEC_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_JMPNZ_EX_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPNZ_EX_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPNZ_EX_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPNZ_EX_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_JMPNZ_EX_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPNZ_EX_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPNZ_EX_SPEC_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_JMPNZ_EX_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPNZ_EX_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPNZ_EX_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_JMPNZ_EX_SPEC_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_CASE_SPEC_CONST_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_CASE_SPEC_CONST_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_CASE_SPEC_CONST_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_CASE_SPEC_CONST_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_CASE_SPEC_TMP_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_CASE_SPEC_TMP_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_CASE_SPEC_TMP_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_CASE_SPEC_TMP_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_CASE_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_CASE_SPEC_VAR_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_CASE_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_CASE_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_CASE_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_CASE_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_CASE_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_CASE_SPEC_CV_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_SWITCH_FREE_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_SWITCH_FREE_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_SWITCH_FREE_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_SWITCH_FREE_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_SWITCH_FREE_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_BRK_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_BRK_SPEC_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BRK_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_BRK_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_BRK_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_CONT_SPEC_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_CONT_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_CONT_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_CONT_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_CONT_SPEC_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BOOL_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_BOOL_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_BOOL_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_BOOL_SPEC_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BOOL_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_BOOL_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_BOOL_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_BOOL_SPEC_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BOOL_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_BOOL_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_BOOL_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_BOOL_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BOOL_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_BOOL_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_BOOL_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BOOL_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_BOOL_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_BOOL_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_BOOL_SPEC_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BOOL_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_STRING_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_STRING_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_STRING_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_INIT_STRING_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_STRING_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_STRING_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_STRING_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_INIT_STRING_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_STRING_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_STRING_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_STRING_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_INIT_STRING_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_STRING_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_STRING_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_STRING_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_INIT_STRING_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_STRING_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_STRING_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_STRING_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_INIT_STRING_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_STRING_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_STRING_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_STRING_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_INIT_STRING_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_STRING_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_CHAR_SPEC_TMP_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_CHAR_SPEC_UNUSED_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ADD_STRING_SPEC_TMP_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_STRING_SPEC_UNUSED_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_VAR_SPEC_TMP_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_VAR_SPEC_TMP_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_VAR_SPEC_TMP_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ADD_VAR_SPEC_UNUSED_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_VAR_SPEC_UNUSED_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_VAR_SPEC_UNUSED_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_BEGIN_SILENCE_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_BEGIN_SILENCE_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_BEGIN_SILENCE_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BEGIN_SILENCE_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_BEGIN_SILENCE_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_BEGIN_SILENCE_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_BEGIN_SILENCE_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BEGIN_SILENCE_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_BEGIN_SILENCE_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_BEGIN_SILENCE_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_BEGIN_SILENCE_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BEGIN_SILENCE_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_BEGIN_SILENCE_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_BEGIN_SILENCE_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_BEGIN_SILENCE_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BEGIN_SILENCE_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_BEGIN_SILENCE_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_BEGIN_SILENCE_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_BEGIN_SILENCE_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BEGIN_SILENCE_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_BEGIN_SILENCE_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_BEGIN_SILENCE_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_BEGIN_SILENCE_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BEGIN_SILENCE_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_BEGIN_SILENCE_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_END_SILENCE_SPEC_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_END_SILENCE_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_END_SILENCE_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_END_SILENCE_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_END_SILENCE_SPEC_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_FCALL_BY_NAME_SPEC_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_INIT_FCALL_BY_NAME_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_FCALL_BY_NAME_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_FCALL_BY_NAME_SPEC_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_INIT_FCALL_BY_NAME_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_FCALL_BY_NAME_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_FCALL_BY_NAME_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_INIT_FCALL_BY_NAME_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_FCALL_BY_NAME_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_FCALL_BY_NAME_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_FCALL_BY_NAME_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_FCALL_BY_NAME_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_FCALL_BY_NAME_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_FCALL_BY_NAME_SPEC_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_INIT_FCALL_BY_NAME_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_FCALL_BY_NAME_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_FCALL_BY_NAME_SPEC_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_INIT_FCALL_BY_NAME_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_FCALL_BY_NAME_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_FCALL_BY_NAME_SPEC_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_DO_FCALL_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_DO_FCALL_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_DO_FCALL_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_DO_FCALL_SPEC_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_DO_FCALL_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_RETURN_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_RETURN_SPEC_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_RETURN_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_RETURN_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_RETURN_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_RETURN_SPEC_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_RETURN_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_RETURN_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_RETURN_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_RETURN_SPEC_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_RETURN_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_RETURN_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_RETURN_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_RETURN_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_RETURN_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_RETURN_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_RETURN_SPEC_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_RETURN_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_RETURN_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_RETURN_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_RECV_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_RECV_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_RECV_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_RECV_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_RECV_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_RECV_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_RECV_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_RECV_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_RECV_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_RECV_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_RECV_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_RECV_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_RECV_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_RECV_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_RECV_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_RECV_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_RECV_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_RECV_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_RECV_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_RECV_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_RECV_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_RECV_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_RECV_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_RECV_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_RECV_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_RECV_INIT_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_RECV_INIT_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_RECV_INIT_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_RECV_INIT_SPEC_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_RECV_INIT_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_SEND_VAL_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_SEND_VAL_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_SEND_VAL_SPEC_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_SEND_VAL_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_SEND_VAL_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_SEND_VAL_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_SEND_VAL_SPEC_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_SEND_VAL_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_SEND_VAL_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_SEND_VAL_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_SEND_VAR_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_SEND_VAR_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_SEND_VAR_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_SEND_VAR_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_SEND_VAR_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_SEND_VAR_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_SEND_VAR_SPEC_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_SEND_VAR_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_SEND_VAR_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_SEND_VAR_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_SEND_REF_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_SEND_REF_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_SEND_REF_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_SEND_REF_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_SEND_REF_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_SEND_REF_SPEC_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_SEND_REF_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_SEND_REF_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_SEND_REF_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_SEND_REF_SPEC_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NEW_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_NEW_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_NEW_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_NEW_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NEW_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_NEW_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_NEW_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_NEW_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NEW_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_NEW_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_NEW_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_NEW_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NEW_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_NEW_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_NEW_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_NEW_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NEW_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_NEW_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_NEW_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_NEW_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NEW_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_NEW_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_NEW_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_NEW_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NEW_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_NS_FCALL_BY_NAME_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_NS_FCALL_BY_NAME_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_NS_FCALL_BY_NAME_SPEC_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_INIT_NS_FCALL_BY_NAME_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_NS_FCALL_BY_NAME_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FREE_SPEC_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FREE_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_FREE_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_FREE_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_FREE_SPEC_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FREE_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_FREE_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_FREE_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_FREE_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FREE_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_ARRAY_SPEC_CONST_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_INIT_ARRAY_SPEC_CONST_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_ARRAY_SPEC_CONST_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_ARRAY_SPEC_CONST_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_ARRAY_SPEC_CONST_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_INIT_ARRAY_SPEC_TMP_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_ARRAY_SPEC_TMP_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_ARRAY_SPEC_TMP_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_ARRAY_SPEC_TMP_UNUSED_HANDLER), 
        (opcode_handler_t const   )(& ZEND_INIT_ARRAY_SPEC_TMP_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_ARRAY_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_ARRAY_SPEC_VAR_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_ARRAY_SPEC_VAR_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_INIT_ARRAY_SPEC_VAR_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_ARRAY_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_ARRAY_SPEC_UNUSED_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_ARRAY_SPEC_UNUSED_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_INIT_ARRAY_SPEC_UNUSED_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_ARRAY_SPEC_UNUSED_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_ARRAY_SPEC_UNUSED_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_ARRAY_SPEC_CV_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_INIT_ARRAY_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_ARRAY_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_ARRAY_SPEC_CV_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_ARRAY_SPEC_CV_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_UNUSED_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_UNUSED_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_INCLUDE_OR_EVAL_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_INCLUDE_OR_EVAL_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_INCLUDE_OR_EVAL_SPEC_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_INCLUDE_OR_EVAL_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_INCLUDE_OR_EVAL_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_INCLUDE_OR_EVAL_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_INCLUDE_OR_EVAL_SPEC_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_INCLUDE_OR_EVAL_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_INCLUDE_OR_EVAL_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_INCLUDE_OR_EVAL_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_INCLUDE_OR_EVAL_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_INCLUDE_OR_EVAL_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_INCLUDE_OR_EVAL_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_INCLUDE_OR_EVAL_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_INCLUDE_OR_EVAL_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_INCLUDE_OR_EVAL_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_INCLUDE_OR_EVAL_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_INCLUDE_OR_EVAL_SPEC_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_INCLUDE_OR_EVAL_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_INCLUDE_OR_EVAL_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_UNSET_VAR_SPEC_CONST_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_UNSET_VAR_SPEC_CONST_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_UNSET_VAR_SPEC_CONST_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_UNSET_VAR_SPEC_TMP_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_UNSET_VAR_SPEC_TMP_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_UNSET_VAR_SPEC_TMP_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_UNSET_VAR_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_UNSET_VAR_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_UNSET_VAR_SPEC_VAR_UNUSED_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_UNSET_VAR_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_UNSET_VAR_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_UNSET_VAR_SPEC_CV_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_UNSET_DIM_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_UNSET_DIM_SPEC_VAR_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_UNSET_DIM_SPEC_VAR_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_UNSET_DIM_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_UNSET_DIM_SPEC_UNUSED_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_UNSET_DIM_SPEC_UNUSED_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_UNSET_DIM_SPEC_UNUSED_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_UNSET_DIM_SPEC_UNUSED_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_UNSET_DIM_SPEC_CV_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_UNSET_DIM_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_UNSET_DIM_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_UNSET_DIM_SPEC_CV_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_UNSET_OBJ_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_UNSET_OBJ_SPEC_VAR_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_UNSET_OBJ_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_UNSET_OBJ_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_UNSET_OBJ_SPEC_UNUSED_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_UNSET_OBJ_SPEC_UNUSED_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_UNSET_OBJ_SPEC_UNUSED_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_UNSET_OBJ_SPEC_UNUSED_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_UNSET_OBJ_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_UNSET_OBJ_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_UNSET_OBJ_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_UNSET_OBJ_SPEC_CV_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_FE_RESET_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_FE_RESET_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_FE_RESET_SPEC_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FE_RESET_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_FE_RESET_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_FE_RESET_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_FE_RESET_SPEC_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FE_RESET_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_FE_RESET_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_FE_RESET_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_FE_RESET_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FE_RESET_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_FE_RESET_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_FE_RESET_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_FE_RESET_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FE_RESET_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_FE_RESET_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_FE_RESET_SPEC_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FE_RESET_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_FE_RESET_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FE_FETCH_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_FE_FETCH_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_FE_FETCH_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_FE_FETCH_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FE_FETCH_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_EXIT_SPEC_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_EXIT_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_EXIT_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_EXIT_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_EXIT_SPEC_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_EXIT_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_EXIT_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_EXIT_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_EXIT_SPEC_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_EXIT_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_EXIT_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_EXIT_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_EXIT_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_EXIT_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_EXIT_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_EXIT_SPEC_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_EXIT_SPEC_UNUSED_HANDLER), 
        (opcode_handler_t const   )(& ZEND_EXIT_SPEC_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_EXIT_SPEC_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_EXIT_SPEC_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_EXIT_SPEC_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_EXIT_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_EXIT_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_EXIT_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_EXIT_SPEC_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_R_SPEC_CONST_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_R_SPEC_CONST_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_R_SPEC_CONST_UNUSED_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_R_SPEC_TMP_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_R_SPEC_TMP_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_R_SPEC_TMP_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_R_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_R_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_R_SPEC_VAR_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_R_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_R_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_R_SPEC_CV_UNUSED_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_DIM_R_SPEC_VAR_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_DIM_R_SPEC_VAR_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_DIM_R_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_DIM_R_SPEC_VAR_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_DIM_R_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_DIM_R_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_DIM_R_SPEC_CV_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_DIM_R_SPEC_CV_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_OBJ_R_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_R_SPEC_VAR_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_R_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_OBJ_R_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_R_SPEC_UNUSED_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_R_SPEC_UNUSED_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_R_SPEC_UNUSED_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_R_SPEC_UNUSED_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_R_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_R_SPEC_CV_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_OBJ_R_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_R_SPEC_CV_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_W_SPEC_CONST_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_W_SPEC_CONST_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_W_SPEC_CONST_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_W_SPEC_TMP_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_W_SPEC_TMP_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_W_SPEC_TMP_UNUSED_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_W_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_W_SPEC_VAR_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_W_SPEC_VAR_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_W_SPEC_CV_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_W_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_W_SPEC_CV_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_DIM_W_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_DIM_W_SPEC_VAR_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_DIM_W_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_DIM_W_SPEC_VAR_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_DIM_W_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_DIM_W_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_DIM_W_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_DIM_W_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_DIM_W_SPEC_CV_UNUSED_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_DIM_W_SPEC_CV_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_W_SPEC_VAR_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_OBJ_W_SPEC_VAR_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_W_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_W_SPEC_VAR_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_OBJ_W_SPEC_UNUSED_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_W_SPEC_UNUSED_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_W_SPEC_UNUSED_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_OBJ_W_SPEC_UNUSED_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_W_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_W_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_W_SPEC_CV_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_W_SPEC_CV_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_RW_SPEC_CONST_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_RW_SPEC_CONST_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_RW_SPEC_CONST_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_RW_SPEC_TMP_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_RW_SPEC_TMP_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_RW_SPEC_TMP_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_RW_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_RW_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_RW_SPEC_VAR_UNUSED_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_RW_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_RW_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_RW_SPEC_CV_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_DIM_RW_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_DIM_RW_SPEC_VAR_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_DIM_RW_SPEC_VAR_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_DIM_RW_SPEC_VAR_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_DIM_RW_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_DIM_RW_SPEC_CV_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_DIM_RW_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_DIM_RW_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_DIM_RW_SPEC_CV_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_DIM_RW_SPEC_CV_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_RW_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_RW_SPEC_VAR_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_OBJ_RW_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_RW_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_RW_SPEC_UNUSED_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_OBJ_RW_SPEC_UNUSED_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_RW_SPEC_UNUSED_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_RW_SPEC_UNUSED_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_OBJ_RW_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_RW_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_RW_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_OBJ_RW_SPEC_CV_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_IS_SPEC_CONST_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_IS_SPEC_CONST_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_IS_SPEC_CONST_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_IS_SPEC_TMP_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_IS_SPEC_TMP_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_IS_SPEC_TMP_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_IS_SPEC_VAR_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_IS_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_IS_SPEC_VAR_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_IS_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_IS_SPEC_CV_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_IS_SPEC_CV_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_DIM_IS_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_DIM_IS_SPEC_VAR_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_DIM_IS_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_DIM_IS_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_DIM_IS_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_DIM_IS_SPEC_CV_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_DIM_IS_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_DIM_IS_SPEC_CV_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_IS_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_IS_SPEC_VAR_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_IS_SPEC_VAR_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_IS_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_IS_SPEC_UNUSED_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_IS_SPEC_UNUSED_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_OBJ_IS_SPEC_UNUSED_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_IS_SPEC_UNUSED_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_IS_SPEC_CV_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_OBJ_IS_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_IS_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_IS_SPEC_CV_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_FUNC_ARG_SPEC_CONST_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_FUNC_ARG_SPEC_CONST_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_FUNC_ARG_SPEC_CONST_UNUSED_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_FUNC_ARG_SPEC_TMP_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_FUNC_ARG_SPEC_TMP_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_FUNC_ARG_SPEC_TMP_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_FUNC_ARG_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_FUNC_ARG_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_FUNC_ARG_SPEC_VAR_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_FUNC_ARG_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_FUNC_ARG_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_FUNC_ARG_SPEC_CV_UNUSED_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_UNSET_SPEC_CONST_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_UNSET_SPEC_CONST_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_UNSET_SPEC_CONST_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_UNSET_SPEC_TMP_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_UNSET_SPEC_TMP_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_UNSET_SPEC_TMP_UNUSED_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_UNSET_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_UNSET_SPEC_VAR_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_UNSET_SPEC_VAR_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_UNSET_SPEC_CV_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_UNSET_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_UNSET_SPEC_CV_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_DIM_UNSET_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_DIM_UNSET_SPEC_VAR_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_DIM_UNSET_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_DIM_UNSET_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_DIM_UNSET_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_DIM_UNSET_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_DIM_UNSET_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_DIM_UNSET_SPEC_CV_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_UNSET_SPEC_VAR_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_OBJ_UNSET_SPEC_VAR_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_UNSET_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_UNSET_SPEC_VAR_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_UNSET_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_UNSET_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_UNSET_SPEC_CV_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_OBJ_UNSET_SPEC_CV_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_DIM_TMP_VAR_SPEC_CONST_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_DIM_TMP_VAR_SPEC_TMP_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_CONSTANT_SPEC_CONST_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_CONSTANT_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_CONSTANT_SPEC_UNUSED_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_GOTO_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_GOTO_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_GOTO_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_GOTO_SPEC_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_GOTO_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_STMT_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_STMT_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_STMT_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_EXT_STMT_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_STMT_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_STMT_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_STMT_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_EXT_STMT_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_STMT_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_STMT_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_STMT_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_EXT_STMT_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_STMT_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_STMT_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_STMT_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_EXT_STMT_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_STMT_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_STMT_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_STMT_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_EXT_STMT_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_STMT_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_STMT_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_STMT_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_EXT_STMT_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_STMT_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_FCALL_END_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_EXT_FCALL_END_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_FCALL_END_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_FCALL_END_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_FCALL_END_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_EXT_FCALL_END_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_FCALL_END_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_FCALL_END_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_FCALL_END_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_EXT_FCALL_END_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_FCALL_END_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_FCALL_END_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_FCALL_END_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_EXT_FCALL_END_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_FCALL_END_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_FCALL_END_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_FCALL_END_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_EXT_FCALL_END_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_FCALL_END_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_FCALL_END_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_FCALL_END_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_EXT_FCALL_END_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_FCALL_END_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_FCALL_END_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_FCALL_END_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_EXT_NOP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_NOP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_NOP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_NOP_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_EXT_NOP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_NOP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_NOP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_NOP_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_EXT_NOP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_NOP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_NOP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_NOP_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_EXT_NOP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_NOP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_NOP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_NOP_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_EXT_NOP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_NOP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_NOP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_NOP_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_EXT_NOP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_NOP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_NOP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_EXT_NOP_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_EXT_NOP_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_TICKS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_TICKS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_TICKS_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_TICKS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_TICKS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_TICKS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_TICKS_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_TICKS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_TICKS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_TICKS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_TICKS_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_TICKS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_TICKS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_TICKS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_TICKS_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_TICKS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_TICKS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_TICKS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_TICKS_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_TICKS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_TICKS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_TICKS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_TICKS_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_TICKS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_TICKS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_SEND_VAR_NO_REF_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_SEND_VAR_NO_REF_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_SEND_VAR_NO_REF_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_SEND_VAR_NO_REF_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_SEND_VAR_NO_REF_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_SEND_VAR_NO_REF_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_SEND_VAR_NO_REF_SPEC_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_SEND_VAR_NO_REF_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_SEND_VAR_NO_REF_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_SEND_VAR_NO_REF_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_CATCH_SPEC_CONST_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_THROW_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_THROW_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_THROW_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_THROW_SPEC_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_THROW_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_THROW_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_THROW_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_THROW_SPEC_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_THROW_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_THROW_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_THROW_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_THROW_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_THROW_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_THROW_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_THROW_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_THROW_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_THROW_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_THROW_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_THROW_SPEC_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_THROW_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_CLASS_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_CLASS_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_CLASS_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_CLASS_SPEC_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_CLASS_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_CLASS_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_CLASS_SPEC_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_CLASS_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_CLASS_SPEC_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_CLASS_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_CLASS_SPEC_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_CLASS_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_CLASS_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_CLASS_SPEC_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_CLASS_SPEC_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_CLASS_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_CLASS_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_CLASS_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_CLASS_SPEC_UNUSED_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_CLASS_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_CLASS_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_CLASS_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_CLASS_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_FETCH_CLASS_SPEC_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_FETCH_CLASS_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_CLONE_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_CLONE_SPEC_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_CLONE_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_CLONE_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_CLONE_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_CLONE_SPEC_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_CLONE_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_CLONE_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_CLONE_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_CLONE_SPEC_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_CLONE_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_CLONE_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_CLONE_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_CLONE_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_CLONE_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_CLONE_SPEC_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_CLONE_SPEC_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_CLONE_SPEC_UNUSED_HANDLER), 
        (opcode_handler_t const   )(& ZEND_CLONE_SPEC_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_CLONE_SPEC_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_CLONE_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_CLONE_SPEC_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_CLONE_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_CLONE_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_CLONE_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_RETURN_BY_REF_SPEC_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_RETURN_BY_REF_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_RETURN_BY_REF_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_RETURN_BY_REF_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_RETURN_BY_REF_SPEC_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_RETURN_BY_REF_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_RETURN_BY_REF_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_RETURN_BY_REF_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_RETURN_BY_REF_SPEC_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_RETURN_BY_REF_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_RETURN_BY_REF_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_RETURN_BY_REF_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_RETURN_BY_REF_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_RETURN_BY_REF_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_RETURN_BY_REF_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_RETURN_BY_REF_SPEC_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_RETURN_BY_REF_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_RETURN_BY_REF_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_RETURN_BY_REF_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_RETURN_BY_REF_SPEC_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_METHOD_CALL_SPEC_TMP_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_METHOD_CALL_SPEC_TMP_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_METHOD_CALL_SPEC_TMP_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_METHOD_CALL_SPEC_TMP_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_METHOD_CALL_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_METHOD_CALL_SPEC_VAR_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_INIT_METHOD_CALL_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_METHOD_CALL_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_METHOD_CALL_SPEC_UNUSED_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_INIT_METHOD_CALL_SPEC_UNUSED_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_METHOD_CALL_SPEC_UNUSED_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_METHOD_CALL_SPEC_UNUSED_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_INIT_METHOD_CALL_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_METHOD_CALL_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_METHOD_CALL_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_INIT_METHOD_CALL_SPEC_CV_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ISSET_ISEMPTY_VAR_SPEC_CONST_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ISSET_ISEMPTY_VAR_SPEC_CONST_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_ISSET_ISEMPTY_VAR_SPEC_CONST_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ISSET_ISEMPTY_VAR_SPEC_TMP_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ISSET_ISEMPTY_VAR_SPEC_TMP_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_ISSET_ISEMPTY_VAR_SPEC_TMP_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ISSET_ISEMPTY_VAR_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ISSET_ISEMPTY_VAR_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_ISSET_ISEMPTY_VAR_SPEC_VAR_UNUSED_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ISSET_ISEMPTY_VAR_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ISSET_ISEMPTY_VAR_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_ISSET_ISEMPTY_VAR_SPEC_CV_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_VAR_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_VAR_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_PRE_INC_OBJ_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_PRE_INC_OBJ_SPEC_VAR_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_PRE_INC_OBJ_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_PRE_INC_OBJ_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_PRE_INC_OBJ_SPEC_UNUSED_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_PRE_INC_OBJ_SPEC_UNUSED_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_PRE_INC_OBJ_SPEC_UNUSED_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_PRE_INC_OBJ_SPEC_UNUSED_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_PRE_INC_OBJ_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_PRE_INC_OBJ_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_PRE_INC_OBJ_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_PRE_INC_OBJ_SPEC_CV_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_PRE_DEC_OBJ_SPEC_VAR_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_PRE_DEC_OBJ_SPEC_VAR_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_PRE_DEC_OBJ_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_PRE_DEC_OBJ_SPEC_VAR_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_PRE_DEC_OBJ_SPEC_UNUSED_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_PRE_DEC_OBJ_SPEC_UNUSED_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_PRE_DEC_OBJ_SPEC_UNUSED_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_PRE_DEC_OBJ_SPEC_UNUSED_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_PRE_DEC_OBJ_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_PRE_DEC_OBJ_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_PRE_DEC_OBJ_SPEC_CV_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_PRE_DEC_OBJ_SPEC_CV_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_POST_INC_OBJ_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_POST_INC_OBJ_SPEC_VAR_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_POST_INC_OBJ_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_POST_INC_OBJ_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_POST_INC_OBJ_SPEC_UNUSED_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_POST_INC_OBJ_SPEC_UNUSED_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_POST_INC_OBJ_SPEC_UNUSED_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_POST_INC_OBJ_SPEC_UNUSED_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_POST_INC_OBJ_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_POST_INC_OBJ_SPEC_CV_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_POST_INC_OBJ_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_POST_INC_OBJ_SPEC_CV_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_POST_DEC_OBJ_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_POST_DEC_OBJ_SPEC_VAR_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_POST_DEC_OBJ_SPEC_VAR_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_POST_DEC_OBJ_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_POST_DEC_OBJ_SPEC_UNUSED_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_POST_DEC_OBJ_SPEC_UNUSED_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_POST_DEC_OBJ_SPEC_UNUSED_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_POST_DEC_OBJ_SPEC_UNUSED_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_POST_DEC_OBJ_SPEC_CV_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_POST_DEC_OBJ_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_POST_DEC_OBJ_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_POST_DEC_OBJ_SPEC_CV_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_OBJ_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_OBJ_SPEC_VAR_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_OBJ_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_OBJ_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_OBJ_SPEC_UNUSED_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_OBJ_SPEC_UNUSED_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_OBJ_SPEC_UNUSED_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_OBJ_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_OBJ_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_OBJ_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_OBJ_SPEC_CV_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_INSTANCEOF_SPEC_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_INSTANCEOF_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_INSTANCEOF_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_INSTANCEOF_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_INSTANCEOF_SPEC_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_INSTANCEOF_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_INSTANCEOF_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_INSTANCEOF_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_INSTANCEOF_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_INSTANCEOF_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_INSTANCEOF_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_INSTANCEOF_SPEC_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_INSTANCEOF_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_INSTANCEOF_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_INSTANCEOF_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_CLASS_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_DECLARE_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_CLASS_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_DECLARE_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_CLASS_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_DECLARE_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_CLASS_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_DECLARE_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_CLASS_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_DECLARE_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_CLASS_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_DECLARE_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_CLASS_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_FUNCTION_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_FUNCTION_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_FUNCTION_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_DECLARE_FUNCTION_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_FUNCTION_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_FUNCTION_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_FUNCTION_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_DECLARE_FUNCTION_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_FUNCTION_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_FUNCTION_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_FUNCTION_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_DECLARE_FUNCTION_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_FUNCTION_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_FUNCTION_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_FUNCTION_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_DECLARE_FUNCTION_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_FUNCTION_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_FUNCTION_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_FUNCTION_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_DECLARE_FUNCTION_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_FUNCTION_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_FUNCTION_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_FUNCTION_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_DECLARE_FUNCTION_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_FUNCTION_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_CONST_SPEC_CONST_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ADD_INTERFACE_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_INTERFACE_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_INTERFACE_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_INTERFACE_SPEC_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ADD_INTERFACE_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_DIM_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_DIM_SPEC_VAR_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_DIM_SPEC_VAR_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_DIM_SPEC_VAR_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_DIM_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_DIM_SPEC_CV_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ASSIGN_DIM_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_DIM_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_DIM_SPEC_CV_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_ASSIGN_DIM_SPEC_CV_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_VAR_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_VAR_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_VAR_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_VAR_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_HANDLE_EXCEPTION_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_HANDLE_EXCEPTION_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_HANDLE_EXCEPTION_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_HANDLE_EXCEPTION_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_HANDLE_EXCEPTION_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_HANDLE_EXCEPTION_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_HANDLE_EXCEPTION_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_HANDLE_EXCEPTION_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_HANDLE_EXCEPTION_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_HANDLE_EXCEPTION_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_HANDLE_EXCEPTION_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_HANDLE_EXCEPTION_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_HANDLE_EXCEPTION_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_HANDLE_EXCEPTION_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_HANDLE_EXCEPTION_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_HANDLE_EXCEPTION_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_HANDLE_EXCEPTION_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_HANDLE_EXCEPTION_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_HANDLE_EXCEPTION_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_HANDLE_EXCEPTION_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_HANDLE_EXCEPTION_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_HANDLE_EXCEPTION_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_HANDLE_EXCEPTION_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_HANDLE_EXCEPTION_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_HANDLE_EXCEPTION_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_USER_OPCODE_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_USER_OPCODE_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_USER_OPCODE_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_USER_OPCODE_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_USER_OPCODE_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_USER_OPCODE_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_USER_OPCODE_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_USER_OPCODE_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_USER_OPCODE_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_USER_OPCODE_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_USER_OPCODE_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_USER_OPCODE_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_USER_OPCODE_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_USER_OPCODE_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_USER_OPCODE_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_USER_OPCODE_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_USER_OPCODE_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_USER_OPCODE_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_USER_OPCODE_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_USER_OPCODE_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_USER_OPCODE_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_USER_OPCODE_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_USER_OPCODE_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_USER_OPCODE_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_USER_OPCODE_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_JMP_SET_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SET_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SET_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SET_SPEC_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_JMP_SET_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SET_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SET_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SET_SPEC_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_JMP_SET_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SET_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SET_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SET_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_JMP_SET_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SET_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SET_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_JMP_SET_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SET_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SET_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SET_SPEC_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_JMP_SET_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_DECLARE_LAMBDA_FUNCTION_SPEC_CONST_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_TRAIT_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_TRAIT_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ADD_TRAIT_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_TRAIT_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_TRAIT_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_TRAIT_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ADD_TRAIT_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_TRAIT_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_TRAIT_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_TRAIT_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ADD_TRAIT_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_TRAIT_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_TRAIT_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_TRAIT_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ADD_TRAIT_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_TRAIT_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_TRAIT_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_TRAIT_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ADD_TRAIT_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_TRAIT_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_TRAIT_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_TRAIT_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_ADD_TRAIT_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_TRAIT_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_ADD_TRAIT_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_BIND_TRAITS_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BIND_TRAITS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_BIND_TRAITS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_BIND_TRAITS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_BIND_TRAITS_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BIND_TRAITS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_BIND_TRAITS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_BIND_TRAITS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_BIND_TRAITS_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BIND_TRAITS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_BIND_TRAITS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_BIND_TRAITS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_BIND_TRAITS_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BIND_TRAITS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_BIND_TRAITS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_BIND_TRAITS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_BIND_TRAITS_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BIND_TRAITS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_BIND_TRAITS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_BIND_TRAITS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_BIND_TRAITS_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_BIND_TRAITS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_BIND_TRAITS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_BIND_TRAITS_SPEC_HANDLER),      (opcode_handler_t const   )(& ZEND_BIND_TRAITS_SPEC_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_SEPARATE_SPEC_VAR_UNUSED_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_QM_ASSIGN_VAR_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_QM_ASSIGN_VAR_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_QM_ASSIGN_VAR_SPEC_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_QM_ASSIGN_VAR_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_QM_ASSIGN_VAR_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_QM_ASSIGN_VAR_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_QM_ASSIGN_VAR_SPEC_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_QM_ASSIGN_VAR_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_QM_ASSIGN_VAR_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_QM_ASSIGN_VAR_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_QM_ASSIGN_VAR_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_QM_ASSIGN_VAR_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_QM_ASSIGN_VAR_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_QM_ASSIGN_VAR_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_QM_ASSIGN_VAR_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_QM_ASSIGN_VAR_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_QM_ASSIGN_VAR_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_QM_ASSIGN_VAR_SPEC_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_QM_ASSIGN_VAR_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_QM_ASSIGN_VAR_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SET_VAR_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SET_VAR_SPEC_CONST_HANDLER), 
        (opcode_handler_t const   )(& ZEND_JMP_SET_VAR_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SET_VAR_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SET_VAR_SPEC_CONST_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SET_VAR_SPEC_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_JMP_SET_VAR_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SET_VAR_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SET_VAR_SPEC_TMP_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SET_VAR_SPEC_TMP_HANDLER), 
        (opcode_handler_t const   )(& ZEND_JMP_SET_VAR_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SET_VAR_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SET_VAR_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SET_VAR_SPEC_VAR_HANDLER), 
        (opcode_handler_t const   )(& ZEND_JMP_SET_VAR_SPEC_VAR_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER), 
        (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SET_VAR_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SET_VAR_SPEC_CV_HANDLER), 
        (opcode_handler_t const   )(& ZEND_JMP_SET_VAR_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SET_VAR_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_JMP_SET_VAR_SPEC_CV_HANDLER),      (opcode_handler_t const   )(& ZEND_NULL_HANDLER)};
void zend_init_opcodes_handlers(void) 
{ 

  {
  zend_opcode_handlers = (opcode_handler_t __attribute__((__visibility__("default")))  *)((opcode_handler_t *)(labels));
  return;
}
}
static opcode_handler_t zend_vm_get_opcode_handler(zend_uchar opcode , zend_op *op ) ;
static int const   zend_vm_decode[17]  = 
  {      (int const   )3,      (int const   )0,      (int const   )1,      (int const   )3, 
        (int const   )2,      (int const   )3,      (int const   )3,      (int const   )3, 
        (int const   )3,      (int const   )3,      (int const   )3,      (int const   )3, 
        (int const   )3,      (int const   )3,      (int const   )3,      (int const   )3, 
        (int const   )4};
static opcode_handler_t zend_vm_get_opcode_handler(zend_uchar opcode , zend_op *op ) 
{ 

  {
  return ((int ( __attribute__((__fastcall__)) (*))(zend_execute_data *execute_data ))*(zend_opcode_handlers + (((int )opcode * 25 + (int )(zend_vm_decode[op->op1_type] * 5)) + (int )zend_vm_decode[op->op2_type])));
}
}
void __attribute__((__visibility__("default")))  zend_vm_set_opcode_handler(zend_op *op ) 
{ 

  {
  op->handler = zend_vm_get_opcode_handler(zend_user_opcodes[op->opcode], op);
  return;
}
}
int __attribute__((__visibility__("default")))  zend_do_fcall(zend_execute_data *execute_data ) 
{ int tmp ;

  {
  tmp = zend_do_fcall_common_helper_SPEC(execute_data);
  return ((int __attribute__((__visibility__("default")))  )tmp);
}
}
int __attribute__((__visibility__("default")))  zend_set_user_opcode_handler(zend_uchar opcode , int (*handler)(zend_execute_data *execute_data ) ) 
{ 

  {
  if ((int )opcode != 150) {
    zend_user_opcodes[opcode] = (unsigned char)150;
    zend_user_opcode_handlers[opcode] = handler;
    return ((int __attribute__((__visibility__("default")))  )0);
  } else {

  }
  return ((int __attribute__((__visibility__("default")))  )-1);
}
}
user_opcode_handler_t __attribute__((__visibility__("default")))  zend_get_user_opcode_handler(zend_uchar opcode ) 
{ 

  {
  return ((int (*/* __attribute__((__visibility__("default"))) */)(zend_execute_data *execute_data ))zend_user_opcode_handlers[opcode]);
}
}
zval __attribute__((__visibility__("default")))  *zend_get_zval_ptr(int op_type , znode_op const   *node , temp_variable const   *Ts , zend_free_op *should_free , int type ) 
{ zval *tmp ;

  {
  tmp = _get_zval_ptr(op_type, node, Ts, should_free, type);
  return ((zval __attribute__((__visibility__("default")))  *)tmp);
}
}
zval __attribute__((__visibility__("default")))  **zend_get_zval_ptr_ptr(int op_type , znode_op const   *node , temp_variable const   *Ts , zend_free_op *should_free , int type ) 
{ zval **tmp ;

  {
  tmp = _get_zval_ptr_ptr(op_type, node, Ts, should_free, type);
  return ((zval __attribute__((__visibility__("default")))  **)tmp);
}
}
