# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_execute.c"
# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_execute.c"
# 24 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_execute.c"
# 1 "/usr/include/stdio.h" 1 3 4
# 28 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 361 "/usr/include/features.h" 3 4
# 1 "/usr/include/sys/cdefs.h" 1 3 4
# 365 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 366 "/usr/include/sys/cdefs.h" 2 3 4
# 362 "/usr/include/features.h" 2 3 4
# 385 "/usr/include/features.h" 3 4
# 1 "/usr/include/gnu/stubs.h" 1 3 4



# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 5 "/usr/include/gnu/stubs.h" 2 3 4


# 1 "/usr/include/gnu/stubs-32.h" 1 3 4
# 8 "/usr/include/gnu/stubs.h" 2 3 4
# 386 "/usr/include/features.h" 2 3 4
# 29 "/usr/include/stdio.h" 2 3 4





# 1 "/usr/lib/gcc/i686-redhat-linux/4.4.5/include/stddef.h" 1 3 4
# 211 "/usr/lib/gcc/i686-redhat-linux/4.4.5/include/stddef.h" 3 4
typedef unsigned int size_t;
# 35 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/bits/types.h" 1 3 4
# 28 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;




__extension__ typedef signed long long int __int64_t;
__extension__ typedef unsigned long long int __uint64_t;







__extension__ typedef long long int __quad_t;
__extension__ typedef unsigned long long int __u_quad_t;
# 131 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/typesizes.h" 1 3 4
# 132 "/usr/include/bits/types.h" 2 3 4


__extension__ typedef __u_quad_t __dev_t;
__extension__ typedef unsigned int __uid_t;
__extension__ typedef unsigned int __gid_t;
__extension__ typedef unsigned long int __ino_t;
__extension__ typedef __u_quad_t __ino64_t;
__extension__ typedef unsigned int __mode_t;
__extension__ typedef unsigned int __nlink_t;
__extension__ typedef long int __off_t;
__extension__ typedef __quad_t __off64_t;
__extension__ typedef int __pid_t;
__extension__ typedef struct { int __val[2]; } __fsid_t;
__extension__ typedef long int __clock_t;
__extension__ typedef unsigned long int __rlim_t;
__extension__ typedef __u_quad_t __rlim64_t;
__extension__ typedef unsigned int __id_t;
__extension__ typedef long int __time_t;
__extension__ typedef unsigned int __useconds_t;
__extension__ typedef long int __suseconds_t;

__extension__ typedef int __daddr_t;
__extension__ typedef long int __swblk_t;
__extension__ typedef int __key_t;


__extension__ typedef int __clockid_t;


__extension__ typedef void * __timer_t;


__extension__ typedef long int __blksize_t;




__extension__ typedef long int __blkcnt_t;
__extension__ typedef __quad_t __blkcnt64_t;


__extension__ typedef unsigned long int __fsblkcnt_t;
__extension__ typedef __u_quad_t __fsblkcnt64_t;


__extension__ typedef unsigned long int __fsfilcnt_t;
__extension__ typedef __u_quad_t __fsfilcnt64_t;

__extension__ typedef int __ssize_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


__extension__ typedef int __intptr_t;


__extension__ typedef unsigned int __socklen_t;
# 37 "/usr/include/stdio.h" 2 3 4
# 45 "/usr/include/stdio.h" 3 4
struct _IO_FILE;



typedef struct _IO_FILE FILE;





# 65 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 75 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
# 32 "/usr/include/libio.h" 3 4
# 1 "/usr/include/_G_config.h" 1 3 4
# 15 "/usr/include/_G_config.h" 3 4
# 1 "/usr/lib/gcc/i686-redhat-linux/4.4.5/include/stddef.h" 1 3 4
# 16 "/usr/include/_G_config.h" 2 3 4




# 1 "/usr/include/wchar.h" 1 3 4
# 83 "/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;
# 21 "/usr/include/_G_config.h" 2 3 4

typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 53 "/usr/include/_G_config.h" 3 4
typedef int _G_int16_t __attribute__ ((__mode__ (__HI__)));
typedef int _G_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int _G_uint16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int _G_uint32_t __attribute__ ((__mode__ (__SI__)));
# 33 "/usr/include/libio.h" 2 3 4
# 53 "/usr/include/libio.h" 3 4
# 1 "/usr/lib/gcc/i686-redhat-linux/4.4.5/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/i686-redhat-linux/4.4.5/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 54 "/usr/include/libio.h" 2 3 4
# 170 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;
# 180 "/usr/include/libio.h" 3 4
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 203 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 271 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 319 "/usr/include/libio.h" 3 4
  __off64_t _offset;
# 328 "/usr/include/libio.h" 3 4
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};


typedef struct _IO_FILE _IO_FILE;


struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 364 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, __const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);
# 416 "/usr/include/libio.h" 3 4
extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 460 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) __attribute__ ((__nothrow__));
extern int _IO_ferror (_IO_FILE *__fp) __attribute__ ((__nothrow__));

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) __attribute__ ((__nothrow__));
extern void _IO_funlockfile (_IO_FILE *) __attribute__ ((__nothrow__));
extern int _IO_ftrylockfile (_IO_FILE *) __attribute__ ((__nothrow__));
# 490 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) __attribute__ ((__nothrow__));
# 76 "/usr/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
# 91 "/usr/include/stdio.h" 3 4
typedef __off_t off_t;
# 103 "/usr/include/stdio.h" 3 4
typedef __ssize_t ssize_t;







typedef _G_fpos_t fpos_t;




# 161 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 162 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;









extern int remove (__const char *__filename) __attribute__ ((__nothrow__));

extern int rename (__const char *__old, __const char *__new) __attribute__ ((__nothrow__));




extern int renameat (int __oldfd, __const char *__old, int __newfd,
       __const char *__new) __attribute__ ((__nothrow__));








extern FILE *tmpfile (void) ;
# 208 "/usr/include/stdio.h" 3 4
extern char *tmpnam (char *__s) __attribute__ ((__nothrow__)) ;





extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__)) ;
# 226 "/usr/include/stdio.h" 3 4
extern char *tempnam (__const char *__dir, __const char *__pfx)
     __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) ;








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

# 251 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 265 "/usr/include/stdio.h" 3 4






extern FILE *fopen (__const char *__restrict __filename,
      __const char *__restrict __modes) ;




extern FILE *freopen (__const char *__restrict __filename,
        __const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 294 "/usr/include/stdio.h" 3 4

# 305 "/usr/include/stdio.h" 3 4
extern FILE *fdopen (int __fd, __const char *__modes) __attribute__ ((__nothrow__)) ;
# 318 "/usr/include/stdio.h" 3 4
extern FILE *fmemopen (void *__s, size_t __len, __const char *__modes)
  __attribute__ ((__nothrow__)) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__)) ;






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__));





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__));








extern int fprintf (FILE *__restrict __stream,
      __const char *__restrict __format, ...);




extern int printf (__const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      __const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, __const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (__const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, __const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));





extern int snprintf (char *__restrict __s, size_t __maxlen,
       __const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        __const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));

# 416 "/usr/include/stdio.h" 3 4
extern int vdprintf (int __fd, __const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, __const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));








extern int fscanf (FILE *__restrict __stream,
     __const char *__restrict __format, ...) ;




extern int scanf (__const char *__restrict __format, ...) ;

extern int sscanf (__const char *__restrict __s,
     __const char *__restrict __format, ...) __attribute__ ((__nothrow__));
# 447 "/usr/include/stdio.h" 3 4
extern int fscanf (FILE *__restrict __stream, __const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf")

                               ;
extern int scanf (__const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf")
                              ;
extern int sscanf (__const char *__restrict __s, __const char *__restrict __format, ...) __asm__ ("" "__isoc99_sscanf") __attribute__ ((__nothrow__))

                      ;
# 467 "/usr/include/stdio.h" 3 4








extern int vfscanf (FILE *__restrict __s, __const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (__const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (__const char *__restrict __s,
      __const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__scanf__, 2, 0)));
# 498 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, __const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (__const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (__const char *__restrict __s, __const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vsscanf") __attribute__ ((__nothrow__))



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 526 "/usr/include/stdio.h" 3 4









extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

# 554 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 565 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);

# 598 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;






extern char *gets (char *__s) ;

# 660 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;








extern int fputs (__const char *__restrict __s, FILE *__restrict __stream);





extern int puts (__const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (__const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s) ;

# 732 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (__const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream) ;








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);

# 768 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 787 "/usr/include/stdio.h" 3 4






extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, __const fpos_t *__pos);
# 810 "/usr/include/stdio.h" 3 4

# 819 "/usr/include/stdio.h" 3 4


extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__)) ;

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__)) ;




extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__)) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__)) ;








extern void perror (__const char *__s);






# 1 "/usr/include/bits/sys_errlist.h" 1 3 4
# 27 "/usr/include/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern __const char *__const sys_errlist[];
# 849 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__)) ;




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__)) ;
# 868 "/usr/include/stdio.h" 3 4
extern FILE *popen (__const char *__command, __const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) __attribute__ ((__nothrow__));
# 908 "/usr/include/stdio.h" 3 4
extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__)) ;


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__));
# 929 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/stdio.h" 1 3 4
# 36 "/usr/include/bits/stdio.h" 3 4
extern __inline int
vprintf (__const char *__restrict __fmt, __gnuc_va_list __arg)
{
  return vfprintf (stdout, __fmt, __arg);
}



extern __inline int
getchar (void)
{
  return _IO_getc (stdin);
}




extern __inline int
fgetc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}





extern __inline int
getc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}


extern __inline int
getchar_unlocked (void)
{
  return (__builtin_expect (((stdin)->_IO_read_ptr >= (stdin)->_IO_read_end), 0) ? __uflow (stdin) : *(unsigned char *) (stdin)->_IO_read_ptr++);
}




extern __inline int
putchar (int __c)
{
  return _IO_putc (__c, stdout);
}




extern __inline int
fputc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}





extern __inline int
putc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}


extern __inline int
putchar_unlocked (int __c)
{
  return (__builtin_expect (((stdout)->_IO_write_ptr >= (stdout)->_IO_write_end), 0) ? __overflow (stdout, (unsigned char) (__c)) : (unsigned char) (*(stdout)->_IO_write_ptr++ = (__c)));
}
# 125 "/usr/include/bits/stdio.h" 3 4
extern __inline int
__attribute__ ((__nothrow__)) feof_unlocked (FILE *__stream)
{
  return (((__stream)->_flags & 0x10) != 0);
}


extern __inline int
__attribute__ ((__nothrow__)) ferror_unlocked (FILE *__stream)
{
  return (((__stream)->_flags & 0x20) != 0);
}
# 930 "/usr/include/stdio.h" 2 3 4
# 938 "/usr/include/stdio.h" 3 4

# 25 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_execute.c" 2
# 1 "/usr/include/signal.h" 1 3 4
# 31 "/usr/include/signal.h" 3 4


# 1 "/usr/include/bits/sigset.h" 1 3 4
# 24 "/usr/include/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 104 "/usr/include/bits/sigset.h" 3 4
extern int __sigismember (__const __sigset_t *, int);
extern int __sigaddset (__sigset_t *, int);
extern int __sigdelset (__sigset_t *, int);
# 118 "/usr/include/bits/sigset.h" 3 4
extern __inline int __sigismember (__const __sigset_t *__set, int __sig) { unsigned long int __mask = (((unsigned long int) 1) << (((__sig) - 1) % (8 * sizeof (unsigned long int)))); unsigned long int __word = (((__sig) - 1) / (8 * sizeof (unsigned long int))); return (__set->__val[__word] & __mask) ? 1 : 0; }
extern __inline int __sigaddset ( __sigset_t *__set, int __sig) { unsigned long int __mask = (((unsigned long int) 1) << (((__sig) - 1) % (8 * sizeof (unsigned long int)))); unsigned long int __word = (((__sig) - 1) / (8 * sizeof (unsigned long int))); return ((__set->__val[__word] |= __mask), 0); }
extern __inline int __sigdelset ( __sigset_t *__set, int __sig) { unsigned long int __mask = (((unsigned long int) 1) << (((__sig) - 1) % (8 * sizeof (unsigned long int)))); unsigned long int __word = (((__sig) - 1) / (8 * sizeof (unsigned long int))); return ((__set->__val[__word] &= ~__mask), 0); }
# 34 "/usr/include/signal.h" 2 3 4







typedef __sig_atomic_t sig_atomic_t;








typedef __sigset_t sigset_t;







# 1 "/usr/include/bits/signum.h" 1 3 4
# 59 "/usr/include/signal.h" 2 3 4



typedef __pid_t pid_t;





typedef __uid_t uid_t;







# 1 "/usr/include/time.h" 1 3 4
# 120 "/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    long int tv_nsec;
  };
# 77 "/usr/include/signal.h" 2 3 4


# 1 "/usr/include/bits/siginfo.h" 1 3 4
# 25 "/usr/include/bits/siginfo.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 26 "/usr/include/bits/siginfo.h" 2 3 4







typedef union sigval
  {
    int sival_int;
    void *sival_ptr;
  } sigval_t;
# 51 "/usr/include/bits/siginfo.h" 3 4
typedef struct siginfo
  {
    int si_signo;
    int si_errno;

    int si_code;

    union
      {
 int _pad[((128 / sizeof (int)) - 3)];


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
   } _kill;


 struct
   {
     int si_tid;
     int si_overrun;
     sigval_t si_sigval;
   } _timer;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     sigval_t si_sigval;
   } _rt;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     int si_status;
     __clock_t si_utime;
     __clock_t si_stime;
   } _sigchld;


 struct
   {
     void *si_addr;
   } _sigfault;


 struct
   {
     long int si_band;
     int si_fd;
   } _sigpoll;
      } _sifields;
  } siginfo_t;
# 129 "/usr/include/bits/siginfo.h" 3 4
enum
{
  SI_ASYNCNL = -60,

  SI_TKILL = -6,

  SI_SIGIO,

  SI_ASYNCIO,

  SI_MESGQ,

  SI_TIMER,

  SI_QUEUE,

  SI_USER,

  SI_KERNEL = 0x80

};



enum
{
  ILL_ILLOPC = 1,

  ILL_ILLOPN,

  ILL_ILLADR,

  ILL_ILLTRP,

  ILL_PRVOPC,

  ILL_PRVREG,

  ILL_COPROC,

  ILL_BADSTK

};


enum
{
  FPE_INTDIV = 1,

  FPE_INTOVF,

  FPE_FLTDIV,

  FPE_FLTOVF,

  FPE_FLTUND,

  FPE_FLTRES,

  FPE_FLTINV,

  FPE_FLTSUB

};


enum
{
  SEGV_MAPERR = 1,

  SEGV_ACCERR

};


enum
{
  BUS_ADRALN = 1,

  BUS_ADRERR,

  BUS_OBJERR

};


enum
{
  TRAP_BRKPT = 1,

  TRAP_TRACE

};


enum
{
  CLD_EXITED = 1,

  CLD_KILLED,

  CLD_DUMPED,

  CLD_TRAPPED,

  CLD_STOPPED,

  CLD_CONTINUED

};


enum
{
  POLL_IN = 1,

  POLL_OUT,

  POLL_MSG,

  POLL_ERR,

  POLL_PRI,

  POLL_HUP

};
# 273 "/usr/include/bits/siginfo.h" 3 4
typedef struct sigevent
  {
    sigval_t sigev_value;
    int sigev_signo;
    int sigev_notify;

    union
      {
 int _pad[((64 / sizeof (int)) - 3)];



 __pid_t _tid;

 struct
   {
     void (*_function) (sigval_t);
     void *_attribute;
   } _sigev_thread;
      } _sigev_un;
  } sigevent_t;






enum
{
  SIGEV_SIGNAL = 0,

  SIGEV_NONE,

  SIGEV_THREAD,


  SIGEV_THREAD_ID = 4

};
# 80 "/usr/include/signal.h" 2 3 4




typedef void (*__sighandler_t) (int);




extern __sighandler_t __sysv_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__));
# 99 "/usr/include/signal.h" 3 4


extern __sighandler_t signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__));
# 113 "/usr/include/signal.h" 3 4

# 126 "/usr/include/signal.h" 3 4
extern int kill (__pid_t __pid, int __sig) __attribute__ ((__nothrow__));






extern int killpg (__pid_t __pgrp, int __sig) __attribute__ ((__nothrow__));




extern int raise (int __sig) __attribute__ ((__nothrow__));




extern __sighandler_t ssignal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__));
extern int gsignal (int __sig) __attribute__ ((__nothrow__));




extern void psignal (int __sig, __const char *__s);




extern void psiginfo (__const siginfo_t *__pinfo, __const char *__s);
# 168 "/usr/include/signal.h" 3 4
extern int __sigpause (int __sig_or_mask, int __is_sig);
# 196 "/usr/include/signal.h" 3 4
extern int sigblock (int __mask) __attribute__ ((__nothrow__)) __attribute__ ((__deprecated__));


extern int sigsetmask (int __mask) __attribute__ ((__nothrow__)) __attribute__ ((__deprecated__));


extern int siggetmask (void) __attribute__ ((__nothrow__)) __attribute__ ((__deprecated__));
# 216 "/usr/include/signal.h" 3 4
typedef __sighandler_t sig_t;





extern int sigemptyset (sigset_t *__set) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int sigfillset (sigset_t *__set) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int sigaddset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int sigdelset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int sigismember (__const sigset_t *__set, int __signo)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
# 252 "/usr/include/signal.h" 3 4
# 1 "/usr/include/bits/sigaction.h" 1 3 4
# 25 "/usr/include/bits/sigaction.h" 3 4
struct sigaction
  {


    union
      {

 __sighandler_t sa_handler;

 void (*sa_sigaction) (int, siginfo_t *, void *);
      }
    __sigaction_handler;







    __sigset_t sa_mask;


    int sa_flags;


    void (*sa_restorer) (void);
  };
# 253 "/usr/include/signal.h" 2 3 4


extern int sigprocmask (int __how, __const sigset_t *__restrict __set,
   sigset_t *__restrict __oset) __attribute__ ((__nothrow__));






extern int sigsuspend (__const sigset_t *__set) __attribute__ ((__nonnull__ (1)));


extern int sigaction (int __sig, __const struct sigaction *__restrict __act,
        struct sigaction *__restrict __oact) __attribute__ ((__nothrow__));


extern int sigpending (sigset_t *__set) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern int sigwait (__const sigset_t *__restrict __set, int *__restrict __sig)
     __attribute__ ((__nonnull__ (1, 2)));






extern int sigwaitinfo (__const sigset_t *__restrict __set,
   siginfo_t *__restrict __info) __attribute__ ((__nonnull__ (1)));






extern int sigtimedwait (__const sigset_t *__restrict __set,
    siginfo_t *__restrict __info,
    __const struct timespec *__restrict __timeout)
     __attribute__ ((__nonnull__ (1)));



extern int sigqueue (__pid_t __pid, int __sig, __const union sigval __val)
     __attribute__ ((__nothrow__));
# 310 "/usr/include/signal.h" 3 4
extern __const char *__const _sys_siglist[65];
extern __const char *__const sys_siglist[65];


struct sigvec
  {
    __sighandler_t sv_handler;
    int sv_mask;

    int sv_flags;

  };
# 334 "/usr/include/signal.h" 3 4
extern int sigvec (int __sig, __const struct sigvec *__vec,
     struct sigvec *__ovec) __attribute__ ((__nothrow__));



# 1 "/usr/include/bits/sigcontext.h" 1 3 4
# 28 "/usr/include/bits/sigcontext.h" 3 4
# 1 "/usr/include/asm/sigcontext.h" 1 3 4




# 1 "/usr/include/linux/types.h" 1 3 4



# 1 "/usr/include/asm/types.h" 1 3 4





# 1 "/usr/include/asm-generic/types.h" 1 3 4






# 1 "/usr/include/asm-generic/int-ll64.h" 1 3 4
# 11 "/usr/include/asm-generic/int-ll64.h" 3 4
# 1 "/usr/include/asm/bitsperlong.h" 1 3 4
# 10 "/usr/include/asm/bitsperlong.h" 3 4
# 1 "/usr/include/asm-generic/bitsperlong.h" 1 3 4
# 11 "/usr/include/asm/bitsperlong.h" 2 3 4
# 12 "/usr/include/asm-generic/int-ll64.h" 2 3 4







typedef __signed__ char __s8;
typedef unsigned char __u8;

typedef __signed__ short __s16;
typedef unsigned short __u16;

typedef __signed__ int __s32;
typedef unsigned int __u32;


__extension__ typedef __signed__ long long __s64;
__extension__ typedef unsigned long long __u64;
# 8 "/usr/include/asm-generic/types.h" 2 3 4



typedef unsigned short umode_t;
# 7 "/usr/include/asm/types.h" 2 3 4
# 5 "/usr/include/linux/types.h" 2 3 4



# 1 "/usr/include/linux/posix_types.h" 1 3 4



# 1 "/usr/include/linux/stddef.h" 1 3 4
# 5 "/usr/include/linux/posix_types.h" 2 3 4
# 36 "/usr/include/linux/posix_types.h" 3 4
typedef struct {
 unsigned long fds_bits [(1024/(8 * sizeof(unsigned long)))];
} __kernel_fd_set;


typedef void (*__kernel_sighandler_t)(int);


typedef int __kernel_key_t;
typedef int __kernel_mqd_t;

# 1 "/usr/include/asm/posix_types.h" 1 3 4

# 1 "/usr/include/asm/posix_types_32.h" 1 3 4
# 10 "/usr/include/asm/posix_types_32.h" 3 4
typedef unsigned long __kernel_ino_t;
typedef unsigned short __kernel_mode_t;
typedef unsigned short __kernel_nlink_t;
typedef long __kernel_off_t;
typedef int __kernel_pid_t;
typedef unsigned short __kernel_ipc_pid_t;
typedef unsigned short __kernel_uid_t;
typedef unsigned short __kernel_gid_t;
typedef unsigned int __kernel_size_t;
typedef int __kernel_ssize_t;
typedef int __kernel_ptrdiff_t;
typedef long __kernel_time_t;
typedef long __kernel_suseconds_t;
typedef long __kernel_clock_t;
typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef int __kernel_daddr_t;
typedef char * __kernel_caddr_t;
typedef unsigned short __kernel_uid16_t;
typedef unsigned short __kernel_gid16_t;
typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;

typedef unsigned short __kernel_old_uid_t;
typedef unsigned short __kernel_old_gid_t;
typedef unsigned short __kernel_old_dev_t;


typedef long long __kernel_loff_t;


typedef struct {
 int val[2];
} __kernel_fsid_t;
# 3 "/usr/include/asm/posix_types.h" 2 3 4
# 48 "/usr/include/linux/posix_types.h" 2 3 4
# 9 "/usr/include/linux/types.h" 2 3 4
# 27 "/usr/include/linux/types.h" 3 4
typedef __u16 __le16;
typedef __u16 __be16;
typedef __u32 __le32;
typedef __u32 __be32;
typedef __u64 __le64;
typedef __u64 __be64;

typedef __u16 __sum16;
typedef __u32 __wsum;
# 6 "/usr/include/asm/sigcontext.h" 2 3 4
# 23 "/usr/include/asm/sigcontext.h" 3 4
struct _fpx_sw_bytes {
 __u32 magic1;
 __u32 extended_size;


 __u64 xstate_bv;




 __u32 xstate_size;




 __u32 padding[7];
};
# 56 "/usr/include/asm/sigcontext.h" 3 4
struct _fpreg {
 unsigned short significand[4];
 unsigned short exponent;
};

struct _fpxreg {
 unsigned short significand[4];
 unsigned short exponent;
 unsigned short padding[3];
};

struct _xmmreg {
 unsigned long element[4];
};

struct _fpstate {

 unsigned long cw;
 unsigned long sw;
 unsigned long tag;
 unsigned long ipoff;
 unsigned long cssel;
 unsigned long dataoff;
 unsigned long datasel;
 struct _fpreg _st[8];
 unsigned short status;
 unsigned short magic;


 unsigned long _fxsr_env[6];
 unsigned long mxcsr;
 unsigned long reserved;
 struct _fpxreg _fxsr_st[8];
 struct _xmmreg _xmm[8];
 unsigned long padding1[44];

 union {
  unsigned long padding2[12];
  struct _fpx_sw_bytes sw_reserved;

 };
};






struct sigcontext {
 unsigned short gs, __gsh;
 unsigned short fs, __fsh;
 unsigned short es, __esh;
 unsigned short ds, __dsh;
 unsigned long edi;
 unsigned long esi;
 unsigned long ebp;
 unsigned long esp;
 unsigned long ebx;
 unsigned long edx;
 unsigned long ecx;
 unsigned long eax;
 unsigned long trapno;
 unsigned long err;
 unsigned long eip;
 unsigned short cs, __csh;
 unsigned long eflags;
 unsigned long esp_at_signal;
 unsigned short ss, __ssh;
 struct _fpstate *fpstate;
 unsigned long oldmask;
 unsigned long cr2;
};
# 190 "/usr/include/asm/sigcontext.h" 3 4
struct _xsave_hdr {
 __u64 xstate_bv;
 __u64 reserved1[2];
 __u64 reserved2[5];
};

struct _ymmh_state {

 __u32 ymmh_space[64];
};







struct _xstate {
 struct _fpstate fpstate;
 struct _xsave_hdr xstate_hdr;
 struct _ymmh_state ymmh;

};
# 29 "/usr/include/bits/sigcontext.h" 2 3 4
# 340 "/usr/include/signal.h" 2 3 4


extern int sigreturn (struct sigcontext *__scp) __attribute__ ((__nothrow__));






# 1 "/usr/lib/gcc/i686-redhat-linux/4.4.5/include/stddef.h" 1 3 4
# 350 "/usr/include/signal.h" 2 3 4




extern int siginterrupt (int __sig, int __interrupt) __attribute__ ((__nothrow__));

# 1 "/usr/include/bits/sigstack.h" 1 3 4
# 26 "/usr/include/bits/sigstack.h" 3 4
struct sigstack
  {
    void *ss_sp;
    int ss_onstack;
  };



enum
{
  SS_ONSTACK = 1,

  SS_DISABLE

};
# 50 "/usr/include/bits/sigstack.h" 3 4
typedef struct sigaltstack
  {
    void *ss_sp;
    int ss_flags;
    size_t ss_size;
  } stack_t;
# 357 "/usr/include/signal.h" 2 3 4


# 1 "/usr/include/sys/ucontext.h" 1 3 4
# 23 "/usr/include/sys/ucontext.h" 3 4
# 1 "/usr/include/signal.h" 1 3 4
# 24 "/usr/include/sys/ucontext.h" 2 3 4



# 1 "/usr/include/bits/sigcontext.h" 1 3 4
# 28 "/usr/include/sys/ucontext.h" 2 3 4



typedef int greg_t;





typedef greg_t gregset_t[19];
# 85 "/usr/include/sys/ucontext.h" 3 4
struct _libc_fpreg
{
  unsigned short int significand[4];
  unsigned short int exponent;
};

struct _libc_fpstate
{
  unsigned long int cw;
  unsigned long int sw;
  unsigned long int tag;
  unsigned long int ipoff;
  unsigned long int cssel;
  unsigned long int dataoff;
  unsigned long int datasel;
  struct _libc_fpreg _st[8];
  unsigned long int status;
};


typedef struct _libc_fpstate *fpregset_t;


typedef struct
  {
    gregset_t gregs;


    fpregset_t fpregs;
    unsigned long int oldmask;
    unsigned long int cr2;
  } mcontext_t;


typedef struct ucontext
  {
    unsigned long int uc_flags;
    struct ucontext *uc_link;
    stack_t uc_stack;
    mcontext_t uc_mcontext;
    __sigset_t uc_sigmask;
    struct _libc_fpstate __fpregs_mem;
  } ucontext_t;
# 360 "/usr/include/signal.h" 2 3 4





extern int sigstack (struct sigstack *__ss, struct sigstack *__oss)
     __attribute__ ((__nothrow__)) __attribute__ ((__deprecated__));



extern int sigaltstack (__const struct sigaltstack *__restrict __ss,
   struct sigaltstack *__restrict __oss) __attribute__ ((__nothrow__));
# 394 "/usr/include/signal.h" 3 4
# 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
# 36 "/usr/include/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


typedef union
{
  char __size[36];
  long int __align;
} pthread_attr_t;


typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;




typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;


    int __kind;
    unsigned int __nusers;
    __extension__ union
    {
      int __spins;
      __pthread_slist_t __list;
    };
  } __data;
  char __size[24];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  long int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  long int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{
  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;


    unsigned char __flags;
    unsigned char __shared;
    unsigned char __pad1;
    unsigned char __pad2;
    int __writer;
  } __data;
  char __size[32];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[20];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 395 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/bits/sigthread.h" 1 3 4
# 31 "/usr/include/bits/sigthread.h" 3 4
extern int pthread_sigmask (int __how,
       __const __sigset_t *__restrict __newmask,
       __sigset_t *__restrict __oldmask)__attribute__ ((__nothrow__));


extern int pthread_kill (pthread_t __threadid, int __signo) __attribute__ ((__nothrow__));
# 396 "/usr/include/signal.h" 2 3 4






extern int __libc_current_sigrtmin (void) __attribute__ ((__nothrow__));

extern int __libc_current_sigrtmax (void) __attribute__ ((__nothrow__));




# 26 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_execute.c" 2

# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend.h" 1
# 51 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend.h"
# 1 "Zend/zend_config.h" 1
# 1 "Zend/../main/php_config.h" 1
# 2396 "Zend/../main/php_config.h"
# 1 "/usr/include/stdlib.h" 1 3 4
# 33 "/usr/include/stdlib.h" 3 4
# 1 "/usr/lib/gcc/i686-redhat-linux/4.4.5/include/stddef.h" 1 3 4
# 323 "/usr/lib/gcc/i686-redhat-linux/4.4.5/include/stddef.h" 3 4
typedef long int wchar_t;
# 34 "/usr/include/stdlib.h" 2 3 4








# 1 "/usr/include/bits/waitflags.h" 1 3 4
# 43 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/bits/waitstatus.h" 1 3 4
# 65 "/usr/include/bits/waitstatus.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/endian.h" 1 3 4
# 38 "/usr/include/endian.h" 2 3 4
# 61 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/byteswap.h" 1 3 4
# 62 "/usr/include/endian.h" 2 3 4
# 66 "/usr/include/bits/waitstatus.h" 2 3 4

union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };
# 44 "/usr/include/stdlib.h" 2 3 4
# 68 "/usr/include/stdlib.h" 3 4
typedef union
  {
    union wait *__uptr;
    int *__iptr;
  } __WAIT_STATUS __attribute__ ((__transparent_union__));
# 96 "/usr/include/stdlib.h" 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;


# 140 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__)) ;




extern double atof (__const char *__nptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (__const char *__nptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (__const char *__nptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (__const char *__nptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (__const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;





extern float strtof (__const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;

extern long double strtold (__const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;





extern long int strtol (__const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;

extern unsigned long int strtoul (__const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;




__extension__
extern long long int strtoq (__const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;

__extension__
extern unsigned long long int strtouq (__const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;





__extension__
extern long long int strtoll (__const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;

__extension__
extern unsigned long long int strtoull (__const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;

# 277 "/usr/include/stdlib.h" 3 4

extern __inline double
__attribute__ ((__nothrow__)) atof (__const char *__nptr)
{
  return strtod (__nptr, (char **) ((void *)0));
}
extern __inline int
__attribute__ ((__nothrow__)) atoi (__const char *__nptr)
{
  return (int) strtol (__nptr, (char **) ((void *)0), 10);
}
extern __inline long int
__attribute__ ((__nothrow__)) atol (__const char *__nptr)
{
  return strtol (__nptr, (char **) ((void *)0), 10);
}




__extension__ extern __inline long long int
__attribute__ ((__nothrow__)) atoll (__const char *__nptr)
{
  return strtoll (__nptr, (char **) ((void *)0), 10);
}

# 311 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) __attribute__ ((__nothrow__)) ;


extern long int a64l (__const char *__s)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/usr/include/sys/types.h" 1 3 4
# 28 "/usr/include/sys/types.h" 3 4






typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;
# 61 "/usr/include/sys/types.h" 3 4
typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;
# 105 "/usr/include/sys/types.h" 3 4
typedef __id_t id_t;
# 116 "/usr/include/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 133 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
# 58 "/usr/include/time.h" 3 4


typedef __clock_t clock_t;



# 74 "/usr/include/time.h" 3 4


typedef __time_t time_t;



# 92 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
# 104 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
# 134 "/usr/include/sys/types.h" 2 3 4
# 147 "/usr/include/sys/types.h" 3 4
# 1 "/usr/lib/gcc/i686-redhat-linux/4.4.5/include/stddef.h" 1 3 4
# 148 "/usr/include/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 195 "/usr/include/sys/types.h" 3 4
typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 220 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/sys/select.h" 1 3 4
# 31 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/bits/select.h" 1 3 4
# 32 "/usr/include/sys/select.h" 2 3 4


# 1 "/usr/include/bits/sigset.h" 1 3 4
# 35 "/usr/include/sys/select.h" 2 3 4
# 44 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
# 45 "/usr/include/sys/select.h" 2 3 4

# 1 "/usr/include/bits/time.h" 1 3 4
# 75 "/usr/include/bits/time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 47 "/usr/include/sys/select.h" 2 3 4


typedef __suseconds_t suseconds_t;





typedef long int __fd_mask;
# 67 "/usr/include/sys/select.h" 3 4
typedef struct
  {






    __fd_mask __fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];


  } fd_set;






typedef __fd_mask fd_mask;
# 99 "/usr/include/sys/select.h" 3 4

# 109 "/usr/include/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 121 "/usr/include/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);



# 221 "/usr/include/sys/types.h" 2 3 4


# 1 "/usr/include/sys/sysmacros.h" 1 3 4
# 30 "/usr/include/sys/sysmacros.h" 3 4
__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     __attribute__ ((__nothrow__));
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     __attribute__ ((__nothrow__));
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     __attribute__ ((__nothrow__));


__extension__ extern __inline unsigned int
__attribute__ ((__nothrow__)) gnu_dev_major (unsigned long long int __dev)
{
  return ((__dev >> 8) & 0xfff) | ((unsigned int) (__dev >> 32) & ~0xfff);
}

__extension__ extern __inline unsigned int
__attribute__ ((__nothrow__)) gnu_dev_minor (unsigned long long int __dev)
{
  return (__dev & 0xff) | ((unsigned int) (__dev >> 12) & ~0xff);
}

__extension__ extern __inline unsigned long long int
__attribute__ ((__nothrow__)) gnu_dev_makedev (unsigned int __major, unsigned int __minor)
{
  return ((__minor & 0xff) | ((__major & 0xfff) << 8)
   | (((unsigned long long int) (__minor & ~0xff)) << 12)
   | (((unsigned long long int) (__major & ~0xfff)) << 32));
}
# 224 "/usr/include/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 274 "/usr/include/sys/types.h" 3 4

# 321 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) __attribute__ ((__nothrow__));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) __attribute__ ((__nothrow__));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__));




extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__));







extern double drand48 (void) __attribute__ ((__nothrow__));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    unsigned long long int __a;
  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));









extern void *malloc (size_t __size) __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) ;










extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) __attribute__ ((__nothrow__));




extern void cfree (void *__ptr) __attribute__ ((__nothrow__));



# 1 "/usr/include/alloca.h" 1 3 4
# 25 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/i686-redhat-linux/4.4.5/include/stddef.h" 1 3 4
# 26 "/usr/include/alloca.h" 2 3 4







extern void *alloca (size_t __size) __attribute__ ((__nothrow__));






# 498 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;




extern void abort (void) __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
# 531 "/usr/include/stdlib.h" 3 4





extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));
# 554 "/usr/include/stdlib.h" 3 4






extern void _Exit (int __status) __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));






extern char *getenv (__const char *__name) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;




extern char *__secure_getenv (__const char *__name)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;





extern int putenv (char *__string) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int setenv (__const char *__name, __const char *__value, int __replace)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (__const char *__name) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) __attribute__ ((__nothrow__));
# 606 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
# 620 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 642 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 663 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
# 712 "/usr/include/stdlib.h" 3 4





extern int system (__const char *__command) ;

# 734 "/usr/include/stdlib.h" 3 4
extern char *realpath (__const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__)) ;






typedef int (*__compar_fn_t) (__const void *, __const void *);
# 752 "/usr/include/stdlib.h" 3 4



extern void *bsearch (__const void *__key, __const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;



extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));
# 771 "/usr/include/stdlib.h" 3 4
extern int abs (int __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)) ;
extern long int labs (long int __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__)) __attribute__ ((__const__)) ;







extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__)) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__)) __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__)) __attribute__ ((__const__)) ;

# 808 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4, 5)));







extern int mblen (__const char *__s, size_t __n) __attribute__ ((__nothrow__)) ;


extern int mbtowc (wchar_t *__restrict __pwc,
     __const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__)) ;


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__)) ;



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   __const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__));

extern size_t wcstombs (char *__restrict __s,
   __const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__));








extern int rpmatch (__const char *__response) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
# 896 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *__const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2, 3))) ;
# 948 "/usr/include/stdlib.h" 3 4
extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
# 964 "/usr/include/stdlib.h" 3 4

# 2397 "Zend/../main/php_config.h" 2
# 2412 "Zend/../main/php_config.h"
# 1 "/usr/include/string.h" 1 3 4
# 29 "/usr/include/string.h" 3 4





# 1 "/usr/lib/gcc/i686-redhat-linux/4.4.5/include/stddef.h" 1 3 4
# 35 "/usr/include/string.h" 2 3 4









extern void *memcpy (void *__restrict __dest,
       __const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, __const void *__src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, __const void *__restrict __src,
        int __c, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int memcmp (__const void *__s1, __const void *__s2, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 95 "/usr/include/string.h" 3 4
extern void *memchr (__const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


# 126 "/usr/include/string.h" 3 4


extern char *strcpy (char *__restrict __dest, __const char *__restrict __src)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        __const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, __const char *__restrict __src)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, __const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (__const char *__s1, __const char *__s2)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (__const char *__s1, __const char *__s2, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (__const char *__s1, __const char *__s2)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         __const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));






# 1 "/usr/include/xlocale.h" 1 3 4
# 28 "/usr/include/xlocale.h" 3 4
typedef struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;


typedef __locale_t locale_t;
# 163 "/usr/include/string.h" 2 3 4


extern int strcoll_l (__const char *__s1, __const char *__s2, __locale_t __l)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, __const char *__src, size_t __n,
    __locale_t __l) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (__const char *__s)
     __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (__const char *__string, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 210 "/usr/include/string.h" 3 4

# 235 "/usr/include/string.h" 3 4
extern char *strchr (__const char *__s, int __c)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 262 "/usr/include/string.h" 3 4
extern char *strrchr (__const char *__s, int __c)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


# 281 "/usr/include/string.h" 3 4



extern size_t strcspn (__const char *__s, __const char *__reject)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (__const char *__s, __const char *__accept)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 314 "/usr/include/string.h" 3 4
extern char *strpbrk (__const char *__s, __const char *__accept)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 342 "/usr/include/string.h" 3 4
extern char *strstr (__const char *__haystack, __const char *__needle)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, __const char *__restrict __delim)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    __const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, __const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3)));
# 397 "/usr/include/string.h" 3 4


extern size_t strlen (__const char *__s)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (__const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) __attribute__ ((__nothrow__));

# 427 "/usr/include/string.h" 3 4
extern int strerror_r (int __errnum, char *__buf, size_t __buflen) __asm__ ("" "__xpg_strerror_r") __attribute__ ((__nothrow__))

                        __attribute__ ((__nonnull__ (2)));
# 445 "/usr/include/string.h" 3 4
extern char *strerror_l (int __errnum, __locale_t __l) __attribute__ ((__nothrow__));





extern void __bzero (void *__s, size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern void bcopy (__const void *__src, void *__dest, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int bcmp (__const void *__s1, __const void *__s2, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 489 "/usr/include/string.h" 3 4
extern char *index (__const char *__s, int __c)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 517 "/usr/include/string.h" 3 4
extern char *rindex (__const char *__s, int __c)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern int ffs (int __i) __attribute__ ((__nothrow__)) __attribute__ ((__const__));
# 536 "/usr/include/string.h" 3 4
extern int strcasecmp (__const char *__s1, __const char *__s2)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (__const char *__s1, __const char *__s2, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 559 "/usr/include/string.h" 3 4
extern char *strsep (char **__restrict __stringp,
       __const char *__restrict __delim)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) __attribute__ ((__nothrow__));


extern char *__stpcpy (char *__restrict __dest, __const char *__restrict __src)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, __const char *__restrict __src)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   __const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        __const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
# 634 "/usr/include/string.h" 3 4
# 1 "/usr/include/bits/string.h" 1 3 4
# 635 "/usr/include/string.h" 2 3 4


# 1 "/usr/include/bits/string2.h" 1 3 4
# 394 "/usr/include/bits/string2.h" 3 4
extern void *__rawmemchr (const void *__s, int __c);
# 969 "/usr/include/bits/string2.h" 3 4
extern __inline size_t __strcspn_c1 (__const char *__s, int __reject);
extern __inline size_t
__strcspn_c1 (__const char *__s, int __reject)
{
  register size_t __result = 0;
  while (__s[__result] != '\0' && __s[__result] != __reject)
    ++__result;
  return __result;
}

extern __inline size_t __strcspn_c2 (__const char *__s, int __reject1,
         int __reject2);
extern __inline size_t
__strcspn_c2 (__const char *__s, int __reject1, int __reject2)
{
  register size_t __result = 0;
  while (__s[__result] != '\0' && __s[__result] != __reject1
  && __s[__result] != __reject2)
    ++__result;
  return __result;
}

extern __inline size_t __strcspn_c3 (__const char *__s, int __reject1,
         int __reject2, int __reject3);
extern __inline size_t
__strcspn_c3 (__const char *__s, int __reject1, int __reject2,
       int __reject3)
{
  register size_t __result = 0;
  while (__s[__result] != '\0' && __s[__result] != __reject1
  && __s[__result] != __reject2 && __s[__result] != __reject3)
    ++__result;
  return __result;
}
# 1045 "/usr/include/bits/string2.h" 3 4
extern __inline size_t __strspn_c1 (__const char *__s, int __accept);
extern __inline size_t
__strspn_c1 (__const char *__s, int __accept)
{
  register size_t __result = 0;

  while (__s[__result] == __accept)
    ++__result;
  return __result;
}

extern __inline size_t __strspn_c2 (__const char *__s, int __accept1,
        int __accept2);
extern __inline size_t
__strspn_c2 (__const char *__s, int __accept1, int __accept2)
{
  register size_t __result = 0;

  while (__s[__result] == __accept1 || __s[__result] == __accept2)
    ++__result;
  return __result;
}

extern __inline size_t __strspn_c3 (__const char *__s, int __accept1,
        int __accept2, int __accept3);
extern __inline size_t
__strspn_c3 (__const char *__s, int __accept1, int __accept2, int __accept3)
{
  register size_t __result = 0;

  while (__s[__result] == __accept1 || __s[__result] == __accept2
  || __s[__result] == __accept3)
    ++__result;
  return __result;
}
# 1121 "/usr/include/bits/string2.h" 3 4
extern __inline char *__strpbrk_c2 (__const char *__s, int __accept1,
         int __accept2);
extern __inline char *
__strpbrk_c2 (__const char *__s, int __accept1, int __accept2)
{

  while (*__s != '\0' && *__s != __accept1 && *__s != __accept2)
    ++__s;
  return *__s == '\0' ? ((void *)0) : (char *) (size_t) __s;
}

extern __inline char *__strpbrk_c3 (__const char *__s, int __accept1,
         int __accept2, int __accept3);
extern __inline char *
__strpbrk_c3 (__const char *__s, int __accept1, int __accept2,
       int __accept3)
{

  while (*__s != '\0' && *__s != __accept1 && *__s != __accept2
  && *__s != __accept3)
    ++__s;
  return *__s == '\0' ? ((void *)0) : (char *) (size_t) __s;
}
# 1172 "/usr/include/bits/string2.h" 3 4
extern __inline char *__strtok_r_1c (char *__s, char __sep, char **__nextp);
extern __inline char *
__strtok_r_1c (char *__s, char __sep, char **__nextp)
{
  char *__result;
  if (__s == ((void *)0))
    __s = *__nextp;
  while (*__s == __sep)
    ++__s;
  __result = ((void *)0);
  if (*__s != '\0')
    {
      __result = __s++;
      while (*__s != '\0')
 if (*__s++ == __sep)
   {
     __s[-1] = '\0';
     break;
   }
    }
  *__nextp = __s;
  return __result;
}
# 1204 "/usr/include/bits/string2.h" 3 4
extern char *__strsep_g (char **__stringp, __const char *__delim);
# 1222 "/usr/include/bits/string2.h" 3 4
extern __inline char *__strsep_1c (char **__s, char __reject);
extern __inline char *
__strsep_1c (char **__s, char __reject)
{
  register char *__retval = *__s;
  if (__retval != ((void *)0) && (*__s = (__extension__ (__builtin_constant_p (__reject) && !__builtin_constant_p (__retval) && (__reject) == '\0' ? (char *) __rawmemchr (__retval, __reject) : __builtin_strchr (__retval, __reject)))) != ((void *)0))
    *(*__s)++ = '\0';
  return __retval;
}

extern __inline char *__strsep_2c (char **__s, char __reject1, char __reject2);
extern __inline char *
__strsep_2c (char **__s, char __reject1, char __reject2)
{
  register char *__retval = *__s;
  if (__retval != ((void *)0))
    {
      register char *__cp = __retval;
      while (1)
 {
   if (*__cp == '\0')
     {
       __cp = ((void *)0);
   break;
     }
   if (*__cp == __reject1 || *__cp == __reject2)
     {
       *__cp++ = '\0';
       break;
     }
   ++__cp;
 }
      *__s = __cp;
    }
  return __retval;
}

extern __inline char *__strsep_3c (char **__s, char __reject1, char __reject2,
       char __reject3);
extern __inline char *
__strsep_3c (char **__s, char __reject1, char __reject2, char __reject3)
{
  register char *__retval = *__s;
  if (__retval != ((void *)0))
    {
      register char *__cp = __retval;
      while (1)
 {
   if (*__cp == '\0')
     {
       __cp = ((void *)0);
   break;
     }
   if (*__cp == __reject1 || *__cp == __reject2 || *__cp == __reject3)
     {
       *__cp++ = '\0';
       break;
     }
   ++__cp;
 }
      *__s = __cp;
    }
  return __retval;
}
# 1303 "/usr/include/bits/string2.h" 3 4
extern char *__strdup (__const char *__string) __attribute__ ((__nothrow__)) __attribute__ ((__malloc__));
# 1322 "/usr/include/bits/string2.h" 3 4
extern char *__strndup (__const char *__string, size_t __n)
     __attribute__ ((__nothrow__)) __attribute__ ((__malloc__));
# 638 "/usr/include/string.h" 2 3 4
# 646 "/usr/include/string.h" 3 4

# 2413 "Zend/../main/php_config.h" 2
# 2423 "Zend/../main/php_config.h"
# 1 "/usr/include/math.h" 1 3 4
# 30 "/usr/include/math.h" 3 4




# 1 "/usr/include/bits/huge_val.h" 1 3 4
# 35 "/usr/include/math.h" 2 3 4

# 1 "/usr/include/bits/huge_valf.h" 1 3 4
# 37 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/bits/huge_vall.h" 1 3 4
# 38 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/bits/inf.h" 1 3 4
# 41 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/bits/nan.h" 1 3 4
# 44 "/usr/include/math.h" 2 3 4



# 1 "/usr/include/bits/mathdef.h" 1 3 4
# 36 "/usr/include/bits/mathdef.h" 3 4
typedef long double float_t;

typedef long double double_t;
# 48 "/usr/include/math.h" 2 3 4
# 71 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4


extern double acos (double __x) __attribute__ ((__nothrow__)); extern double __acos (double __x) __attribute__ ((__nothrow__));

extern double asin (double __x) __attribute__ ((__nothrow__)); extern double __asin (double __x) __attribute__ ((__nothrow__));

extern double atan (double __x) __attribute__ ((__nothrow__)); extern double __atan (double __x) __attribute__ ((__nothrow__));

extern double atan2 (double __y, double __x) __attribute__ ((__nothrow__)); extern double __atan2 (double __y, double __x) __attribute__ ((__nothrow__));


extern double cos (double __x) __attribute__ ((__nothrow__)); extern double __cos (double __x) __attribute__ ((__nothrow__));

extern double sin (double __x) __attribute__ ((__nothrow__)); extern double __sin (double __x) __attribute__ ((__nothrow__));

extern double tan (double __x) __attribute__ ((__nothrow__)); extern double __tan (double __x) __attribute__ ((__nothrow__));




extern double cosh (double __x) __attribute__ ((__nothrow__)); extern double __cosh (double __x) __attribute__ ((__nothrow__));

extern double sinh (double __x) __attribute__ ((__nothrow__)); extern double __sinh (double __x) __attribute__ ((__nothrow__));

extern double tanh (double __x) __attribute__ ((__nothrow__)); extern double __tanh (double __x) __attribute__ ((__nothrow__));

# 87 "/usr/include/bits/mathcalls.h" 3 4


extern double acosh (double __x) __attribute__ ((__nothrow__)); extern double __acosh (double __x) __attribute__ ((__nothrow__));

extern double asinh (double __x) __attribute__ ((__nothrow__)); extern double __asinh (double __x) __attribute__ ((__nothrow__));

extern double atanh (double __x) __attribute__ ((__nothrow__)); extern double __atanh (double __x) __attribute__ ((__nothrow__));







extern double exp (double __x) __attribute__ ((__nothrow__)); extern double __exp (double __x) __attribute__ ((__nothrow__));


extern double frexp (double __x, int *__exponent) __attribute__ ((__nothrow__)); extern double __frexp (double __x, int *__exponent) __attribute__ ((__nothrow__));


extern double ldexp (double __x, int __exponent) __attribute__ ((__nothrow__)); extern double __ldexp (double __x, int __exponent) __attribute__ ((__nothrow__));


extern double log (double __x) __attribute__ ((__nothrow__)); extern double __log (double __x) __attribute__ ((__nothrow__));


extern double log10 (double __x) __attribute__ ((__nothrow__)); extern double __log10 (double __x) __attribute__ ((__nothrow__));


extern double modf (double __x, double *__iptr) __attribute__ ((__nothrow__)); extern double __modf (double __x, double *__iptr) __attribute__ ((__nothrow__));

# 127 "/usr/include/bits/mathcalls.h" 3 4


extern double expm1 (double __x) __attribute__ ((__nothrow__)); extern double __expm1 (double __x) __attribute__ ((__nothrow__));


extern double log1p (double __x) __attribute__ ((__nothrow__)); extern double __log1p (double __x) __attribute__ ((__nothrow__));


extern double logb (double __x) __attribute__ ((__nothrow__)); extern double __logb (double __x) __attribute__ ((__nothrow__));






extern double exp2 (double __x) __attribute__ ((__nothrow__)); extern double __exp2 (double __x) __attribute__ ((__nothrow__));


extern double log2 (double __x) __attribute__ ((__nothrow__)); extern double __log2 (double __x) __attribute__ ((__nothrow__));








extern double pow (double __x, double __y) __attribute__ ((__nothrow__)); extern double __pow (double __x, double __y) __attribute__ ((__nothrow__));


extern double sqrt (double __x) __attribute__ ((__nothrow__)); extern double __sqrt (double __x) __attribute__ ((__nothrow__));





extern double hypot (double __x, double __y) __attribute__ ((__nothrow__)); extern double __hypot (double __x, double __y) __attribute__ ((__nothrow__));






extern double cbrt (double __x) __attribute__ ((__nothrow__)); extern double __cbrt (double __x) __attribute__ ((__nothrow__));








extern double ceil (double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern double __ceil (double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern double fabs (double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern double __fabs (double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern double floor (double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern double __floor (double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern double fmod (double __x, double __y) __attribute__ ((__nothrow__)); extern double __fmod (double __x, double __y) __attribute__ ((__nothrow__));




extern int __isinf (double __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern int __finite (double __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));





extern int isinf (double __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern int finite (double __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern double drem (double __x, double __y) __attribute__ ((__nothrow__)); extern double __drem (double __x, double __y) __attribute__ ((__nothrow__));



extern double significand (double __x) __attribute__ ((__nothrow__)); extern double __significand (double __x) __attribute__ ((__nothrow__));





extern double copysign (double __x, double __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern double __copysign (double __x, double __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__));






extern double nan (__const char *__tagb) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern double __nan (__const char *__tagb) __attribute__ ((__nothrow__)) __attribute__ ((__const__));





extern int __isnan (double __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));



extern int isnan (double __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern double j0 (double) __attribute__ ((__nothrow__)); extern double __j0 (double) __attribute__ ((__nothrow__));
extern double j1 (double) __attribute__ ((__nothrow__)); extern double __j1 (double) __attribute__ ((__nothrow__));
extern double jn (int, double) __attribute__ ((__nothrow__)); extern double __jn (int, double) __attribute__ ((__nothrow__));
extern double y0 (double) __attribute__ ((__nothrow__)); extern double __y0 (double) __attribute__ ((__nothrow__));
extern double y1 (double) __attribute__ ((__nothrow__)); extern double __y1 (double) __attribute__ ((__nothrow__));
extern double yn (int, double) __attribute__ ((__nothrow__)); extern double __yn (int, double) __attribute__ ((__nothrow__));






extern double erf (double) __attribute__ ((__nothrow__)); extern double __erf (double) __attribute__ ((__nothrow__));
extern double erfc (double) __attribute__ ((__nothrow__)); extern double __erfc (double) __attribute__ ((__nothrow__));
extern double lgamma (double) __attribute__ ((__nothrow__)); extern double __lgamma (double) __attribute__ ((__nothrow__));






extern double tgamma (double) __attribute__ ((__nothrow__)); extern double __tgamma (double) __attribute__ ((__nothrow__));





extern double gamma (double) __attribute__ ((__nothrow__)); extern double __gamma (double) __attribute__ ((__nothrow__));






extern double lgamma_r (double, int *__signgamp) __attribute__ ((__nothrow__)); extern double __lgamma_r (double, int *__signgamp) __attribute__ ((__nothrow__));







extern double rint (double __x) __attribute__ ((__nothrow__)); extern double __rint (double __x) __attribute__ ((__nothrow__));


extern double nextafter (double __x, double __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern double __nextafter (double __x, double __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__));

extern double nexttoward (double __x, long double __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern double __nexttoward (double __x, long double __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__));



extern double remainder (double __x, double __y) __attribute__ ((__nothrow__)); extern double __remainder (double __x, double __y) __attribute__ ((__nothrow__));



extern double scalbn (double __x, int __n) __attribute__ ((__nothrow__)); extern double __scalbn (double __x, int __n) __attribute__ ((__nothrow__));



extern int ilogb (double __x) __attribute__ ((__nothrow__)); extern int __ilogb (double __x) __attribute__ ((__nothrow__));




extern double scalbln (double __x, long int __n) __attribute__ ((__nothrow__)); extern double __scalbln (double __x, long int __n) __attribute__ ((__nothrow__));



extern double nearbyint (double __x) __attribute__ ((__nothrow__)); extern double __nearbyint (double __x) __attribute__ ((__nothrow__));



extern double round (double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern double __round (double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__));



extern double trunc (double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern double __trunc (double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) __attribute__ ((__nothrow__)); extern double __remquo (double __x, double __y, int *__quo) __attribute__ ((__nothrow__));






extern long int lrint (double __x) __attribute__ ((__nothrow__)); extern long int __lrint (double __x) __attribute__ ((__nothrow__));
extern long long int llrint (double __x) __attribute__ ((__nothrow__)); extern long long int __llrint (double __x) __attribute__ ((__nothrow__));



extern long int lround (double __x) __attribute__ ((__nothrow__)); extern long int __lround (double __x) __attribute__ ((__nothrow__));
extern long long int llround (double __x) __attribute__ ((__nothrow__)); extern long long int __llround (double __x) __attribute__ ((__nothrow__));



extern double fdim (double __x, double __y) __attribute__ ((__nothrow__)); extern double __fdim (double __x, double __y) __attribute__ ((__nothrow__));


extern double fmax (double __x, double __y) __attribute__ ((__nothrow__)); extern double __fmax (double __x, double __y) __attribute__ ((__nothrow__));


extern double fmin (double __x, double __y) __attribute__ ((__nothrow__)); extern double __fmin (double __x, double __y) __attribute__ ((__nothrow__));



extern int __fpclassify (double __value) __attribute__ ((__nothrow__))
     __attribute__ ((__const__));


extern int __signbit (double __value) __attribute__ ((__nothrow__))
     __attribute__ ((__const__));



extern double fma (double __x, double __y, double __z) __attribute__ ((__nothrow__)); extern double __fma (double __x, double __y, double __z) __attribute__ ((__nothrow__));








extern double scalb (double __x, double __n) __attribute__ ((__nothrow__)); extern double __scalb (double __x, double __n) __attribute__ ((__nothrow__));
# 72 "/usr/include/math.h" 2 3 4
# 94 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4


extern float acosf (float __x) __attribute__ ((__nothrow__)); extern float __acosf (float __x) __attribute__ ((__nothrow__));

extern float asinf (float __x) __attribute__ ((__nothrow__)); extern float __asinf (float __x) __attribute__ ((__nothrow__));

extern float atanf (float __x) __attribute__ ((__nothrow__)); extern float __atanf (float __x) __attribute__ ((__nothrow__));

extern float atan2f (float __y, float __x) __attribute__ ((__nothrow__)); extern float __atan2f (float __y, float __x) __attribute__ ((__nothrow__));


extern float cosf (float __x) __attribute__ ((__nothrow__)); extern float __cosf (float __x) __attribute__ ((__nothrow__));

extern float sinf (float __x) __attribute__ ((__nothrow__)); extern float __sinf (float __x) __attribute__ ((__nothrow__));

extern float tanf (float __x) __attribute__ ((__nothrow__)); extern float __tanf (float __x) __attribute__ ((__nothrow__));




extern float coshf (float __x) __attribute__ ((__nothrow__)); extern float __coshf (float __x) __attribute__ ((__nothrow__));

extern float sinhf (float __x) __attribute__ ((__nothrow__)); extern float __sinhf (float __x) __attribute__ ((__nothrow__));

extern float tanhf (float __x) __attribute__ ((__nothrow__)); extern float __tanhf (float __x) __attribute__ ((__nothrow__));

# 87 "/usr/include/bits/mathcalls.h" 3 4


extern float acoshf (float __x) __attribute__ ((__nothrow__)); extern float __acoshf (float __x) __attribute__ ((__nothrow__));

extern float asinhf (float __x) __attribute__ ((__nothrow__)); extern float __asinhf (float __x) __attribute__ ((__nothrow__));

extern float atanhf (float __x) __attribute__ ((__nothrow__)); extern float __atanhf (float __x) __attribute__ ((__nothrow__));







extern float expf (float __x) __attribute__ ((__nothrow__)); extern float __expf (float __x) __attribute__ ((__nothrow__));


extern float frexpf (float __x, int *__exponent) __attribute__ ((__nothrow__)); extern float __frexpf (float __x, int *__exponent) __attribute__ ((__nothrow__));


extern float ldexpf (float __x, int __exponent) __attribute__ ((__nothrow__)); extern float __ldexpf (float __x, int __exponent) __attribute__ ((__nothrow__));


extern float logf (float __x) __attribute__ ((__nothrow__)); extern float __logf (float __x) __attribute__ ((__nothrow__));


extern float log10f (float __x) __attribute__ ((__nothrow__)); extern float __log10f (float __x) __attribute__ ((__nothrow__));


extern float modff (float __x, float *__iptr) __attribute__ ((__nothrow__)); extern float __modff (float __x, float *__iptr) __attribute__ ((__nothrow__));

# 127 "/usr/include/bits/mathcalls.h" 3 4


extern float expm1f (float __x) __attribute__ ((__nothrow__)); extern float __expm1f (float __x) __attribute__ ((__nothrow__));


extern float log1pf (float __x) __attribute__ ((__nothrow__)); extern float __log1pf (float __x) __attribute__ ((__nothrow__));


extern float logbf (float __x) __attribute__ ((__nothrow__)); extern float __logbf (float __x) __attribute__ ((__nothrow__));






extern float exp2f (float __x) __attribute__ ((__nothrow__)); extern float __exp2f (float __x) __attribute__ ((__nothrow__));


extern float log2f (float __x) __attribute__ ((__nothrow__)); extern float __log2f (float __x) __attribute__ ((__nothrow__));








extern float powf (float __x, float __y) __attribute__ ((__nothrow__)); extern float __powf (float __x, float __y) __attribute__ ((__nothrow__));


extern float sqrtf (float __x) __attribute__ ((__nothrow__)); extern float __sqrtf (float __x) __attribute__ ((__nothrow__));





extern float hypotf (float __x, float __y) __attribute__ ((__nothrow__)); extern float __hypotf (float __x, float __y) __attribute__ ((__nothrow__));






extern float cbrtf (float __x) __attribute__ ((__nothrow__)); extern float __cbrtf (float __x) __attribute__ ((__nothrow__));








extern float ceilf (float __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern float __ceilf (float __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern float fabsf (float __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern float __fabsf (float __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern float floorf (float __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern float __floorf (float __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern float fmodf (float __x, float __y) __attribute__ ((__nothrow__)); extern float __fmodf (float __x, float __y) __attribute__ ((__nothrow__));




extern int __isinff (float __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern int __finitef (float __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));





extern int isinff (float __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern int finitef (float __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern float dremf (float __x, float __y) __attribute__ ((__nothrow__)); extern float __dremf (float __x, float __y) __attribute__ ((__nothrow__));



extern float significandf (float __x) __attribute__ ((__nothrow__)); extern float __significandf (float __x) __attribute__ ((__nothrow__));





extern float copysignf (float __x, float __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__));






extern float nanf (__const char *__tagb) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern float __nanf (__const char *__tagb) __attribute__ ((__nothrow__)) __attribute__ ((__const__));





extern int __isnanf (float __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));



extern int isnanf (float __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern float j0f (float) __attribute__ ((__nothrow__)); extern float __j0f (float) __attribute__ ((__nothrow__));
extern float j1f (float) __attribute__ ((__nothrow__)); extern float __j1f (float) __attribute__ ((__nothrow__));
extern float jnf (int, float) __attribute__ ((__nothrow__)); extern float __jnf (int, float) __attribute__ ((__nothrow__));
extern float y0f (float) __attribute__ ((__nothrow__)); extern float __y0f (float) __attribute__ ((__nothrow__));
extern float y1f (float) __attribute__ ((__nothrow__)); extern float __y1f (float) __attribute__ ((__nothrow__));
extern float ynf (int, float) __attribute__ ((__nothrow__)); extern float __ynf (int, float) __attribute__ ((__nothrow__));






extern float erff (float) __attribute__ ((__nothrow__)); extern float __erff (float) __attribute__ ((__nothrow__));
extern float erfcf (float) __attribute__ ((__nothrow__)); extern float __erfcf (float) __attribute__ ((__nothrow__));
extern float lgammaf (float) __attribute__ ((__nothrow__)); extern float __lgammaf (float) __attribute__ ((__nothrow__));






extern float tgammaf (float) __attribute__ ((__nothrow__)); extern float __tgammaf (float) __attribute__ ((__nothrow__));





extern float gammaf (float) __attribute__ ((__nothrow__)); extern float __gammaf (float) __attribute__ ((__nothrow__));






extern float lgammaf_r (float, int *__signgamp) __attribute__ ((__nothrow__)); extern float __lgammaf_r (float, int *__signgamp) __attribute__ ((__nothrow__));







extern float rintf (float __x) __attribute__ ((__nothrow__)); extern float __rintf (float __x) __attribute__ ((__nothrow__));


extern float nextafterf (float __x, float __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern float __nextafterf (float __x, float __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__));

extern float nexttowardf (float __x, long double __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern float __nexttowardf (float __x, long double __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__));



extern float remainderf (float __x, float __y) __attribute__ ((__nothrow__)); extern float __remainderf (float __x, float __y) __attribute__ ((__nothrow__));



extern float scalbnf (float __x, int __n) __attribute__ ((__nothrow__)); extern float __scalbnf (float __x, int __n) __attribute__ ((__nothrow__));



extern int ilogbf (float __x) __attribute__ ((__nothrow__)); extern int __ilogbf (float __x) __attribute__ ((__nothrow__));




extern float scalblnf (float __x, long int __n) __attribute__ ((__nothrow__)); extern float __scalblnf (float __x, long int __n) __attribute__ ((__nothrow__));



extern float nearbyintf (float __x) __attribute__ ((__nothrow__)); extern float __nearbyintf (float __x) __attribute__ ((__nothrow__));



extern float roundf (float __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern float __roundf (float __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__));



extern float truncf (float __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern float __truncf (float __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) __attribute__ ((__nothrow__)); extern float __remquof (float __x, float __y, int *__quo) __attribute__ ((__nothrow__));






extern long int lrintf (float __x) __attribute__ ((__nothrow__)); extern long int __lrintf (float __x) __attribute__ ((__nothrow__));
extern long long int llrintf (float __x) __attribute__ ((__nothrow__)); extern long long int __llrintf (float __x) __attribute__ ((__nothrow__));



extern long int lroundf (float __x) __attribute__ ((__nothrow__)); extern long int __lroundf (float __x) __attribute__ ((__nothrow__));
extern long long int llroundf (float __x) __attribute__ ((__nothrow__)); extern long long int __llroundf (float __x) __attribute__ ((__nothrow__));



extern float fdimf (float __x, float __y) __attribute__ ((__nothrow__)); extern float __fdimf (float __x, float __y) __attribute__ ((__nothrow__));


extern float fmaxf (float __x, float __y) __attribute__ ((__nothrow__)); extern float __fmaxf (float __x, float __y) __attribute__ ((__nothrow__));


extern float fminf (float __x, float __y) __attribute__ ((__nothrow__)); extern float __fminf (float __x, float __y) __attribute__ ((__nothrow__));



extern int __fpclassifyf (float __value) __attribute__ ((__nothrow__))
     __attribute__ ((__const__));


extern int __signbitf (float __value) __attribute__ ((__nothrow__))
     __attribute__ ((__const__));



extern float fmaf (float __x, float __y, float __z) __attribute__ ((__nothrow__)); extern float __fmaf (float __x, float __y, float __z) __attribute__ ((__nothrow__));








extern float scalbf (float __x, float __n) __attribute__ ((__nothrow__)); extern float __scalbf (float __x, float __n) __attribute__ ((__nothrow__));
# 95 "/usr/include/math.h" 2 3 4
# 141 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4


extern long double acosl (long double __x) __attribute__ ((__nothrow__)); extern long double __acosl (long double __x) __attribute__ ((__nothrow__));

extern long double asinl (long double __x) __attribute__ ((__nothrow__)); extern long double __asinl (long double __x) __attribute__ ((__nothrow__));

extern long double atanl (long double __x) __attribute__ ((__nothrow__)); extern long double __atanl (long double __x) __attribute__ ((__nothrow__));

extern long double atan2l (long double __y, long double __x) __attribute__ ((__nothrow__)); extern long double __atan2l (long double __y, long double __x) __attribute__ ((__nothrow__));


extern long double cosl (long double __x) __attribute__ ((__nothrow__)); extern long double __cosl (long double __x) __attribute__ ((__nothrow__));

extern long double sinl (long double __x) __attribute__ ((__nothrow__)); extern long double __sinl (long double __x) __attribute__ ((__nothrow__));

extern long double tanl (long double __x) __attribute__ ((__nothrow__)); extern long double __tanl (long double __x) __attribute__ ((__nothrow__));




extern long double coshl (long double __x) __attribute__ ((__nothrow__)); extern long double __coshl (long double __x) __attribute__ ((__nothrow__));

extern long double sinhl (long double __x) __attribute__ ((__nothrow__)); extern long double __sinhl (long double __x) __attribute__ ((__nothrow__));

extern long double tanhl (long double __x) __attribute__ ((__nothrow__)); extern long double __tanhl (long double __x) __attribute__ ((__nothrow__));

# 87 "/usr/include/bits/mathcalls.h" 3 4


extern long double acoshl (long double __x) __attribute__ ((__nothrow__)); extern long double __acoshl (long double __x) __attribute__ ((__nothrow__));

extern long double asinhl (long double __x) __attribute__ ((__nothrow__)); extern long double __asinhl (long double __x) __attribute__ ((__nothrow__));

extern long double atanhl (long double __x) __attribute__ ((__nothrow__)); extern long double __atanhl (long double __x) __attribute__ ((__nothrow__));







extern long double expl (long double __x) __attribute__ ((__nothrow__)); extern long double __expl (long double __x) __attribute__ ((__nothrow__));


extern long double frexpl (long double __x, int *__exponent) __attribute__ ((__nothrow__)); extern long double __frexpl (long double __x, int *__exponent) __attribute__ ((__nothrow__));


extern long double ldexpl (long double __x, int __exponent) __attribute__ ((__nothrow__)); extern long double __ldexpl (long double __x, int __exponent) __attribute__ ((__nothrow__));


extern long double logl (long double __x) __attribute__ ((__nothrow__)); extern long double __logl (long double __x) __attribute__ ((__nothrow__));


extern long double log10l (long double __x) __attribute__ ((__nothrow__)); extern long double __log10l (long double __x) __attribute__ ((__nothrow__));


extern long double modfl (long double __x, long double *__iptr) __attribute__ ((__nothrow__)); extern long double __modfl (long double __x, long double *__iptr) __attribute__ ((__nothrow__));

# 127 "/usr/include/bits/mathcalls.h" 3 4


extern long double expm1l (long double __x) __attribute__ ((__nothrow__)); extern long double __expm1l (long double __x) __attribute__ ((__nothrow__));


extern long double log1pl (long double __x) __attribute__ ((__nothrow__)); extern long double __log1pl (long double __x) __attribute__ ((__nothrow__));


extern long double logbl (long double __x) __attribute__ ((__nothrow__)); extern long double __logbl (long double __x) __attribute__ ((__nothrow__));






extern long double exp2l (long double __x) __attribute__ ((__nothrow__)); extern long double __exp2l (long double __x) __attribute__ ((__nothrow__));


extern long double log2l (long double __x) __attribute__ ((__nothrow__)); extern long double __log2l (long double __x) __attribute__ ((__nothrow__));








extern long double powl (long double __x, long double __y) __attribute__ ((__nothrow__)); extern long double __powl (long double __x, long double __y) __attribute__ ((__nothrow__));


extern long double sqrtl (long double __x) __attribute__ ((__nothrow__)); extern long double __sqrtl (long double __x) __attribute__ ((__nothrow__));





extern long double hypotl (long double __x, long double __y) __attribute__ ((__nothrow__)); extern long double __hypotl (long double __x, long double __y) __attribute__ ((__nothrow__));






extern long double cbrtl (long double __x) __attribute__ ((__nothrow__)); extern long double __cbrtl (long double __x) __attribute__ ((__nothrow__));








extern long double ceill (long double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern long double __ceill (long double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern long double fabsl (long double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern long double __fabsl (long double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern long double floorl (long double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern long double __floorl (long double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) __attribute__ ((__nothrow__)); extern long double __fmodl (long double __x, long double __y) __attribute__ ((__nothrow__));




extern int __isinfl (long double __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern int __finitel (long double __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));





extern int isinfl (long double __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern int finitel (long double __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) __attribute__ ((__nothrow__)); extern long double __dreml (long double __x, long double __y) __attribute__ ((__nothrow__));



extern long double significandl (long double __x) __attribute__ ((__nothrow__)); extern long double __significandl (long double __x) __attribute__ ((__nothrow__));





extern long double copysignl (long double __x, long double __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__));






extern long double nanl (__const char *__tagb) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern long double __nanl (__const char *__tagb) __attribute__ ((__nothrow__)) __attribute__ ((__const__));





extern int __isnanl (long double __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));



extern int isnanl (long double __value) __attribute__ ((__nothrow__)) __attribute__ ((__const__));


extern long double j0l (long double) __attribute__ ((__nothrow__)); extern long double __j0l (long double) __attribute__ ((__nothrow__));
extern long double j1l (long double) __attribute__ ((__nothrow__)); extern long double __j1l (long double) __attribute__ ((__nothrow__));
extern long double jnl (int, long double) __attribute__ ((__nothrow__)); extern long double __jnl (int, long double) __attribute__ ((__nothrow__));
extern long double y0l (long double) __attribute__ ((__nothrow__)); extern long double __y0l (long double) __attribute__ ((__nothrow__));
extern long double y1l (long double) __attribute__ ((__nothrow__)); extern long double __y1l (long double) __attribute__ ((__nothrow__));
extern long double ynl (int, long double) __attribute__ ((__nothrow__)); extern long double __ynl (int, long double) __attribute__ ((__nothrow__));






extern long double erfl (long double) __attribute__ ((__nothrow__)); extern long double __erfl (long double) __attribute__ ((__nothrow__));
extern long double erfcl (long double) __attribute__ ((__nothrow__)); extern long double __erfcl (long double) __attribute__ ((__nothrow__));
extern long double lgammal (long double) __attribute__ ((__nothrow__)); extern long double __lgammal (long double) __attribute__ ((__nothrow__));






extern long double tgammal (long double) __attribute__ ((__nothrow__)); extern long double __tgammal (long double) __attribute__ ((__nothrow__));





extern long double gammal (long double) __attribute__ ((__nothrow__)); extern long double __gammal (long double) __attribute__ ((__nothrow__));






extern long double lgammal_r (long double, int *__signgamp) __attribute__ ((__nothrow__)); extern long double __lgammal_r (long double, int *__signgamp) __attribute__ ((__nothrow__));







extern long double rintl (long double __x) __attribute__ ((__nothrow__)); extern long double __rintl (long double __x) __attribute__ ((__nothrow__));


extern long double nextafterl (long double __x, long double __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern long double __nextafterl (long double __x, long double __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__));

extern long double nexttowardl (long double __x, long double __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern long double __nexttowardl (long double __x, long double __y) __attribute__ ((__nothrow__)) __attribute__ ((__const__));



extern long double remainderl (long double __x, long double __y) __attribute__ ((__nothrow__)); extern long double __remainderl (long double __x, long double __y) __attribute__ ((__nothrow__));



extern long double scalbnl (long double __x, int __n) __attribute__ ((__nothrow__)); extern long double __scalbnl (long double __x, int __n) __attribute__ ((__nothrow__));



extern int ilogbl (long double __x) __attribute__ ((__nothrow__)); extern int __ilogbl (long double __x) __attribute__ ((__nothrow__));




extern long double scalblnl (long double __x, long int __n) __attribute__ ((__nothrow__)); extern long double __scalblnl (long double __x, long int __n) __attribute__ ((__nothrow__));



extern long double nearbyintl (long double __x) __attribute__ ((__nothrow__)); extern long double __nearbyintl (long double __x) __attribute__ ((__nothrow__));



extern long double roundl (long double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern long double __roundl (long double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__));



extern long double truncl (long double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__)); extern long double __truncl (long double __x) __attribute__ ((__nothrow__)) __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) __attribute__ ((__nothrow__)); extern long double __remquol (long double __x, long double __y, int *__quo) __attribute__ ((__nothrow__));






extern long int lrintl (long double __x) __attribute__ ((__nothrow__)); extern long int __lrintl (long double __x) __attribute__ ((__nothrow__));
extern long long int llrintl (long double __x) __attribute__ ((__nothrow__)); extern long long int __llrintl (long double __x) __attribute__ ((__nothrow__));



extern long int lroundl (long double __x) __attribute__ ((__nothrow__)); extern long int __lroundl (long double __x) __attribute__ ((__nothrow__));
extern long long int llroundl (long double __x) __attribute__ ((__nothrow__)); extern long long int __llroundl (long double __x) __attribute__ ((__nothrow__));



extern long double fdiml (long double __x, long double __y) __attribute__ ((__nothrow__)); extern long double __fdiml (long double __x, long double __y) __attribute__ ((__nothrow__));


extern long double fmaxl (long double __x, long double __y) __attribute__ ((__nothrow__)); extern long double __fmaxl (long double __x, long double __y) __attribute__ ((__nothrow__));


extern long double fminl (long double __x, long double __y) __attribute__ ((__nothrow__)); extern long double __fminl (long double __x, long double __y) __attribute__ ((__nothrow__));



extern int __fpclassifyl (long double __value) __attribute__ ((__nothrow__))
     __attribute__ ((__const__));


extern int __signbitl (long double __value) __attribute__ ((__nothrow__))
     __attribute__ ((__const__));



extern long double fmal (long double __x, long double __y, long double __z) __attribute__ ((__nothrow__)); extern long double __fmal (long double __x, long double __y, long double __z) __attribute__ ((__nothrow__));








extern long double scalbl (long double __x, long double __n) __attribute__ ((__nothrow__)); extern long double __scalbl (long double __x, long double __n) __attribute__ ((__nothrow__));
# 142 "/usr/include/math.h" 2 3 4
# 157 "/usr/include/math.h" 3 4
extern int signgam;
# 198 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN,

    FP_INFINITE,

    FP_ZERO,

    FP_SUBNORMAL,

    FP_NORMAL

  };
# 291 "/usr/include/math.h" 3 4
typedef enum
{
  _IEEE_ = -1,
  _SVID_,
  _XOPEN_,
  _POSIX_,
  _ISOC_
} _LIB_VERSION_TYPE;




extern _LIB_VERSION_TYPE _LIB_VERSION;
# 316 "/usr/include/math.h" 3 4
struct exception

  {
    int type;
    char *name;
    double arg1;
    double arg2;
    double retval;
  };




extern int matherr (struct exception *__exc);
# 416 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathinline.h" 1 3 4
# 127 "/usr/include/bits/mathinline.h" 3 4
extern __inline int
__attribute__ ((__nothrow__)) __signbitf (float __x)
{
  __extension__ union { float __f; int __i; } __u = { __f: __x };
  return __u.__i < 0;
}
extern __inline int
__attribute__ ((__nothrow__)) __signbit (double __x)
{
  __extension__ union { double __d; int __i[2]; } __u = { __d: __x };
  return __u.__i[1] < 0;
}
extern __inline int
__attribute__ ((__nothrow__)) __signbitl (long double __x)
{
  __extension__ union { long double __l; int __i[3]; } __u = { __l: __x };
  return (__u.__i[2] & 0x8000) != 0;
}
# 295 "/usr/include/bits/mathinline.h" 3 4
extern __inline double __sgn (double) __attribute__ ((__nothrow__)); extern __inline double __attribute__ ((__nothrow__)) __sgn (double __x) { return __x == 0.0 ? 0.0 : (__x > 0.0 ? 1.0 : -1.0); } extern __inline float __sgnf (float) __attribute__ ((__nothrow__)); extern __inline float __attribute__ ((__nothrow__)) __sgnf (float __x) { return __x == 0.0 ? 0.0 : (__x > 0.0 ? 1.0 : -1.0); } extern __inline long double __sgnl (long double) __attribute__ ((__nothrow__)); extern __inline long double __attribute__ ((__nothrow__)) __sgnl (long double __x) { return __x == 0.0 ? 0.0 : (__x > 0.0 ? 1.0 : -1.0); }
# 437 "/usr/include/bits/mathinline.h" 3 4
extern __inline long double __attribute__ ((__nothrow__)) __atan2l (long double __y, long double __x) { return __builtin_atan2l (__y, __x); }
# 477 "/usr/include/bits/mathinline.h" 3 4
extern __inline double __attribute__ ((__nothrow__)) fabs (double __x) { return __builtin_fabs (__x); }

extern __inline float __attribute__ ((__nothrow__)) fabsf (float __x) { return __builtin_fabsf (__x); }
extern __inline long double __attribute__ ((__nothrow__)) fabsl (long double __x) { return __builtin_fabsl (__x); }

extern __inline long double __attribute__ ((__nothrow__)) __fabsl (long double __x) { return __builtin_fabsl (__x); }
# 510 "/usr/include/bits/mathinline.h" 3 4
extern __inline long double __sgn1l (long double) __attribute__ ((__nothrow__)); extern __inline long double __attribute__ ((__nothrow__)) __sgn1l (long double __x) { __extension__ union { long double __xld; unsigned int __xi[3]; } __n = { __xld: __x }; __n.__xi[2] = (__n.__xi[2] & 0x8000) | 0x3fff; __n.__xi[1] = 0x80000000; __n.__xi[0] = 0; return __n.__xld; }
# 534 "/usr/include/bits/mathinline.h" 3 4
extern __inline double __attribute__ ((__nothrow__)) floor (double __x) { register long double __value; register int __ignore; unsigned short int __cw; unsigned short int __cwtmp; __asm __volatile ("fnstcw %3\n\t" "movzwl %3, %1\n\t" "andl $0xf3ff, %1\n\t" "orl $0x0400, %1\n\t" "movw %w1, %2\n\t" "fldcw %2\n\t" "frndint\n\t" "fldcw %3" : "=t" (__value), "=&q" (__ignore), "=m" (__cwtmp), "=m" (__cw) : "0" (__x)); return __value; } extern __inline float __attribute__ ((__nothrow__)) floorf (float __x) { register long double __value; register int __ignore; unsigned short int __cw; unsigned short int __cwtmp; __asm __volatile ("fnstcw %3\n\t" "movzwl %3, %1\n\t" "andl $0xf3ff, %1\n\t" "orl $0x0400, %1\n\t" "movw %w1, %2\n\t" "fldcw %2\n\t" "frndint\n\t" "fldcw %3" : "=t" (__value), "=&q" (__ignore), "=m" (__cwtmp), "=m" (__cw) : "0" (__x)); return __value; } extern __inline long double __attribute__ ((__nothrow__)) floorl (long double __x) { register long double __value; register int __ignore; unsigned short int __cw; unsigned short int __cwtmp; __asm __volatile ("fnstcw %3\n\t" "movzwl %3, %1\n\t" "andl $0xf3ff, %1\n\t" "orl $0x0400, %1\n\t" "movw %w1, %2\n\t" "fldcw %2\n\t" "frndint\n\t" "fldcw %3" : "=t" (__value), "=&q" (__ignore), "=m" (__cwtmp), "=m" (__cw) : "0" (__x)); return __value; }
# 552 "/usr/include/bits/mathinline.h" 3 4
extern __inline double __attribute__ ((__nothrow__)) ceil (double __x) { register long double __value; register int __ignore; unsigned short int __cw; unsigned short int __cwtmp; __asm __volatile ("fnstcw %3\n\t" "movzwl %3, %1\n\t" "andl $0xf3ff, %1\n\t" "orl $0x0800, %1\n\t" "movw %w1, %2\n\t" "fldcw %2\n\t" "frndint\n\t" "fldcw %3" : "=t" (__value), "=&q" (__ignore), "=m" (__cwtmp), "=m" (__cw) : "0" (__x)); return __value; } extern __inline float __attribute__ ((__nothrow__)) ceilf (float __x) { register long double __value; register int __ignore; unsigned short int __cw; unsigned short int __cwtmp; __asm __volatile ("fnstcw %3\n\t" "movzwl %3, %1\n\t" "andl $0xf3ff, %1\n\t" "orl $0x0800, %1\n\t" "movw %w1, %2\n\t" "fldcw %2\n\t" "frndint\n\t" "fldcw %3" : "=t" (__value), "=&q" (__ignore), "=m" (__cwtmp), "=m" (__cw) : "0" (__x)); return __value; } extern __inline long double __attribute__ ((__nothrow__)) ceill (long double __x) { register long double __value; register int __ignore; unsigned short int __cw; unsigned short int __cwtmp; __asm __volatile ("fnstcw %3\n\t" "movzwl %3, %1\n\t" "andl $0xf3ff, %1\n\t" "orl $0x0800, %1\n\t" "movw %w1, %2\n\t" "fldcw %2\n\t" "frndint\n\t" "fldcw %3" : "=t" (__value), "=&q" (__ignore), "=m" (__cwtmp), "=m" (__cw) : "0" (__x)); return __value; }
# 671 "/usr/include/bits/mathinline.h" 3 4
extern __inline long int
__attribute__ ((__nothrow__)) lrintf (float __x)
{
  long int __lrintres; __asm__ __volatile__ ("fistpl %0" : "=m" (__lrintres) : "t" (__x) : "st"); return __lrintres;
}
extern __inline long int
__attribute__ ((__nothrow__)) lrint (double __x)
{
  long int __lrintres; __asm__ __volatile__ ("fistpl %0" : "=m" (__lrintres) : "t" (__x) : "st"); return __lrintres;
}
extern __inline long int
__attribute__ ((__nothrow__)) lrintl (long double __x)
{
  long int __lrintres; __asm__ __volatile__ ("fistpl %0" : "=m" (__lrintres) : "t" (__x) : "st"); return __lrintres;
}
# 694 "/usr/include/bits/mathinline.h" 3 4
extern __inline long long int
__attribute__ ((__nothrow__)) llrintf (float __x)
{
  long long int __llrintres; __asm__ __volatile__ ("fistpll %0" : "=m" (__llrintres) : "t" (__x) : "st"); return __llrintres;
}
extern __inline long long int
__attribute__ ((__nothrow__)) llrint (double __x)
{
  long long int __llrintres; __asm__ __volatile__ ("fistpll %0" : "=m" (__llrintres) : "t" (__x) : "st"); return __llrintres;
}
extern __inline long long int
__attribute__ ((__nothrow__)) llrintl (long double __x)
{
  long long int __llrintres; __asm__ __volatile__ ("fistpll %0" : "=m" (__llrintres) : "t" (__x) : "st"); return __llrintres;
}
# 731 "/usr/include/bits/mathinline.h" 3 4
extern __inline int
__attribute__ ((__nothrow__)) __finite (double __x)
{
  return (__extension__
   (((((union { double __d; int __i[2]; }) {__d: __x}).__i[1]
      | 0x800fffffu) + 1) >> 31));
}
# 417 "/usr/include/math.h" 2 3 4
# 472 "/usr/include/math.h" 3 4

# 2424 "Zend/../main/php_config.h" 2
# 2 "Zend/zend_config.h" 2
# 52 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend.h" 2
# 75 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend.h"
# 1 "/usr/lib/gcc/i686-redhat-linux/4.4.5/include/stdarg.h" 1 3 4
# 76 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend.h" 2



# 1 "/usr/include/dlfcn.h" 1 3 4
# 25 "/usr/include/dlfcn.h" 3 4
# 1 "/usr/lib/gcc/i686-redhat-linux/4.4.5/include/stddef.h" 1 3 4
# 26 "/usr/include/dlfcn.h" 2 3 4


# 1 "/usr/include/bits/dlfcn.h" 1 3 4
# 29 "/usr/include/dlfcn.h" 2 3 4
# 53 "/usr/include/dlfcn.h" 3 4




extern void *dlopen (__const char *__file, int __mode) __attribute__ ((__nothrow__));



extern int dlclose (void *__handle) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern void *dlsym (void *__restrict __handle,
      __const char *__restrict __name) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));
# 83 "/usr/include/dlfcn.h" 3 4
extern char *dlerror (void) __attribute__ ((__nothrow__));
# 189 "/usr/include/dlfcn.h" 3 4

# 80 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend.h" 2
# 236 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend.h"
# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_errors.h" 1
# 237 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend.h" 2
# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_alloc.h" 1
# 27 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_alloc.h"
# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/../TSRM/TSRM.h" 1
# 20 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/../TSRM/TSRM.h"
# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/TSRM/tsrm_config.h" 1
# 1 "Zend/../main/php_config.h" 1
# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/TSRM/tsrm_config.h" 2
# 21 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/../TSRM/TSRM.h" 2
# 39 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/../TSRM/TSRM.h"
typedef long tsrm_intptr_t;
typedef unsigned long tsrm_uintptr_t;
# 28 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_alloc.h" 2
# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend.h" 1
# 29 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_alloc.h" 2
# 44 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_alloc.h"
typedef struct _zend_leak_info {
 void *addr;
 size_t size;
 char *filename;
 uint lineno;
 char *orig_filename;
 uint orig_lineno;
} zend_leak_info;



__attribute__ ((visibility("default"))) char *zend_strndup(const char *s, unsigned int length) __attribute__ ((__malloc__));

__attribute__ ((visibility("default"))) void *_emalloc(size_t size ) __attribute__ ((__malloc__));
__attribute__ ((visibility("default"))) void *_safe_emalloc(size_t nmemb, size_t size, size_t offset ) __attribute__ ((__malloc__));
__attribute__ ((visibility("default"))) void *_safe_malloc(size_t nmemb, size_t size, size_t offset) __attribute__ ((__malloc__));
__attribute__ ((visibility("default"))) void _efree(void *ptr );
__attribute__ ((visibility("default"))) void *_ecalloc(size_t nmemb, size_t size ) __attribute__ ((__malloc__));
__attribute__ ((visibility("default"))) void *_erealloc(void *ptr, size_t size, int allow_failure );
__attribute__ ((visibility("default"))) void *_safe_erealloc(void *ptr, size_t nmemb, size_t size, size_t offset );
__attribute__ ((visibility("default"))) void *_safe_realloc(void *ptr, size_t nmemb, size_t size, size_t offset);
__attribute__ ((visibility("default"))) char *_estrdup(const char *s ) __attribute__ ((__malloc__));
__attribute__ ((visibility("default"))) char *_estrndup(const char *s, unsigned int length ) __attribute__ ((__malloc__));
__attribute__ ((visibility("default"))) size_t _zend_mem_block_size(void *ptr );
# 93 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_alloc.h"
inline static void * __zend_malloc(size_t len)
{
 void *tmp = malloc(len);
 if (tmp) {
  return tmp;
 }
 fprintf(stderr, "Out of memory\n");
 exit(1);
}

inline static void * __zend_calloc(size_t nmemb, size_t len)
{
 void *tmp = _safe_malloc(nmemb, len, 0);
 memset(tmp, 0, nmemb * len);
 return tmp;
}

inline static void * __zend_realloc(void *p, size_t len)
{
 p = realloc(p, len);
 if (p) {
  return p;
 }
 fprintf(stderr, "Out of memory\n");
 exit(1);
}
# 142 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_alloc.h"
__attribute__ ((visibility("default"))) int zend_set_memory_limit(size_t memory_limit);

__attribute__ ((visibility("default"))) void start_memory_manager(void);
__attribute__ ((visibility("default"))) void shutdown_memory_manager(int silent, int full_shutdown );
__attribute__ ((visibility("default"))) int is_zend_mm(void);
# 159 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_alloc.h"
__attribute__ ((visibility("default"))) size_t zend_memory_usage(int real_usage );
__attribute__ ((visibility("default"))) size_t zend_memory_peak_usage(int real_usage );


# 191 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_alloc.h"
typedef struct _zend_mm_heap zend_mm_heap;

__attribute__ ((visibility("default"))) zend_mm_heap *zend_mm_startup(void);
__attribute__ ((visibility("default"))) void zend_mm_shutdown(zend_mm_heap *heap, int full_shutdown, int silent );
__attribute__ ((visibility("default"))) void *_zend_mm_alloc(zend_mm_heap *heap, size_t size ) __attribute__ ((__malloc__));
__attribute__ ((visibility("default"))) void _zend_mm_free(zend_mm_heap *heap, void *p );
__attribute__ ((visibility("default"))) void *_zend_mm_realloc(zend_mm_heap *heap, void *p, size_t size );
__attribute__ ((visibility("default"))) size_t _zend_mm_block_size(zend_mm_heap *heap, void *p );
# 211 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_alloc.h"
typedef struct _zend_mm_storage zend_mm_storage;

typedef struct _zend_mm_segment {
 size_t size;
 struct _zend_mm_segment *next_segment;
} zend_mm_segment;

typedef struct _zend_mm_mem_handlers {
 const char *name;
 zend_mm_storage* (*init)(void *params);
 void (*dtor)(zend_mm_storage *storage);
 void (*compact)(zend_mm_storage *storage);
 zend_mm_segment* (*_alloc)(zend_mm_storage *storage, size_t size);
 zend_mm_segment* (*_realloc)(zend_mm_storage *storage, zend_mm_segment *ptr, size_t size);
 void (*_free)(zend_mm_storage *storage, zend_mm_segment *ptr);
} zend_mm_mem_handlers;

struct _zend_mm_storage {
 const zend_mm_mem_handlers *handlers;
 void *data;
};

__attribute__ ((visibility("default"))) zend_mm_heap *zend_mm_startup_ex(const zend_mm_mem_handlers *handlers, size_t block_size, size_t reserve_size, int internal, void *params);
__attribute__ ((visibility("default"))) zend_mm_heap *zend_mm_set_heap(zend_mm_heap *new_heap );
__attribute__ ((visibility("default"))) zend_mm_storage *zend_mm_get_storage(zend_mm_heap *heap);

__attribute__ ((visibility("default"))) void zend_mm_set_custom_handlers(zend_mm_heap *heap,
                                          void* (*_malloc)(size_t),
                                          void (*_free)(void*),
                                          void* (*_realloc)(void*, size_t));
# 238 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend.h" 2

# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_types.h" 1
# 25 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_types.h"
typedef unsigned char zend_bool;
typedef unsigned char zend_uchar;
typedef unsigned int zend_uint;
typedef unsigned long zend_ulong;
typedef unsigned short zend_ushort;






typedef long long int zend_long64;
typedef unsigned long long int zend_ulong64;
# 49 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_types.h"
typedef long zend_intptr_t;
typedef unsigned long zend_uintptr_t;


typedef unsigned int zend_object_handle;
typedef struct _zend_object_handlers zend_object_handlers;

typedef struct _zend_object_value {
 zend_object_handle handle;
 zend_object_handlers *handlers;
} zend_object_value;
# 240 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend.h" 2
# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_string.h" 1
# 26 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_string.h"
__attribute__ ((visibility("default"))) extern const char *(*zend_new_interned_string)(const char *str, int len, int free_src );
__attribute__ ((visibility("default"))) extern void (*zend_interned_strings_snapshot)(void);
__attribute__ ((visibility("default"))) extern void (*zend_interned_strings_restore)(void);

void zend_interned_strings_init(void);
void zend_interned_strings_dtor(void);
# 241 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend.h" 2


# 1 "/usr/lib/gcc/i686-redhat-linux/4.4.5/include/limits.h" 1 3 4
# 11 "/usr/lib/gcc/i686-redhat-linux/4.4.5/include/limits.h" 3 4
# 1 "/usr/lib/gcc/i686-redhat-linux/4.4.5/include/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/i686-redhat-linux/4.4.5/include/limits.h" 1 3 4
# 122 "/usr/lib/gcc/i686-redhat-linux/4.4.5/include/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 145 "/usr/include/limits.h" 3 4
# 1 "/usr/include/bits/posix1_lim.h" 1 3 4
# 157 "/usr/include/bits/posix1_lim.h" 3 4
# 1 "/usr/include/bits/local_lim.h" 1 3 4
# 39 "/usr/include/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 40 "/usr/include/bits/local_lim.h" 2 3 4
# 158 "/usr/include/bits/posix1_lim.h" 2 3 4
# 146 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/posix2_lim.h" 1 3 4
# 150 "/usr/include/limits.h" 2 3 4
# 123 "/usr/lib/gcc/i686-redhat-linux/4.4.5/include/limits.h" 2 3 4
# 8 "/usr/lib/gcc/i686-redhat-linux/4.4.5/include/syslimits.h" 2 3 4
# 12 "/usr/lib/gcc/i686-redhat-linux/4.4.5/include/limits.h" 2 3 4
# 244 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend.h" 2
# 256 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend.h"
static const char long_min_digits[] = "2147483648";
# 271 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend.h"
# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_hash.h" 1
# 45 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_hash.h"
typedef ulong (*hash_func_t)(const char *arKey, uint nKeyLength);
typedef int (*compare_func_t)(const void *, const void * );
typedef void (*sort_func_t)(void *, size_t, register size_t, compare_func_t );
typedef void (*dtor_func_t)(void *pDest);
typedef void (*copy_ctor_func_t)(void *pElement);
typedef void (*copy_ctor_param_func_t)(void *pElement, void *pParam);

struct _hashtable;

typedef struct bucket {
 ulong h;
 uint nKeyLength;
 void *pData;
 void *pDataPtr;
 struct bucket *pListNext;
 struct bucket *pListLast;
 struct bucket *pNext;
 struct bucket *pLast;
 char *arKey;
} Bucket;

typedef struct _hashtable {
 uint nTableSize;
 uint nTableMask;
 uint nNumOfElements;
 ulong nNextFreeElement;
 Bucket *pInternalPointer;
 Bucket *pListHead;
 Bucket *pListTail;
 Bucket **arBuckets;
 dtor_func_t pDestructor;
 zend_bool persistent;
 unsigned char nApplyCount;
 zend_bool bApplyProtection;



} HashTable;


typedef struct _zend_hash_key {
 char *arKey;
 uint nKeyLength;
 ulong h;
} zend_hash_key;


typedef zend_bool (*merge_checker_func_t)(HashTable *target_ht, void *source_data, zend_hash_key *hash_key, void *pParam);

typedef Bucket* HashPosition;




__attribute__ ((visibility("default"))) int _zend_hash_init(HashTable *ht, uint nSize, hash_func_t pHashFunction, dtor_func_t pDestructor, zend_bool persistent );
__attribute__ ((visibility("default"))) int _zend_hash_init_ex(HashTable *ht, uint nSize, hash_func_t pHashFunction, dtor_func_t pDestructor, zend_bool persistent, zend_bool bApplyProtection );
__attribute__ ((visibility("default"))) void zend_hash_destroy(HashTable *ht);
__attribute__ ((visibility("default"))) void zend_hash_clean(HashTable *ht);




__attribute__ ((visibility("default"))) int _zend_hash_add_or_update(HashTable *ht, const char *arKey, uint nKeyLength, void *pData, uint nDataSize, void **pDest, int flag );





__attribute__ ((visibility("default"))) int _zend_hash_quick_add_or_update(HashTable *ht, const char *arKey, uint nKeyLength, ulong h, void *pData, uint nDataSize, void **pDest, int flag );





__attribute__ ((visibility("default"))) int _zend_hash_index_update_or_next_insert(HashTable *ht, ulong h, void *pData, uint nDataSize, void **pDest, int flag );





__attribute__ ((visibility("default"))) int zend_hash_add_empty_element(HashTable *ht, const char *arKey, uint nKeyLength);






typedef int (*apply_func_t)(void *pDest );
typedef int (*apply_func_arg_t)(void *pDest, void *argument );
typedef int (*apply_func_args_t)(void *pDest , int num_args, va_list args, zend_hash_key *hash_key);

__attribute__ ((visibility("default"))) void zend_hash_graceful_destroy(HashTable *ht);
__attribute__ ((visibility("default"))) void zend_hash_graceful_reverse_destroy(HashTable *ht);
__attribute__ ((visibility("default"))) void zend_hash_apply(HashTable *ht, apply_func_t apply_func );
__attribute__ ((visibility("default"))) void zend_hash_apply_with_argument(HashTable *ht, apply_func_arg_t apply_func, void * );
__attribute__ ((visibility("default"))) void zend_hash_apply_with_arguments(HashTable *ht , apply_func_args_t apply_func, int, ...);







__attribute__ ((visibility("default"))) void zend_hash_reverse_apply(HashTable *ht, apply_func_t apply_func );



__attribute__ ((visibility("default"))) int zend_hash_del_key_or_index(HashTable *ht, const char *arKey, uint nKeyLength, ulong h, int flag);







__attribute__ ((visibility("default"))) ulong zend_get_hash_value(const char *arKey, uint nKeyLength);


__attribute__ ((visibility("default"))) int zend_hash_find(const HashTable *ht, const char *arKey, uint nKeyLength, void **pData);
__attribute__ ((visibility("default"))) int zend_hash_quick_find(const HashTable *ht, const char *arKey, uint nKeyLength, ulong h, void **pData);
__attribute__ ((visibility("default"))) int zend_hash_index_find(const HashTable *ht, ulong h, void **pData);


__attribute__ ((visibility("default"))) int zend_hash_exists(const HashTable *ht, const char *arKey, uint nKeyLength);
__attribute__ ((visibility("default"))) int zend_hash_quick_exists(const HashTable *ht, const char *arKey, uint nKeyLength, ulong h);
__attribute__ ((visibility("default"))) int zend_hash_index_exists(const HashTable *ht, ulong h);
__attribute__ ((visibility("default"))) ulong zend_hash_next_free_element(const HashTable *ht);





__attribute__ ((visibility("default"))) int zend_hash_move_forward_ex(HashTable *ht, HashPosition *pos);
__attribute__ ((visibility("default"))) int zend_hash_move_backwards_ex(HashTable *ht, HashPosition *pos);
__attribute__ ((visibility("default"))) int zend_hash_get_current_key_ex(const HashTable *ht, char **str_index, uint *str_length, ulong *num_index, zend_bool duplicate, HashPosition *pos);
__attribute__ ((visibility("default"))) int zend_hash_get_current_key_type_ex(HashTable *ht, HashPosition *pos);
__attribute__ ((visibility("default"))) int zend_hash_get_current_data_ex(HashTable *ht, void **pData, HashPosition *pos);
__attribute__ ((visibility("default"))) void zend_hash_internal_pointer_reset_ex(HashTable *ht, HashPosition *pos);
__attribute__ ((visibility("default"))) void zend_hash_internal_pointer_end_ex(HashTable *ht, HashPosition *pos);
__attribute__ ((visibility("default"))) int zend_hash_update_current_key_ex(HashTable *ht, int key_type, const char *str_index, uint str_length, ulong num_index, int mode, HashPosition *pos);

typedef struct _HashPointer {
 HashPosition pos;
 ulong h;
} HashPointer;

__attribute__ ((visibility("default"))) int zend_hash_get_pointer(const HashTable *ht, HashPointer *ptr);
__attribute__ ((visibility("default"))) int zend_hash_set_pointer(HashTable *ht, const HashPointer *ptr);
# 214 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_hash.h"
__attribute__ ((visibility("default"))) void zend_hash_copy(HashTable *target, HashTable *source, copy_ctor_func_t pCopyConstructor, void *tmp, uint size);
__attribute__ ((visibility("default"))) void _zend_hash_merge(HashTable *target, HashTable *source, copy_ctor_func_t pCopyConstructor, void *tmp, uint size, int overwrite );
__attribute__ ((visibility("default"))) void zend_hash_merge_ex(HashTable *target, HashTable *source, copy_ctor_func_t pCopyConstructor, uint size, merge_checker_func_t pMergeSource, void *pParam);
__attribute__ ((visibility("default"))) int zend_hash_sort(HashTable *ht, sort_func_t sort_func, compare_func_t compare_func, int renumber );
__attribute__ ((visibility("default"))) int zend_hash_compare(HashTable *ht1, HashTable *ht2, compare_func_t compar, zend_bool ordered );
__attribute__ ((visibility("default"))) int zend_hash_minmax(const HashTable *ht, compare_func_t compar, int flag, void **pData );




__attribute__ ((visibility("default"))) int zend_hash_num_elements(const HashTable *ht);

__attribute__ ((visibility("default"))) int zend_hash_rehash(HashTable *ht);
# 261 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_hash.h"
static inline ulong zend_inline_hash_func(const char *arKey, uint nKeyLength)
{
 register ulong hash = 5381;


 for (; nKeyLength >= 8; nKeyLength -= 8) {
  hash = ((hash << 5) + hash) + *arKey++;
  hash = ((hash << 5) + hash) + *arKey++;
  hash = ((hash << 5) + hash) + *arKey++;
  hash = ((hash << 5) + hash) + *arKey++;
  hash = ((hash << 5) + hash) + *arKey++;
  hash = ((hash << 5) + hash) + *arKey++;
  hash = ((hash << 5) + hash) + *arKey++;
  hash = ((hash << 5) + hash) + *arKey++;
 }
 switch (nKeyLength) {
  case 7: hash = ((hash << 5) + hash) + *arKey++;
  case 6: hash = ((hash << 5) + hash) + *arKey++;
  case 5: hash = ((hash << 5) + hash) + *arKey++;
  case 4: hash = ((hash << 5) + hash) + *arKey++;
  case 3: hash = ((hash << 5) + hash) + *arKey++;
  case 2: hash = ((hash << 5) + hash) + *arKey++;
  case 1: hash = ((hash << 5) + hash) + *arKey++; break;
  case 0: break;

 }
 return hash;
}


__attribute__ ((visibility("default"))) ulong zend_hash_func(const char *arKey, uint nKeyLength);








# 348 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_hash.h"
static inline int zend_symtable_update(HashTable *ht, const char *arKey, uint nKeyLength, void *pData, uint nDataSize, void **pDest)
 {
 do { ulong idx; do { register const char *tmp = arKey; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = arKey + nKeyLength - 1; if ((*end != '\0') || (*tmp == '0' && nKeyLength > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } idx = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { idx = (idx * 10) + (*tmp - '0'); } if (tmp == end) { if (*arKey == '-') { if (idx-1 > 2147483647L) { break; } idx = (ulong)(-(long)idx); } else if (idx > 2147483647L) { break; } return _zend_hash_index_update_or_next_insert(ht, idx, pData, nDataSize, pDest, (1<<0) ); } } } while (0); } while (0);
 return _zend_hash_add_or_update(ht, arKey, nKeyLength, pData, nDataSize, pDest, (1<<0) );
}


static inline int zend_symtable_del(HashTable *ht, const char *arKey, uint nKeyLength)
{
 do { ulong idx; do { register const char *tmp = arKey; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = arKey + nKeyLength - 1; if ((*end != '\0') || (*tmp == '0' && nKeyLength > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } idx = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { idx = (idx * 10) + (*tmp - '0'); } if (tmp == end) { if (*arKey == '-') { if (idx-1 > 2147483647L) { break; } idx = (ulong)(-(long)idx); } else if (idx > 2147483647L) { break; } return zend_hash_del_key_or_index(ht, ((void *)0), 0, idx, 1); } } } while (0); } while (0);
 return zend_hash_del_key_or_index(ht, arKey, nKeyLength, 0, 0);
}


static inline int zend_symtable_find(HashTable *ht, const char *arKey, uint nKeyLength, void **pData)
{
 do { ulong idx; do { register const char *tmp = arKey; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = arKey + nKeyLength - 1; if ((*end != '\0') || (*tmp == '0' && nKeyLength > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } idx = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { idx = (idx * 10) + (*tmp - '0'); } if (tmp == end) { if (*arKey == '-') { if (idx-1 > 2147483647L) { break; } idx = (ulong)(-(long)idx); } else if (idx > 2147483647L) { break; } return zend_hash_index_find(ht, idx, pData); } } } while (0); } while (0);
 return zend_hash_find(ht, arKey, nKeyLength, pData);
}


static inline int zend_symtable_exists(HashTable *ht, const char *arKey, uint nKeyLength)
{
 do { ulong idx; do { register const char *tmp = arKey; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = arKey + nKeyLength - 1; if ((*end != '\0') || (*tmp == '0' && nKeyLength > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } idx = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { idx = (idx * 10) + (*tmp - '0'); } if (tmp == end) { if (*arKey == '-') { if (idx-1 > 2147483647L) { break; } idx = (ulong)(-(long)idx); } else if (idx > 2147483647L) { break; } return zend_hash_index_exists(ht, idx); } } } while (0); } while (0);
 return zend_hash_exists(ht, arKey, nKeyLength);
}

static inline int zend_symtable_update_current_key_ex(HashTable *ht, const char *arKey, uint nKeyLength, int mode, HashPosition *pos)
{
 do { ulong idx; do { register const char *tmp = arKey; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = arKey + nKeyLength - 1; if ((*end != '\0') || (*tmp == '0' && nKeyLength > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } idx = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { idx = (idx * 10) + (*tmp - '0'); } if (tmp == end) { if (*arKey == '-') { if (idx-1 > 2147483647L) { break; } idx = (ulong)(-(long)idx); } else if (idx > 2147483647L) { break; } return zend_hash_update_current_key_ex(ht, 2, ((void *)0), 0, idx, mode, pos); } } } while (0); } while (0);
 return zend_hash_update_current_key_ex(ht, 1, arKey, nKeyLength, 0, mode, pos);
}
# 272 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend.h" 2
# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_ts_hash.h" 1
# 26 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_ts_hash.h"
typedef struct _zend_ts_hashtable {
 HashTable hash;
 zend_uint reader;




} TsHashTable;






__attribute__ ((visibility("default"))) int _zend_ts_hash_init(TsHashTable *ht, uint nSize, hash_func_t pHashFunction, dtor_func_t pDestructor, zend_bool persistent );
__attribute__ ((visibility("default"))) int _zend_ts_hash_init_ex(TsHashTable *ht, uint nSize, hash_func_t pHashFunction, dtor_func_t pDestructor, zend_bool persistent, zend_bool bApplyProtection );
__attribute__ ((visibility("default"))) void zend_ts_hash_destroy(TsHashTable *ht);
__attribute__ ((visibility("default"))) void zend_ts_hash_clean(TsHashTable *ht);
# 52 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_ts_hash.h"
__attribute__ ((visibility("default"))) int _zend_ts_hash_add_or_update(TsHashTable *ht, char *arKey, uint nKeyLength, void *pData, uint nDataSize, void **pDest, int flag );





__attribute__ ((visibility("default"))) int _zend_ts_hash_quick_add_or_update(TsHashTable *ht, char *arKey, uint nKeyLength, ulong h, void *pData, uint nDataSize, void **pDest, int flag );





__attribute__ ((visibility("default"))) int _zend_ts_hash_index_update_or_next_insert(TsHashTable *ht, ulong h, void *pData, uint nDataSize, void **pDest, int flag );





__attribute__ ((visibility("default"))) int zend_ts_hash_add_empty_element(TsHashTable *ht, char *arKey, uint nKeyLength);

__attribute__ ((visibility("default"))) void zend_ts_hash_graceful_destroy(TsHashTable *ht);
__attribute__ ((visibility("default"))) void zend_ts_hash_apply(TsHashTable *ht, apply_func_t apply_func );
__attribute__ ((visibility("default"))) void zend_ts_hash_apply_with_argument(TsHashTable *ht, apply_func_arg_t apply_func, void * );
__attribute__ ((visibility("default"))) void zend_ts_hash_apply_with_arguments(TsHashTable *ht , apply_func_args_t apply_func, int, ...);

__attribute__ ((visibility("default"))) void zend_ts_hash_reverse_apply(TsHashTable *ht, apply_func_t apply_func );



__attribute__ ((visibility("default"))) int zend_ts_hash_del_key_or_index(TsHashTable *ht, char *arKey, uint nKeyLength, ulong h, int flag);





__attribute__ ((visibility("default"))) ulong zend_ts_get_hash_value(TsHashTable *ht, char *arKey, uint nKeyLength);


__attribute__ ((visibility("default"))) int zend_ts_hash_find(TsHashTable *ht, char *arKey, uint nKeyLength, void **pData);
__attribute__ ((visibility("default"))) int zend_ts_hash_quick_find(TsHashTable *ht, char *arKey, uint nKeyLength, ulong h, void **pData);
__attribute__ ((visibility("default"))) int zend_ts_hash_index_find(TsHashTable *ht, ulong h, void **pData);


__attribute__ ((visibility("default"))) int zend_ts_hash_exists(TsHashTable *ht, char *arKey, uint nKeyLength);
__attribute__ ((visibility("default"))) int zend_ts_hash_index_exists(TsHashTable *ht, ulong h);


__attribute__ ((visibility("default"))) void zend_ts_hash_copy(TsHashTable *target, TsHashTable *source, copy_ctor_func_t pCopyConstructor, void *tmp, uint size);
__attribute__ ((visibility("default"))) void zend_ts_hash_copy_to_hash(HashTable *target, TsHashTable *source, copy_ctor_func_t pCopyConstructor, void *tmp, uint size);
__attribute__ ((visibility("default"))) void zend_ts_hash_merge(TsHashTable *target, TsHashTable *source, copy_ctor_func_t pCopyConstructor, void *tmp, uint size, int overwrite);
__attribute__ ((visibility("default"))) void zend_ts_hash_merge_ex(TsHashTable *target, TsHashTable *source, copy_ctor_func_t pCopyConstructor, uint size, merge_checker_func_t pMergeSource, void *pParam);
__attribute__ ((visibility("default"))) int zend_ts_hash_sort(TsHashTable *ht, sort_func_t sort_func, compare_func_t compare_func, int renumber );
__attribute__ ((visibility("default"))) int zend_ts_hash_compare(TsHashTable *ht1, TsHashTable *ht2, compare_func_t compar, zend_bool ordered );
__attribute__ ((visibility("default"))) int zend_ts_hash_minmax(TsHashTable *ht, compare_func_t compar, int flag, void **pData );

__attribute__ ((visibility("default"))) int zend_ts_hash_num_elements(TsHashTable *ht);

__attribute__ ((visibility("default"))) int zend_ts_hash_rehash(TsHashTable *ht);

__attribute__ ((visibility("default"))) ulong zend_ts_hash_func(char *arKey, uint nKeyLength);








# 273 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend.h" 2
# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_llist.h" 1
# 25 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_llist.h"
typedef struct _zend_llist_element {
 struct _zend_llist_element *next;
 struct _zend_llist_element *prev;
 char data[1];
} zend_llist_element;

typedef void (*llist_dtor_func_t)(void *);
typedef int (*llist_compare_func_t)(const zend_llist_element **, const zend_llist_element ** );
typedef void (*llist_apply_with_args_func_t)(void *data, int num_args, va_list args );
typedef void (*llist_apply_with_arg_func_t)(void *data, void *arg );
typedef void (*llist_apply_func_t)(void * );

typedef struct _zend_llist {
 zend_llist_element *head;
 zend_llist_element *tail;
 size_t count;
 size_t size;
 llist_dtor_func_t dtor;
 unsigned char persistent;
 zend_llist_element *traverse_ptr;
} zend_llist;

typedef zend_llist_element* zend_llist_position;


__attribute__ ((visibility("default"))) void zend_llist_init(zend_llist *l, size_t size, llist_dtor_func_t dtor, unsigned char persistent);
__attribute__ ((visibility("default"))) void zend_llist_add_element(zend_llist *l, void *element);
__attribute__ ((visibility("default"))) void zend_llist_prepend_element(zend_llist *l, void *element);
__attribute__ ((visibility("default"))) void zend_llist_del_element(zend_llist *l, void *element, int (*compare)(void *element1, void *element2));
__attribute__ ((visibility("default"))) void zend_llist_destroy(zend_llist *l);
__attribute__ ((visibility("default"))) void zend_llist_clean(zend_llist *l);
__attribute__ ((visibility("default"))) void *zend_llist_remove_tail(zend_llist *l);
__attribute__ ((visibility("default"))) void zend_llist_copy(zend_llist *dst, zend_llist *src);
__attribute__ ((visibility("default"))) void zend_llist_apply(zend_llist *l, llist_apply_func_t func );
__attribute__ ((visibility("default"))) void zend_llist_apply_with_del(zend_llist *l, int (*func)(void *data));
__attribute__ ((visibility("default"))) void zend_llist_apply_with_argument(zend_llist *l, llist_apply_with_arg_func_t func, void *arg );
__attribute__ ((visibility("default"))) void zend_llist_apply_with_arguments(zend_llist *l, llist_apply_with_args_func_t func , int num_args, ...);
__attribute__ ((visibility("default"))) int zend_llist_count(zend_llist *l);
__attribute__ ((visibility("default"))) void zend_llist_sort(zend_llist *l, llist_compare_func_t comp_func );


__attribute__ ((visibility("default"))) void *zend_llist_get_first_ex(zend_llist *l, zend_llist_position *pos);
__attribute__ ((visibility("default"))) void *zend_llist_get_last_ex(zend_llist *l, zend_llist_position *pos);
__attribute__ ((visibility("default"))) void *zend_llist_get_next_ex(zend_llist *l, zend_llist_position *pos);
__attribute__ ((visibility("default"))) void *zend_llist_get_prev_ex(zend_llist *l, zend_llist_position *pos);







# 274 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend.h" 2





void zend_error_noreturn(int type, const char *format, ...) __attribute__ ((noreturn));







typedef struct _zval_struct zval;
typedef struct _zend_class_entry zend_class_entry;

typedef struct _zend_guard {
 zend_bool in_get;
 zend_bool in_set;
 zend_bool in_unset;
 zend_bool in_isset;
 zend_bool dummy;
} zend_guard;

typedef struct _zend_object {
 zend_class_entry *ce;
 HashTable *properties;
 zval **properties_table;
 HashTable *guards;
} zend_object;

# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_object_handlers.h" 1
# 25 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_object_handlers.h"
union _zend_function;
struct _zend_property_info;
struct _zend_literal;






typedef zval *(*zend_object_read_property_t)(zval *object, zval *member, int type, const struct _zend_literal *key );


typedef zval *(*zend_object_read_dimension_t)(zval *object, zval *offset, int type );
# 46 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_object_handlers.h"
typedef void (*zend_object_write_property_t)(zval *object, zval *member, zval *value, const struct _zend_literal *key );


typedef void (*zend_object_write_dimension_t)(zval *object, zval *offset, zval *value );



typedef zval **(*zend_object_get_property_ptr_ptr_t)(zval *object, zval *member, const struct _zend_literal *key );



typedef void (*zend_object_set_t)(zval **object, zval *value );




typedef zval* (*zend_object_get_t)(zval *object );







typedef int (*zend_object_has_property_t)(zval *object, zval *member, int has_set_exists, const struct _zend_literal *key );


typedef int (*zend_object_has_dimension_t)(zval *object, zval *member, int check_empty );


typedef void (*zend_object_unset_property_t)(zval *object, zval *member, const struct _zend_literal *key );


typedef void (*zend_object_unset_dimension_t)(zval *object, zval *offset );


typedef HashTable *(*zend_object_get_properties_t)(zval *object );

typedef HashTable *(*zend_object_get_debug_info_t)(zval *object, int *is_temp );





typedef int (*zend_object_call_method_t)(char *method, int ht, zval *return_value, zval **return_value_ptr, zval *this_ptr, int return_value_used );
typedef union _zend_function *(*zend_object_get_method_t)(zval **object_ptr, char *method, int method_len, const struct _zend_literal *key );
typedef union _zend_function *(*zend_object_get_constructor_t)(zval *object );


typedef void (*zend_object_add_ref_t)(zval *object );
typedef void (*zend_object_del_ref_t)(zval *object );
typedef void (*zend_object_delete_obj_t)(zval *object );
typedef zend_object_value (*zend_object_clone_obj_t)(zval *object );

typedef zend_class_entry *(*zend_object_get_class_entry_t)(const zval *object );
typedef int (*zend_object_get_class_name_t)(const zval *object, char **class_name, zend_uint *class_name_len, int parent );
typedef int (*zend_object_compare_t)(zval *object1, zval *object2 );



typedef int (*zend_object_cast_t)(zval *readobj, zval *retval, int type );



typedef int (*zend_object_count_elements_t)(zval *object, long *count );

typedef int (*zend_object_get_closure_t)(zval *obj, zend_class_entry **ce_ptr, union _zend_function **fptr_ptr, zval **zobj_ptr );

struct _zend_object_handlers {

 zend_object_add_ref_t add_ref;
 zend_object_del_ref_t del_ref;
 zend_object_clone_obj_t clone_obj;

 zend_object_read_property_t read_property;
 zend_object_write_property_t write_property;
 zend_object_read_dimension_t read_dimension;
 zend_object_write_dimension_t write_dimension;
 zend_object_get_property_ptr_ptr_t get_property_ptr_ptr;
 zend_object_get_t get;
 zend_object_set_t set;
 zend_object_has_property_t has_property;
 zend_object_unset_property_t unset_property;
 zend_object_has_dimension_t has_dimension;
 zend_object_unset_dimension_t unset_dimension;
 zend_object_get_properties_t get_properties;
 zend_object_get_method_t get_method;
 zend_object_call_method_t call_method;
 zend_object_get_constructor_t get_constructor;
 zend_object_get_class_entry_t get_class_entry;
 zend_object_get_class_name_t get_class_name;
 zend_object_compare_t compare_objects;
 zend_object_cast_t cast_object;
 zend_object_count_elements_t count_elements;
 zend_object_get_debug_info_t get_debug_info;
 zend_object_get_closure_t get_closure;
};

extern __attribute__ ((visibility("default"))) zend_object_handlers std_object_handlers;


__attribute__ ((visibility("default"))) union _zend_function *zend_std_get_static_method(zend_class_entry *ce, char *function_name_strval, int function_name_strlen, const struct _zend_literal *key );
__attribute__ ((visibility("default"))) zval **zend_std_get_static_property(zend_class_entry *ce, char *property_name, int property_name_len, zend_bool silent, const struct _zend_literal *key );
__attribute__ ((visibility("default"))) zend_bool zend_std_unset_static_property(zend_class_entry *ce, char *property_name, int property_name_len, const struct _zend_literal *key );
__attribute__ ((visibility("default"))) union _zend_function *zend_std_get_constructor(zval *object );
__attribute__ ((visibility("default"))) struct _zend_property_info *zend_get_property_info(zend_class_entry *ce, zval *member, int silent );
__attribute__ ((visibility("default"))) HashTable *zend_std_get_properties(zval *object );
__attribute__ ((visibility("default"))) HashTable *zend_std_get_debug_info(zval *object, int *is_temp );
__attribute__ ((visibility("default"))) int zend_std_cast_object_tostring(zval *readobj, zval *writeobj, int type );
__attribute__ ((visibility("default"))) void zend_std_write_property(zval *object, zval *member, zval *value, const struct _zend_literal *key );
__attribute__ ((visibility("default"))) void rebuild_object_properties(zend_object *zobj);





__attribute__ ((visibility("default"))) int zend_check_private(union _zend_function *fbc, zend_class_entry *ce, char *function_name_strval, int function_name_strlen );

__attribute__ ((visibility("default"))) int zend_check_protected(zend_class_entry *ce, zend_class_entry *scope);

__attribute__ ((visibility("default"))) int zend_check_property_access(zend_object *zobj, char *prop_info_name, int prop_info_name_len );

__attribute__ ((visibility("default"))) void zend_std_call_user_call(int ht, zval *return_value, zval **return_value_ptr, zval *this_ptr, int return_value_used );

# 306 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend.h" 2

typedef union _zvalue_value {
 long lval;
 double dval;
 struct {
  char *val;
  int len;
 } str;
 HashTable *ht;
 zend_object_value obj;
} zvalue_value;

struct _zval_struct {

 zvalue_value value;
 zend_uint refcount__gc;
 zend_uchar type;
 zend_uchar is_ref__gc;
};
# 378 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend.h"
static inline __attribute__((always_inline)) zend_uint zval_refcount_p(zval* pz) {
 return pz->refcount__gc;
}

static inline __attribute__((always_inline)) zend_uint zval_set_refcount_p(zval* pz, zend_uint rc) {
 return pz->refcount__gc = rc;
}

static inline __attribute__((always_inline)) zend_uint zval_addref_p(zval* pz) {
 return ++pz->refcount__gc;
}

static inline __attribute__((always_inline)) zend_uint zval_delref_p(zval* pz) {
 return --pz->refcount__gc;
}

static inline __attribute__((always_inline)) zend_bool zval_isref_p(zval* pz) {
 return pz->is_ref__gc;
}

static inline __attribute__((always_inline)) zend_bool zval_set_isref_p(zval* pz) {
 return pz->is_ref__gc = 1;
}

static inline __attribute__((always_inline)) zend_bool zval_unset_isref_p(zval* pz) {
 return pz->is_ref__gc = 0;
}

static inline __attribute__((always_inline)) zend_bool zval_set_isref_to_p(zval* pz, zend_bool isref) {
 return pz->is_ref__gc = isref;
}





union _zend_function;

# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_iterators.h" 1
# 29 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_iterators.h"
typedef struct _zend_object_iterator zend_object_iterator;

typedef struct _zend_object_iterator_funcs {

 void (*dtor)(zend_object_iterator *iter );


 int (*valid)(zend_object_iterator *iter );


 void (*get_current_data)(zend_object_iterator *iter, zval ***data );


 int (*get_current_key)(zend_object_iterator *iter, char **str_key, uint *str_key_len, ulong *int_key );


 void (*move_forward)(zend_object_iterator *iter );


 void (*rewind)(zend_object_iterator *iter );


 void (*invalidate_current)(zend_object_iterator *iter );
} zend_object_iterator_funcs;

struct _zend_object_iterator {
 void *data;
 zend_object_iterator_funcs *funcs;
 ulong index;
};

typedef struct _zend_class_iterator_funcs {
 zend_object_iterator_funcs *funcs;
 union _zend_function *zf_new_iterator;
 union _zend_function *zf_valid;
 union _zend_function *zf_current;
 union _zend_function *zf_key;
 union _zend_function *zf_next;
 union _zend_function *zf_rewind;
} zend_class_iterator_funcs;

enum zend_object_iterator_kind {
 ZEND_ITER_INVALID,
 ZEND_ITER_PLAIN_ARRAY,
 ZEND_ITER_PLAIN_OBJECT,
 ZEND_ITER_OBJECT
};



__attribute__ ((visibility("default"))) enum zend_object_iterator_kind zend_iterator_unwrap(zval *array_ptr, zend_object_iterator **iter );


__attribute__ ((visibility("default"))) zval *zend_iterator_wrap(zend_object_iterator *iter );

__attribute__ ((visibility("default"))) void zend_register_iterator_wrapper(void);

# 417 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend.h" 2

struct _zend_serialize_data;
struct _zend_unserialize_data;

typedef struct _zend_serialize_data zend_serialize_data;
typedef struct _zend_unserialize_data zend_unserialize_data;

struct _zend_trait_method_reference {
 char* method_name;
 unsigned int mname_len;

 zend_class_entry *ce;

 char* class_name;
 unsigned int cname_len;
};
typedef struct _zend_trait_method_reference zend_trait_method_reference;

struct _zend_trait_precedence {
 zend_trait_method_reference *trait_method;

 zend_class_entry** exclude_from_classes;

 union _zend_function* function;
};
typedef struct _zend_trait_precedence zend_trait_precedence;

struct _zend_trait_alias {
 zend_trait_method_reference *trait_method;




 char* alias;
 unsigned int alias_len;




 zend_uint modifiers;

 union _zend_function* function;
};
typedef struct _zend_trait_alias zend_trait_alias;

struct _zend_class_entry {
 char type;
 const char *name;
 zend_uint name_length;
 struct _zend_class_entry *parent;
 int refcount;
 zend_uint ce_flags;

 HashTable function_table;
 HashTable properties_info;
 zval **default_properties_table;
 zval **default_static_members_table;
 zval **static_members_table;
 HashTable constants_table;
 int default_properties_count;
 int default_static_members_count;

 union _zend_function *constructor;
 union _zend_function *destructor;
 union _zend_function *clone;
 union _zend_function *__get;
 union _zend_function *__set;
 union _zend_function *__unset;
 union _zend_function *__isset;
 union _zend_function *__call;
 union _zend_function *__callstatic;
 union _zend_function *__tostring;
 union _zend_function *serialize_func;
 union _zend_function *unserialize_func;

 zend_class_iterator_funcs iterator_funcs;


 zend_object_value (*create_object)(zend_class_entry *class_type );
 zend_object_iterator *(*get_iterator)(zend_class_entry *ce, zval *object, int by_ref );
 int (*interface_gets_implemented)(zend_class_entry *iface, zend_class_entry *class_type );
 union _zend_function *(*get_static_method)(zend_class_entry *ce, char* method, int method_len );


 int (*serialize)(zval *object, unsigned char **buffer, zend_uint *buf_len, zend_serialize_data *data );
 int (*unserialize)(zval **object, zend_class_entry *ce, const unsigned char *buf, zend_uint buf_len, zend_unserialize_data *data );

 zend_class_entry **interfaces;
 zend_uint num_interfaces;

 zend_class_entry **traits;
 zend_uint num_traits;
 zend_trait_alias **trait_aliases;
 zend_trait_precedence **trait_precedences;

 union {
  struct {
   char *filename;
   zend_uint line_start;
   zend_uint line_end;
   char *doc_comment;
   zend_uint doc_comment_len;
  } user;
  struct {
   const struct _zend_function_entry *builtin_functions;
   struct _zend_module_entry *module;
  } internal;
 } info;
};

# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_stream.h" 1
# 30 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_stream.h"
typedef size_t (*zend_stream_fsizer_t)(void* handle );
typedef size_t (*zend_stream_reader_t)(void* handle, char *buf, size_t len );
typedef void (*zend_stream_closer_t)(void* handle );



typedef enum {
 ZEND_HANDLE_FILENAME,
 ZEND_HANDLE_FD,
 ZEND_HANDLE_FP,
 ZEND_HANDLE_STREAM,
 ZEND_HANDLE_MAPPED
} zend_stream_type;

typedef struct _zend_mmap {
 size_t len;
 size_t pos;
 void *map;
 char *buf;
 void *old_handle;
 zend_stream_closer_t old_closer;
} zend_mmap;

typedef struct _zend_stream {
 void *handle;
 int isatty;
 zend_mmap mmap;
 zend_stream_reader_t reader;
 zend_stream_fsizer_t fsizer;
 zend_stream_closer_t closer;
} zend_stream;

typedef struct _zend_file_handle {
 zend_stream_type type;
 char *filename;
 char *opened_path;
 union {
  int fd;
  FILE *fp;
  zend_stream stream;
 } handle;
 zend_bool free_filename;
} zend_file_handle;


__attribute__ ((visibility("default"))) int zend_stream_open(const char *filename, zend_file_handle *handle );
__attribute__ ((visibility("default"))) int zend_stream_fixup(zend_file_handle *file_handle, char **buf, size_t *len );
__attribute__ ((visibility("default"))) void zend_file_handle_dtor(zend_file_handle *fh );
__attribute__ ((visibility("default"))) int zend_compare_file_handles(zend_file_handle *fh1, zend_file_handle *fh2);

# 528 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend.h" 2
typedef struct _zend_utility_functions {
 void (*error_function)(int type, const char *error_filename, const uint error_lineno, const char *format, va_list args) __attribute__ ((format(printf, 4, 0)));
 int (*printf_function)(const char *format, ...) __attribute__ ((format(printf, 1, 2)));
 int (*write_function)(const char *str, uint str_length);
 FILE *(*fopen_function)(const char *filename, char **opened_path );
 void (*message_handler)(long message, void *data );
 void (*block_interruptions)(void);
 void (*unblock_interruptions)(void);
 int (*get_configuration_directive)(const char *name, uint name_length, zval *contents);
 void (*ticks_function)(int ticks);
 void (*on_timeout)(int seconds );
 int (*stream_open_function)(const char *filename, zend_file_handle *handle );
 int (*vspprintf_function)(char **pbuf, size_t max_len, const char *format, va_list ap);
 char *(*getenv_function)(char *name, size_t name_len );
 char *(*resolve_path_function)(const char *filename, int filename_len );
} zend_utility_functions;

typedef struct _zend_utility_values {
 char *import_use_extension;
 uint import_use_extension_length;
 zend_bool html_errors;
} zend_utility_values;

typedef int (*zend_write_func_t)(const char *str, uint str_length);
# 594 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend.h"
int zend_startup(zend_utility_functions *utility_functions, char **extensions );
void zend_shutdown(void);
void zend_register_standard_ini_entries(void);
void zend_post_startup(void);
void zend_set_utility_values(zend_utility_values *utility_values);


__attribute__ ((visibility("default"))) void _zend_bailout(char *filename, uint lineno);

# 632 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend.h"

__attribute__ ((visibility("default"))) char *get_zend_version(void);
__attribute__ ((visibility("default"))) void zend_make_printable_zval(zval *expr, zval *expr_copy, int *use_copy);
__attribute__ ((visibility("default"))) int zend_print_zval(zval *expr, int indent);
__attribute__ ((visibility("default"))) int zend_print_zval_ex(zend_write_func_t write_func, zval *expr, int indent);
__attribute__ ((visibility("default"))) void zend_print_zval_r(zval *expr, int indent );
__attribute__ ((visibility("default"))) void zend_print_flat_zval_r(zval *expr );
__attribute__ ((visibility("default"))) void zend_print_zval_r_ex(zend_write_func_t write_func, zval *expr, int indent );
__attribute__ ((visibility("default"))) void zend_output_debug_string(zend_bool trigger_break, const char *format, ...) __attribute__ ((format(printf, 2, 3)));


void zend_activate(void);
void zend_deactivate(void);
void zend_call_destructors(void);
void zend_activate_modules(void);
void zend_deactivate_modules(void);
void zend_post_deactivate_modules(void);








__attribute__ ((visibility("default"))) void free_estring(char **str_p);

# 677 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend.h"

extern __attribute__ ((visibility("default"))) int (*zend_printf)(const char *format, ...) __attribute__ ((format(printf, 1, 2)));
extern __attribute__ ((visibility("default"))) zend_write_func_t zend_write;
extern __attribute__ ((visibility("default"))) FILE *(*zend_fopen)(const char *filename, char **opened_path );
extern __attribute__ ((visibility("default"))) void (*zend_block_interruptions)(void);
extern __attribute__ ((visibility("default"))) void (*zend_unblock_interruptions)(void);
extern __attribute__ ((visibility("default"))) void (*zend_ticks_function)(int ticks);
extern __attribute__ ((visibility("default"))) void (*zend_error_cb)(int type, const char *error_filename, const uint error_lineno, const char *format, va_list args) __attribute__ ((format(printf, 4, 0)));
extern void (*zend_on_timeout)(int seconds );
extern __attribute__ ((visibility("default"))) int (*zend_stream_open_function)(const char *filename, zend_file_handle *handle );
extern int (*zend_vspprintf)(char **pbuf, size_t max_len, const char *format, va_list ap);
extern __attribute__ ((visibility("default"))) char *(*zend_getenv)(char *name, size_t name_len );
extern __attribute__ ((visibility("default"))) char *(*zend_resolve_path)(const char *filename, int filename_len );

__attribute__ ((visibility("default"))) void zend_error(int type, const char *format, ...) __attribute__ ((format(printf, 2, 3)));

void zenderror(const char *error);



extern __attribute__ ((visibility("default"))) zend_class_entry *zend_standard_class_def;
extern __attribute__ ((visibility("default"))) zend_utility_values zend_uv;
extern __attribute__ ((visibility("default"))) zval zval_used_for_init;









__attribute__ ((visibility("default"))) void zend_message_dispatcher(long message, void *data );

__attribute__ ((visibility("default"))) int zend_get_configuration_directive(const char *name, uint name_length, zval *contents);

# 821 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend.h"
# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_gc.h" 1
# 81 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_gc.h"
typedef struct _gc_root_buffer {
 struct _gc_root_buffer *prev;
 struct _gc_root_buffer *next;
 zend_object_handle handle;
 union {
  zval *pz;
  zend_object_handlers *handlers;
 } u;
} gc_root_buffer;

typedef struct _zval_gc_info {
 zval z;
 union {
  gc_root_buffer *buffered;
  struct _zval_gc_info *next;
 } u;
} zval_gc_info;

typedef struct _zend_gc_globals {
 zend_bool gc_enabled;
 zend_bool gc_active;

 gc_root_buffer *buf;
 gc_root_buffer roots;
 gc_root_buffer *unused;
 gc_root_buffer *first_unused;
 gc_root_buffer *last_unused;

 zval_gc_info *zval_to_free;
 zval_gc_info *free_list;
 zval_gc_info *next_to_free;

 zend_uint gc_runs;
 zend_uint collected;
# 129 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_gc.h"
} zend_gc_globals;
# 138 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_gc.h"
extern __attribute__ ((visibility("default"))) zend_gc_globals gc_globals;



__attribute__ ((visibility("default"))) int gc_collect_cycles(void);
__attribute__ ((visibility("default"))) void gc_zval_possible_root(zval *zv );
__attribute__ ((visibility("default"))) void gc_zobj_possible_root(zval *zv );
__attribute__ ((visibility("default"))) void gc_remove_zval_from_buffer(zval *zv );
__attribute__ ((visibility("default"))) void gc_globals_ctor(void);
__attribute__ ((visibility("default"))) void gc_globals_dtor(void);
__attribute__ ((visibility("default"))) void gc_init(void);
__attribute__ ((visibility("default"))) void gc_reset(void);

# 180 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_gc.h"
static inline __attribute__((always_inline)) void gc_zval_check_possible_root(zval *z )
{
 if (z->type == 4 || z->type == 5) {
  gc_zval_possible_root(z );
 }
}

static inline __attribute__((always_inline)) void gc_remove_from_buffer(gc_root_buffer *root )
{
 root->next->prev = root->prev;
 root->prev->next = root->next;
 root->prev = (gc_globals.unused);
 (gc_globals.unused) = root;
 ;
}
# 822 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend.h" 2
# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_operators.h" 1
# 25 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_operators.h"
# 1 "/usr/include/errno.h" 1 3 4
# 32 "/usr/include/errno.h" 3 4




# 1 "/usr/include/bits/errno.h" 1 3 4
# 25 "/usr/include/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4



# 1 "/usr/include/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4



# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 5 "/usr/include/asm-generic/errno.h" 2 3 4
# 1 "/usr/include/asm/errno.h" 2 3 4
# 5 "/usr/include/linux/errno.h" 2 3 4
# 26 "/usr/include/bits/errno.h" 2 3 4
# 47 "/usr/include/bits/errno.h" 3 4
extern int *__errno_location (void) __attribute__ ((__nothrow__)) __attribute__ ((__const__));
# 37 "/usr/include/errno.h" 2 3 4
# 59 "/usr/include/errno.h" 3 4

# 26 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_operators.h" 2

# 1 "/usr/include/assert.h" 1 3 4
# 66 "/usr/include/assert.h" 3 4



extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));



# 28 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_operators.h" 2





# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_strtod.h" 1
# 25 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_strtod.h"
# 1 "Zend/zend.h" 1
# 26 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_strtod.h" 2


__attribute__ ((visibility("default"))) void zend_freedtoa(char *s);
__attribute__ ((visibility("default"))) char * zend_dtoa(double _d, int mode, int ndigits, int *decpt, int *sign, char **rve);
__attribute__ ((visibility("default"))) double zend_strtod(const char *s00, const char **se);
__attribute__ ((visibility("default"))) double zend_hex_strtod(const char *str, const char **endptr);
__attribute__ ((visibility("default"))) double zend_oct_strtod(const char *str, const char **endptr);
__attribute__ ((visibility("default"))) int zend_startup_strtod(void);
__attribute__ ((visibility("default"))) int zend_shutdown_strtod(void);

# 34 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_operators.h" 2






__attribute__ ((visibility("default"))) int add_function(zval *result, zval *op1, zval *op2 );
__attribute__ ((visibility("default"))) int sub_function(zval *result, zval *op1, zval *op2 );
__attribute__ ((visibility("default"))) int mul_function(zval *result, zval *op1, zval *op2 );
__attribute__ ((visibility("default"))) int div_function(zval *result, zval *op1, zval *op2 );
__attribute__ ((visibility("default"))) int mod_function(zval *result, zval *op1, zval *op2 );
__attribute__ ((visibility("default"))) int boolean_xor_function(zval *result, zval *op1, zval *op2 );
__attribute__ ((visibility("default"))) int boolean_not_function(zval *result, zval *op1 );
__attribute__ ((visibility("default"))) int bitwise_not_function(zval *result, zval *op1 );
__attribute__ ((visibility("default"))) int bitwise_or_function(zval *result, zval *op1, zval *op2 );
__attribute__ ((visibility("default"))) int bitwise_and_function(zval *result, zval *op1, zval *op2 );
__attribute__ ((visibility("default"))) int bitwise_xor_function(zval *result, zval *op1, zval *op2 );
__attribute__ ((visibility("default"))) int shift_left_function(zval *result, zval *op1, zval *op2 );
__attribute__ ((visibility("default"))) int shift_right_function(zval *result, zval *op1, zval *op2 );
__attribute__ ((visibility("default"))) int concat_function(zval *result, zval *op1, zval *op2 );

__attribute__ ((visibility("default"))) int is_equal_function(zval *result, zval *op1, zval *op2 );
__attribute__ ((visibility("default"))) int is_identical_function(zval *result, zval *op1, zval *op2 );
__attribute__ ((visibility("default"))) int is_not_identical_function(zval *result, zval *op1, zval *op2 );
__attribute__ ((visibility("default"))) int is_not_equal_function(zval *result, zval *op1, zval *op2 );
__attribute__ ((visibility("default"))) int is_smaller_function(zval *result, zval *op1, zval *op2 );
__attribute__ ((visibility("default"))) int is_smaller_or_equal_function(zval *result, zval *op1, zval *op2 );

__attribute__ ((visibility("default"))) zend_bool instanceof_function_ex(const zend_class_entry *instance_ce, const zend_class_entry *ce, zend_bool interfaces_only );
__attribute__ ((visibility("default"))) zend_bool instanceof_function(const zend_class_entry *instance_ce, const zend_class_entry *ce );





static inline __attribute__((always_inline)) long zend_dval_to_lval(double d)
{
 if (d > 2147483647L || d < (-2147483647L - 1L)) {
  return (long)(unsigned long)(zend_long64) d;
 }
 return (long) d;
}
# 102 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_operators.h"
static inline zend_uchar is_numeric_string(const char *str, int length, long *lval, double *dval, int allow_errors)
{
 const char *ptr;
 int base = 10, digits = 0, dp_or_e = 0;
 double local_dval;
 zend_uchar type;

 if (!length) {
  return 0;
 }



 while (*str == ' ' || *str == '\t' || *str == '\n' || *str == '\r' || *str == '\v' || *str == '\f') {
  str++;
  length--;
 }
 ptr = str;

 if (*ptr == '-' || *ptr == '+') {
  ptr++;
 }

 if (((*ptr) >= '0' && (*ptr) <= '9')) {


  if (length > 2 && *str == '0' && (str[1] == 'x' || str[1] == 'X')) {
   base = 16;
   ptr += 2;
  }


  while (*ptr == '0') {
   ptr++;
  }




  for (type = 1; !(digits >= 11 && (dval || allow_errors == 1)); digits++, ptr++) {
check_digits:
   if (((*ptr) >= '0' && (*ptr) <= '9') || (base == 16 && (((*ptr) >= 'A' && (*ptr) <= 'F') || ((*ptr) >= 'a' && (*ptr) <= 'f')))) {
    continue;
   } else if (base == 10) {
    if (*ptr == '.' && dp_or_e < 1) {
     goto process_double;
    } else if ((*ptr == 'e' || *ptr == 'E') && dp_or_e < 2) {
     const char *e = ptr + 1;

     if (*e == '-' || *e == '+') {
      ptr = e++;
     }
     if (((*e) >= '0' && (*e) <= '9')) {
      goto process_double;
     }
    }
   }

   break;
  }

  if (base == 10) {
   if (digits >= 11) {
    dp_or_e = -1;
    goto process_double;
   }
  } else if (!(digits < 4 * 2 || (digits == 4 * 2 && ptr[-digits] <= '7'))) {
   if (dval) {
    local_dval = zend_hex_strtod(str, &ptr);
   }
   type = 2;
  }
 } else if (*ptr == '.' && ((ptr[1]) >= '0' && (ptr[1]) <= '9')) {
process_double:
  type = 2;



  if (dval) {
   local_dval = zend_strtod(str, &ptr);
  } else if (allow_errors != 1 && dp_or_e != -1) {
   dp_or_e = (*ptr++ == '.') ? 1 : 2;
   goto check_digits;
  }
 } else {
  return 0;
 }

 if (ptr != str + length) {
  if (!allow_errors) {
   return 0;
  }
  if (allow_errors == -1) {
   zend_error((1<<3L), "A non well formed numeric value encountered");
  }
 }

 if (type == 1) {
  if (digits == 11 - 1) {
   int cmp = __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (&ptr[-digits]) && __builtin_constant_p (long_min_digits) && (__s1_len = strlen (&ptr[-digits]), __s2_len = strlen (long_min_digits), (!((size_t)(const void *)((&ptr[-digits]) + 1) - (size_t)(const void *)(&ptr[-digits]) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((long_min_digits) + 1) - (size_t)(const void *)(long_min_digits) == 1) || __s2_len >= 4)) ? __builtin_strcmp (&ptr[-digits], long_min_digits) : (__builtin_constant_p (&ptr[-digits]) && ((size_t)(const void *)((&ptr[-digits]) + 1) - (size_t)(const void *)(&ptr[-digits]) == 1) && (__s1_len = strlen (&ptr[-digits]), __s1_len < 4) ? (__builtin_constant_p (long_min_digits) && ((size_t)(const void *)((long_min_digits) + 1) - (size_t)(const void *)(long_min_digits) == 1) ? __builtin_strcmp (&ptr[-digits], long_min_digits) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (long_min_digits); register int __result = (((__const unsigned char *) (__const char *) (&ptr[-digits]))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (&ptr[-digits]))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (&ptr[-digits]))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (&ptr[-digits]))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (long_min_digits) && ((size_t)(const void *)((long_min_digits) + 1) - (size_t)(const void *)(long_min_digits) == 1) && (__s2_len = strlen (long_min_digits), __s2_len < 4) ? (__builtin_constant_p (&ptr[-digits]) && ((size_t)(const void *)((&ptr[-digits]) + 1) - (size_t)(const void *)(&ptr[-digits]) == 1) ? __builtin_strcmp (&ptr[-digits], long_min_digits) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (&ptr[-digits]); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (long_min_digits))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (long_min_digits))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (long_min_digits))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (long_min_digits))[3]); } } __result; }))) : __builtin_strcmp (&ptr[-digits], long_min_digits)))); });

   if (!(cmp < 0 || (cmp == 0 && *str == '-'))) {
    if (dval) {
     *dval = zend_strtod(str, ((void *)0));
    }

    return 2;
   }
  }

  if (lval) {
   *lval = strtol(str, ((void *)0), base);
  }

  return 1;
 } else {
  if (dval) {
   *dval = local_dval;
  }

  return 2;
 }
}

static inline char *
zend_memnstr(char *haystack, char *needle, int needle_len, char *end)
{
 char *p = haystack;
 char ne = needle[needle_len-1];

 if (needle_len == 1) {
  return (char *)memchr(p, *needle, (end-p));
 }

 if (needle_len > end-haystack) {
  return ((void *)0);
 }

 end -= needle_len;

 while (p <= end) {
  if ((p = (char *)memchr(p, *needle, (end-p+1))) && ne == p[needle_len-1]) {
   if (!memcmp(needle, p, needle_len-1)) {
    return p;
   }
  }

  if (p == ((void *)0)) {
   return ((void *)0);
  }

  p++;
 }

 return ((void *)0);
}

static inline const void *zend_memrchr(const void *s, int c, size_t n)
{
 register const unsigned char *e;

 if (n <= 0) {
  return ((void *)0);
 }

 for (e = (const unsigned char *)s + n - 1; e >= (const unsigned char *)s; e--) {
  if (*e == (const unsigned char)c) {
   return (const void *)e;
  }
 }

 return ((void *)0);
}


__attribute__ ((visibility("default"))) int increment_function(zval *op1);
__attribute__ ((visibility("default"))) int decrement_function(zval *op2);

__attribute__ ((visibility("default"))) void convert_scalar_to_number(zval *op );
__attribute__ ((visibility("default"))) void _convert_to_string(zval *op );
__attribute__ ((visibility("default"))) void convert_to_long(zval *op);
__attribute__ ((visibility("default"))) void convert_to_double(zval *op);
__attribute__ ((visibility("default"))) void convert_to_long_base(zval *op, int base);
__attribute__ ((visibility("default"))) void convert_to_null(zval *op);
__attribute__ ((visibility("default"))) void convert_to_boolean(zval *op);
__attribute__ ((visibility("default"))) void convert_to_array(zval *op);
__attribute__ ((visibility("default"))) void convert_to_object(zval *op);
__attribute__ ((visibility("default"))) void multi_convert_to_long_ex(int argc, ...);
__attribute__ ((visibility("default"))) void multi_convert_to_double_ex(int argc, ...);
__attribute__ ((visibility("default"))) void multi_convert_to_string_ex(int argc, ...);
__attribute__ ((visibility("default"))) int add_char_to_string(zval *result, const zval *op1, const zval *op2);
__attribute__ ((visibility("default"))) int add_string_to_string(zval *result, const zval *op1, const zval *op2);


__attribute__ ((visibility("default"))) double zend_string_to_double(const char *number, zend_uint length);

__attribute__ ((visibility("default"))) int zval_is_true(zval *op);
__attribute__ ((visibility("default"))) int compare_function(zval *result, zval *op1, zval *op2 );
__attribute__ ((visibility("default"))) int numeric_compare_function(zval *result, zval *op1, zval *op2 );
__attribute__ ((visibility("default"))) int string_compare_function(zval *result, zval *op1, zval *op2 );

__attribute__ ((visibility("default"))) int string_locale_compare_function(zval *result, zval *op1, zval *op2 );


__attribute__ ((visibility("default"))) void zend_str_tolower(char *str, unsigned int length);
__attribute__ ((visibility("default"))) char *zend_str_tolower_copy(char *dest, const char *source, unsigned int length);
__attribute__ ((visibility("default"))) char *zend_str_tolower_dup(const char *source, unsigned int length);

__attribute__ ((visibility("default"))) int zend_binary_zval_strcmp(zval *s1, zval *s2);
__attribute__ ((visibility("default"))) int zend_binary_zval_strncmp(zval *s1, zval *s2, zval *s3);
__attribute__ ((visibility("default"))) int zend_binary_zval_strcasecmp(zval *s1, zval *s2);
__attribute__ ((visibility("default"))) int zend_binary_zval_strncasecmp(zval *s1, zval *s2, zval *s3);
__attribute__ ((visibility("default"))) int zend_binary_strcmp(const char *s1, uint len1, const char *s2, uint len2);
__attribute__ ((visibility("default"))) int zend_binary_strncmp(const char *s1, uint len1, const char *s2, uint len2, uint length);
__attribute__ ((visibility("default"))) int zend_binary_strcasecmp(const char *s1, uint len1, const char *s2, uint len2);
__attribute__ ((visibility("default"))) int zend_binary_strncasecmp(const char *s1, uint len1, const char *s2, uint len2, uint length);

__attribute__ ((visibility("default"))) void zendi_smart_strcmp(zval *result, zval *s1, zval *s2);
__attribute__ ((visibility("default"))) void zend_compare_symbol_tables(zval *result, HashTable *ht1, HashTable *ht2 );
__attribute__ ((visibility("default"))) void zend_compare_arrays(zval *result, zval *a1, zval *a2 );
__attribute__ ((visibility("default"))) void zend_compare_objects(zval *result, zval *o1, zval *o2 );

__attribute__ ((visibility("default"))) int zend_atoi(const char *str, int str_len);
__attribute__ ((visibility("default"))) long zend_atol(const char *str, int str_len);

__attribute__ ((visibility("default"))) void zend_locale_sprintf_double(zval *op );

# 823 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend.h" 2
# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_variables.h" 1
# 26 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_variables.h"


__attribute__ ((visibility("default"))) void _zval_dtor_func(zval *zvalue );

static inline __attribute__((always_inline)) void _zval_dtor(zval *zvalue )
{
 if (zvalue->type <= 3) {
  return;
 }
 _zval_dtor_func(zvalue );
}

__attribute__ ((visibility("default"))) void _zval_copy_ctor_func(zval *zvalue );

static inline __attribute__((always_inline)) void _zval_copy_ctor(zval *zvalue )
{
 if (zvalue->type <= 3) {
  return;
 }
 _zval_copy_ctor_func(zvalue );
}

__attribute__ ((visibility("default"))) int zval_copy_static_var(zval **p , int num_args, va_list args, zend_hash_key *key);

__attribute__ ((visibility("default"))) int zend_print_variable(zval *var);
__attribute__ ((visibility("default"))) void _zval_ptr_dtor(zval **zval_ptr );
__attribute__ ((visibility("default"))) void _zval_internal_dtor(zval *zvalue );
__attribute__ ((visibility("default"))) void _zval_internal_ptr_dtor(zval **zvalue );
__attribute__ ((visibility("default"))) void _zval_dtor_wrapper(zval *zvalue);
# 78 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_variables.h"
__attribute__ ((visibility("default"))) void zval_add_ref(zval **p);


# 824 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend.h" 2

typedef enum {
 EH_NORMAL = 0,
 EH_SUPPRESS,
 EH_THROW
} zend_error_handling_t;

typedef struct {
 zend_error_handling_t handling;
 zend_class_entry *exception;
 zval *user_handler;
} zend_error_handling;

__attribute__ ((visibility("default"))) void zend_save_error_handling(zend_error_handling *current );
__attribute__ ((visibility("default"))) void zend_replace_error_handling(zend_error_handling_t error_handling, zend_class_entry *exception_class, zend_error_handling *current );
__attribute__ ((visibility("default"))) void zend_restore_error_handling(zend_error_handling *saved );
# 28 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_execute.c" 2
# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_compile.h" 1
# 52 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_compile.h"
typedef struct _zend_op_array zend_op_array;
typedef struct _zend_op zend_op;

typedef struct _zend_compiler_context {
 zend_uint opcodes_size;
 int vars_size;
 int literals_size;
 int current_brk_cont;
 int backpatch_count;
 HashTable *labels;
} zend_compiler_context;

typedef struct _zend_literal {
 zval constant;
 zend_ulong hash_value;
 zend_uint cache_slot;
} zend_literal;




typedef union _znode_op {
 zend_uint constant;
 zend_uint var;
 zend_uint num;
 zend_ulong hash;
 zend_uint opline_num;
 zend_op *jmp_addr;
 zval *zv;
 zend_literal *literal;
  void *ptr;
} znode_op;

typedef struct _znode {
 int op_type;
 union {
  znode_op op;
  zval constant;
  zend_op_array *op_array;
 } u;
 zend_uint EA;
} znode;

typedef struct _zend_execute_data zend_execute_data;




typedef int (*user_opcode_handler_t) (zend_execute_data *execute_data );
typedef int (__attribute__((fastcall)) *opcode_handler_t) (zend_execute_data *execute_data );

extern __attribute__ ((visibility("default"))) opcode_handler_t *zend_opcode_handlers;

struct _zend_op {
 opcode_handler_t handler;
 znode_op op1;
 znode_op op2;
 znode_op result;
 ulong extended_value;
 uint lineno;
 zend_uchar opcode;
 zend_uchar op1_type;
 zend_uchar op2_type;
 zend_uchar result_type;
};


typedef struct _zend_brk_cont_element {
 int start;
 int cont;
 int brk;
 int parent;
} zend_brk_cont_element;

typedef struct _zend_label {
 int brk_cont;
 zend_uint opline_num;
} zend_label;

typedef struct _zend_try_catch_element {
 zend_uint try_op;
 zend_uint catch_op;
} zend_try_catch_element;
# 201 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_compile.h"
char *zend_visibility_string(zend_uint fn_flags);


typedef struct _zend_property_info {
 zend_uint flags;
 char *name;
 int name_length;
 ulong h;
 int offset;
 char *doc_comment;
 int doc_comment_len;
 zend_class_entry *ce;
} zend_property_info;


typedef struct _zend_arg_info {
 const char *name;
 zend_uint name_len;
 const char *class_name;
 zend_uint class_name_len;
 zend_uchar type_hint;
 zend_bool allow_null;
 zend_bool pass_by_reference;
} zend_arg_info;





typedef struct _zend_internal_function_info {
 const char *_name;
 zend_uint _name_len;
 const char *_class_name;
 zend_uint required_num_args;
 zend_uchar _type_hint;
 zend_bool return_reference;
 zend_bool pass_rest_by_reference;
} zend_internal_function_info;

typedef struct _zend_compiled_variable {
 char *name;
 int name_len;
 ulong hash_value;
} zend_compiled_variable;

struct _zend_op_array {

 zend_uchar type;
 char *function_name;
 zend_class_entry *scope;
 zend_uint fn_flags;
 union _zend_function *prototype;
 zend_uint num_args;
 zend_uint required_num_args;
 zend_arg_info *arg_info;


 zend_uint *refcount;

 zend_op *opcodes;
 zend_uint last;

 zend_compiled_variable *vars;
 int last_var;

 zend_uint T;

 zend_brk_cont_element *brk_cont_array;
 int last_brk_cont;

 zend_try_catch_element *try_catch_array;
 int last_try_catch;


 HashTable *static_variables;

 zend_uint this_var;

 char *filename;
 zend_uint line_start;
 zend_uint line_end;
 char *doc_comment;
 zend_uint doc_comment_len;
 zend_uint early_binding;

 zend_literal *literals;
 int last_literal;

 void **run_time_cache;
 int last_cache_slot;

 void *reserved[4];
};





typedef struct _zend_internal_function {

 zend_uchar type;
 char * function_name;
 zend_class_entry *scope;
 zend_uint fn_flags;
 union _zend_function *prototype;
 zend_uint num_args;
 zend_uint required_num_args;
 zend_arg_info *arg_info;


 void (*handler)(int ht, zval *return_value, zval **return_value_ptr, zval *this_ptr, int return_value_used );
 struct _zend_module_entry *module;
} zend_internal_function;



typedef union _zend_function {
 zend_uchar type;

 struct {
  zend_uchar type;
  char *function_name;
  zend_class_entry *scope;
  zend_uint fn_flags;
  union _zend_function *prototype;
  zend_uint num_args;
  zend_uint required_num_args;
  zend_arg_info *arg_info;
 } common;

 zend_op_array op_array;
 zend_internal_function internal_function;
} zend_function;


typedef struct _zend_function_state {
 zend_function *function;
 void **arguments;
} zend_function_state;


typedef struct _zend_switch_entry {
 znode cond;
 int default_case;
 int control_var;
} zend_switch_entry;


typedef struct _list_llist_element {
 znode var;
 zend_llist dimensions;
 znode value;
} list_llist_element;

union _temp_variable;

struct _zend_execute_data {
 struct _zend_op *opline;
 zend_function_state function_state;
 zend_function *fbc;
 zend_class_entry *called_scope;
 zend_op_array *op_array;
 zval *object;
 union _temp_variable *Ts;
 zval ***CVs;
 HashTable *symbol_table;
 struct _zend_execute_data *prev_execute_data;
 zval *old_error_reporting;
 zend_bool nested;
 zval **original_return_value;
 zend_class_entry *current_scope;
 zend_class_entry *current_called_scope;
 zval *current_this;
 zval *current_object;
};
# 388 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_compile.h"
# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_globals.h" 1
# 26 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_globals.h"
# 1 "/usr/include/setjmp.h" 1 3 4
# 28 "/usr/include/setjmp.h" 3 4


# 1 "/usr/include/bits/setjmp.h" 1 3 4
# 29 "/usr/include/bits/setjmp.h" 3 4
typedef int __jmp_buf[6];
# 31 "/usr/include/setjmp.h" 2 3 4
# 1 "/usr/include/bits/sigset.h" 1 3 4
# 32 "/usr/include/setjmp.h" 2 3 4



struct __jmp_buf_tag
  {




    __jmp_buf __jmpbuf;
    int __mask_was_saved;
    __sigset_t __saved_mask;
  };




typedef struct __jmp_buf_tag jmp_buf[1];



extern int setjmp (jmp_buf __env) __attribute__ ((__nothrow__));






extern int __sigsetjmp (struct __jmp_buf_tag __env[1], int __savemask) __attribute__ ((__nothrow__));




extern int _setjmp (struct __jmp_buf_tag __env[1]) __attribute__ ((__nothrow__));
# 78 "/usr/include/setjmp.h" 3 4




extern void longjmp (struct __jmp_buf_tag __env[1], int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));







extern void _longjmp (struct __jmp_buf_tag __env[1], int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));







typedef struct __jmp_buf_tag sigjmp_buf[1];
# 110 "/usr/include/setjmp.h" 3 4
extern void siglongjmp (sigjmp_buf __env, int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));
# 120 "/usr/include/setjmp.h" 3 4

# 27 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_globals.h" 2

# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_globals_macros.h" 1
# 25 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_globals_macros.h"
typedef struct _zend_compiler_globals zend_compiler_globals;
typedef struct _zend_executor_globals zend_executor_globals;
typedef struct _zend_php_scanner_globals zend_php_scanner_globals;
typedef struct _zend_ini_scanner_globals zend_ini_scanner_globals;









extern __attribute__ ((visibility("default"))) struct _zend_compiler_globals compiler_globals;
int zendparse(void);
# 48 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_globals_macros.h"
extern __attribute__ ((visibility("default"))) zend_executor_globals executor_globals;
# 57 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_globals_macros.h"
extern __attribute__ ((visibility("default"))) zend_php_scanner_globals language_scanner_globals;
# 67 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_globals_macros.h"
extern __attribute__ ((visibility("default"))) zend_ini_scanner_globals ini_scanner_globals;



# 29 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_globals.h" 2

# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_stack.h" 1
# 25 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_stack.h"
typedef struct _zend_stack {
 int top, max;
 void **elements;
} zend_stack;





__attribute__ ((visibility("default"))) int zend_stack_init(zend_stack *stack);
__attribute__ ((visibility("default"))) int zend_stack_push(zend_stack *stack, const void *element, int size);
__attribute__ ((visibility("default"))) int zend_stack_top(const zend_stack *stack, void **element);
__attribute__ ((visibility("default"))) int zend_stack_del_top(zend_stack *stack);
__attribute__ ((visibility("default"))) int zend_stack_int_top(const zend_stack *stack);
__attribute__ ((visibility("default"))) int zend_stack_is_empty(const zend_stack *stack);
__attribute__ ((visibility("default"))) int zend_stack_destroy(zend_stack *stack);
__attribute__ ((visibility("default"))) void **zend_stack_base(const zend_stack *stack);
__attribute__ ((visibility("default"))) int zend_stack_count(const zend_stack *stack);
__attribute__ ((visibility("default"))) void zend_stack_apply(zend_stack *stack, int type, int (*apply_function)(void *element));
__attribute__ ((visibility("default"))) void zend_stack_apply_with_argument(zend_stack *stack, int type, int (*apply_function)(void *element, void *arg), void *arg);

# 31 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_globals.h" 2
# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_ptr_stack.h" 1
# 25 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_ptr_stack.h"
typedef struct _zend_ptr_stack {
 int top, max;
 void **elements;
 void **top_element;
 zend_bool persistent;
} zend_ptr_stack;





__attribute__ ((visibility("default"))) void zend_ptr_stack_init(zend_ptr_stack *stack);
__attribute__ ((visibility("default"))) void zend_ptr_stack_init_ex(zend_ptr_stack *stack, zend_bool persistent);
__attribute__ ((visibility("default"))) void zend_ptr_stack_n_push(zend_ptr_stack *stack, int count, ...);
__attribute__ ((visibility("default"))) void zend_ptr_stack_n_pop(zend_ptr_stack *stack, int count, ...);
__attribute__ ((visibility("default"))) void zend_ptr_stack_destroy(zend_ptr_stack *stack);
__attribute__ ((visibility("default"))) void zend_ptr_stack_apply(zend_ptr_stack *stack, void (*func)(void *));
__attribute__ ((visibility("default"))) void zend_ptr_stack_clean(zend_ptr_stack *stack, void (*func)(void *), zend_bool free_elements);
__attribute__ ((visibility("default"))) int zend_ptr_stack_num_elements(zend_ptr_stack *stack);

# 58 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_ptr_stack.h"
static inline __attribute__((always_inline)) void zend_ptr_stack_3_push(zend_ptr_stack *stack, void *a, void *b, void *c)
{


 if (stack->top+3 > stack->max) { do { stack->max += 64; } while (stack->top+3 > stack->max); stack->elements = (void **) ((stack->persistent)?__zend_realloc((stack->elements), ((sizeof(void *) * (stack->max)))):_erealloc(((stack->elements)), (((sizeof(void *) * (stack->max)))), 0 )); stack->top_element = stack->elements+stack->top; }

 stack->top += 3;
 *(stack->top_element++) = a;
 *(stack->top_element++) = b;
 *(stack->top_element++) = c;


}

static inline __attribute__((always_inline)) void zend_ptr_stack_2_push(zend_ptr_stack *stack, void *a, void *b)
{


 if (stack->top+2 > stack->max) { do { stack->max += 64; } while (stack->top+2 > stack->max); stack->elements = (void **) ((stack->persistent)?__zend_realloc((stack->elements), ((sizeof(void *) * (stack->max)))):_erealloc(((stack->elements)), (((sizeof(void *) * (stack->max)))), 0 )); stack->top_element = stack->elements+stack->top; }

 stack->top += 2;
 *(stack->top_element++) = a;
 *(stack->top_element++) = b;


}

static inline __attribute__((always_inline)) void zend_ptr_stack_3_pop(zend_ptr_stack *stack, void **a, void **b, void **c)
{
 *a = *(--stack->top_element);
 *b = *(--stack->top_element);
 *c = *(--stack->top_element);
 stack->top -= 3;
}

static inline __attribute__((always_inline)) void zend_ptr_stack_2_pop(zend_ptr_stack *stack, void **a, void **b)
{
 *a = *(--stack->top_element);
 *b = *(--stack->top_element);
 stack->top -= 2;
}

static inline __attribute__((always_inline)) void zend_ptr_stack_push(zend_ptr_stack *stack, void *ptr)
{
 if (stack->top+1 > stack->max) { do { stack->max += 64; } while (stack->top+1 > stack->max); stack->elements = (void **) ((stack->persistent)?__zend_realloc((stack->elements), ((sizeof(void *) * (stack->max)))):_erealloc(((stack->elements)), (((sizeof(void *) * (stack->max)))), 0 )); stack->top_element = stack->elements+stack->top; }

 stack->top++;
 *(stack->top_element++) = ptr;
}

static inline __attribute__((always_inline)) void *zend_ptr_stack_pop(zend_ptr_stack *stack)
{
 stack->top--;
 return *(--stack->top_element);
}
# 32 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_globals.h" 2


# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_objects.h" 1
# 27 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_objects.h"

__attribute__ ((visibility("default"))) void zend_object_std_init(zend_object *object, zend_class_entry *ce );
__attribute__ ((visibility("default"))) void zend_object_std_dtor(zend_object *object );
__attribute__ ((visibility("default"))) zend_object_value zend_objects_new(zend_object **object, zend_class_entry *class_type );
__attribute__ ((visibility("default"))) void zend_objects_destroy_object(zend_object *object, zend_object_handle handle );
__attribute__ ((visibility("default"))) zend_object *zend_objects_get_address(const zval *object );
__attribute__ ((visibility("default"))) void zend_objects_clone_members(zend_object *new_object, zend_object_value new_obj_val, zend_object *old_object, zend_object_handle handle );
__attribute__ ((visibility("default"))) zend_object_value zend_objects_clone_obj(zval *object );
__attribute__ ((visibility("default"))) void zend_objects_free_object_storage(zend_object *object );

# 35 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_globals.h" 2
# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_objects_API.h" 1
# 27 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_objects_API.h"
typedef void (*zend_objects_store_dtor_t)(void *object, zend_object_handle handle );
typedef void (*zend_objects_free_object_storage_t)(void *object );
typedef void (*zend_objects_store_clone_t)(void *object, void **object_clone );

typedef struct _zend_object_store_bucket {
 zend_bool destructor_called;
 zend_bool valid;
 union _store_bucket {
  struct _store_object {
   void *object;
   zend_objects_store_dtor_t dtor;
   zend_objects_free_object_storage_t free_storage;
   zend_objects_store_clone_t clone;
   const zend_object_handlers *handlers;
   zend_uint refcount;
   gc_root_buffer *buffered;
  } obj;
  struct {
   int next;
  } free_list;
 } bucket;
} zend_object_store_bucket;

typedef struct _zend_objects_store {
 zend_object_store_bucket *object_buckets;
 zend_uint top;
 zend_uint size;
 int free_list_head;
} zend_objects_store;



__attribute__ ((visibility("default"))) void zend_objects_store_init(zend_objects_store *objects, zend_uint init_size);
__attribute__ ((visibility("default"))) void zend_objects_store_call_destructors(zend_objects_store *objects );
__attribute__ ((visibility("default"))) void zend_objects_store_mark_destructed(zend_objects_store *objects );
__attribute__ ((visibility("default"))) void zend_objects_store_destroy(zend_objects_store *objects);


__attribute__ ((visibility("default"))) zend_object_handle zend_objects_store_put(void *object, zend_objects_store_dtor_t dtor, zend_objects_free_object_storage_t storage, zend_objects_store_clone_t clone );

__attribute__ ((visibility("default"))) void zend_objects_store_add_ref(zval *object );
__attribute__ ((visibility("default"))) void zend_objects_store_del_ref(zval *object );
__attribute__ ((visibility("default"))) void zend_objects_store_add_ref_by_handle(zend_object_handle handle );
__attribute__ ((visibility("default"))) void zend_objects_store_del_ref_by_handle_ex(zend_object_handle handle, const zend_object_handlers *handlers );
static inline __attribute__((always_inline)) void zend_objects_store_del_ref_by_handle(zend_object_handle handle ) {
 zend_objects_store_del_ref_by_handle_ex(handle, ((void *)0) );
}
__attribute__ ((visibility("default"))) zend_uint zend_objects_store_get_refcount(zval *object );
__attribute__ ((visibility("default"))) zend_object_value zend_objects_store_clone_obj(zval *object );
__attribute__ ((visibility("default"))) void *zend_object_store_get_object(const zval *object );
__attribute__ ((visibility("default"))) void *zend_object_store_get_object_by_handle(zend_object_handle handle );

__attribute__ ((visibility("default"))) void zend_object_store_set_object(zval *zobject, void *object );
__attribute__ ((visibility("default"))) void zend_object_store_ctor_failed(zval *zobject );

__attribute__ ((visibility("default"))) void zend_objects_store_free_object_storage(zend_objects_store *objects );



__attribute__ ((visibility("default"))) zval *zend_object_create_proxy(zval *object, zval *member );

__attribute__ ((visibility("default"))) zend_object_handlers *zend_get_std_object_handlers(void);

# 36 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_globals.h" 2
# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_modules.h" 1
# 26 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_modules.h"
# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_compile.h" 1
# 27 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_modules.h" 2
# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_build.h" 1
# 28 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_modules.h" 2
# 69 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_modules.h"
struct _zend_ini_entry;
typedef struct _zend_module_entry zend_module_entry;
typedef struct _zend_module_dep zend_module_dep;

struct _zend_module_entry {
 unsigned short size;
 unsigned int zend_api;
 unsigned char zend_debug;
 unsigned char zts;
 const struct _zend_ini_entry *ini_entry;
 const struct _zend_module_dep *deps;
 const char *name;
 const struct _zend_function_entry *functions;
 int (*module_startup_func)(int type, int module_number );
 int (*module_shutdown_func)(int type, int module_number );
 int (*request_startup_func)(int type, int module_number );
 int (*request_shutdown_func)(int type, int module_number );
 void (*info_func)(zend_module_entry *zend_module );
 const char *version;
 size_t globals_size;



 void* globals_ptr;

 void (*globals_ctor)(void *global );
 void (*globals_dtor)(void *global );
 int (*post_deactivate_func)(void);
 int module_started;
 unsigned char type;
 void *handle;
 int module_number;
 const char *build_id;
};
# 116 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_modules.h"
struct _zend_module_dep {
 const char *name;
 const char *rel;
 const char *version;
 unsigned char type;
};

extern __attribute__ ((visibility("default"))) HashTable module_registry;

void module_destructor(zend_module_entry *module);
int module_registry_cleanup(zend_module_entry *module );
int module_registry_request_startup(zend_module_entry *module );
int module_registry_unload_temp(const zend_module_entry *module );
# 37 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_globals.h" 2
# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_float.h" 1
# 27 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_float.h"
extern __attribute__ ((visibility("default"))) void zend_init_fpu(void);
extern __attribute__ ((visibility("default"))) void zend_shutdown_fpu(void);
extern __attribute__ ((visibility("default"))) void zend_ensure_fpu_mode(void);
# 212 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_float.h"
# 1 "/usr/include/fpu_control.h" 1 3 4
# 89 "/usr/include/fpu_control.h" 3 4
typedef unsigned int fpu_control_t __attribute__ ((__mode__ (__HI__)));
# 100 "/usr/include/fpu_control.h" 3 4
extern fpu_control_t __fpu_control;
# 213 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_float.h" 2
# 38 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_globals.h" 2
# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_multibyte.h" 1
# 25 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_multibyte.h"
typedef struct _zend_encoding zend_encoding;

typedef size_t (*zend_encoding_filter)(unsigned char **str, size_t *str_length, const unsigned char *buf, size_t length );

typedef const zend_encoding* (*zend_encoding_fetcher)(const char *encoding_name );
typedef const char* (*zend_encoding_name_getter)(const zend_encoding *encoding);
typedef int (*zend_encoding_lexer_compatibility_checker)(const zend_encoding *encoding);
typedef const zend_encoding *(*zend_encoding_detector)(const unsigned char *string, size_t length, const zend_encoding **list, size_t list_size );
typedef size_t (*zend_encoding_converter)(unsigned char **to, size_t *to_length, const unsigned char *from, size_t from_length, const zend_encoding *encoding_to, const zend_encoding *encoding_from );
typedef int (*zend_encoding_list_parser)(const char *encoding_list, size_t encoding_list_len, const zend_encoding ***return_list, size_t *return_size, int persistent );
typedef const zend_encoding *(*zend_encoding_internal_encoding_getter)(void);
typedef int (*zend_encoding_internal_encoding_setter)(const zend_encoding *encoding );

typedef struct _zend_multibyte_functions {
    const char *provider_name;
    zend_encoding_fetcher encoding_fetcher;
    zend_encoding_name_getter encoding_name_getter;
    zend_encoding_lexer_compatibility_checker lexer_compatibility_checker;
    zend_encoding_detector encoding_detector;
    zend_encoding_converter encoding_converter;
    zend_encoding_list_parser encoding_list_parser;
    zend_encoding_internal_encoding_getter internal_encoding_getter;
    zend_encoding_internal_encoding_setter internal_encoding_setter;
} zend_multibyte_functions;






__attribute__ ((visibility("default"))) extern const zend_encoding *zend_multibyte_encoding_utf32be;
__attribute__ ((visibility("default"))) extern const zend_encoding *zend_multibyte_encoding_utf32le;
__attribute__ ((visibility("default"))) extern const zend_encoding *zend_multibyte_encoding_utf16be;
__attribute__ ((visibility("default"))) extern const zend_encoding *zend_multibyte_encoding_utf16le;
__attribute__ ((visibility("default"))) extern const zend_encoding *zend_multibyte_encoding_utf8;


__attribute__ ((visibility("default"))) int zend_multibyte_set_functions(const zend_multibyte_functions *functions );
__attribute__ ((visibility("default"))) const zend_multibyte_functions *zend_multibyte_get_functions(void);

__attribute__ ((visibility("default"))) const zend_encoding *zend_multibyte_fetch_encoding(const char *name );
__attribute__ ((visibility("default"))) const char *zend_multibyte_get_encoding_name(const zend_encoding *encoding);
__attribute__ ((visibility("default"))) int zend_multibyte_check_lexer_compatibility(const zend_encoding *encoding);
__attribute__ ((visibility("default"))) const zend_encoding *zend_multibyte_encoding_detector(const unsigned char *string, size_t length, const zend_encoding **list, size_t list_size );
__attribute__ ((visibility("default"))) size_t zend_multibyte_encoding_converter(unsigned char **to, size_t *to_length, const unsigned char *from, size_t from_length, const zend_encoding *encoding_to, const zend_encoding *encoding_from );
__attribute__ ((visibility("default"))) int zend_multibyte_parse_encoding_list(const char *encoding_list, size_t encoding_list_len, const zend_encoding ***return_list, size_t *return_size, int persistent );

__attribute__ ((visibility("default"))) const zend_encoding *zend_multibyte_get_internal_encoding(void);
__attribute__ ((visibility("default"))) const zend_encoding *zend_multibyte_get_script_encoding(void);
__attribute__ ((visibility("default"))) int zend_multibyte_set_script_encoding(const zend_encoding **encoding_list, size_t encoding_list_size );
__attribute__ ((visibility("default"))) int zend_multibyte_set_internal_encoding(const zend_encoding *encoding );
__attribute__ ((visibility("default"))) int zend_multibyte_set_script_encoding_by_string(const char *new_value, size_t new_value_length );

__attribute__ ((visibility("default"))) size_t zend_multibyte_script_encoding_filter(unsigned char **to, size_t *to_length, const unsigned char *from, size_t from_length );
__attribute__ ((visibility("default"))) size_t zend_multibyte_internal_encoding_filter(unsigned char **to, size_t *to_length, const unsigned char *from, size_t from_length );


# 39 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_globals.h" 2
# 64 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_globals.h"
typedef struct _zend_declarables {
 zval ticks;
} zend_declarables;

typedef struct _zend_vm_stack *zend_vm_stack;
typedef struct _zend_ini_entry zend_ini_entry;


struct _zend_compiler_globals {
 zend_stack bp_stack;
 zend_stack switch_cond_stack;
 zend_stack foreach_copy_stack;
 zend_stack object_stack;
 zend_stack declare_stack;

 zend_class_entry *active_class_entry;


 zend_llist list_llist;
 zend_llist dimension_llist;
 zend_stack list_stack;

 zend_stack function_call_stack;

 char *compiled_filename;

 int zend_lineno;

 char *heredoc;
 int heredoc_len;

 zend_op_array *active_op_array;

 HashTable *function_table;
 HashTable *class_table;

 HashTable filenames_table;

 HashTable *auto_globals;

 zend_bool in_compilation;
 zend_bool short_tags;
 zend_bool asp_tags;

 zend_declarables declarables;

 zend_bool unclean_shutdown;

 zend_bool ini_parser_unbuffered_errors;

 zend_llist open_files;

 long catch_begin;

 struct _zend_ini_parser_param *ini_parser_param;

 int interactive;

 zend_uint start_lineno;
 zend_bool increment_lineno;

 znode implementing_class;

 zend_uint access_type;

 char *doc_comment;
 zend_uint doc_comment_len;

 zend_uint compiler_options;

 zval *current_namespace;
 HashTable *current_import;
 zend_bool in_namespace;
 zend_bool has_bracketed_namespaces;

 zend_compiler_context context;
 zend_stack context_stack;


 char *interned_strings_start;
 char *interned_strings_end;
 char *interned_strings_top;
 char *interned_strings_snapshot_top;

 HashTable interned_strings;

 const zend_encoding **script_encoding_list;
 size_t script_encoding_list_size;
 zend_bool multibyte;
 zend_bool detect_unicode;
 zend_bool encoding_declared;





};


struct _zend_executor_globals {
 zval **return_value_ptr_ptr;

 zval uninitialized_zval;
 zval *uninitialized_zval_ptr;

 zval error_zval;
 zval *error_zval_ptr;

 zend_ptr_stack arg_types_stack;


 HashTable *symtable_cache[32];
 HashTable **symtable_cache_limit;
 HashTable **symtable_cache_ptr;

 zend_op **opline_ptr;

 HashTable *active_symbol_table;
 HashTable symbol_table;

 HashTable included_files;

 jmp_buf *bailout;

 int error_reporting;
 int orig_error_reporting;
 int exit_status;

 zend_op_array *active_op_array;

 HashTable *function_table;
 HashTable *class_table;
 HashTable *zend_constants;

 zend_class_entry *scope;
 zend_class_entry *called_scope;

 zval *This;

 long precision;

 int ticks_count;

 zend_bool in_execution;
 HashTable *in_autoload;
 zend_function *autoload_func;
 zend_bool full_tables_cleanup;


 zend_bool no_extensions;






 HashTable regular_list;
 HashTable persistent_list;

 zend_vm_stack argument_stack;

 int user_error_handler_error_reporting;
 zval *user_error_handler;
 zval *user_exception_handler;
 zend_stack user_error_handlers_error_reporting;
 zend_ptr_stack user_error_handlers;
 zend_ptr_stack user_exception_handlers;

 zend_error_handling_t error_handling;
 zend_class_entry *exception_class;


 int timeout_seconds;

 int lambda_count;

 HashTable *ini_directives;
 HashTable *modified_ini_directives;
 zend_ini_entry *error_reporting_ini_entry;

 zend_objects_store objects_store;
 zval *exception, *prev_exception;
 zend_op *opline_before_exception;
 zend_op exception_op[3];

 struct _zend_execute_data *current_execute_data;

 struct _zend_module_entry *current_module;

 zend_property_info std_property_info;

 zend_bool active;

 zend_op *start_op;

 void *saved_fpu_cw_ptr;

 fpu_control_t saved_fpu_cw;


 void *reserved[4];
};

struct _zend_ini_scanner_globals {
 zend_file_handle *yy_in;
 zend_file_handle *yy_out;

 unsigned int yy_leng;
 unsigned char *yy_start;
 unsigned char *yy_text;
 unsigned char *yy_cursor;
 unsigned char *yy_marker;
 unsigned char *yy_limit;
 int yy_state;
 zend_stack state_stack;

 char *filename;
 int lineno;


 int scanner_mode;
};

struct _zend_php_scanner_globals {
 zend_file_handle *yy_in;
 zend_file_handle *yy_out;

 unsigned int yy_leng;
 unsigned char *yy_start;
 unsigned char *yy_text;
 unsigned char *yy_cursor;
 unsigned char *yy_marker;
 unsigned char *yy_limit;
 int yy_state;
 zend_stack state_stack;


 unsigned char *script_org;
 size_t script_org_size;


 unsigned char *script_filtered;
 size_t script_filtered_size;


 zend_encoding_filter input_filter;
 zend_encoding_filter output_filter;
 const zend_encoding *script_encoding;
};
# 389 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_compile.h" 2



void init_compiler(void);
void shutdown_compiler(void);
void zend_init_compiler_data_structures(void);
void zend_init_compiler_context(void);

extern __attribute__ ((visibility("default"))) zend_op_array *(*zend_compile_file)(zend_file_handle *file_handle, int type );
extern __attribute__ ((visibility("default"))) zend_op_array *(*zend_compile_string)(zval *source_string, char *filename );

__attribute__ ((visibility("default"))) int lex_scan(zval *zendlval );
void startup_scanner(void);
void shutdown_scanner(void);

__attribute__ ((visibility("default"))) char *zend_set_compiled_filename(const char *new_compiled_filename );
__attribute__ ((visibility("default"))) void zend_restore_compiled_filename(char *original_compiled_filename );
__attribute__ ((visibility("default"))) char *zend_get_compiled_filename(void);
__attribute__ ((visibility("default"))) int zend_get_compiled_lineno(void);
__attribute__ ((visibility("default"))) size_t zend_get_scanned_file_offset(void);

void zend_resolve_non_class_name(znode *element_name, zend_bool check_namespace );
void zend_resolve_class_name(znode *class_name, ulong *fetch_type, int check_ns_name );
__attribute__ ((visibility("default"))) char* zend_get_compiled_variable_name(const zend_op_array *op_array, zend_uint var, int* name_len);
# 421 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_compile.h"
void zend_do_binary_op(zend_uchar op, znode *result, const znode *op1, const znode *op2 );
void zend_do_unary_op(zend_uchar op, znode *result, const znode *op1 );
void zend_do_binary_assign_op(zend_uchar op, znode *result, const znode *op1, const znode *op2 );
void zend_do_assign(znode *result, znode *variable, znode *value );
void zend_do_assign_ref(znode *result, const znode *lvar, const znode *rvar );
void fetch_simple_variable(znode *result, znode *varname, int bp );
void fetch_simple_variable_ex(znode *result, znode *varname, int bp, zend_uchar op );
void zend_do_indirect_references(znode *result, const znode *num_references, znode *variable );
void zend_do_fetch_static_variable(znode *varname, const znode *static_assignment, int fetch_type );
void zend_do_fetch_global_variable(znode *varname, const znode *static_assignment, int fetch_type );

void fetch_array_begin(znode *result, znode *varname, znode *first_dim );
void fetch_array_dim(znode *result, const znode *parent, const znode *dim );
void fetch_string_offset(znode *result, const znode *parent, const znode *offset );
void zend_do_fetch_static_member(znode *result, znode *class_znode );
void zend_do_print(znode *result, const znode *arg );
void zend_do_echo(const znode *arg );
typedef int (*unary_op_type)(zval *, zval * );
typedef int (*binary_op_type)(zval *, zval *, zval * );
__attribute__ ((visibility("default"))) unary_op_type get_unary_op(int opcode);
__attribute__ ((visibility("default"))) binary_op_type get_binary_op(int opcode);

void zend_do_while_cond(const znode *expr, znode *close_bracket_token );
void zend_do_while_end(const znode *while_token, const znode *close_bracket_token );
void zend_do_do_while_begin(void);
void zend_do_do_while_end(const znode *do_token, const znode *expr_open_bracket, const znode *expr );


void zend_do_if_cond(const znode *cond, znode *closing_bracket_token );
void zend_do_if_after_statement(const znode *closing_bracket_token, unsigned char initialize );
void zend_do_if_end(void);

void zend_do_for_cond(const znode *expr, znode *second_semicolon_token );
void zend_do_for_before_statement(const znode *cond_start, const znode *second_semicolon_token );
void zend_do_for_end(const znode *second_semicolon_token );

void zend_do_pre_incdec(znode *result, const znode *op1, zend_uchar op );
void zend_do_post_incdec(znode *result, const znode *op1, zend_uchar op );

void zend_do_begin_variable_parse(void);
void zend_do_end_variable_parse(znode *variable, int type, int arg_offset );

void zend_check_writable_variable(const znode *variable);

void zend_do_free(znode *op1 );

void zend_do_add_string(znode *result, const znode *op1, znode *op2 );
void zend_do_add_variable(znode *result, const znode *op1, const znode *op2 );

int zend_do_verify_access_types(const znode *current_access_type, const znode *new_modifier);
void zend_do_begin_function_declaration(znode *function_token, znode *function_name, int is_method, int return_reference, znode *fn_flags_znode );
void zend_do_end_function_declaration(const znode *function_token );
void zend_do_receive_arg(zend_uchar op, znode *varname, const znode *offset, const znode *initialization, znode *class_type, zend_bool pass_by_reference );
int zend_do_begin_function_call(znode *function_name, zend_bool check_namespace );
void zend_do_begin_method_call(znode *left_bracket );
void zend_do_clone(znode *result, const znode *expr );
void zend_do_begin_dynamic_function_call(znode *function_name, int prefix_len );
void zend_do_fetch_class(znode *result, znode *class_name );
void zend_do_build_full_name(znode *result, znode *prefix, znode *name, int is_class_member );
int zend_do_begin_class_member_function_call(znode *class_name, znode *method_name );
void zend_do_end_function_call(znode *function_name, znode *result, const znode *argument_list, int is_method, int is_dynamic_fcall );
void zend_do_return(znode *expr, int do_end_vparse );
void zend_do_handle_exception(void);

void zend_do_begin_lambda_function_declaration(znode *result, znode *function_token, int return_reference, int is_static );
void zend_do_fetch_lexical_variable(znode *varname, zend_bool is_ref );

void zend_do_try(znode *try_token );
void zend_do_begin_catch(znode *try_token, znode *catch_class, znode *catch_var, znode *first_catch );
void zend_do_end_catch(const znode *try_token );
void zend_do_throw(const znode *expr );

__attribute__ ((visibility("default"))) int do_bind_function(const zend_op_array *op_array, zend_op *opline, HashTable *function_table, zend_bool compile_time);
__attribute__ ((visibility("default"))) zend_class_entry *do_bind_class(const zend_op_array *op_array, const zend_op *opline, HashTable *class_table, zend_bool compile_time );
__attribute__ ((visibility("default"))) zend_class_entry *do_bind_inherited_class(const zend_op_array *op_array, const zend_op *opline, HashTable *class_table, zend_class_entry *parent_ce, zend_bool compile_time );
__attribute__ ((visibility("default"))) void zend_do_inherit_interfaces(zend_class_entry *ce, const zend_class_entry *iface );
__attribute__ ((visibility("default"))) void zend_do_implement_interface(zend_class_entry *ce, zend_class_entry *iface );
void zend_do_implements_interface(znode *interface_znode );


void zend_add_trait_precedence(znode *precedence_znode );
void zend_add_trait_alias(znode *alias_znode );


void zend_do_implements_trait(znode *interface_znode );
__attribute__ ((visibility("default"))) void zend_do_implement_trait(zend_class_entry *ce, zend_class_entry *trait );
__attribute__ ((visibility("default"))) void zend_do_bind_traits(zend_class_entry *ce );
void zend_prepare_trait_precedence(znode *result, znode *method_reference, znode *trait_list );
void zend_prepare_reference(znode *result, znode *class_name, znode *method_name );
void zend_prepare_trait_alias(znode *result, znode *method_reference, znode *modifiers, znode *alias );

void init_trait_alias_list(znode* result, const znode* trait_alias );
void add_trait_alias(znode* result, const znode* trait_alias );
void init_trait_alias(znode* result, const znode* method_name, const znode* alias, const znode* modifiers );

__attribute__ ((visibility("default"))) void zend_do_inheritance(zend_class_entry *ce, zend_class_entry *parent_ce );
void zend_do_early_binding(void);
__attribute__ ((visibility("default"))) void zend_do_delayed_early_binding(const zend_op_array *op_array );

void zend_do_pass_param(znode *param, zend_uchar op, int offset );


void zend_do_boolean_or_begin(znode *expr1, znode *op_token );
void zend_do_boolean_or_end(znode *result, const znode *expr1, const znode *expr2, znode *op_token );
void zend_do_boolean_and_begin(znode *expr1, znode *op_token );
void zend_do_boolean_and_end(znode *result, const znode *expr1, const znode *expr2, const znode *op_token );

void zend_do_brk_cont(zend_uchar op, const znode *expr );

void zend_do_switch_cond(const znode *cond );
void zend_do_switch_end(const znode *case_list );
void zend_do_case_before_statement(const znode *case_list, znode *case_token, const znode *case_expr );
void zend_do_case_after_statement(znode *result, const znode *case_token );
void zend_do_default_before_statement(const znode *case_list, znode *default_token );

void zend_do_begin_class_declaration(const znode *class_token, znode *class_name, const znode *parent_class_name );
void zend_do_end_class_declaration(const znode *class_token, const znode *parent_token );
void zend_do_declare_property(const znode *var_name, const znode *value, zend_uint access_type );
void zend_do_declare_class_constant(znode *var_name, const znode *value );

void zend_do_fetch_property(znode *result, znode *object, const znode *property );

void zend_do_halt_compiler_register(void);

void zend_do_push_object(const znode *object );
void zend_do_pop_object(znode *object );


void zend_do_begin_new_object(znode *new_token, znode *class_type );
void zend_do_end_new_object(znode *result, const znode *new_token, const znode *argument_list );

void zend_do_fetch_constant(znode *result, znode *constant_container, znode *constant_name, int mode, zend_bool check_namespace );

void zend_do_shell_exec(znode *result, const znode *cmd );

void zend_do_init_array(znode *result, const znode *expr, const znode *offset, zend_bool is_ref );
void zend_do_add_array_element(znode *result, const znode *expr, const znode *offset, zend_bool is_ref );
void zend_do_add_static_array_element(znode *result, znode *offset, const znode *expr);
void zend_do_list_init(void);
void zend_do_list_end(znode *result, znode *expr );
void zend_do_add_list_element(const znode *element );
void zend_do_new_list_begin(void);
void zend_do_new_list_end(void);


void zend_init_list(void *result, void *item );
void zend_add_to_list(void *result, void *item );


void zend_do_cast(znode *result, const znode *expr, int type );
void zend_do_include_or_eval(int type, znode *result, const znode *op1 );

void zend_do_unset(const znode *variable );
void zend_do_isset_or_isempty(int type, znode *result, znode *variable );

void zend_do_instanceof(znode *result, const znode *expr, const znode *class_znode, int type );

void zend_do_foreach_begin(znode *foreach_token, znode *open_brackets_token, znode *array, znode *as_token, int variable );
void zend_do_foreach_cont(znode *foreach_token, const znode *open_brackets_token, const znode *as_token, znode *value, znode *key );
void zend_do_foreach_end(const znode *foreach_token, const znode *as_token );

void zend_do_declare_begin(void);
void zend_do_declare_stmt(znode *var, znode *val );
void zend_do_declare_end(const znode *declare_token );

void zend_do_exit(znode *result, const znode *message );

void zend_do_begin_silence(znode *strudel_token );
void zend_do_end_silence(const znode *strudel_token );

void zend_do_jmp_set(const znode *value, znode *jmp_token, znode *colon_token );
void zend_do_jmp_set_else(znode *result, const znode *false_value, const znode *jmp_token, const znode *colon_token );

void zend_do_begin_qm_op(const znode *cond, znode *qm_token );
void zend_do_qm_true(const znode *true_value, znode *qm_token, znode *colon_token );
void zend_do_qm_false(znode *result, const znode *false_value, const znode *qm_token, const znode *colon_token );

void zend_do_extended_info(void);
void zend_do_extended_fcall_begin(void);
void zend_do_extended_fcall_end(void);

void zend_do_ticks(void);

void zend_do_abstract_method(const znode *function_name, znode *modifiers, const znode *body );

void zend_do_declare_constant(znode *name, znode *value );
void zend_do_build_namespace_name(znode *result, znode *prefix, znode *name );
void zend_do_begin_namespace(const znode *name, zend_bool with_brackets );
void zend_do_end_namespace(void);
void zend_verify_namespace(void);
void zend_do_use(znode *name, znode *new_name, int is_global );
void zend_do_end_compilation(void);

void zend_do_label(znode *label );
void zend_do_goto(const znode *label );
void zend_resolve_goto_label(zend_op_array *op_array, zend_op *opline, int pass2 );
void zend_release_labels(void);

__attribute__ ((visibility("default"))) void function_add_ref(zend_function *function);






__attribute__ ((visibility("default"))) zend_op_array *compile_file(zend_file_handle *file_handle, int type );
__attribute__ ((visibility("default"))) zend_op_array *compile_string(zval *source_string, char *filename );
__attribute__ ((visibility("default"))) zend_op_array *compile_filename(int type, zval *filename );
__attribute__ ((visibility("default"))) int zend_execute_scripts(int type , zval **retval, int file_count, ...);
__attribute__ ((visibility("default"))) int open_file_for_scanning(zend_file_handle *file_handle );
__attribute__ ((visibility("default"))) void init_op_array(zend_op_array *op_array, zend_uchar type, int initial_ops_size );
__attribute__ ((visibility("default"))) void destroy_op_array(zend_op_array *op_array );
__attribute__ ((visibility("default"))) void zend_destroy_file_handle(zend_file_handle *file_handle );
__attribute__ ((visibility("default"))) int zend_cleanup_class_data(zend_class_entry **pce );
__attribute__ ((visibility("default"))) int zend_cleanup_user_class_data(zend_class_entry **pce );
__attribute__ ((visibility("default"))) void zend_cleanup_internal_class_data(zend_class_entry *ce );
__attribute__ ((visibility("default"))) void zend_cleanup_internal_classes(void);
__attribute__ ((visibility("default"))) int zend_cleanup_function_data(zend_function *function );
__attribute__ ((visibility("default"))) int zend_cleanup_function_data_full(zend_function *function );

__attribute__ ((visibility("default"))) void destroy_zend_function(zend_function *function );
__attribute__ ((visibility("default"))) void zend_function_dtor(zend_function *function);
__attribute__ ((visibility("default"))) void destroy_zend_class(zend_class_entry **pce);
void zend_class_add_ref(zend_class_entry **ce);

__attribute__ ((visibility("default"))) void zend_mangle_property_name(char **dest, int *dest_length, const char *src1, int src1_length, const char *src2, int src2_length, int internal);
__attribute__ ((visibility("default"))) int zend_unmangle_property_name(char *mangled_property, int mangled_property_len, char **class_name, char **prop_name);




zend_op *get_next_op(zend_op_array *op_array );
void init_op(zend_op *op );
int get_next_op_number(zend_op_array *op_array);
int print_class(zend_class_entry *class_entry );
void print_op_array(zend_op_array *op_array, int optimizations);
__attribute__ ((visibility("default"))) int pass_two(zend_op_array *op_array );
zend_brk_cont_element *get_next_brk_cont_element(zend_op_array *op_array);
void zend_do_first_catch(znode *open_parentheses );
void zend_initialize_try_catch_element(const znode *try_token );
void zend_do_mark_last_catch(const znode *first_catch, const znode *last_additional_catch );
__attribute__ ((visibility("default"))) zend_bool zend_is_compiling(void);
__attribute__ ((visibility("default"))) char *zend_make_compiled_string_description(const char *name );
__attribute__ ((visibility("default"))) void zend_initialize_class_data(zend_class_entry *ce, zend_bool nullify_handlers );
int zend_get_class_fetch_type(const char *class_name, uint class_name_len);

typedef zend_bool (*zend_auto_global_callback)(char *name, uint name_len );
typedef struct _zend_auto_global {
 char *name;
 uint name_len;
 zend_auto_global_callback auto_global_callback;
 zend_bool jit;
 zend_bool armed;
} zend_auto_global;

__attribute__ ((visibility("default"))) int zend_register_auto_global(const char *name, uint name_len, zend_bool jit, zend_auto_global_callback auto_global_callback );
__attribute__ ((visibility("default"))) void zend_activate_auto_globals(void);
__attribute__ ((visibility("default"))) zend_bool zend_is_auto_global(const char *name, uint name_len );
__attribute__ ((visibility("default"))) size_t zend_dirname(char *path, size_t len);

int zendlex(znode *zendlval );

int zend_add_literal(zend_op_array *op_array, const zval *zv );



# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_vm_opcodes.h" 1
# 688 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_compile.h" 2
# 810 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_compile.h"

# 29 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_execute.c" 2
# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_execute.h" 1
# 30 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_execute.h"
typedef union _temp_variable {
 zval tmp_var;
 struct {
  zval **ptr_ptr;
  zval *ptr;
  zend_bool fcall_returned_reference;
 } var;
 struct {
  zval **ptr_ptr;
  zval *str;
  zend_uint offset;
 } str_offset;
 struct {
  zval **ptr_ptr;
  zval *ptr;
  HashPointer fe_pos;
 } fe;
 zend_class_entry *class_entry;
} temp_variable;



__attribute__ ((visibility("default"))) extern void (*zend_execute)(zend_op_array *op_array );
__attribute__ ((visibility("default"))) extern void (*zend_execute_internal)(zend_execute_data *execute_data_ptr, int return_value_used );

void init_executor(void);
void shutdown_executor(void);
void shutdown_destructors(void);
__attribute__ ((visibility("default"))) void execute(zend_op_array *op_array );
__attribute__ ((visibility("default"))) void execute_internal(zend_execute_data *execute_data_ptr, int return_value_used );
__attribute__ ((visibility("default"))) int zend_is_true(zval *op);

static inline __attribute__((always_inline)) void safe_free_zval_ptr_rel(zval *p )
{
 ;

 if (p!=(executor_globals.uninitialized_zval_ptr)) {
  do { if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)p)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(p ); }; _efree((p) ); } while (0);
 }
}
__attribute__ ((visibility("default"))) int zend_lookup_class(const char *name, int name_length, zend_class_entry ***ce );
__attribute__ ((visibility("default"))) int zend_lookup_class_ex(const char *name, int name_length, const zend_literal *key, int use_autoload, zend_class_entry ***ce );
__attribute__ ((visibility("default"))) int zend_eval_string(char *str, zval *retval_ptr, char *string_name );
__attribute__ ((visibility("default"))) int zend_eval_stringl(char *str, int str_len, zval *retval_ptr, char *string_name );
__attribute__ ((visibility("default"))) int zend_eval_string_ex(char *str, zval *retval_ptr, char *string_name, int handle_exceptions );
__attribute__ ((visibility("default"))) int zend_eval_stringl_ex(char *str, int str_len, zval *retval_ptr, char *string_name, int handle_exceptions );

__attribute__ ((visibility("default"))) char * zend_verify_arg_class_kind(const zend_arg_info *cur_arg_info, ulong fetch_type, const char **class_name, zend_class_entry **pce );
__attribute__ ((visibility("default"))) int zend_verify_arg_error(int error_type, const zend_function *zf, zend_uint arg_num, const char *need_msg, const char *need_kind, const char *given_msg, char *given_kind );

static inline __attribute__((always_inline)) void i_zval_ptr_dtor(zval *zval_ptr )
{
 if (!zval_delref_p(zval_ptr)) {
  ;

  if (zval_ptr != &(executor_globals.uninitialized_zval)) {
   if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)zval_ptr)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(zval_ptr ); };
   _zval_dtor((zval_ptr) );
   _efree((zval_ptr) );
  }
 } else {
  ;

  if (zval_refcount_p(zval_ptr) == 1) {
   zval_unset_isref_p(zval_ptr);
  }

  gc_zval_check_possible_root((zval_ptr) );
 }
}

static inline __attribute__((always_inline)) int i_zend_is_true(zval *op)
{
 int result;

 switch ((*op).type) {
  case 0:
   result = 0;
   break;
  case 1:
  case 3:
  case 7:
   result = ((*op).value.lval?1:0);
   break;
  case 2:
   result = ((*op).value.dval ? 1 : 0);
   break;
  case 6:
   if ((*op).value.str.len == 0
    || ((*op).value.str.len==1 && (*op).value.str.val[0]=='0')) {
    result = 0;
   } else {
    result = 1;
   }
   break;
  case 4:
   result = (zend_hash_num_elements((*op).value.ht)?1:0);
   break;
  case 5:
   if(((*op).type == 5 && (((*op)).value.obj.handlers->get_class_entry != ((void *)0)))) {
    ;

    if ((*op).value.obj.handlers->cast_object) {
     zval tmp;
     if ((*op).value.obj.handlers->cast_object(op, &tmp, 3 ) == 0) {
      result = (tmp).value.lval;
      break;
     }
    } else if ((*op).value.obj.handlers->get) {
     zval *tmp = (*op).value.obj.handlers->get(op );
     if((*tmp).type != 5) {

      convert_to_boolean(tmp);
      result = (*tmp).value.lval;
      _zval_ptr_dtor((&tmp) );
      break;
     }
    }
   }
   result = 1;
   break;
  default:
   result = 0;
   break;
 }
 return result;
}

__attribute__ ((visibility("default"))) int zval_update_constant(zval **pp, void *arg );
__attribute__ ((visibility("default"))) int zval_update_constant_inline_change(zval **pp, void *arg );
__attribute__ ((visibility("default"))) int zval_update_constant_no_inline_change(zval **pp, void *arg );
__attribute__ ((visibility("default"))) int zval_update_constant_ex(zval **pp, void *arg, zend_class_entry *scope );




struct _zend_vm_stack {
 void **top;
 void **end;
 zend_vm_stack prev;
};
# 183 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_execute.h"
static inline __attribute__((always_inline)) zend_vm_stack zend_vm_stack_new_page(int count) {
 zend_vm_stack page = (zend_vm_stack)_emalloc(((((sizeof(*page)) + 4 - 1) & ~(4 -1)) + sizeof(void*) * count) );

 page->top = ((void**)(((char*)(page)) + (((sizeof(struct _zend_vm_stack)) + 4 - 1) & ~(4 -1))));
 page->end = page->top + count;
 page->prev = ((void *)0);
 return page;
}

static inline __attribute__((always_inline)) void zend_vm_stack_init(void)
{
 (executor_globals.argument_stack) = zend_vm_stack_new_page(((16 * 1024) - 16));
}

static inline __attribute__((always_inline)) void zend_vm_stack_destroy(void)
{
 zend_vm_stack stack = (executor_globals.argument_stack);

 while (stack != ((void *)0)) {
  zend_vm_stack p = stack->prev;
  _efree((stack) );
  stack = p;
 }
}

static inline __attribute__((always_inline)) void zend_vm_stack_extend(int count )
{
 zend_vm_stack p = zend_vm_stack_new_page(count >= ((16 * 1024) - 16) ? count : ((16 * 1024) - 16));
 p->prev = (executor_globals.argument_stack);
 (executor_globals.argument_stack) = p;
}

static inline __attribute__((always_inline)) void **zend_vm_stack_top(void)
{
 return (executor_globals.argument_stack)->top;
}

static inline __attribute__((always_inline)) void zend_vm_stack_push(void *ptr )
{
 do { if (__builtin_expect((1) > (executor_globals.argument_stack)->end - (executor_globals.argument_stack)->top, 0)) { zend_vm_stack_extend((1) ); } } while (0);
 *((executor_globals.argument_stack)->top++) = ptr;
}

static inline __attribute__((always_inline)) void zend_vm_stack_push_nocheck(void *ptr )
{
 *((executor_globals.argument_stack)->top++) = ptr;
}

static inline __attribute__((always_inline)) void *zend_vm_stack_pop(void)
{
 void *el = *(--(executor_globals.argument_stack)->top);

 if (__builtin_expect((executor_globals.argument_stack)->top == ((void**)(((char*)((executor_globals.argument_stack))) + (((sizeof(struct _zend_vm_stack)) + 4 - 1) & ~(4 -1)))), 0)) {
  zend_vm_stack p = (executor_globals.argument_stack);
  (executor_globals.argument_stack) = p->prev;
  _efree((p) );
  }
 return el;
}

static inline __attribute__((always_inline)) void *zend_vm_stack_alloc(size_t size )
{
 void *ret;

 size = (size + (sizeof(void*) - 1)) / sizeof(void*);


 if (4 > sizeof(void*)) {
  int extra = (4 - ((zend_uintptr_t)(executor_globals.argument_stack)->top & (4 - 1))) / sizeof(void*);

  if (__builtin_expect(size + extra + (((sizeof(void*)) + 4 - 1) & ~(4 -1)) / sizeof(void*) > (zend_uintptr_t)((executor_globals.argument_stack)->end - (executor_globals.argument_stack)->top), 0)
                                                                          ) {
   zend_vm_stack_extend(size );
  } else {
   void **old_top = (executor_globals.argument_stack)->top;

   (executor_globals.argument_stack)->top += extra;

   *(executor_globals.argument_stack)->top = (void*)old_top;
   (executor_globals.argument_stack)->top += (((sizeof(void*)) + 4 - 1) & ~(4 -1)) / sizeof(void*);
  }
 } else {
  do { if (__builtin_expect(((int)size) > (executor_globals.argument_stack)->end - (executor_globals.argument_stack)->top, 0)) { zend_vm_stack_extend(((int)size) ); } } while (0);
 }
 ret = (void*)(executor_globals.argument_stack)->top;
 (executor_globals.argument_stack)->top += size;
 return ret;
}

static inline __attribute__((always_inline)) void zend_vm_stack_free_int(void *ptr )
{
 if (__builtin_expect(((void**)(((char*)((executor_globals.argument_stack))) + (((sizeof(struct _zend_vm_stack)) + 4 - 1) & ~(4 -1)))) == (void**)ptr, 0)) {
  zend_vm_stack p = (executor_globals.argument_stack);

  (executor_globals.argument_stack) = p->prev;
  _efree((p) );
 } else {
  (executor_globals.argument_stack)->top = (void**)ptr;
 }
}

static inline __attribute__((always_inline)) void zend_vm_stack_free(void *ptr )
{
 if (__builtin_expect(((void**)(((char*)((executor_globals.argument_stack))) + (((sizeof(struct _zend_vm_stack)) + 4 - 1) & ~(4 -1)))) == (void**)ptr, 0)) {
  zend_vm_stack p = (executor_globals.argument_stack);

  (executor_globals.argument_stack) = p->prev;
  _efree((p) );
 } else {

  if (4 > sizeof(void*)) {
   ptr = (void*)(((char*)ptr) - (((sizeof(void*)) + 4 - 1) & ~(4 -1)));
   (executor_globals.argument_stack)->top = *(void***)ptr;
  } else {
   (executor_globals.argument_stack)->top = (void**)ptr;
  }
 }
}

static inline __attribute__((always_inline)) void** zend_vm_stack_push_args(int count )
{

 if (__builtin_expect((executor_globals.argument_stack)->top - ((void**)(((char*)((executor_globals.argument_stack))) + (((sizeof(struct _zend_vm_stack)) + 4 - 1) & ~(4 -1)))) < count, 0) ||
  __builtin_expect((executor_globals.argument_stack)->top == (executor_globals.argument_stack)->end, 0)) {
  zend_vm_stack p = (executor_globals.argument_stack);

  zend_vm_stack_extend(count + 1 );

  (executor_globals.argument_stack)->top += count;
  *((executor_globals.argument_stack)->top) = (void*)(zend_uintptr_t)count;
  while (count-- > 0) {
   void *data = *(--p->top);

   if (__builtin_expect(p->top == ((void**)(((char*)(p)) + (((sizeof(struct _zend_vm_stack)) + 4 - 1) & ~(4 -1)))), 0)) {
    zend_vm_stack r = p;

    (executor_globals.argument_stack)->prev = p->prev;
    p = p->prev;
    _efree((r) );
   }
   *(((void**)(((char*)((executor_globals.argument_stack))) + (((sizeof(struct _zend_vm_stack)) + 4 - 1) & ~(4 -1)))) + count) = data;
  }
  return (executor_globals.argument_stack)->top++;
 }
 *((executor_globals.argument_stack)->top) = (void*)(zend_uintptr_t)count;
 return (executor_globals.argument_stack)->top++;
}

static inline __attribute__((always_inline)) void zend_vm_stack_clear_multiple(void)
{
 void **p = (executor_globals.argument_stack)->top - 1;
 int delete_count = (int)(zend_uintptr_t) *p;

 while (--delete_count>=0) {
  zval *q = *(zval **)(--p);
  *p = ((void *)0);
  i_zval_ptr_dtor(q );
 }
 zend_vm_stack_free_int(p );
}

static inline __attribute__((always_inline)) zval** zend_vm_stack_get_arg(int requested_arg )
{
 void **p = (executor_globals.current_execute_data)->prev_execute_data->function_state.arguments;
 int arg_count = (int)(zend_uintptr_t) *p;

 if (__builtin_expect(requested_arg > arg_count, 0)) {
  return ((void *)0);
 }
 return (zval**)p - arg_count + requested_arg - 1;
}

static inline __attribute__((always_inline)) void zend_arg_types_stack_2_pop(zend_ptr_stack *stack, zval **object, zend_function **fbc)
{
 void *a, *b;

 zend_ptr_stack_2_pop(stack, &a, &b);

 *object = (zval *) a;
 *fbc = (zend_function *) b;
}

static inline __attribute__((always_inline)) void zend_arg_types_stack_3_pop(zend_ptr_stack *stack, zend_class_entry **called_scope, zval **object, zend_function **fbc)
{
 void *a, *b, *c;

 zend_ptr_stack_3_pop(stack, &a, &b, &c);

 *called_scope = (zend_class_entry *) a;
 *object = (zval *) b;
 *fbc = (zend_function *) c;
}

void execute_new_code(void);



__attribute__ ((visibility("default"))) char *get_active_class_name(char **space );
__attribute__ ((visibility("default"))) char *get_active_function_name(void);
__attribute__ ((visibility("default"))) char *zend_get_executed_filename(void);
__attribute__ ((visibility("default"))) uint zend_get_executed_lineno(void);
__attribute__ ((visibility("default"))) zend_bool zend_is_executing(void);

__attribute__ ((visibility("default"))) void zend_set_timeout(long seconds, int reset_signals);
__attribute__ ((visibility("default"))) void zend_unset_timeout(void);
__attribute__ ((visibility("default"))) void zend_timeout(int dummy);
__attribute__ ((visibility("default"))) zend_class_entry *zend_fetch_class(const char *class_name, uint class_name_len, int fetch_type );
__attribute__ ((visibility("default"))) zend_class_entry *zend_fetch_class_by_name(const char *class_name, uint class_name_len, const zend_literal *key, int fetch_type );
void zend_verify_abstract_class(zend_class_entry *ce );
# 410 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_execute.h"
__attribute__ ((visibility("default"))) zval** zend_get_compiled_variable_value(const zend_execute_data *execute_data_ptr, zend_uint var);
# 420 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_execute.h"
__attribute__ ((visibility("default"))) int zend_set_user_opcode_handler(zend_uchar opcode, user_opcode_handler_t handler);
__attribute__ ((visibility("default"))) user_opcode_handler_t zend_get_user_opcode_handler(zend_uchar opcode);


typedef struct _zend_free_op {
 zval* var;

} zend_free_op;

__attribute__ ((visibility("default"))) zval *zend_get_zval_ptr(int op_type, const znode_op *node, const temp_variable *Ts, zend_free_op *should_free, int type );
__attribute__ ((visibility("default"))) zval **zend_get_zval_ptr_ptr(int op_type, const znode_op *node, const temp_variable *Ts, zend_free_op *should_free, int type );

__attribute__ ((visibility("default"))) int zend_do_fcall(zend_execute_data *execute_data );
# 451 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_execute.h"

# 30 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_execute.c" 2
# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_API.h" 1
# 27 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_API.h"
# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_list.h" 1
# 28 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_list.h"





typedef struct _zend_rsrc_list_entry {
 void *ptr;
 int type;
 int refcount;
} zend_rsrc_list_entry;

typedef void (*rsrc_dtor_func_t)(zend_rsrc_list_entry *rsrc );


typedef struct _zend_rsrc_list_dtors_entry {

 void (*list_dtor)(void *);
 void (*plist_dtor)(void *);


 rsrc_dtor_func_t list_dtor_ex;
 rsrc_dtor_func_t plist_dtor_ex;

 const char *type_name;

 int module_number;
 int resource_id;
 unsigned char type;
} zend_rsrc_list_dtors_entry;



__attribute__ ((visibility("default"))) int zend_register_list_destructors(void (*ld)(void *), void (*pld)(void *), int module_number);
__attribute__ ((visibility("default"))) int zend_register_list_destructors_ex(rsrc_dtor_func_t ld, rsrc_dtor_func_t pld, const char *type_name, int module_number);

void list_entry_destructor(void *ptr);
void plist_entry_destructor(void *ptr);

void zend_clean_module_rsrc_dtors(int module_number );
int zend_init_rsrc_list(void);
int zend_init_rsrc_plist(void);
void zend_destroy_rsrc_list(HashTable *ht );
int zend_init_rsrc_list_dtors(void);
void zend_destroy_rsrc_list_dtors(void);

__attribute__ ((visibility("default"))) int zend_list_insert(void *ptr, int type );
__attribute__ ((visibility("default"))) int _zend_list_addref(int id );
__attribute__ ((visibility("default"))) int _zend_list_delete(int id );
__attribute__ ((visibility("default"))) void *_zend_list_find(int id, int *type );





__attribute__ ((visibility("default"))) int zend_register_resource(zval *rsrc_result, void *rsrc_pointer, int rsrc_type );
__attribute__ ((visibility("default"))) void *zend_fetch_resource(zval **passed_id , int default_id, const char *resource_type_name, int *found_resource_type, int num_resource_types, ...);

__attribute__ ((visibility("default"))) const char *zend_rsrc_list_get_rsrc_type(int resource );
__attribute__ ((visibility("default"))) int zend_fetch_list_dtor_id(char *type_name);

extern __attribute__ ((visibility("default"))) int le_index_ptr;
# 116 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_list.h"

# 28 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_API.h" 2







typedef struct _zend_function_entry {
 const char *fname;
 void (*handler)(int ht, zval *return_value, zval **return_value_ptr, zval *this_ptr, int return_value_used );
 const struct _zend_arg_info *arg_info;
 zend_uint num_args;
 zend_uint flags;
} zend_function_entry;

typedef struct _zend_fcall_info {
 size_t size;
 HashTable *function_table;
 zval *function_name;
 HashTable *symbol_table;
 zval **retval_ptr_ptr;
 zend_uint param_count;
 zval ***params;
 zval *object_ptr;
 zend_bool no_separation;
} zend_fcall_info;

typedef struct _zend_fcall_info_cache {
 zend_bool initialized;
 zend_function *function_handler;
 zend_class_entry *calling_scope;
 zend_class_entry *called_scope;
 zval *object_ptr;
} zend_fcall_info_cache;
# 226 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_API.h"
int zend_next_free_module(void);


__attribute__ ((visibility("default"))) int zend_get_parameters(int ht, int param_count, ...);
__attribute__ ((visibility("default"))) int _zend_get_parameters_array(int ht, int param_count, zval **argument_array );
__attribute__ ((visibility("default"))) __attribute__((deprecated)) int zend_get_parameters_ex(int param_count, ...);
__attribute__ ((visibility("default"))) int _zend_get_parameters_array_ex(int param_count, zval ***argument_array );


__attribute__ ((visibility("default"))) int zend_copy_parameters_array(int param_count, zval *argument_array );
# 247 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_API.h"
__attribute__ ((visibility("default"))) int zend_parse_parameters(int num_args , const char *type_spec, ...);
__attribute__ ((visibility("default"))) int zend_parse_parameters_ex(int flags, int num_args , const char *type_spec, ...);
__attribute__ ((visibility("default"))) char *zend_zval_type_name(const zval *arg);

__attribute__ ((visibility("default"))) int zend_parse_method_parameters(int num_args , zval *this_ptr, const char *type_spec, ...);
__attribute__ ((visibility("default"))) int zend_parse_method_parameters_ex(int flags, int num_args , zval *this_ptr, const char *type_spec, ...);



__attribute__ ((visibility("default"))) int zend_register_functions(zend_class_entry *scope, const zend_function_entry *functions, HashTable *function_table, int type );
__attribute__ ((visibility("default"))) void zend_unregister_functions(const zend_function_entry *functions, int count, HashTable *function_table );
__attribute__ ((visibility("default"))) int zend_startup_module(zend_module_entry *module_entry);
__attribute__ ((visibility("default"))) zend_module_entry* zend_register_internal_module(zend_module_entry *module_entry );
__attribute__ ((visibility("default"))) zend_module_entry* zend_register_module_ex(zend_module_entry *module );
__attribute__ ((visibility("default"))) int zend_startup_module_ex(zend_module_entry *module );
__attribute__ ((visibility("default"))) int zend_startup_modules(void);
__attribute__ ((visibility("default"))) void zend_collect_module_handlers(void);
__attribute__ ((visibility("default"))) void zend_destroy_modules(void);
__attribute__ ((visibility("default"))) void zend_check_magic_method_implementation(const zend_class_entry *ce, const zend_function *fptr, int error_type );

__attribute__ ((visibility("default"))) zend_class_entry *zend_register_internal_class(zend_class_entry *class_entry );
__attribute__ ((visibility("default"))) zend_class_entry *zend_register_internal_class_ex(zend_class_entry *class_entry, zend_class_entry *parent_ce, char *parent_name );
__attribute__ ((visibility("default"))) zend_class_entry *zend_register_internal_interface(zend_class_entry *orig_class_entry );
__attribute__ ((visibility("default"))) void zend_class_implements(zend_class_entry *class_entry , int num_interfaces, ...);

__attribute__ ((visibility("default"))) int zend_register_class_alias_ex(const char *name, int name_len, zend_class_entry *ce );






__attribute__ ((visibility("default"))) int zend_disable_function(char *function_name, uint function_name_length );
__attribute__ ((visibility("default"))) int zend_disable_class(char *class_name, uint class_name_length );

__attribute__ ((visibility("default"))) void zend_wrong_param_count(void);
# 291 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_API.h"
__attribute__ ((visibility("default"))) zend_bool zend_is_callable_ex(zval *callable, zval *object_ptr, uint check_flags, char **callable_name, int *callable_name_len, zend_fcall_info_cache *fcc, char **error );
__attribute__ ((visibility("default"))) zend_bool zend_is_callable(zval *callable, uint check_flags, char **callable_name );
__attribute__ ((visibility("default"))) zend_bool zend_make_callable(zval *callable, char **callable_name );
__attribute__ ((visibility("default"))) const char *zend_get_module_version(const char *module_name);
__attribute__ ((visibility("default"))) int zend_get_module_started(const char *module_name);
__attribute__ ((visibility("default"))) int zend_declare_property(zend_class_entry *ce, char *name, int name_length, zval *property, int access_type );
__attribute__ ((visibility("default"))) int zend_declare_property_ex(zend_class_entry *ce, const char *name, int name_length, zval *property, int access_type, char *doc_comment, int doc_comment_len );
__attribute__ ((visibility("default"))) int zend_declare_property_null(zend_class_entry *ce, char *name, int name_length, int access_type );
__attribute__ ((visibility("default"))) int zend_declare_property_bool(zend_class_entry *ce, char *name, int name_length, long value, int access_type );
__attribute__ ((visibility("default"))) int zend_declare_property_long(zend_class_entry *ce, char *name, int name_length, long value, int access_type );
__attribute__ ((visibility("default"))) int zend_declare_property_double(zend_class_entry *ce, char *name, int name_length, double value, int access_type );
__attribute__ ((visibility("default"))) int zend_declare_property_string(zend_class_entry *ce, char *name, int name_length, const char *value, int access_type );
__attribute__ ((visibility("default"))) int zend_declare_property_stringl(zend_class_entry *ce, char *name, int name_length, const char *value, int value_len, int access_type );

__attribute__ ((visibility("default"))) int zend_declare_class_constant(zend_class_entry *ce, const char *name, size_t name_length, zval *value );
__attribute__ ((visibility("default"))) int zend_declare_class_constant_null(zend_class_entry *ce, const char *name, size_t name_length );
__attribute__ ((visibility("default"))) int zend_declare_class_constant_long(zend_class_entry *ce, const char *name, size_t name_length, long value );
__attribute__ ((visibility("default"))) int zend_declare_class_constant_bool(zend_class_entry *ce, const char *name, size_t name_length, zend_bool value );
__attribute__ ((visibility("default"))) int zend_declare_class_constant_double(zend_class_entry *ce, const char *name, size_t name_length, double value );
__attribute__ ((visibility("default"))) int zend_declare_class_constant_stringl(zend_class_entry *ce, const char *name, size_t name_length, const char *value, size_t value_length );
__attribute__ ((visibility("default"))) int zend_declare_class_constant_string(zend_class_entry *ce, const char *name, size_t name_length, const char *value );

__attribute__ ((visibility("default"))) void zend_update_class_constants(zend_class_entry *class_type );
__attribute__ ((visibility("default"))) void zend_update_property(zend_class_entry *scope, zval *object, char *name, int name_length, zval *value );
__attribute__ ((visibility("default"))) void zend_update_property_null(zend_class_entry *scope, zval *object, char *name, int name_length );
__attribute__ ((visibility("default"))) void zend_update_property_bool(zend_class_entry *scope, zval *object, char *name, int name_length, long value );
__attribute__ ((visibility("default"))) void zend_update_property_long(zend_class_entry *scope, zval *object, char *name, int name_length, long value );
__attribute__ ((visibility("default"))) void zend_update_property_double(zend_class_entry *scope, zval *object, char *name, int name_length, double value );
__attribute__ ((visibility("default"))) void zend_update_property_string(zend_class_entry *scope, zval *object, char *name, int name_length, const char *value );
__attribute__ ((visibility("default"))) void zend_update_property_stringl(zend_class_entry *scope, zval *object, char *name, int name_length, const char *value, int value_length );

__attribute__ ((visibility("default"))) int zend_update_static_property(zend_class_entry *scope, char *name, int name_length, zval *value );
__attribute__ ((visibility("default"))) int zend_update_static_property_null(zend_class_entry *scope, char *name, int name_length );
__attribute__ ((visibility("default"))) int zend_update_static_property_bool(zend_class_entry *scope, char *name, int name_length, long value );
__attribute__ ((visibility("default"))) int zend_update_static_property_long(zend_class_entry *scope, char *name, int name_length, long value );
__attribute__ ((visibility("default"))) int zend_update_static_property_double(zend_class_entry *scope, char *name, int name_length, double value );
__attribute__ ((visibility("default"))) int zend_update_static_property_string(zend_class_entry *scope, char *name, int name_length, const char *value );
__attribute__ ((visibility("default"))) int zend_update_static_property_stringl(zend_class_entry *scope, char *name, int name_length, const char *value, int value_length );

__attribute__ ((visibility("default"))) zval *zend_read_property(zend_class_entry *scope, zval *object, char *name, int name_length, zend_bool silent );

__attribute__ ((visibility("default"))) zval *zend_read_static_property(zend_class_entry *scope, char *name, int name_length, zend_bool silent );

__attribute__ ((visibility("default"))) zend_class_entry *zend_get_class_entry(const zval *zobject );
__attribute__ ((visibility("default"))) int zend_get_object_classname(const zval *object, const char **class_name, zend_uint *class_name_len );
__attribute__ ((visibility("default"))) char *zend_get_type_by_const(int type);
# 356 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_API.h"
__attribute__ ((visibility("default"))) int _array_init(zval *arg, uint size );
__attribute__ ((visibility("default"))) int _object_init(zval *arg );
__attribute__ ((visibility("default"))) int _object_init_ex(zval *arg, zend_class_entry *ce );
__attribute__ ((visibility("default"))) int _object_and_properties_init(zval *arg, zend_class_entry *ce, HashTable *properties );
__attribute__ ((visibility("default"))) void object_properties_init(zend_object *object, zend_class_entry *class_type);

__attribute__ ((visibility("default"))) void zend_merge_properties(zval *obj, HashTable *properties, int destroy_ht );


__attribute__ ((visibility("default"))) int add_assoc_function(zval *arg, const char *key, void (*function_ptr)(int ht, zval *return_value, zval **return_value_ptr, zval *this_ptr, int return_value_used ));

__attribute__ ((visibility("default"))) int add_assoc_long_ex(zval *arg, const char *key, uint key_len, long n);
__attribute__ ((visibility("default"))) int add_assoc_null_ex(zval *arg, const char *key, uint key_len);
__attribute__ ((visibility("default"))) int add_assoc_bool_ex(zval *arg, const char *key, uint key_len, int b);
__attribute__ ((visibility("default"))) int add_assoc_resource_ex(zval *arg, const char *key, uint key_len, int r);
__attribute__ ((visibility("default"))) int add_assoc_double_ex(zval *arg, const char *key, uint key_len, double d);
__attribute__ ((visibility("default"))) int add_assoc_string_ex(zval *arg, const char *key, uint key_len, char *str, int duplicate);
__attribute__ ((visibility("default"))) int add_assoc_stringl_ex(zval *arg, const char *key, uint key_len, char *str, uint length, int duplicate);
__attribute__ ((visibility("default"))) int add_assoc_zval_ex(zval *arg, const char *key, uint key_len, zval *value);
# 391 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_API.h"
__attribute__ ((visibility("default"))) int add_index_long(zval *arg, ulong idx, long n);
__attribute__ ((visibility("default"))) int add_index_null(zval *arg, ulong idx);
__attribute__ ((visibility("default"))) int add_index_bool(zval *arg, ulong idx, int b);
__attribute__ ((visibility("default"))) int add_index_resource(zval *arg, ulong idx, int r);
__attribute__ ((visibility("default"))) int add_index_double(zval *arg, ulong idx, double d);
__attribute__ ((visibility("default"))) int add_index_string(zval *arg, ulong idx, const char *str, int duplicate);
__attribute__ ((visibility("default"))) int add_index_stringl(zval *arg, ulong idx, const char *str, uint length, int duplicate);
__attribute__ ((visibility("default"))) int add_index_zval(zval *arg, ulong index, zval *value);

__attribute__ ((visibility("default"))) int add_next_index_long(zval *arg, long n);
__attribute__ ((visibility("default"))) int add_next_index_null(zval *arg);
__attribute__ ((visibility("default"))) int add_next_index_bool(zval *arg, int b);
__attribute__ ((visibility("default"))) int add_next_index_resource(zval *arg, int r);
__attribute__ ((visibility("default"))) int add_next_index_double(zval *arg, double d);
__attribute__ ((visibility("default"))) int add_next_index_string(zval *arg, const char *str, int duplicate);
__attribute__ ((visibility("default"))) int add_next_index_stringl(zval *arg, const char *str, uint length, int duplicate);
__attribute__ ((visibility("default"))) int add_next_index_zval(zval *arg, zval *value);

__attribute__ ((visibility("default"))) int add_get_assoc_string_ex(zval *arg, const char *key, uint key_len, const char *str, void **dest, int duplicate);
__attribute__ ((visibility("default"))) int add_get_assoc_stringl_ex(zval *arg, const char *key, uint key_len, const char *str, uint length, void **dest, int duplicate);




__attribute__ ((visibility("default"))) int add_get_index_long(zval *arg, ulong idx, long l, void **dest);
__attribute__ ((visibility("default"))) int add_get_index_double(zval *arg, ulong idx, double d, void **dest);
__attribute__ ((visibility("default"))) int add_get_index_string(zval *arg, ulong idx, const char *str, void **dest, int duplicate);
__attribute__ ((visibility("default"))) int add_get_index_stringl(zval *arg, ulong idx, const char *str, uint length, void **dest, int duplicate);

__attribute__ ((visibility("default"))) int add_property_long_ex(zval *arg, const char *key, uint key_len, long l );
__attribute__ ((visibility("default"))) int add_property_null_ex(zval *arg, const char *key, uint key_len );
__attribute__ ((visibility("default"))) int add_property_bool_ex(zval *arg, const char *key, uint key_len, int b );
__attribute__ ((visibility("default"))) int add_property_resource_ex(zval *arg, const char *key, uint key_len, long r );
__attribute__ ((visibility("default"))) int add_property_double_ex(zval *arg, const char *key, uint key_len, double d );
__attribute__ ((visibility("default"))) int add_property_string_ex(zval *arg, const char *key, uint key_len, const char *str, int duplicate );
__attribute__ ((visibility("default"))) int add_property_stringl_ex(zval *arg, const char *key, uint key_len, const char *str, uint length, int duplicate );
__attribute__ ((visibility("default"))) int add_property_zval_ex(zval *arg, const char *key, uint key_len, zval *value );
# 439 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_API.h"
__attribute__ ((visibility("default"))) int call_user_function(HashTable *function_table, zval **object_pp, zval *function_name, zval *retval_ptr, zend_uint param_count, zval *params[] );
__attribute__ ((visibility("default"))) int call_user_function_ex(HashTable *function_table, zval **object_pp, zval *function_name, zval **retval_ptr_ptr, zend_uint param_count, zval **params[], int no_separation, HashTable *symbol_table );

__attribute__ ((visibility("default"))) extern const zend_fcall_info empty_fcall_info;
__attribute__ ((visibility("default"))) extern const zend_fcall_info_cache empty_fcall_info_cache;
# 455 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_API.h"
__attribute__ ((visibility("default"))) int zend_fcall_info_init(zval *callable, uint check_flags, zend_fcall_info *fci, zend_fcall_info_cache *fcc, char **callable_name, char **error );




__attribute__ ((visibility("default"))) void zend_fcall_info_args_clear(zend_fcall_info *fci, int free_mem);




__attribute__ ((visibility("default"))) void zend_fcall_info_args_save(zend_fcall_info *fci, int *param_count, zval ****params);



__attribute__ ((visibility("default"))) void zend_fcall_info_args_restore(zend_fcall_info *fci, int param_count, zval ***params);




__attribute__ ((visibility("default"))) int zend_fcall_info_args(zend_fcall_info *fci, zval *args );





__attribute__ ((visibility("default"))) int zend_fcall_info_argp(zend_fcall_info *fci , int argc, zval ***argv);





__attribute__ ((visibility("default"))) int zend_fcall_info_argv(zend_fcall_info *fci , int argc, va_list *argv);





__attribute__ ((visibility("default"))) int zend_fcall_info_argn(zend_fcall_info *fci , int argc, ...);




__attribute__ ((visibility("default"))) int zend_fcall_info_call(zend_fcall_info *fci, zend_fcall_info_cache *fcc, zval **retval, zval *args );

__attribute__ ((visibility("default"))) int zend_call_function(zend_fcall_info *fci, zend_fcall_info_cache *fci_cache );

__attribute__ ((visibility("default"))) int zend_set_hash_symbol(zval *symbol, const char *name, int name_length, zend_bool is_ref, int num_symbol_tables, ...);

__attribute__ ((visibility("default"))) void zend_delete_variable(zend_execute_data *ex, HashTable *ht, char *name, int name_len, ulong hash_value );

__attribute__ ((visibility("default"))) int zend_delete_global_variable(char *name, int name_len );

__attribute__ ((visibility("default"))) int zend_delete_global_variable_ex(char *name, int name_len, ulong hash_value );

__attribute__ ((visibility("default"))) void zend_reset_all_cv(HashTable *symbol_table );

__attribute__ ((visibility("default"))) void zend_rebuild_symbol_table(void);



__attribute__ ((visibility("default"))) void zif_display_disabled_function(int ht, zval *return_value, zval **return_value_ptr, zval *this_ptr, int return_value_used );
__attribute__ ((visibility("default"))) void zif_display_disabled_class(int ht, zval *return_value, zval **return_value_ptr, zval *this_ptr, int return_value_used );

# 726 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_API.h"

# 31 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_execute.c" 2

# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_constants.h" 1
# 33 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_constants.h"
typedef struct _zend_constant {
 zval value;
 int flags;
 char *name;
 uint name_len;
 int module_number;
} zend_constant;
# 56 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_constants.h"

void clean_module_constants(int module_number );
void free_zend_constant(zend_constant *c);
int zend_startup_constants(void);
int zend_shutdown_constants(void);
void zend_register_standard_constants(void);
void clean_non_persistent_constants(void);
__attribute__ ((visibility("default"))) int zend_get_constant(const char *name, uint name_len, zval *result );
__attribute__ ((visibility("default"))) int zend_get_constant_ex(const char *name, uint name_len, zval *result, zend_class_entry *scope, ulong flags );
__attribute__ ((visibility("default"))) void zend_register_long_constant(const char *name, uint name_len, long lval, int flags, int module_number );
__attribute__ ((visibility("default"))) void zend_register_double_constant(const char *name, uint name_len, double dval, int flags, int module_number );
__attribute__ ((visibility("default"))) void zend_register_string_constant(const char *name, uint name_len, char *strval, int flags, int module_number );
__attribute__ ((visibility("default"))) void zend_register_stringl_constant(const char *name, uint name_len, char *strval, uint strlen, int flags, int module_number );
__attribute__ ((visibility("default"))) int zend_register_constant(zend_constant *c );
void zend_copy_constants(HashTable *target, HashTable *sourc);
void copy_zend_constant(zend_constant *c);
zend_constant *zend_quick_get_constant(const zend_literal *key, ulong flags );

# 33 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_execute.c" 2
# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_extensions.h" 1
# 33 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_extensions.h"
typedef struct _zend_extension_version_info {
 int zend_extension_api_no;
 char *build_id;
} zend_extension_version_info;



typedef struct _zend_extension zend_extension;


typedef int (*startup_func_t)(zend_extension *extension);
typedef void (*shutdown_func_t)(zend_extension *extension);
typedef void (*activate_func_t)(void);
typedef void (*deactivate_func_t)(void);

typedef void (*message_handler_func_t)(int message, void *arg);

typedef void (*op_array_handler_func_t)(zend_op_array *op_array);

typedef void (*statement_handler_func_t)(zend_op_array *op_array);
typedef void (*fcall_begin_handler_func_t)(zend_op_array *op_array);
typedef void (*fcall_end_handler_func_t)(zend_op_array *op_array);

typedef void (*op_array_ctor_func_t)(zend_op_array *op_array);
typedef void (*op_array_dtor_func_t)(zend_op_array *op_array);

struct _zend_extension {
 char *name;
 char *version;
 char *author;
 char *URL;
 char *copyright;

 startup_func_t startup;
 shutdown_func_t shutdown;
 activate_func_t activate;
 deactivate_func_t deactivate;

 message_handler_func_t message_handler;

 op_array_handler_func_t op_array_handler;

 statement_handler_func_t statement_handler;
 fcall_begin_handler_func_t fcall_begin_handler;
 fcall_end_handler_func_t fcall_end_handler;

 op_array_ctor_func_t op_array_ctor;
 op_array_dtor_func_t op_array_dtor;

 int (*api_no_check)(int api_no);
 int (*build_id_check)(const char* build_id);
 void *reserved3;
 void *reserved4;
 void *reserved5;
 void *reserved6;
 void *reserved7;
 void *reserved8;

 void * handle;
 int resource_number;
};


__attribute__ ((visibility("default"))) int zend_get_resource_handle(zend_extension *extension);
__attribute__ ((visibility("default"))) void zend_extension_dispatch_message(int message, void *arg);

# 111 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_extensions.h"
__attribute__ ((visibility("default"))) extern zend_llist zend_extensions;

void zend_extension_dtor(zend_extension *extension);
void zend_append_version_info(const zend_extension *extension);
int zend_startup_extensions_mechanism(void);
int zend_startup_extensions(void);
void zend_shutdown_extensions(void);


__attribute__ ((visibility("default"))) int zend_load_extension(const char *path);
__attribute__ ((visibility("default"))) int zend_register_extension(zend_extension *new_extension, void * handle);
__attribute__ ((visibility("default"))) zend_extension *zend_get_extension(const char *extension_name);

# 34 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_execute.c" 2
# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_ini.h" 1
# 63 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_ini.h"
struct _zend_ini_entry {
 int module_number;
 int modifiable;
 char *name;
 uint name_length;
 int (*on_modify)(zend_ini_entry *entry, char *new_value, uint new_value_length, void *mh_arg1, void *mh_arg2, void *mh_arg3, int stage );
 void *mh_arg1;
 void *mh_arg2;
 void *mh_arg3;

 char *value;
 uint value_length;

 char *orig_value;
 uint orig_value_length;
 int orig_modifiable;
 int modified;

 void (*displayer)(zend_ini_entry *ini_entry, int type);
};


__attribute__ ((visibility("default"))) int zend_ini_startup(void);
__attribute__ ((visibility("default"))) int zend_ini_shutdown(void);
__attribute__ ((visibility("default"))) int zend_ini_global_shutdown(void);
__attribute__ ((visibility("default"))) int zend_ini_deactivate(void);

__attribute__ ((visibility("default"))) int zend_copy_ini_directives(void);

__attribute__ ((visibility("default"))) void zend_ini_sort_entries(void);

__attribute__ ((visibility("default"))) int zend_register_ini_entries(const zend_ini_entry *ini_entry, int module_number );
__attribute__ ((visibility("default"))) void zend_unregister_ini_entries(int module_number );
__attribute__ ((visibility("default"))) void zend_ini_refresh_caches(int stage );
__attribute__ ((visibility("default"))) int zend_alter_ini_entry(char *name, uint name_length, char *new_value, uint new_value_length, int modify_type, int stage);
__attribute__ ((visibility("default"))) int zend_alter_ini_entry_ex(char *name, uint name_length, char *new_value, uint new_value_length, int modify_type, int stage, int force_change );
__attribute__ ((visibility("default"))) int zend_restore_ini_entry(char *name, uint name_length, int stage);
__attribute__ ((visibility("default"))) void display_ini_entries(zend_module_entry *module);

__attribute__ ((visibility("default"))) long zend_ini_long(char *name, uint name_length, int orig);
__attribute__ ((visibility("default"))) double zend_ini_double(char *name, uint name_length, int orig);
__attribute__ ((visibility("default"))) char *zend_ini_string(char *name, uint name_length, int orig);
__attribute__ ((visibility("default"))) char *zend_ini_string_ex(char *name, uint name_length, int orig, zend_bool *exists);

__attribute__ ((visibility("default"))) int zend_ini_register_displayer(char *name, uint name_length, void (*displayer)(zend_ini_entry *ini_entry, int type));

__attribute__ ((visibility("default"))) void zend_ini_boolean_displayer_cb(zend_ini_entry *ini_entry, int type);
__attribute__ ((visibility("default"))) void zend_ini_color_displayer_cb(zend_ini_entry *ini_entry, int type);
__attribute__ ((visibility("default"))) void display_link_numbers(zend_ini_entry *ini_entry, int type);

# 175 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_ini.h"

__attribute__ ((visibility("default"))) int OnUpdateBool(zend_ini_entry *entry, char *new_value, uint new_value_length, void *mh_arg1, void *mh_arg2, void *mh_arg3, int stage );
__attribute__ ((visibility("default"))) int OnUpdateLong(zend_ini_entry *entry, char *new_value, uint new_value_length, void *mh_arg1, void *mh_arg2, void *mh_arg3, int stage );
__attribute__ ((visibility("default"))) int OnUpdateLongGEZero(zend_ini_entry *entry, char *new_value, uint new_value_length, void *mh_arg1, void *mh_arg2, void *mh_arg3, int stage );
__attribute__ ((visibility("default"))) int OnUpdateReal(zend_ini_entry *entry, char *new_value, uint new_value_length, void *mh_arg1, void *mh_arg2, void *mh_arg3, int stage );
__attribute__ ((visibility("default"))) int OnUpdateString(zend_ini_entry *entry, char *new_value, uint new_value_length, void *mh_arg1, void *mh_arg2, void *mh_arg3, int stage );
__attribute__ ((visibility("default"))) int OnUpdateStringUnempty(zend_ini_entry *entry, char *new_value, uint new_value_length, void *mh_arg1, void *mh_arg2, void *mh_arg3, int stage );

# 195 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_ini.h"
typedef void (*zend_ini_parser_cb_t)(zval *arg1, zval *arg2, zval *arg3, int callback_type, void *arg );

__attribute__ ((visibility("default"))) int zend_parse_ini_file(zend_file_handle *fh, zend_bool unbuffered_errors, int scanner_mode, zend_ini_parser_cb_t ini_parser_cb, void *arg );
__attribute__ ((visibility("default"))) int zend_parse_ini_string(char *str, zend_bool unbuffered_errors, int scanner_mode, zend_ini_parser_cb_t ini_parser_cb, void *arg );







typedef struct _zend_ini_parser_param {
 zend_ini_parser_cb_t ini_parser_cb;
 void *arg;
} zend_ini_parser_param;
# 35 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_execute.c" 2
# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_exceptions.h" 1
# 27 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_exceptions.h"


__attribute__ ((visibility("default"))) void zend_exception_set_previous(zval *exception, zval *add_previous );
__attribute__ ((visibility("default"))) void zend_exception_save(void);
__attribute__ ((visibility("default"))) void zend_exception_restore(void);

void zend_throw_exception_internal(zval *exception );

void zend_register_default_exception(void);

__attribute__ ((visibility("default"))) zend_class_entry *zend_exception_get_default(void);
__attribute__ ((visibility("default"))) zend_class_entry *zend_get_error_exception(void);
__attribute__ ((visibility("default"))) void zend_register_default_classes(void);



__attribute__ ((visibility("default"))) zval * zend_throw_exception(zend_class_entry *exception_ce, char *message, long code );
__attribute__ ((visibility("default"))) zval * zend_throw_exception_ex(zend_class_entry *exception_ce, long code , char *format, ...);
__attribute__ ((visibility("default"))) void zend_throw_exception_object(zval *exception );
__attribute__ ((visibility("default"))) void zend_clear_exception(void);

__attribute__ ((visibility("default"))) zval * zend_throw_error_exception(zend_class_entry *exception_ce, char *message, long code, int severity );

extern __attribute__ ((visibility("default"))) void (*zend_throw_exception_hook)(zval *ex );


__attribute__ ((visibility("default"))) void zend_exception_error(zval *exception, int severity );


int zend_spprintf(char **message, int max_len, char *format, ...);


# 36 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_execute.c" 2
# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_interfaces.h" 1
# 27 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_interfaces.h"


extern __attribute__ ((visibility("default"))) zend_class_entry *zend_ce_traversable;
extern __attribute__ ((visibility("default"))) zend_class_entry *zend_ce_aggregate;
extern __attribute__ ((visibility("default"))) zend_class_entry *zend_ce_iterator;
extern __attribute__ ((visibility("default"))) zend_class_entry *zend_ce_arrayaccess;
extern __attribute__ ((visibility("default"))) zend_class_entry *zend_ce_serializable;

typedef struct _zend_user_iterator {
 zend_object_iterator it;
 zend_class_entry *ce;
 zval *value;
} zend_user_iterator;

__attribute__ ((visibility("default"))) zval* zend_call_method(zval **object_pp, zend_class_entry *obj_ce, zend_function **fn_proxy, char *function_name, int function_name_len, zval **retval_ptr_ptr, int param_count, zval* arg1, zval* arg2 );
# 52 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_interfaces.h"
__attribute__ ((visibility("default"))) void zend_user_it_rewind(zend_object_iterator *_iter );
__attribute__ ((visibility("default"))) int zend_user_it_valid(zend_object_iterator *_iter );
__attribute__ ((visibility("default"))) int zend_user_it_get_current_key(zend_object_iterator *_iter, char **str_key, uint *str_key_len, ulong *int_key );
__attribute__ ((visibility("default"))) void zend_user_it_get_current_data(zend_object_iterator *_iter, zval ***data );
__attribute__ ((visibility("default"))) void zend_user_it_move_forward(zend_object_iterator *_iter );
__attribute__ ((visibility("default"))) void zend_user_it_invalidate_current(zend_object_iterator *_iter );

__attribute__ ((visibility("default"))) zval *zend_user_it_new_iterator(zend_class_entry *ce, zval *object );
__attribute__ ((visibility("default"))) zend_object_iterator *zend_user_it_get_new_iterator(zend_class_entry *ce, zval *object, int by_ref );

__attribute__ ((visibility("default"))) void zend_register_interfaces(void);

__attribute__ ((visibility("default"))) int zend_user_serialize(zval *object, unsigned char **buffer, zend_uint *buf_len, zend_serialize_data *data );
__attribute__ ((visibility("default"))) int zend_user_unserialize(zval **object, zend_class_entry *ce, const unsigned char *buf, zend_uint buf_len, zend_unserialize_data *data );

__attribute__ ((visibility("default"))) int zend_class_serialize_deny(zval *object, unsigned char **buffer, zend_uint *buf_len, zend_serialize_data *data );
__attribute__ ((visibility("default"))) int zend_class_unserialize_deny(zval **object, zend_class_entry *ce, const unsigned char *buf, zend_uint buf_len, zend_unserialize_data *data );


# 37 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_execute.c" 2
# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_closures.h" 1
# 25 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_closures.h"




void zend_register_closure_ce(void);

extern __attribute__ ((visibility("default"))) zend_class_entry *zend_ce_closure;

__attribute__ ((visibility("default"))) void zend_create_closure(zval *res, zend_function *op_array, zend_class_entry *scope, zval *this_ptr );
__attribute__ ((visibility("default"))) zend_function *zend_get_closure_invoke_method(zval *obj );
__attribute__ ((visibility("default"))) const zend_function *zend_get_closure_method_def(zval *obj );
__attribute__ ((visibility("default"))) zval* zend_get_closure_this_ptr(zval *obj );


# 38 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_execute.c" 2
# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_vm.h" 1
# 24 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_vm.h"
__attribute__ ((visibility("default"))) void zend_vm_use_old_executor(void);
__attribute__ ((visibility("default"))) void zend_vm_set_opcode_handler(zend_op* opcode);
# 39 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_execute.c" 2
# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_dtrace.h" 1
# 25 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_dtrace.h"
# 1 "/usr/include/unistd.h" 1 3 4
# 28 "/usr/include/unistd.h" 3 4

# 203 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/bits/posix_opt.h" 1 3 4
# 204 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/bits/environments.h" 1 3 4
# 208 "/usr/include/unistd.h" 2 3 4
# 227 "/usr/include/unistd.h" 3 4
# 1 "/usr/lib/gcc/i686-redhat-linux/4.4.5/include/stddef.h" 1 3 4
# 228 "/usr/include/unistd.h" 2 3 4
# 256 "/usr/include/unistd.h" 3 4
typedef __useconds_t useconds_t;
# 268 "/usr/include/unistd.h" 3 4
typedef __intptr_t intptr_t;






typedef __socklen_t socklen_t;
# 288 "/usr/include/unistd.h" 3 4
extern int access (__const char *__name, int __type) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
# 305 "/usr/include/unistd.h" 3 4
extern int faccessat (int __fd, __const char *__file, int __type, int __flag)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2))) ;
# 331 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) __attribute__ ((__nothrow__));
# 350 "/usr/include/unistd.h" 3 4
extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;





extern ssize_t write (int __fd, __const void *__buf, size_t __n) ;
# 373 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset) ;






extern ssize_t pwrite (int __fd, __const void *__buf, size_t __n,
         __off_t __offset) ;
# 414 "/usr/include/unistd.h" 3 4
extern int pipe (int __pipedes[2]) __attribute__ ((__nothrow__)) ;
# 429 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) __attribute__ ((__nothrow__));
# 441 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     __attribute__ ((__nothrow__));






extern int usleep (__useconds_t __useconds);
# 466 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (__const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) __attribute__ ((__nothrow__)) ;




extern int lchown (__const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, __const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2))) ;



extern int chdir (__const char *__path) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) __attribute__ ((__nothrow__)) ;
# 508 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) __attribute__ ((__nothrow__)) ;
# 522 "/usr/include/unistd.h" 3 4
extern char *getwd (char *__buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;




extern int dup (int __fd) __attribute__ ((__nothrow__)) ;


extern int dup2 (int __fd, int __fd2) __attribute__ ((__nothrow__));
# 540 "/usr/include/unistd.h" 3 4
extern char **__environ;







extern int execve (__const char *__path, char *__const __argv[],
     char *__const __envp[]) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *__const __argv[], char *__const __envp[])
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));




extern int execv (__const char *__path, char *__const __argv[])
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execle (__const char *__path, __const char *__arg, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execl (__const char *__path, __const char *__arg, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (__const char *__file, char *__const __argv[])
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (__const char *__file, __const char *__arg, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
# 595 "/usr/include/unistd.h" 3 4
extern int nice (int __inc) __attribute__ ((__nothrow__)) ;




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/usr/include/bits/confname.h" 1 3 4
# 26 "/usr/include/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 607 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (__const char *__path, int __name)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) __attribute__ ((__nothrow__));


extern long int sysconf (int __name) __attribute__ ((__nothrow__));



extern size_t confstr (int __name, char *__buf, size_t __len) __attribute__ ((__nothrow__));




extern __pid_t getpid (void) __attribute__ ((__nothrow__));


extern __pid_t getppid (void) __attribute__ ((__nothrow__));




extern __pid_t getpgrp (void) __attribute__ ((__nothrow__));
# 643 "/usr/include/unistd.h" 3 4
extern __pid_t __getpgid (__pid_t __pid) __attribute__ ((__nothrow__));

extern __pid_t getpgid (__pid_t __pid) __attribute__ ((__nothrow__));






extern int setpgid (__pid_t __pid, __pid_t __pgid) __attribute__ ((__nothrow__));
# 669 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) __attribute__ ((__nothrow__));
# 686 "/usr/include/unistd.h" 3 4
extern __pid_t setsid (void) __attribute__ ((__nothrow__));



extern __pid_t getsid (__pid_t __pid) __attribute__ ((__nothrow__));



extern __uid_t getuid (void) __attribute__ ((__nothrow__));


extern __uid_t geteuid (void) __attribute__ ((__nothrow__));


extern __gid_t getgid (void) __attribute__ ((__nothrow__));


extern __gid_t getegid (void) __attribute__ ((__nothrow__));




extern int getgroups (int __size, __gid_t __list[]) __attribute__ ((__nothrow__)) ;
# 719 "/usr/include/unistd.h" 3 4
extern int setuid (__uid_t __uid) __attribute__ ((__nothrow__));




extern int setreuid (__uid_t __ruid, __uid_t __euid) __attribute__ ((__nothrow__));




extern int seteuid (__uid_t __uid) __attribute__ ((__nothrow__));






extern int setgid (__gid_t __gid) __attribute__ ((__nothrow__));




extern int setregid (__gid_t __rgid, __gid_t __egid) __attribute__ ((__nothrow__));




extern int setegid (__gid_t __gid) __attribute__ ((__nothrow__));
# 775 "/usr/include/unistd.h" 3 4
extern __pid_t fork (void) __attribute__ ((__nothrow__));







extern __pid_t vfork (void) __attribute__ ((__nothrow__));





extern char *ttyname (int __fd) __attribute__ ((__nothrow__));



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2))) ;



extern int isatty (int __fd) __attribute__ ((__nothrow__));





extern int ttyslot (void) __attribute__ ((__nothrow__));




extern int link (__const char *__from, __const char *__to)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, __const char *__from, int __tofd,
     __const char *__to, int __flags)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (__const char *__from, __const char *__to)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (__const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern int symlinkat (__const char *__from, int __tofd,
        __const char *__to) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, __const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3))) ;



extern int unlink (__const char *__name) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, __const char *__name, int __flag)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));



extern int rmdir (__const char *__path) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) __attribute__ ((__nothrow__));


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) __attribute__ ((__nothrow__));






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (__const char *__name) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
# 890 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/getopt.h" 1 3 4
# 59 "/usr/include/getopt.h" 3 4
extern char *optarg;
# 73 "/usr/include/getopt.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 152 "/usr/include/getopt.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       __attribute__ ((__nothrow__));
# 891 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern int sethostname (__const char *__name, size_t __len)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) __attribute__ ((__nothrow__)) ;





extern int getdomainname (char *__name, size_t __len)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (__const char *__name, size_t __len)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;





extern int vhangup (void) __attribute__ ((__nothrow__));


extern int revoke (__const char *__file) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int acct (__const char *__name) __attribute__ ((__nothrow__));



extern char *getusershell (void) __attribute__ ((__nothrow__));
extern void endusershell (void) __attribute__ ((__nothrow__));
extern void setusershell (void) __attribute__ ((__nothrow__));





extern int daemon (int __nochdir, int __noclose) __attribute__ ((__nothrow__)) ;






extern int chroot (__const char *__path) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (__const char *__prompt) __attribute__ ((__nonnull__ (1)));
# 976 "/usr/include/unistd.h" 3 4
extern int fsync (int __fd);






extern long int gethostid (void);


extern void sync (void) __attribute__ ((__nothrow__));





extern int getpagesize (void) __attribute__ ((__nothrow__)) __attribute__ ((__const__));




extern int getdtablesize (void) __attribute__ ((__nothrow__));
# 1007 "/usr/include/unistd.h" 3 4
extern int truncate (__const char *__file, __off_t __length)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) ;
# 1026 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) __attribute__ ((__nothrow__)) ;
# 1047 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) __attribute__ ((__nothrow__)) ;





extern void *sbrk (intptr_t __delta) __attribute__ ((__nothrow__));
# 1068 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) __attribute__ ((__nothrow__));
# 1091 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len) ;
# 1122 "/usr/include/unistd.h" 3 4
extern int fdatasync (int __fildes);
# 1151 "/usr/include/unistd.h" 3 4
extern char *ctermid (char *__s) __attribute__ ((__nothrow__));
# 1160 "/usr/include/unistd.h" 3 4

# 26 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_dtrace.h" 2
# 40 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_execute.c" 2


# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/TSRM/tsrm_virtual_cwd.h" 1
# 26 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/TSRM/tsrm_virtual_cwd.h"
# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/TSRM/TSRM.h" 1
# 27 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/TSRM/tsrm_virtual_cwd.h" 2
# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/TSRM/tsrm_config_common.h" 1
# 13 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/TSRM/tsrm_config_common.h"
# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/TSRM/tsrm_config.h" 1
# 1 "Zend/../main/php_config.h" 1
# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/TSRM/tsrm_config.h" 2
# 14 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/TSRM/tsrm_config_common.h" 2
# 1 "/usr/include/sys/param.h" 1 3 4
# 26 "/usr/include/sys/param.h" 3 4
# 1 "/usr/lib/gcc/i686-redhat-linux/4.4.5/include/limits.h" 1 3 4
# 27 "/usr/include/sys/param.h" 2 3 4

# 1 "/usr/include/linux/param.h" 1 3 4



# 1 "/usr/include/asm/param.h" 1 3 4
# 1 "/usr/include/asm-generic/param.h" 1 3 4
# 1 "/usr/include/asm/param.h" 2 3 4
# 5 "/usr/include/linux/param.h" 2 3 4
# 29 "/usr/include/sys/param.h" 2 3 4
# 15 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/TSRM/tsrm_config_common.h" 2
# 41 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/TSRM/tsrm_config_common.h"
# 1 "/usr/lib/gcc/i686-redhat-linux/4.4.5/include/limits.h" 1 3 4
# 42 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/TSRM/tsrm_config_common.h" 2
# 28 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/TSRM/tsrm_virtual_cwd.h" 2


# 1 "/usr/include/sys/stat.h" 1 3 4
# 39 "/usr/include/sys/stat.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
# 40 "/usr/include/sys/stat.h" 2 3 4
# 105 "/usr/include/sys/stat.h" 3 4


# 1 "/usr/include/bits/stat.h" 1 3 4
# 39 "/usr/include/bits/stat.h" 3 4
struct stat
  {
    __dev_t st_dev;
    unsigned short int __pad1;

    __ino_t st_ino;



    __mode_t st_mode;
    __nlink_t st_nlink;
    __uid_t st_uid;
    __gid_t st_gid;
    __dev_t st_rdev;
    unsigned short int __pad2;

    __off_t st_size;



    __blksize_t st_blksize;


    __blkcnt_t st_blocks;
# 73 "/usr/include/bits/stat.h" 3 4
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 88 "/usr/include/bits/stat.h" 3 4
    unsigned long int __unused4;
    unsigned long int __unused5;



  };
# 108 "/usr/include/sys/stat.h" 2 3 4
# 211 "/usr/include/sys/stat.h" 3 4
extern int stat (__const char *__restrict __file,
   struct stat *__restrict __buf) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));



extern int fstat (int __fd, struct stat *__buf) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));
# 240 "/usr/include/sys/stat.h" 3 4
extern int fstatat (int __fd, __const char *__restrict __file,
      struct stat *__restrict __buf, int __flag)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3)));
# 265 "/usr/include/sys/stat.h" 3 4
extern int lstat (__const char *__restrict __file,
    struct stat *__restrict __buf) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
# 286 "/usr/include/sys/stat.h" 3 4
extern int chmod (__const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int lchmod (__const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));




extern int fchmod (int __fd, __mode_t __mode) __attribute__ ((__nothrow__));





extern int fchmodat (int __fd, __const char *__file, __mode_t __mode,
       int __flag)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2))) ;






extern __mode_t umask (__mode_t __mask) __attribute__ ((__nothrow__));
# 323 "/usr/include/sys/stat.h" 3 4
extern int mkdir (__const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int mkdirat (int __fd, __const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));






extern int mknod (__const char *__path, __mode_t __mode, __dev_t __dev)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int mknodat (int __fd, __const char *__path, __mode_t __mode,
      __dev_t __dev) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));





extern int mkfifo (__const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int mkfifoat (int __fd, __const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));





extern int utimensat (int __fd, __const char *__path,
        __const struct timespec __times[2],
        int __flags)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));




extern int futimens (int __fd, __const struct timespec __times[2]) __attribute__ ((__nothrow__));
# 401 "/usr/include/sys/stat.h" 3 4
extern int __fxstat (int __ver, int __fildes, struct stat *__stat_buf)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3)));
extern int __xstat (int __ver, __const char *__filename,
      struct stat *__stat_buf) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat (int __ver, __const char *__filename,
       struct stat *__stat_buf) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat (int __ver, int __fildes, __const char *__filename,
         struct stat *__stat_buf, int __flag)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 4)));
# 444 "/usr/include/sys/stat.h" 3 4
extern int __xmknod (int __ver, __const char *__path, __mode_t __mode,
       __dev_t *__dev) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 4)));

extern int __xmknodat (int __ver, int __fd, __const char *__path,
         __mode_t __mode, __dev_t *__dev)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (3, 5)));




extern __inline int
__attribute__ ((__nothrow__)) stat (__const char *__path, struct stat *__statbuf)
{
  return __xstat (3, __path, __statbuf);
}


extern __inline int
__attribute__ ((__nothrow__)) lstat (__const char *__path, struct stat *__statbuf)
{
  return __lxstat (3, __path, __statbuf);
}


extern __inline int
__attribute__ ((__nothrow__)) fstat (int __fd, struct stat *__statbuf)
{
  return __fxstat (3, __fd, __statbuf);
}


extern __inline int
__attribute__ ((__nothrow__)) fstatat (int __fd, __const char *__filename, struct stat *__statbuf, int __flag)

{
  return __fxstatat (3, __fd, __filename, __statbuf, __flag);
}



extern __inline int
__attribute__ ((__nothrow__)) mknod (__const char *__path, __mode_t __mode, __dev_t __dev)
{
  return __xmknod (1, __path, __mode, &__dev);
}



extern __inline int
__attribute__ ((__nothrow__)) mknodat (int __fd, __const char *__path, __mode_t __mode, __dev_t __dev)

{
  return __xmknodat (1, __fd, __path, __mode, &__dev);
}
# 536 "/usr/include/sys/stat.h" 3 4

# 31 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/TSRM/tsrm_virtual_cwd.h" 2
# 1 "/usr/include/ctype.h" 1 3 4
# 30 "/usr/include/ctype.h" 3 4

# 48 "/usr/include/ctype.h" 3 4
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 81 "/usr/include/ctype.h" 3 4
extern __const unsigned short int **__ctype_b_loc (void)
     __attribute__ ((__nothrow__)) __attribute__ ((__const));
extern __const __int32_t **__ctype_tolower_loc (void)
     __attribute__ ((__nothrow__)) __attribute__ ((__const));
extern __const __int32_t **__ctype_toupper_loc (void)
     __attribute__ ((__nothrow__)) __attribute__ ((__const));
# 96 "/usr/include/ctype.h" 3 4






extern int isalnum (int) __attribute__ ((__nothrow__));
extern int isalpha (int) __attribute__ ((__nothrow__));
extern int iscntrl (int) __attribute__ ((__nothrow__));
extern int isdigit (int) __attribute__ ((__nothrow__));
extern int islower (int) __attribute__ ((__nothrow__));
extern int isgraph (int) __attribute__ ((__nothrow__));
extern int isprint (int) __attribute__ ((__nothrow__));
extern int ispunct (int) __attribute__ ((__nothrow__));
extern int isspace (int) __attribute__ ((__nothrow__));
extern int isupper (int) __attribute__ ((__nothrow__));
extern int isxdigit (int) __attribute__ ((__nothrow__));



extern int tolower (int __c) __attribute__ ((__nothrow__));


extern int toupper (int __c) __attribute__ ((__nothrow__));








extern int isblank (int) __attribute__ ((__nothrow__));


# 142 "/usr/include/ctype.h" 3 4
extern int isascii (int __c) __attribute__ ((__nothrow__));



extern int toascii (int __c) __attribute__ ((__nothrow__));



extern int _toupper (int) __attribute__ ((__nothrow__));
extern int _tolower (int) __attribute__ ((__nothrow__));
# 190 "/usr/include/ctype.h" 3 4
extern __inline int
__attribute__ ((__nothrow__)) tolower (int __c)
{
  return __c >= -128 && __c < 256 ? (*__ctype_tolower_loc ())[__c] : __c;
}

extern __inline int
__attribute__ ((__nothrow__)) toupper (int __c)
{
  return __c >= -128 && __c < 256 ? (*__ctype_toupper_loc ())[__c] : __c;
}
# 247 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, __locale_t) __attribute__ ((__nothrow__));
extern int isalpha_l (int, __locale_t) __attribute__ ((__nothrow__));
extern int iscntrl_l (int, __locale_t) __attribute__ ((__nothrow__));
extern int isdigit_l (int, __locale_t) __attribute__ ((__nothrow__));
extern int islower_l (int, __locale_t) __attribute__ ((__nothrow__));
extern int isgraph_l (int, __locale_t) __attribute__ ((__nothrow__));
extern int isprint_l (int, __locale_t) __attribute__ ((__nothrow__));
extern int ispunct_l (int, __locale_t) __attribute__ ((__nothrow__));
extern int isspace_l (int, __locale_t) __attribute__ ((__nothrow__));
extern int isupper_l (int, __locale_t) __attribute__ ((__nothrow__));
extern int isxdigit_l (int, __locale_t) __attribute__ ((__nothrow__));

extern int isblank_l (int, __locale_t) __attribute__ ((__nothrow__));



extern int __tolower_l (int __c, __locale_t __l) __attribute__ ((__nothrow__));
extern int tolower_l (int __c, __locale_t __l) __attribute__ ((__nothrow__));


extern int __toupper_l (int __c, __locale_t __l) __attribute__ ((__nothrow__));
extern int toupper_l (int __c, __locale_t __l) __attribute__ ((__nothrow__));
# 323 "/usr/include/ctype.h" 3 4

# 32 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/TSRM/tsrm_virtual_cwd.h" 2


# 1 "/usr/include/utime.h" 1 3 4
# 28 "/usr/include/utime.h" 3 4






# 1 "/usr/include/time.h" 1 3 4
# 35 "/usr/include/utime.h" 2 3 4



struct utimbuf
  {
    __time_t actime;
    __time_t modtime;
  };



extern int utime (__const char *__file,
    __const struct utimbuf *__file_times)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


# 35 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/TSRM/tsrm_virtual_cwd.h" 2
# 90 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/TSRM/tsrm_virtual_cwd.h"
# 1 "/usr/include/dirent.h" 1 3 4
# 28 "/usr/include/dirent.h" 3 4

# 62 "/usr/include/dirent.h" 3 4
# 1 "/usr/include/bits/dirent.h" 1 3 4
# 23 "/usr/include/bits/dirent.h" 3 4
struct dirent
  {

    __ino_t d_ino;
    __off_t d_off;




    unsigned short int d_reclen;
    unsigned char d_type;
    char d_name[256];
  };
# 63 "/usr/include/dirent.h" 2 3 4
# 98 "/usr/include/dirent.h" 3 4
enum
  {
    DT_UNKNOWN = 0,

    DT_FIFO = 1,

    DT_CHR = 2,

    DT_DIR = 4,

    DT_BLK = 6,

    DT_REG = 8,

    DT_LNK = 10,

    DT_SOCK = 12,

    DT_WHT = 14

  };
# 128 "/usr/include/dirent.h" 3 4
typedef struct __dirstream DIR;






extern DIR *opendir (__const char *__name) __attribute__ ((__nonnull__ (1)));






extern DIR *fdopendir (int __fd);







extern int closedir (DIR *__dirp) __attribute__ ((__nonnull__ (1)));
# 163 "/usr/include/dirent.h" 3 4
extern struct dirent *readdir (DIR *__dirp) __attribute__ ((__nonnull__ (1)));
# 184 "/usr/include/dirent.h" 3 4
extern int readdir_r (DIR *__restrict __dirp,
        struct dirent *__restrict __entry,
        struct dirent **__restrict __result)
     __attribute__ ((__nonnull__ (1, 2, 3)));
# 209 "/usr/include/dirent.h" 3 4
extern void rewinddir (DIR *__dirp) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern void seekdir (DIR *__dirp, long int __pos) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern long int telldir (DIR *__dirp) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int dirfd (DIR *__dirp) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));
# 245 "/usr/include/dirent.h" 3 4
# 1 "/usr/lib/gcc/i686-redhat-linux/4.4.5/include/stddef.h" 1 3 4
# 246 "/usr/include/dirent.h" 2 3 4






extern int scandir (__const char *__restrict __dir,
      struct dirent ***__restrict __namelist,
      int (*__selector) (__const struct dirent *),
      int (*__cmp) (__const struct dirent **,
      __const struct dirent **))
     __attribute__ ((__nonnull__ (1, 2)));
# 285 "/usr/include/dirent.h" 3 4
extern int alphasort (__const struct dirent **__e1,
        __const struct dirent **__e2)
     __attribute__ ((__nothrow__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 313 "/usr/include/dirent.h" 3 4
extern __ssize_t getdirentries (int __fd, char *__restrict __buf,
    size_t __nbytes,
    __off_t *__restrict __basep)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 4)));
# 362 "/usr/include/dirent.h" 3 4

# 91 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/TSRM/tsrm_virtual_cwd.h" 2
# 145 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/TSRM/tsrm_virtual_cwd.h"
typedef struct _cwd_state {
 char *cwd;
 int cwd_length;
} cwd_state;

typedef int (*verify_path_func)(const cwd_state *);

__attribute__ ((visibility("default"))) void virtual_cwd_startup(void);
__attribute__ ((visibility("default"))) void virtual_cwd_shutdown(void);
__attribute__ ((visibility("default"))) char *virtual_getcwd_ex(size_t *length );
__attribute__ ((visibility("default"))) char *virtual_getcwd(char *buf, size_t size );
__attribute__ ((visibility("default"))) int virtual_chdir(const char *path );
__attribute__ ((visibility("default"))) int virtual_chdir_file(const char *path, int (*p_chdir)(const char *path ) );
__attribute__ ((visibility("default"))) int virtual_filepath(const char *path, char **filepath );
__attribute__ ((visibility("default"))) int virtual_filepath_ex(const char *path, char **filepath, verify_path_func verify_path );
__attribute__ ((visibility("default"))) char *virtual_realpath(const char *path, char *real_path );
__attribute__ ((visibility("default"))) FILE *virtual_fopen(const char *path, const char *mode );
__attribute__ ((visibility("default"))) int virtual_open(const char *path , int flags, ...);
__attribute__ ((visibility("default"))) int virtual_creat(const char *path, mode_t mode );
__attribute__ ((visibility("default"))) int virtual_rename(char *oldname, char *newname );
__attribute__ ((visibility("default"))) int virtual_stat(const char *path, struct stat *buf );
__attribute__ ((visibility("default"))) int virtual_lstat(const char *path, struct stat *buf );
__attribute__ ((visibility("default"))) int virtual_unlink(const char *path );
__attribute__ ((visibility("default"))) int virtual_mkdir(const char *pathname, mode_t mode );
__attribute__ ((visibility("default"))) int virtual_rmdir(const char *pathname );
__attribute__ ((visibility("default"))) DIR *virtual_opendir(const char *pathname );
__attribute__ ((visibility("default"))) FILE *virtual_popen(const char *command, const char *type );
__attribute__ ((visibility("default"))) int virtual_access(const char *pathname, int mode );
# 190 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/TSRM/tsrm_virtual_cwd.h"
__attribute__ ((visibility("default"))) int virtual_utime(const char *filename, struct utimbuf *buf );

__attribute__ ((visibility("default"))) int virtual_chmod(const char *filename, mode_t mode );

__attribute__ ((visibility("default"))) int virtual_chown(const char *filename, uid_t owner, gid_t group, int link );
# 204 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/TSRM/tsrm_virtual_cwd.h"
__attribute__ ((visibility("default"))) int virtual_file_ex(cwd_state *state, const char *path, verify_path_func verify_path, int use_realpath );

__attribute__ ((visibility("default"))) char *tsrm_realpath(const char *path, char *real_path );




typedef struct _realpath_cache_bucket {
 unsigned long key;
 char *path;
 int path_len;
 char *realpath;
 int realpath_len;
 int is_dir;
 time_t expires;






 struct _realpath_cache_bucket *next;
} realpath_cache_bucket;

typedef struct _virtual_cwd_globals {
 cwd_state cwd;
 long realpath_cache_size;
 long realpath_cache_size_limit;
 long realpath_cache_ttl;
 realpath_cache_bucket *realpath_cache[1024];
} virtual_cwd_globals;





extern virtual_cwd_globals cwd_globals;



__attribute__ ((visibility("default"))) void realpath_cache_clean(void);
__attribute__ ((visibility("default"))) void realpath_cache_del(const char *path, int path_len );
__attribute__ ((visibility("default"))) realpath_cache_bucket* realpath_cache_lookup(const char *path, int path_len, time_t t );
__attribute__ ((visibility("default"))) int realpath_cache_size(void);
__attribute__ ((visibility("default"))) int realpath_cache_max_buckets(void);
__attribute__ ((visibility("default"))) realpath_cache_bucket** realpath_cache_get_buckets(void);
# 43 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_execute.c" 2







typedef int (*incdec_t)(zval *);







static void zend_extension_statement_handler(const zend_extension *extension, zend_op_array *op_array );
static void zend_extension_fcall_begin_handler(const zend_extension *extension, zend_op_array *op_array );
static void zend_extension_fcall_end_handler(const zend_extension *extension, zend_op_array *op_array );
# 69 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_execute.c"
static inline __attribute__((always_inline)) void zend_pzval_unlock_func(zval *z, zend_free_op *should_free, int unref )
{
 if (!zval_delref_p(z)) {
  zval_set_refcount_p(z, 1);
  zval_unset_isref_p(z);
  should_free->var = z;

 } else {
  should_free->var = 0;
  if (unref && zval_isref_p(z) && zval_refcount_p(z) == 1) {
   zval_unset_isref_p(z);
  }
  gc_zval_check_possible_root((z) );
 }
}

static inline __attribute__((always_inline)) void zend_pzval_unlock_free_func(zval *z )
{
 if (!zval_delref_p(z)) {
  if (z != &(executor_globals.uninitialized_zval)) {
   if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); };
   _zval_dtor((z) );
   _efree((z) );
  }
 }
}
# 170 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_execute.c"
__attribute__ ((visibility("default"))) zval** zend_get_compiled_variable_value(const zend_execute_data *execute_data_ptr, zend_uint var)
{
 return execute_data_ptr->CVs[var];
}

static inline __attribute__((always_inline)) zval *_get_zval_ptr_tmp(zend_uint var, const temp_variable *Ts, zend_free_op *should_free )
{
 return should_free->var = &(*(temp_variable *)((char *) Ts + var)).tmp_var;
}

static inline __attribute__((always_inline)) zval *_get_zval_ptr_var(zend_uint var, const temp_variable *Ts, zend_free_op *should_free )
{
 zval *ptr = (*(temp_variable *)((char *) Ts + var)).var.ptr;

 zend_pzval_unlock_func(ptr, should_free, 1 );
 return ptr;
}

static __attribute__((noinline)) zval **_get_zval_cv_lookup(zval ***ptr, zend_uint var, int type )
{
 zend_compiled_variable *cv = &((executor_globals.active_op_array)->vars[var]);

 if (!(executor_globals.active_symbol_table) ||
     zend_hash_quick_find((executor_globals.active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, (void **)ptr)==-1) {
  switch (type) {
   case 0:
   case 6:
    zend_error((1<<3L), "Undefined variable: %s", cv->name);

   case 3:
    return &(executor_globals.uninitialized_zval_ptr);
    break;
   case 2:
    zend_error((1<<3L), "Undefined variable: %s", cv->name);

   case 1:
    zval_addref_p(&((executor_globals.uninitialized_zval)));
    if (!(executor_globals.active_symbol_table)) {
     *ptr = (zval**)(executor_globals.current_execute_data)->CVs + ((executor_globals.active_op_array)->last_var + var);
     **ptr = &(executor_globals.uninitialized_zval);
    } else {
     _zend_hash_quick_add_or_update((executor_globals.active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, &(executor_globals.uninitialized_zval_ptr), sizeof(zval *), (void **)ptr, (1<<0) );
    }
    break;
  }
 }
 return *ptr;
}

static __attribute__((noinline)) zval **_get_zval_cv_lookup_BP_VAR_R(zval ***ptr, zend_uint var )
{
 zend_compiled_variable *cv = &((executor_globals.active_op_array)->vars[var]);

 if (!(executor_globals.active_symbol_table) ||
     zend_hash_quick_find((executor_globals.active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, (void **)ptr)==-1) {
  zend_error((1<<3L), "Undefined variable: %s", cv->name);
  return &(executor_globals.uninitialized_zval_ptr);
 }
 return *ptr;
}

static __attribute__((noinline)) zval **_get_zval_cv_lookup_BP_VAR_UNSET(zval ***ptr, zend_uint var )
{
 zend_compiled_variable *cv = &((executor_globals.active_op_array)->vars[var]);

 if (!(executor_globals.active_symbol_table) ||
     zend_hash_quick_find((executor_globals.active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, (void **)ptr)==-1) {
  zend_error((1<<3L), "Undefined variable: %s", cv->name);
  return &(executor_globals.uninitialized_zval_ptr);
 }
 return *ptr;
}

static __attribute__((noinline)) zval **_get_zval_cv_lookup_BP_VAR_IS(zval ***ptr, zend_uint var )
{
 zend_compiled_variable *cv = &((executor_globals.active_op_array)->vars[var]);

 if (!(executor_globals.active_symbol_table) ||
     zend_hash_quick_find((executor_globals.active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, (void **)ptr)==-1) {
  return &(executor_globals.uninitialized_zval_ptr);
 }
 return *ptr;
}

static __attribute__((noinline)) zval **_get_zval_cv_lookup_BP_VAR_RW(zval ***ptr, zend_uint var )
{
 zend_compiled_variable *cv = &((executor_globals.active_op_array)->vars[var]);

 if (!(executor_globals.active_symbol_table)) {
  zval_addref_p(&((executor_globals.uninitialized_zval)));
  *ptr = (zval**)(executor_globals.current_execute_data)->CVs + ((executor_globals.active_op_array)->last_var + var);
  **ptr = &(executor_globals.uninitialized_zval);
  zend_error((1<<3L), "Undefined variable: %s", cv->name);
 } else if (zend_hash_quick_find((executor_globals.active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, (void **)ptr)==-1) {
  zval_addref_p(&((executor_globals.uninitialized_zval)));
  _zend_hash_quick_add_or_update((executor_globals.active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, &(executor_globals.uninitialized_zval_ptr), sizeof(zval *), (void **)ptr, (1<<0) );
  zend_error((1<<3L), "Undefined variable: %s", cv->name);
 }
 return *ptr;
}

static __attribute__((noinline)) zval **_get_zval_cv_lookup_BP_VAR_W(zval ***ptr, zend_uint var )
{
 zend_compiled_variable *cv = &((executor_globals.active_op_array)->vars[var]);

 if (!(executor_globals.active_symbol_table)) {
  zval_addref_p(&((executor_globals.uninitialized_zval)));
  *ptr = (zval**)(executor_globals.current_execute_data)->CVs + ((executor_globals.active_op_array)->last_var + var);
  **ptr = &(executor_globals.uninitialized_zval);
 } else if (zend_hash_quick_find((executor_globals.active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, (void **)ptr)==-1) {
  zval_addref_p(&((executor_globals.uninitialized_zval)));
  _zend_hash_quick_add_or_update((executor_globals.active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, &(executor_globals.uninitialized_zval_ptr), sizeof(zval *), (void **)ptr, (1<<0) );
 }
 return *ptr;
}

static inline __attribute__((always_inline)) zval *_get_zval_ptr_cv(zend_uint var, int type )
{
 zval ***ptr = &((executor_globals.current_execute_data)->CVs[var]);

 if (__builtin_expect(*ptr == ((void *)0), 0)) {
  return *_get_zval_cv_lookup(ptr, var, type );
 }
 return **ptr;
}

static inline __attribute__((always_inline)) zval *_get_zval_ptr_cv_BP_VAR_R(zval ***CVs, zend_uint var )
{
 zval ***ptr = &CVs[var];

 if (__builtin_expect(*ptr == ((void *)0), 0)) {
  return *_get_zval_cv_lookup_BP_VAR_R(ptr, var );
 }
 return **ptr;
}

static inline __attribute__((always_inline)) zval *_get_zval_ptr_cv_BP_VAR_UNSET(zval ***CVs, zend_uint var )
{
 zval ***ptr = &CVs[var];

 if (__builtin_expect(*ptr == ((void *)0), 0)) {
  return *_get_zval_cv_lookup_BP_VAR_UNSET(ptr, var );
 }
 return **ptr;
}

static inline __attribute__((always_inline)) zval *_get_zval_ptr_cv_BP_VAR_IS(zval ***CVs, zend_uint var )
{
 zval ***ptr = &CVs[var];

 if (__builtin_expect(*ptr == ((void *)0), 0)) {
  return *_get_zval_cv_lookup_BP_VAR_IS(ptr, var );
 }
 return **ptr;
}

static inline __attribute__((always_inline)) zval *_get_zval_ptr_cv_BP_VAR_RW(zval ***CVs, zend_uint var )
{
 zval ***ptr = &CVs[var];

 if (__builtin_expect(*ptr == ((void *)0), 0)) {
  return *_get_zval_cv_lookup_BP_VAR_RW(ptr, var );
 }
 return **ptr;
}

static inline __attribute__((always_inline)) zval *_get_zval_ptr_cv_BP_VAR_W(zval ***CVs, zend_uint var )
{
 zval ***ptr = &CVs[var];

 if (__builtin_expect(*ptr == ((void *)0), 0)) {
  return *_get_zval_cv_lookup_BP_VAR_W(ptr, var );
 }
 return **ptr;
}

static inline zval *_get_zval_ptr(int op_type, const znode_op *node, const temp_variable *Ts, zend_free_op *should_free, int type )
{

 switch (op_type) {
  case (1<<0):
   should_free->var = 0;
   return node->zv;
   break;
  case (1<<1):
   should_free->var = (zval*)(((zend_uintptr_t)(&(*(temp_variable *)((char *) Ts + node->var)).tmp_var)) | 1L);
   return &(*(temp_variable *)((char *) Ts + node->var)).tmp_var;
   break;
  case (1<<2):
   return _get_zval_ptr_var(node->var, Ts, should_free );
   break;
  case (1<<3):
   should_free->var = 0;
   return ((void *)0);
   break;
  case (1<<4):
   should_free->var = 0;
   return _get_zval_ptr_cv(node->var, type );
   break;
 
 }
 return ((void *)0);
}

static inline __attribute__((always_inline)) zval **_get_zval_ptr_ptr_var(zend_uint var, const temp_variable *Ts, zend_free_op *should_free )
{
 zval** ptr_ptr = (*(temp_variable *)((char *) Ts + var)).var.ptr_ptr;

 if (__builtin_expect(ptr_ptr != ((void *)0), 1)) {
  zend_pzval_unlock_func(*ptr_ptr, should_free, 1 );
 } else {

  zend_pzval_unlock_func((*(temp_variable *)((char *) Ts + var)).str_offset.str, should_free, 1 );
 }
 return ptr_ptr;
}

static inline __attribute__((always_inline)) zval **_get_zval_ptr_ptr_cv(zend_uint var, int type )
{
 zval ***ptr = &((executor_globals.current_execute_data)->CVs[var]);

 if (__builtin_expect(*ptr == ((void *)0), 0)) {
  return _get_zval_cv_lookup(ptr, var, type );
 }
 return *ptr;
}

static inline __attribute__((always_inline)) zval **_get_zval_ptr_ptr_cv_BP_VAR_R(zval ***CVs, zend_uint var )
{
 zval ***ptr = &CVs[var];

 if (__builtin_expect(*ptr == ((void *)0), 0)) {
  return _get_zval_cv_lookup_BP_VAR_R(ptr, var );
 }
 return *ptr;
}

static inline __attribute__((always_inline)) zval **_get_zval_ptr_ptr_cv_BP_VAR_UNSET(zval ***CVs, zend_uint var )
{
 zval ***ptr = &CVs[var];

 if (__builtin_expect(*ptr == ((void *)0), 0)) {
  return _get_zval_cv_lookup_BP_VAR_UNSET(ptr, var );
 }
 return *ptr;
}

static inline __attribute__((always_inline)) zval **_get_zval_ptr_ptr_cv_BP_VAR_IS(zval ***CVs, zend_uint var )
{
 zval ***ptr = &CVs[var];

 if (__builtin_expect(*ptr == ((void *)0), 0)) {
  return _get_zval_cv_lookup_BP_VAR_IS(ptr, var );
 }
 return *ptr;
}

static inline __attribute__((always_inline)) zval **_get_zval_ptr_ptr_cv_BP_VAR_RW(zval ***CVs, zend_uint var )
{
 zval ***ptr = &CVs[var];

 if (__builtin_expect(*ptr == ((void *)0), 0)) {
  return _get_zval_cv_lookup_BP_VAR_RW(ptr, var );
 }
 return *ptr;
}

static inline __attribute__((always_inline)) zval **_get_zval_ptr_ptr_cv_BP_VAR_W(zval ***CVs, zend_uint var )
{
 zval ***ptr = &CVs[var];

 if (__builtin_expect(*ptr == ((void *)0), 0)) {
  return _get_zval_cv_lookup_BP_VAR_W(ptr, var );
 }
 return *ptr;
}

static inline zval **_get_zval_ptr_ptr(int op_type, const znode_op *node, const temp_variable *Ts, zend_free_op *should_free, int type )
{
 if (op_type == (1<<4)) {
  should_free->var = 0;
  return _get_zval_ptr_ptr_cv(node->var, type );
 } else if (op_type == (1<<2)) {
  return _get_zval_ptr_ptr_var(node->var, Ts, should_free );
 } else {
  should_free->var = 0;
  return ((void *)0);
 }
}

static inline __attribute__((always_inline)) zval *_get_obj_zval_ptr_unused(void)
{
 if (__builtin_expect((executor_globals.This) != ((void *)0), 1)) {
  return (executor_globals.This);
 } else {
  zend_error_noreturn((1<<0L), "Using $this when not in object context");
  return ((void *)0);
 }
}

static inline zval **_get_obj_zval_ptr_ptr(int op_type, const znode_op *op, const temp_variable *Ts, zend_free_op *should_free, int type )
{
 if (op_type == (1<<3)) {
  if (__builtin_expect((executor_globals.This) != ((void *)0), 1)) {


   should_free->var = 0;
   return &(executor_globals.This);
  } else {
   zend_error_noreturn((1<<0L), "Using $this when not in object context");
  }
 }
 return _get_zval_ptr_ptr(op_type, op, Ts, should_free, type );
}

static inline __attribute__((always_inline)) zval **_get_obj_zval_ptr_ptr_unused(void)
{
 if (__builtin_expect((executor_globals.This) != ((void *)0), 1)) {
  return &(executor_globals.This);
 } else {
  zend_error_noreturn((1<<0L), "Using $this when not in object context");
  return ((void *)0);
 }
}

static inline zval *_get_obj_zval_ptr(int op_type, znode_op *op, const temp_variable *Ts, zend_free_op *should_free, int type )
{
 if (op_type == (1<<3)) {
  if (__builtin_expect((executor_globals.This) != ((void *)0), 1)) {
   should_free->var = 0;
   return (executor_globals.This);
  } else {
   zend_error_noreturn((1<<0L), "Using $this when not in object context");
  }
 }
 return _get_zval_ptr(op_type, op, Ts, should_free, type );
}

static void zend_assign_to_variable_reference(zval **variable_ptr_ptr, zval **value_ptr_ptr )
{
 zval *variable_ptr = *variable_ptr_ptr;
 zval *value_ptr = *value_ptr_ptr;

 if (variable_ptr == &(executor_globals.error_zval) || value_ptr == &(executor_globals.error_zval)) {
  variable_ptr_ptr = &(executor_globals.uninitialized_zval_ptr);
 } else if (variable_ptr != value_ptr) {
  if (!zval_isref_p(value_ptr)) {

   zval_delref_p(value_ptr);
   if (zval_refcount_p(value_ptr)>0) {
    do { (*value_ptr_ptr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(*value_ptr_ptr))->u.buffered = ((void *)0); } while (0);
    do { (*value_ptr_ptr)->value = (value_ptr)->value; (**value_ptr_ptr).type = (*value_ptr).type; } while (0);
    value_ptr = *value_ptr_ptr;
    _zval_copy_ctor((&(*value_ptr)) );
   }
   zval_set_refcount_p(value_ptr, 1);
   zval_set_isref_p(value_ptr);
  }

  *variable_ptr_ptr = value_ptr;
  zval_addref_p(value_ptr);

  i_zval_ptr_dtor(*(&variable_ptr) );
 } else if (!zval_isref_p(variable_ptr)) {
  if (variable_ptr_ptr == value_ptr_ptr) {
   do { if (zval_refcount_p(*((variable_ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(variable_ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(variable_ptr_ptr))->value; (*new_zv).type = (**(variable_ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(variable_ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0);
  } else if (variable_ptr==&(executor_globals.uninitialized_zval)
   || zval_refcount_p(variable_ptr)>2) {

   zval_set_refcount_p(variable_ptr, zval_refcount_p(variable_ptr) - 2);
   do { (*variable_ptr_ptr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(*variable_ptr_ptr))->u.buffered = ((void *)0); } while (0);
   do { (*variable_ptr_ptr)->value = (variable_ptr)->value; (**variable_ptr_ptr).type = (*variable_ptr).type; } while (0);
   _zval_copy_ctor((*variable_ptr_ptr) );
   *value_ptr_ptr = *variable_ptr_ptr;
   zval_set_refcount_p(*(variable_ptr_ptr), 2);
  }
  zval_set_isref_p(*(variable_ptr_ptr));
 }
}


static inline void make_real_object(zval **object_ptr )
{
 if ((**object_ptr).type == 0
  || ((**object_ptr).type == 3 && (**object_ptr).value.lval == 0)
  || ((**object_ptr).type == 6 && (**object_ptr).value.str.len == 0)
 ) {
  zend_error((1<<1L), "Creating default object from empty value");

  if (!zval_isref_p(*object_ptr)) { do { if (zval_refcount_p(*((object_ptr))) > 1) { zval *new_zv; zval_delref_p(*(object_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(object_ptr))->value; (*new_zv).type = (**(object_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(object_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  _zval_dtor((*object_ptr) );
  _object_init((*object_ptr) );
 }
}

__attribute__ ((visibility("default"))) char * zend_verify_arg_class_kind(const zend_arg_info *cur_arg_info, ulong fetch_type, const char **class_name, zend_class_entry **pce )
{
 *pce = zend_fetch_class(cur_arg_info->class_name, cur_arg_info->class_name_len, (fetch_type | 5 | 0x80) );

 *class_name = (*pce) ? (*pce)->name: cur_arg_info->class_name;
 if (*pce && (*pce)->ce_flags & 0x80) {
  return "implement interface ";
 } else {
  return "be an instance of ";
 }
}

__attribute__ ((visibility("default"))) int zend_verify_arg_error(int error_type, const zend_function *zf, zend_uint arg_num, const char *need_msg, const char *need_kind, const char *given_msg, char *given_kind )
{
 zend_execute_data *ptr = (executor_globals.current_execute_data)->prev_execute_data;
 char *fname = zf->common.function_name;
 char *fsep;
 const char *fclass;

 if (zf->common.scope) {
  fsep = "::";
  fclass = zf->common.scope->name;
 } else {
  fsep = "";
  fclass = "";
 }

 if (ptr && ptr->op_array) {
  zend_error(error_type, "Argument %d passed to %s%s%s() must %s%s, %s%s given, called in %s on line %d and defined", arg_num, fclass, fsep, fname, need_msg, need_kind, given_msg, given_kind, ptr->op_array->filename, ptr->opline->lineno);
 } else {
  zend_error(error_type, "Argument %d passed to %s%s%s() must %s%s, %s%s given", arg_num, fclass, fsep, fname, need_msg, need_kind, given_msg, given_kind);
 }
 return 0;
}

static inline int zend_verify_arg_type(zend_function *zf, zend_uint arg_num, zval *arg, ulong fetch_type )
{
 zend_arg_info *cur_arg_info;
 char *need_msg;
 zend_class_entry *ce;

 if (!zf->common.arg_info
  || arg_num>zf->common.num_args) {
  return 1;
 }

 cur_arg_info = &zf->common.arg_info[arg_num-1];

 if (cur_arg_info->class_name) {
  const char *class_name;

  if (!arg) {
   need_msg = zend_verify_arg_class_kind(cur_arg_info, fetch_type, &class_name, &ce );
   return zend_verify_arg_error((1<<12L), zf, arg_num, need_msg, class_name, "none", "" );
  }
  if ((*arg).type == 5) {
   need_msg = zend_verify_arg_class_kind(cur_arg_info, fetch_type, &class_name, &ce );
   if (!ce || !instanceof_function(zend_get_class_entry(&(*arg) ), ce )) {
    return zend_verify_arg_error((1<<12L), zf, arg_num, need_msg, class_name, "instance of ", zend_get_class_entry(&(*arg) )->name );
   }
  } else if ((*arg).type != 0 || !cur_arg_info->allow_null) {
   need_msg = zend_verify_arg_class_kind(cur_arg_info, fetch_type, &class_name, &ce );
   return zend_verify_arg_error((1<<12L), zf, arg_num, need_msg, class_name, zend_zval_type_name(arg), "" );
  }
 } else if (cur_arg_info->type_hint && cur_arg_info->type_hint == 4) {
  if (!arg) {
   return zend_verify_arg_error((1<<12L), zf, arg_num, "be of the type array", "", "none", "" );
  }

  if ((*arg).type != 4 && ((*arg).type != 0 || !cur_arg_info->allow_null)) {
   return zend_verify_arg_error((1<<12L), zf, arg_num, "be of the type array", "", zend_zval_type_name(arg), "" );
  }
 }
 return 1;
}

static inline void zend_assign_to_object(zval **retval, zval **object_ptr, zval *property_name, int value_type, znode_op *value_op, const temp_variable *Ts, int opcode, const zend_literal *key )
{
 zval *object = *object_ptr;
 zend_free_op free_value;
  zval *value = _get_zval_ptr(value_type, value_op, Ts, &free_value, 0 );

 if ((*object).type != 5) {
  if (object == &(executor_globals.error_zval)) {
    if (retval) {
    *retval = &(executor_globals.uninitialized_zval);
    zval_addref_p((*retval));
   }
   if (free_value.var) { if ((zend_uintptr_t)free_value.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_value.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_value.var) ); } };
   return;
  }
  if ((*object).type == 0 ||
      ((*object).type == 3 && (*object).value.lval == 0) ||
      ((*object).type == 6 && (*object).value.str.len == 0)) {
   if (!zval_isref_p(*object_ptr)) { do { if (zval_refcount_p(*((object_ptr))) > 1) { zval *new_zv; zval_delref_p(*(object_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(object_ptr))->value; (*new_zv).type = (**(object_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(object_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
   _zval_dtor((*object_ptr) );
   _object_init((*object_ptr) );
   object = *object_ptr;
   zend_error((1<<1L), "Creating default object from empty value");
  } else {
   zend_error((1<<1L), "Attempt to assign property of non-object");
   if (retval) {
    *retval = &(executor_globals.uninitialized_zval);
    zval_addref_p((*retval));
   }
   if (free_value.var) { if ((zend_uintptr_t)free_value.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_value.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_value.var) ); } };
   return;
  }
 }


 if (value_type == (1<<1)) {
  zval *orig_value = value;

  do { (value) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(value))->u.buffered = ((void *)0); } while (0);
  do { (value)->value = (orig_value)->value; (*value).type = (*orig_value).type; } while (0);
  zval_unset_isref_p(value);
  zval_set_refcount_p(value, 0);
 } else if (value_type == (1<<0)) {
  zval *orig_value = value;

  do { (value) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(value))->u.buffered = ((void *)0); } while (0);
  do { (value)->value = (orig_value)->value; (*value).type = (*orig_value).type; } while (0);
  zval_unset_isref_p(value);
  zval_set_refcount_p(value, 0);
  _zval_copy_ctor((value) );
 }


 zval_addref_p(value);
 if (opcode == 136) {
  if (!(*object).value.obj.handlers->write_property) {
   zend_error((1<<1L), "Attempt to assign property of non-object");
   if (retval) {
    *retval = &(executor_globals.uninitialized_zval);
    zval_addref_p((&(executor_globals.uninitialized_zval)));
   }
   if (value_type == (1<<1)) {
    do { if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)value)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(value ); }; _efree((value) ); } while (0);
   } else if (value_type == (1<<0)) {
    i_zval_ptr_dtor(*(&value) );
   }
   if (free_value.var) { if ((zend_uintptr_t)free_value.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_value.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_value.var) ); } };
   return;
  }
  (*object).value.obj.handlers->write_property(object, property_name, value, key );
 } else {

  if (!(*object).value.obj.handlers->write_dimension) {
   zend_error_noreturn((1<<0L), "Cannot use object as array");
  }
  (*object).value.obj.handlers->write_dimension(object, property_name, value );
 }

 if (retval && !(executor_globals.exception)) {
  *retval = value;
  zval_addref_p((value));
 }
 i_zval_ptr_dtor(*(&value) );
 if (free_value.var != ((void *)0) && (((zend_uintptr_t)free_value.var & 1L) == 0)) { i_zval_ptr_dtor(*(&free_value.var) ); };
}

static inline int zend_assign_to_string_offset(const temp_variable *T, const zval *value, int value_type )
{
 if ((*T->str_offset.str).type == 6) {

  if (((int)T->str_offset.offset < 0)) {
   zend_error((1<<1L), "Illegal string offset:  %d", T->str_offset.offset);
   return 0;
  }

  if (T->str_offset.offset >= (*T->str_offset.str).value.str.len) {
   if (((((*T->str_offset.str).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*T->str_offset.str).value.str.val) < (compiler_globals.interned_strings_end)))) {
    char *tmp = (char *) _emalloc((T->str_offset.offset+1+1) );

    memcpy(tmp, (*T->str_offset.str).value.str.val, T->str_offset.offset+1+1);
    (*T->str_offset.str).value.str.val = tmp;
   } else {
    (*T->str_offset.str).value.str.val = (char *) _erealloc(((*T->str_offset.str).value.str.val), (T->str_offset.offset+1+1), 0 );
   }
   memset((*T->str_offset.str).value.str.val + (*T->str_offset.str).value.str.len,
          ' ',
          T->str_offset.offset - (*T->str_offset.str).value.str.len);
   (*T->str_offset.str).value.str.val[T->str_offset.offset+1] = 0;
   (*T->str_offset.str).value.str.len = T->str_offset.offset+1;
  } else if (((((*T->str_offset.str).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*T->str_offset.str).value.str.val) < (compiler_globals.interned_strings_end)))) {
   char *tmp = (char *) _emalloc(((*T->str_offset.str).value.str.len + 1) );

   memcpy(tmp, (*T->str_offset.str).value.str.val, (*T->str_offset.str).value.str.len + 1);
   (*T->str_offset.str).value.str.val = tmp;
  }

  if ((*value).type != 6) {
   zval tmp;

   do { (&tmp)->value = (value)->value; (*&tmp).type = (*value).type; } while (0);
   if (value_type != (1<<1)) {
    _zval_copy_ctor((&tmp) );
   }
   if ((&tmp)->type != 6) { _convert_to_string((&tmp) ); };
   (*T->str_offset.str).value.str.val[T->str_offset.offset] = (tmp).value.str.val[0];
   if ((tmp).value.str.val && !((((tmp).value.str.val) >= (compiler_globals.interned_strings_start)) && (((tmp).value.str.val) < (compiler_globals.interned_strings_end)))) { _efree(((tmp).value.str.val) ); };
  } else {
   (*T->str_offset.str).value.str.val[T->str_offset.offset] = (*value).value.str.val[0];
   if (value_type == (1<<1)) {



    if ((*value).value.str.val && !((((*value).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*value).value.str.val) < (compiler_globals.interned_strings_end)))) { _efree(((*value).value.str.val) ); };
   }
  }




 }
 return 1;
}


static inline zval* zend_assign_tmp_to_variable(zval **variable_ptr_ptr, zval *value )
{
 zval *variable_ptr = *variable_ptr_ptr;
 zval garbage;

 if ((*variable_ptr).type == 5 &&
     __builtin_expect(((*variable_ptr)).value.obj.handlers->set != ((void *)0), 0)) {
  ((*variable_ptr)).value.obj.handlers->set(variable_ptr_ptr, value );
  return variable_ptr;
 }

  if (__builtin_expect(zval_refcount_p(variable_ptr) > 1, 0) &&
      __builtin_expect(!zval_isref_p(variable_ptr), 1)) {

  zval_delref_p(variable_ptr);
  gc_zval_check_possible_root((variable_ptr) );
  do { (variable_ptr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(variable_ptr))->u.buffered = ((void *)0); } while (0);
  do { do { (variable_ptr)->value = (value)->value; (*variable_ptr).type = (*value).type; } while (0); zval_set_refcount_p(variable_ptr, 1); zval_unset_isref_p(variable_ptr); } while (0);
  *variable_ptr_ptr = variable_ptr;
  return variable_ptr;
 } else {
  if (__builtin_expect((*variable_ptr).type <= 3, 1)) {

   do { (variable_ptr)->value = (value)->value; (*variable_ptr).type = (*value).type; } while (0);
  } else {
   do { (&garbage)->value = (variable_ptr)->value; (*&garbage).type = (*variable_ptr).type; } while (0);
   do { (variable_ptr)->value = (value)->value; (*variable_ptr).type = (*value).type; } while (0);
   _zval_dtor_func(&garbage );
  }
  return variable_ptr;
 }
}

static inline zval* zend_assign_const_to_variable(zval **variable_ptr_ptr, zval *value )
{
 zval *variable_ptr = *variable_ptr_ptr;
 zval garbage;

 if ((*variable_ptr).type == 5 &&
     __builtin_expect(((*variable_ptr)).value.obj.handlers->set != ((void *)0), 0)) {
  ((*variable_ptr)).value.obj.handlers->set(variable_ptr_ptr, value );
  return variable_ptr;
 }

  if (__builtin_expect(zval_refcount_p(variable_ptr) > 1, 0) &&
      __builtin_expect(!zval_isref_p(variable_ptr), 1)) {

  zval_delref_p(variable_ptr);
  gc_zval_check_possible_root((variable_ptr) );
  do { (variable_ptr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(variable_ptr))->u.buffered = ((void *)0); } while (0);
  do { do { (variable_ptr)->value = (value)->value; (*variable_ptr).type = (*value).type; } while (0); zval_set_refcount_p(variable_ptr, 1); zval_unset_isref_p(variable_ptr); } while (0);
  _zval_copy_ctor((variable_ptr) );
  *variable_ptr_ptr = variable_ptr;
  return variable_ptr;
  } else {
  if (__builtin_expect((*variable_ptr).type <= 3, 1)) {

   do { (variable_ptr)->value = (value)->value; (*variable_ptr).type = (*value).type; } while (0);
   _zval_copy_ctor((&(*variable_ptr)) );
  } else {
   do { (&garbage)->value = (variable_ptr)->value; (*&garbage).type = (*variable_ptr).type; } while (0);
   do { (variable_ptr)->value = (value)->value; (*variable_ptr).type = (*value).type; } while (0);
   _zval_copy_ctor((&(*variable_ptr)) );
   _zval_dtor_func(&garbage );
  }
  return variable_ptr;
 }
}

static inline zval* zend_assign_to_variable(zval **variable_ptr_ptr, zval *value )
{
 zval *variable_ptr = *variable_ptr_ptr;
 zval garbage;

 if ((*variable_ptr).type == 5 &&
     __builtin_expect(((*variable_ptr)).value.obj.handlers->set != ((void *)0), 0)) {
  ((*variable_ptr)).value.obj.handlers->set(variable_ptr_ptr, value );
  return variable_ptr;
 }

  if (__builtin_expect(!zval_isref_p(variable_ptr), 1)) {
  if (zval_refcount_p(variable_ptr)==1) {
   if (__builtin_expect(variable_ptr == value, 0)) {
    return variable_ptr;
   } else if (__builtin_expect(!zval_isref_p(value), 1)) {
    zval_addref_p(value);
    *variable_ptr_ptr = value;
    if (__builtin_expect(variable_ptr != &(executor_globals.uninitialized_zval), 1)) {
     if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)variable_ptr)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(variable_ptr ); };
     _zval_dtor((variable_ptr) );
     _efree((variable_ptr) );
    } else {
     zval_delref_p(variable_ptr);
    }
    return value;
   } else {
    goto copy_value;
   }
  } else {
   zval_delref_p(variable_ptr);
   gc_zval_check_possible_root((variable_ptr) );
   if (zval_isref_p(value) && zval_refcount_p(value) > 0) {
    do { (variable_ptr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(variable_ptr))->u.buffered = ((void *)0); } while (0);
    *variable_ptr_ptr = variable_ptr;
    do { do { (variable_ptr)->value = (value)->value; (*variable_ptr).type = (*value).type; } while (0); zval_set_refcount_p(variable_ptr, 1); zval_unset_isref_p(variable_ptr); } while (0);
    _zval_copy_ctor((variable_ptr) );
    return variable_ptr;
   } else {
    *variable_ptr_ptr = value;
    zval_addref_p(value);
    zval_unset_isref_p(value);
    return value;
   }
  }
  } else {
  if (__builtin_expect(variable_ptr != value, 1)) {
copy_value:
   if (__builtin_expect((*variable_ptr).type <= 3, 1)) {

    do { (variable_ptr)->value = (value)->value; (*variable_ptr).type = (*value).type; } while (0);
    _zval_copy_ctor((&(*variable_ptr)) );
   } else {
    do { (&garbage)->value = (variable_ptr)->value; (*&garbage).type = (*variable_ptr).type; } while (0);
    do { (variable_ptr)->value = (value)->value; (*variable_ptr).type = (*value).type; } while (0);
    _zval_copy_ctor((&(*variable_ptr)) );
    _zval_dtor_func(&garbage );
   }
  }
  return variable_ptr;
 }
}


static void zend_extension_statement_handler(const zend_extension *extension, zend_op_array *op_array )
{
 if (extension->statement_handler) {
  extension->statement_handler(op_array);
 }
}


static void zend_extension_fcall_begin_handler(const zend_extension *extension, zend_op_array *op_array )
{
 if (extension->fcall_begin_handler) {
  extension->fcall_begin_handler(op_array);
 }
}


static void zend_extension_fcall_end_handler(const zend_extension *extension, zend_op_array *op_array )
{
 if (extension->fcall_end_handler) {
  extension->fcall_end_handler(op_array);
 }
}


static inline HashTable *zend_get_target_symbol_table(int fetch_type )
{
 switch (fetch_type) {
  case 0x10000000:
   if (!(executor_globals.active_symbol_table)) {
    zend_rebuild_symbol_table();
   }
   return (executor_globals.active_symbol_table);
   break;
  case 0x00000000:
  case 0x40000000:
   return &(executor_globals.symbol_table);
   break;
  case 0x20000000:
   if (!(executor_globals.active_op_array)->static_variables) {
    ((executor_globals.active_op_array)->static_variables) = (HashTable *) _emalloc((sizeof(HashTable)) );
    _zend_hash_init(((executor_globals.active_op_array)->static_variables), (2), (((void *)0)), ((void (*)(void *)) _zval_ptr_dtor), (0) );
   }
   return (executor_globals.active_op_array)->static_variables;
   break;
 
 }
 return ((void *)0);
}

static inline zval **zend_fetch_dimension_address_inner(HashTable *ht, const zval *dim, int dim_type, int type )
{
 zval **retval;
 char *offset_key;
 int offset_key_length;
 ulong hval;

 switch (dim->type) {
  case 0:
   offset_key = "";
   offset_key_length = 0;
   hval = zend_inline_hash_func("", 1);
   goto fetch_string_dim;

  case 6:

   offset_key = dim->value.str.val;
   offset_key_length = dim->value.str.len;

   if (dim_type == (1<<0)) {
    hval = (((zend_literal*)(dim))->hash_value);
   } else {
    do { register const char *tmp = offset_key; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = offset_key + offset_key_length+1 - 1; if ((*end != '\0') || (*tmp == '0' && offset_key_length+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*offset_key == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index; } } } while (0);
    if ((((offset_key) >= (compiler_globals.interned_strings_start)) && ((offset_key) < (compiler_globals.interned_strings_end)))) {
     hval = (((Bucket*)(((char*)(offset_key))-sizeof(Bucket)))->h);
    } else {
     hval = zend_hash_func(offset_key, offset_key_length+1);
    }
   }
fetch_string_dim:
   if (zend_hash_quick_find(ht, offset_key, offset_key_length+1, hval, (void **) &retval) == -1) {
    switch (type) {
     case 0:
      zend_error((1<<3L), "Undefined index: %s", offset_key);

     case 6:
     case 3:
      retval = &(executor_globals.uninitialized_zval_ptr);
      break;
     case 2:
      zend_error((1<<3L),"Undefined index: %s", offset_key);

     case 1: {
       zval *new_zval = &(executor_globals.uninitialized_zval);

       zval_addref_p(new_zval);
       _zend_hash_quick_add_or_update(ht, offset_key, offset_key_length+1, hval, &new_zval, sizeof(zval *), (void **) &retval, (1<<0) );
      }
      break;
    }
   }
   break;
  case 2:
   hval = zend_dval_to_lval((*dim).value.dval);
   goto num_index;
  case 7:
   zend_error((1<<11L), "Resource ID#%ld used as offset, casting to integer (%ld)", (*dim).value.lval, (*dim).value.lval);

  case 3:
  case 1:
   hval = (*dim).value.lval;
num_index:
   if (zend_hash_index_find(ht, hval, (void **) &retval) == -1) {
    switch (type) {
     case 0:
      zend_error((1<<3L),"Undefined offset: %ld", hval);

     case 6:
     case 3:
      retval = &(executor_globals.uninitialized_zval_ptr);
      break;
     case 2:
      zend_error((1<<3L),"Undefined offset: %ld", hval);

     case 1: {
      zval *new_zval = &(executor_globals.uninitialized_zval);

      zval_addref_p(new_zval);
      _zend_hash_index_update_or_next_insert(ht, hval, &new_zval, sizeof(zval *), (void **) &retval, (1<<0) );
     }
     break;
    }
   }
   break;

  default:
   zend_error((1<<1L), "Illegal offset type");
   return (type == 1 || type == 2) ?
    &(executor_globals.error_zval_ptr) : &(executor_globals.uninitialized_zval_ptr);
 }
 return retval;
}

static void zend_fetch_dimension_address(temp_variable *result, zval **container_ptr, zval *dim, int dim_type, int type )
{
 zval *container = *container_ptr;
 zval **retval;

 switch ((*container).type) {

  case 4:
   if (type != 6 && zval_refcount_p(container)>1 && !zval_isref_p(container)) {
    do { if (zval_refcount_p(*((container_ptr))) > 1) { zval *new_zv; zval_delref_p(*(container_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container_ptr))->value; (*new_zv).type = (**(container_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0);
    container = *container_ptr;
   }
fetch_from_array:
   if (dim == ((void *)0)) {
    zval *new_zval = &(executor_globals.uninitialized_zval);

    zval_addref_p(new_zval);
    if (_zend_hash_index_update_or_next_insert((*container).value.ht, 0, &new_zval, sizeof(zval *), (void **) &retval, (1<<2) ) == -1) {
     zend_error((1<<1L), "Cannot add element to the array as the next element is already occupied");
     retval = &(executor_globals.error_zval_ptr);
     zval_delref_p(new_zval);
    }
   } else {
    retval = zend_fetch_dimension_address_inner((*container).value.ht, dim, dim_type, type );
   }
   result->var.ptr_ptr = retval;
   zval_addref_p((*retval));
   return;
   break;

  case 0:
   if (container == &(executor_globals.error_zval)) {
    result->var.ptr_ptr = &(executor_globals.error_zval_ptr);
    zval_addref_p(((executor_globals.error_zval_ptr)));
   } else if (type != 6) {
convert_to_array:
    if (!zval_isref_p(container)) {
     do { if (zval_refcount_p(*((container_ptr))) > 1) { zval *new_zv; zval_delref_p(*(container_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container_ptr))->value; (*new_zv).type = (**(container_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0);
     container = *container_ptr;
    }
    _zval_dtor((container) );
    _array_init((container), 0 );
    goto fetch_from_array;
   } else {

    result->var.ptr_ptr = &(executor_globals.uninitialized_zval_ptr);
    zval_addref_p(((executor_globals.uninitialized_zval_ptr)));
   }
   return;
   break;

  case 6: {
    zval tmp;

    if (type != 6 && (*container).value.str.len==0) {
     goto convert_to_array;
    }
    if (dim == ((void *)0)) {
     zend_error_noreturn((1<<0L), "[] operator not supported for strings");
    }

    if ((*dim).type != 1) {
     switch((*dim).type) {

      case 6:
      case 2:
      case 0:
      case 3:

       break;
      default:
       zend_error((1<<1L), "Illegal offset type");
       break;
     }

     tmp = *dim;
     _zval_copy_ctor((&tmp) );
     convert_to_long(&tmp);
     dim = &tmp;
    }
    if (type != 6) {
     if (!zval_isref_p(*container_ptr)) { do { if (zval_refcount_p(*((container_ptr))) > 1) { zval *new_zv; zval_delref_p(*(container_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container_ptr))->value; (*new_zv).type = (**(container_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
    }
    container = *container_ptr;
    result->str_offset.str = container;
    zval_addref_p((container));
    result->str_offset.offset = (*dim).value.lval;
    result->str_offset.ptr_ptr = ((void *)0);
    return;
   }
   break;

  case 5:
   if (!(*container).value.obj.handlers->read_dimension) {
    zend_error_noreturn((1<<0L), "Cannot use object as array");
   } else {
    zval *overloaded_result;

    if (dim_type == (1<<1)) {
     zval *orig = dim;
     do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((dim))->value; (*_tmp).type = (*(dim)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (dim) = _tmp; } while (0);
     { (*orig).type = 0; };
    }
    overloaded_result = (*container).value.obj.handlers->read_dimension(container, dim, type );

    if (overloaded_result) {
     if (!zval_isref_p(overloaded_result)) {
      if (zval_refcount_p(overloaded_result) > 0) {
       zval *tmp = overloaded_result;

       do { (overloaded_result) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(overloaded_result))->u.buffered = ((void *)0); } while (0);
       do { (overloaded_result)->value = (tmp)->value; (*overloaded_result).type = (*tmp).type; } while (0);
       _zval_copy_ctor((overloaded_result) );
       zval_unset_isref_p(overloaded_result);
       zval_set_refcount_p(overloaded_result, 0);
      }
      if ((*overloaded_result).type != 5) {
       zend_class_entry *ce = zend_get_class_entry(&(*container) );
       zend_error((1<<3L), "Indirect modification of overloaded element of %s has no effect", ce->name);
      }
     }
     retval = &overloaded_result;
    } else {
     retval = &(executor_globals.error_zval_ptr);
    }
    do { temp_variable *__t = (result); __t->var.ptr = (*retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
    zval_addref_p((*retval));
    if (dim_type == (1<<1)) {
     i_zval_ptr_dtor(*(&dim) );
    }
   }
   return;
   break;

  case 3:
   if (type != 6 && (*container).value.lval==0) {
    goto convert_to_array;
   }


  default:
   if (type == 6) {
    zend_error((1<<1L), "Cannot unset offset in a non-array variable");
    do { temp_variable *__t = (result); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
    zval_addref_p((&(executor_globals.uninitialized_zval)));
   } else {
    zend_error((1<<1L), "Cannot use a scalar value as an array");
    result->var.ptr_ptr = &(executor_globals.error_zval_ptr);
    zval_addref_p(((executor_globals.error_zval_ptr)));
   }
   break;
 }
}

static void zend_fetch_dimension_address_read(temp_variable *result, zval **container_ptr, zval *dim, int dim_type, int type )
{
 zval *container = *container_ptr;
 zval **retval;

 switch ((*container).type) {

  case 4:
   retval = zend_fetch_dimension_address_inner((*container).value.ht, dim, dim_type, type );
   do { temp_variable *__t = (result); __t->var.ptr = (*retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   zval_addref_p((*retval));
   return;

  case 0:
   do { temp_variable *__t = (result); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   return;

  case 6: {
    zval tmp;
    zval *ptr;

    if ((*dim).type != 1) {
     switch((*dim).type) {

      case 6:
      case 2:
      case 0:
      case 3:

       break;
      default:
       zend_error((1<<1L), "Illegal offset type");
       break;
     }

     do { (&tmp)->value = (dim)->value; (*&tmp).type = (*dim).type; } while (0);
     _zval_copy_ctor((&tmp) );
     convert_to_long(&tmp);
     dim = &tmp;
    }

    do { (ptr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(ptr))->u.buffered = ((void *)0); } while (0);
    (ptr)->refcount__gc = 1; (ptr)->is_ref__gc = 0;;
    (*ptr).type = 6;

    if ((*dim).value.lval < 0 || (*container).value.str.len <= (*dim).value.lval) {
     zend_error((1<<3L), "Uninitialized string offset: %ld", (*dim).value.lval);
     (*ptr).value.str.val = _estrndup((""), (sizeof("")-1) );
     (*ptr).value.str.len = 0;
    } else {
     (*ptr).value.str.val = (char*)_emalloc((2) );
     (*ptr).value.str.val[0] = (*container).value.str.val[(*dim).value.lval];
     (*ptr).value.str.val[1] = 0;
     (*ptr).value.str.len = 1;
    }
    do { temp_variable *__t = (result); __t->var.ptr = (ptr); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
    return;
   }
   break;

  case 5:
   if (!(*container).value.obj.handlers->read_dimension) {
    zend_error_noreturn((1<<0L), "Cannot use object as array");
   } else {
    zval *overloaded_result;

    if (dim_type == (1<<1)) {
     zval *orig = dim;
     do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((dim))->value; (*_tmp).type = (*(dim)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (dim) = _tmp; } while (0);
     { (*orig).type = 0; };
    }
    overloaded_result = (*container).value.obj.handlers->read_dimension(container, dim, type );

    if (overloaded_result) {
     do { temp_variable *__t = (result); __t->var.ptr = (overloaded_result); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
     zval_addref_p((overloaded_result));
    } else if (result) {
     do { temp_variable *__t = (result); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
     zval_addref_p((&(executor_globals.uninitialized_zval)));
    }
    if (dim_type == (1<<1)) {
     i_zval_ptr_dtor(*(&dim) );
    }
   }
   return;

  default:
   do { temp_variable *__t = (result); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   return;
 }
}

static void zend_fetch_property_address(temp_variable *result, zval **container_ptr, zval *prop_ptr, const zend_literal *key, int type )
{
 zval *container = *container_ptr;;

 if ((*container).type != 5) {
  if (container == &(executor_globals.error_zval)) {
   result->var.ptr_ptr = &(executor_globals.error_zval_ptr);
   zval_addref_p(((executor_globals.error_zval_ptr)));
   return;
  }


  if (type != 6 &&
      (((*container).type == 0 ||
       ((*container).type == 3 && (*container).value.lval==0) ||
       ((*container).type == 6 && (*container).value.str.len==0)))) {
   if (!zval_isref_p(container)) {
    do { if (zval_refcount_p(*((container_ptr))) > 1) { zval *new_zv; zval_delref_p(*(container_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container_ptr))->value; (*new_zv).type = (**(container_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0);
    container = *container_ptr;
   }
   _object_init((container) );
  } else {
   zend_error((1<<1L), "Attempt to modify property of non-object");
   result->var.ptr_ptr = &(executor_globals.error_zval_ptr);
   zval_addref_p(((executor_globals.error_zval_ptr)));
   return;
  }
 }

 if ((*container).value.obj.handlers->get_property_ptr_ptr) {
  zval **ptr_ptr = (*container).value.obj.handlers->get_property_ptr_ptr(container, prop_ptr, key );
  if (((void *)0) == ptr_ptr) {
   zval *ptr;

   if ((*container).value.obj.handlers->read_property &&
    (ptr = (*container).value.obj.handlers->read_property(container, prop_ptr, type, key )) != ((void *)0)) {
    do { temp_variable *__t = (result); __t->var.ptr = (ptr); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
    zval_addref_p((ptr));
   } else {
    zend_error_noreturn((1<<0L), "Cannot access undefined property for object with overloaded property access");
   }
  } else {
   result->var.ptr_ptr = ptr_ptr;
   zval_addref_p((*ptr_ptr));
  }
 } else if ((*container).value.obj.handlers->read_property) {
  zval *ptr = (*container).value.obj.handlers->read_property(container, prop_ptr, type, key );

  do { temp_variable *__t = (result); __t->var.ptr = (ptr); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  zval_addref_p((ptr));
 } else {
  zend_error((1<<1L), "This object doesn't support property references");
  result->var.ptr_ptr = &(executor_globals.error_zval_ptr);
  zval_addref_p(((executor_globals.error_zval_ptr)));
 }
}

static inline zend_brk_cont_element* zend_brk_cont(int nest_levels, int array_offset, const zend_op_array *op_array, const temp_variable *Ts )
{
 int original_nest_levels = nest_levels;
 zend_brk_cont_element *jmp_to;

 do {
  if (array_offset==-1) {
   zend_error_noreturn((1<<0L), "Cannot break/continue %d level%s", original_nest_levels, (original_nest_levels == 1) ? "" : "s");
  }
  jmp_to = &op_array->brk_cont_array[array_offset];
  if (nest_levels>1) {
   zend_op *brk_opline = &op_array->opcodes[jmp_to->brk];

   switch (brk_opline->opcode) {
    case 49:
     if (!(brk_opline->extended_value & (1<<2))) {
      i_zval_ptr_dtor(*(&(*(temp_variable *)((char *) Ts + brk_opline->op1.var)).var.ptr) );
     }
     break;
    case 70:
     if (!(brk_opline->extended_value & (1<<2))) {
      _zval_dtor((&((*(temp_variable *)((char *) Ts + brk_opline->op1.var)).tmp_var)) );
     }
     break;
   }
  }
  array_offset = jmp_to->parent;
 } while (--nest_levels > 0);
 return jmp_to;
}
# 1428 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_execute.c"
__attribute__ ((visibility("default"))) opcode_handler_t *zend_opcode_handlers;

__attribute__ ((visibility("default"))) void execute_internal(zend_execute_data *execute_data_ptr, int return_value_used )
{
 zval **return_value_ptr = &(*(temp_variable *)((char *) execute_data_ptr->Ts + execute_data_ptr->opline->result.var)).var.ptr;
 ((zend_internal_function *) execute_data_ptr->function_state.function)->handler(execute_data_ptr->opline->extended_value, *return_value_ptr, (execute_data_ptr->function_state.function->common.fn_flags & 0x4000000)?return_value_ptr:((void *)0), execute_data_ptr->object, return_value_used );
}
# 1462 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_execute.c"
# 1 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_vm_execute.h" 1
# 24 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_vm_execute.h"
static user_opcode_handler_t zend_user_opcode_handlers[256] = {
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0),
 (user_opcode_handler_t)((void *)0)
};

static zend_uchar zend_user_opcodes[256] = {0,
 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,
 17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,
 33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,
 49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,
 65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,
 81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,
 97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,
 113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,
 129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,
 145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,
 161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,
 177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,
 193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,
 209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,
 225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,
 241,242,243,244,245,246,247,248,249,250,251,252,253,254,255
};

static opcode_handler_t zend_vm_get_opcode_handler(zend_uchar opcode, zend_op* op);
# 342 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_vm_execute.h"
__attribute__ ((visibility("default"))) void execute(zend_op_array *op_array )
{

 zend_execute_data *execute_data;
 zend_bool nested = 0;
 zend_bool original_in_execution = (executor_globals.in_execution);


 if ((executor_globals.exception)) {
  return;
 }

 (executor_globals.in_execution) = 1;

zend_vm_enter:

 execute_data = (zend_execute_data *)zend_vm_stack_alloc(
  (((sizeof(zend_execute_data)) + 4 - 1) & ~(4 -1)) +
  (((sizeof(zval**) * op_array->last_var * ((executor_globals.active_symbol_table) ? 1 : 2)) + 4 - 1) & ~(4 -1)) +
  (((sizeof(temp_variable)) + 4 - 1) & ~(4 -1)) * op_array->T );

 execute_data->CVs = (zval***)((char*)execute_data + (((sizeof(zend_execute_data)) + 4 - 1) & ~(4 -1)));
 memset(execute_data->CVs, 0, sizeof(zval**) * op_array->last_var);
 execute_data->Ts = (temp_variable *)(((char*)execute_data->CVs) + (((sizeof(zval**) * op_array->last_var * ((executor_globals.active_symbol_table) ? 1 : 2)) + 4 - 1) & ~(4 -1)));
 execute_data->fbc = ((void *)0);
 execute_data->called_scope = ((void *)0);
 execute_data->object = ((void *)0);
 execute_data->old_error_reporting = ((void *)0);
 execute_data->op_array = op_array;
 execute_data->symbol_table = (executor_globals.active_symbol_table);
 execute_data->prev_execute_data = (executor_globals.current_execute_data);
 (executor_globals.current_execute_data) = execute_data;
 execute_data->nested = nested;
 nested = 1;

 ;

 if (!op_array->run_time_cache && op_array->last_cache_slot) {
  op_array->run_time_cache = _ecalloc((op_array->last_cache_slot), (sizeof(void*)) );
 }

 if (op_array->this_var != -1 && (executor_globals.This)) {
   zval_addref_p((executor_globals.This));
  if (!(executor_globals.active_symbol_table)) {
   execute_data->CVs[op_array->this_var] = (zval**)execute_data->CVs + (op_array->last_var + op_array->this_var);
   *execute_data->CVs[op_array->this_var] = (executor_globals.This);
  } else {
   if (_zend_hash_add_or_update((executor_globals.active_symbol_table), "this", sizeof("this"), &(executor_globals.This), sizeof(zval *), (void**)&execute_data->CVs[op_array->this_var], (1<<1) )==-1) {
    zval_delref_p((executor_globals.This));
   }
  }
 }

 execute_data->opline = __builtin_expect((op_array->fn_flags & 0x10) != 0, 0) && (executor_globals.start_op) ? (executor_globals.start_op) : op_array->opcodes;
 (executor_globals.opline_ptr) = &execute_data->opline;
 ;

 execute_data->function_state.function = (zend_function *) op_array;
 execute_data->function_state.arguments = ((void *)0);

 while (1) {
     int ret;






  if ((ret = execute_data->opline->handler(execute_data )) > 0) {
   switch (ret) {
    case 1:
     (executor_globals.in_execution) = original_in_execution;
     return;
    case 2:
     op_array = (executor_globals.active_op_array);
     goto zend_vm_enter;
    case 3:
     execute_data = (executor_globals.current_execute_data);
    default:
     break;
   }
  }

 }
 zend_error_noreturn((1<<0L), "Arrived at end of main loop which shouldn't happen");
}

static int __attribute__((fastcall)) ZEND_JMP_SPEC_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;




 execute_data->opline = opline->op1.jmp_addr;
 return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_STRING_SPEC_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *tmp = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 tmp->value.str.val = _emalloc((1) );
 tmp->value.str.val[0] = 0;
 tmp->value.str.len = 0;
 zval_set_refcount_p(tmp, 1);
 tmp->type = 6;
 zval_unset_isref_p(tmp);

 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_leave_helper_SPEC(zend_execute_data *execute_data )
{
 zend_bool nested;
 zend_op_array *op_array = execute_data->op_array;

 (executor_globals.current_execute_data) = execute_data->prev_execute_data;
 (executor_globals.opline_ptr) = ((void *)0);
 if (!(executor_globals.active_symbol_table)) {
  zval ***cv = execute_data->CVs;
  zval ***end = cv + op_array->last_var;
  while (cv != end) {
   if (*cv) {
    i_zval_ptr_dtor(*(*cv) );
   }
   cv++;
  }
 }

 nested = execute_data->nested;

 zend_vm_stack_free(execute_data );

 if (nested) {
  execute_data = (executor_globals.current_execute_data);
 }
 if (nested) {
  zend_op *opline = execute_data->opline;

  ;
  ;
  if (__builtin_expect(opline->opcode == 73, 0)) {

   execute_data->function_state.function = (zend_function *) execute_data->op_array;
   execute_data->function_state.arguments = ((void *)0);
   execute_data->object = execute_data->current_object;

   (executor_globals.opline_ptr) = &execute_data->opline;
   (executor_globals.active_op_array) = execute_data->op_array;
   (executor_globals.return_value_ptr_ptr) = execute_data->original_return_value;
   destroy_op_array(op_array );
   _efree((op_array) );
   if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
    zend_throw_exception_internal(((void *)0) );
    ; return 3;
   } else if ((!((opline)->result_type & (1<<5)))) {
    if (!(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr) {
     zval *retval;

     do { (retval) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(retval))->u.buffered = ((void *)0); } while (0);
     do { zval *__z = (retval); (*__z).value.lval = ((1) != 0); (*__z).type = 3; } while (0);
     (retval)->refcount__gc = 1; (retval)->is_ref__gc = 0;;
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = retval;
    }
   }

   execute_data->opline++;
   return 3;
  } else {

   (executor_globals.opline_ptr) = &execute_data->opline;
   (executor_globals.active_op_array) = execute_data->op_array;
   (executor_globals.return_value_ptr_ptr) = execute_data->original_return_value;
   if ((executor_globals.active_symbol_table)) {
    if ((executor_globals.symtable_cache_ptr)>=(executor_globals.symtable_cache_limit)) {
     zend_hash_destroy((executor_globals.active_symbol_table));
     _efree(((executor_globals.active_symbol_table)) );
    } else {


     zend_hash_clean((executor_globals.active_symbol_table));
     *(++(executor_globals.symtable_cache_ptr)) = (executor_globals.active_symbol_table);
    }
   }
   (executor_globals.active_symbol_table) = execute_data->symbol_table;

   execute_data->function_state.function = (zend_function *) execute_data->op_array;
   execute_data->function_state.arguments = ((void *)0);

   if ((executor_globals.This)) {
    if (__builtin_expect((executor_globals.exception) != ((void *)0), 0) && (((zend_uintptr_t)(execute_data->called_scope)) & 0x1)) {
     if ((((zend_uintptr_t)(execute_data->called_scope)) & 0x2)) {
      zval_delref_p((executor_globals.This));
     }
     if (zval_refcount_p((executor_globals.This)) == 1) {
      zend_object_store_ctor_failed((executor_globals.This) );
     }
    }
    i_zval_ptr_dtor(*(&(executor_globals.This)) );
   }
   (executor_globals.This) = execute_data->current_this;
   (executor_globals.scope) = execute_data->current_scope;
   (executor_globals.called_scope) = execute_data->current_called_scope;

   execute_data->object = execute_data->current_object;
   execute_data->called_scope = ((zend_class_entry*)(((zend_uintptr_t)(execute_data->called_scope)) & ~(0x1|0x2)));

   zend_vm_stack_clear_multiple();

   if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
    zend_throw_exception_internal(((void *)0) );
    if ((!((opline)->result_type & (1<<5))) && (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr) {
     i_zval_ptr_dtor(*(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr) );
    }
    ; return 3;
   }

   execute_data->opline++;
   return 3;
  }
 }
 return 1;
}

static int __attribute__((fastcall)) zend_do_fcall_common_helper_SPEC(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_bool should_change_scope = 0;
 zend_function *fbc = execute_data->function_state.function;

 ;
 if (__builtin_expect((fbc->common.fn_flags & (0x02|0x40000)) != 0, 0)) {
  if (__builtin_expect((fbc->common.fn_flags & 0x02) != 0, 0)) {
   zend_error_noreturn((1<<0L), "Cannot call abstract method %s::%s()", fbc->common.scope->name, fbc->common.function_name);
   ;
   execute_data->opline++; return 0;
  }
  if (__builtin_expect((fbc->common.fn_flags & 0x40000) != 0, 0)) {
   zend_error((1<<13L), "Function %s%s%s() is deprecated",
    fbc->common.scope ? fbc->common.scope->name : "",
    fbc->common.scope ? "::" : "",
    fbc->common.function_name);
  }
 }
 if (fbc->common.scope &&
  !(fbc->common.fn_flags & 0x01) &&
  !execute_data->object) {

  if (fbc->common.fn_flags & 0x10000) {

   zend_error((1<<11L), "Non-static method %s::%s() should not be called statically", fbc->common.scope->name, fbc->common.function_name);
  } else {


   zend_error_noreturn((1<<0L), "Non-static method %s::%s() cannot be called statically", fbc->common.scope->name, fbc->common.function_name);
  }
 }

 if (fbc->type == 2 || fbc->common.scope) {
  should_change_scope = 1;
  execute_data->current_this = (executor_globals.This);
  execute_data->current_scope = (executor_globals.scope);
  execute_data->current_called_scope = (executor_globals.called_scope);
  (executor_globals.This) = execute_data->object;
  (executor_globals.scope) = (fbc->type == 2 || !execute_data->object) ? fbc->common.scope : ((void *)0);
  (executor_globals.called_scope) = execute_data->called_scope;
 }

 zend_arg_types_stack_3_pop(&(executor_globals.arg_types_stack), &execute_data->called_scope, &execute_data->current_object, &execute_data->fbc);
 execute_data->function_state.arguments = zend_vm_stack_push_args(opline->extended_value );
 ;

 if (fbc->type == 1) {
  temp_variable *ret = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var));

  do { (ret->var.ptr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(ret->var.ptr))->u.buffered = ((void *)0); } while (0); (ret->var.ptr)->refcount__gc = 1; (ret->var.ptr)->is_ref__gc = 0;;;
  { (*ret->var.ptr).type = 0; };
  ret->var.ptr_ptr = &ret->var.ptr;
  ret->var.fcall_returned_reference = (fbc->common.fn_flags & 0x4000000) != 0;

  if (fbc->common.arg_info) {
   zend_uint i=0;
   zval **p = (zval**)execute_data->function_state.arguments;
   ulong arg_count = opline->extended_value;

   while (arg_count>0) {
    zend_verify_arg_type(fbc, ++i, *(p-arg_count), 0 );
    arg_count--;
   }
  }

  if (!zend_execute_internal) {

   fbc->internal_function.handler(opline->extended_value, ret->var.ptr, (fbc->common.fn_flags & 0x4000000) ? &ret->var.ptr : ((void *)0), execute_data->object, (!((opline)->result_type & (1<<5))) );
  } else {
   zend_execute_internal(execute_data, (!((opline)->result_type & (1<<5))) );
  }

  if (!(!((opline)->result_type & (1<<5)))) {
   i_zval_ptr_dtor(*(&ret->var.ptr) );
  }
 } else if (fbc->type == 2) {
  execute_data->original_return_value = (executor_globals.return_value_ptr_ptr);
  (executor_globals.active_symbol_table) = ((void *)0);
  (executor_globals.active_op_array) = &fbc->op_array;
  (executor_globals.return_value_ptr_ptr) = ((void *)0);
  if ((!((opline)->result_type & (1<<5)))) {
   temp_variable *ret = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var));

   ret->var.ptr = ((void *)0);
   (executor_globals.return_value_ptr_ptr) = &ret->var.ptr;
   ret->var.ptr_ptr = &ret->var.ptr;
   ret->var.fcall_returned_reference = (fbc->common.fn_flags & 0x4000000) != 0;
  }

  if (__builtin_expect(zend_execute == execute, 1)) {
   if (__builtin_expect((executor_globals.exception) == ((void *)0), 1)) {
    return 2;
   }
  } else {
   zend_execute((executor_globals.active_op_array) );
  }

  (executor_globals.opline_ptr) = &execute_data->opline;
  (executor_globals.active_op_array) = execute_data->op_array;
  (executor_globals.return_value_ptr_ptr) = execute_data->original_return_value;
  if ((executor_globals.active_symbol_table)) {
   if ((executor_globals.symtable_cache_ptr)>=(executor_globals.symtable_cache_limit)) {
    zend_hash_destroy((executor_globals.active_symbol_table));
    _efree(((executor_globals.active_symbol_table)) );
   } else {


    zend_hash_clean((executor_globals.active_symbol_table));
    *(++(executor_globals.symtable_cache_ptr)) = (executor_globals.active_symbol_table);
   }
  }
  (executor_globals.active_symbol_table) = execute_data->symbol_table;
 } else {
  do { ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr))->u.buffered = ((void *)0); } while (0); ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr)->refcount__gc = 1; ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr)->is_ref__gc = 0;;;
  { (*(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr).type = 0; };


  if (__builtin_expect(execute_data->object != ((void *)0), 1)) {
   (*execute_data->object).value.obj.handlers->call_method(fbc->common.function_name, opline->extended_value, (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr, &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr, execute_data->object, (!((opline)->result_type & (1<<5))) );
  } else {
   zend_error_noreturn((1<<0L), "Cannot call overloaded function for non-object");
  }

  if (fbc->type == 5) {
   _efree((fbc->common.function_name) );
  }
  _efree((fbc) );

  if (!(!((opline)->result_type & (1<<5)))) {
   i_zval_ptr_dtor(*(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr) );
  } else {
   zval_unset_isref_p((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr);
   zval_set_refcount_p((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr, 1);
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.fcall_returned_reference = 0;
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr;
  }
 }

 execute_data->function_state.function = (zend_function *) execute_data->op_array;
 execute_data->function_state.arguments = ((void *)0);

 if (should_change_scope) {
  if ((executor_globals.This)) {
   if (__builtin_expect((executor_globals.exception) != ((void *)0), 0) && (((zend_uintptr_t)(execute_data->called_scope)) & 0x1)) {
    if ((((zend_uintptr_t)(execute_data->called_scope)) & 0x2)) {
     zval_delref_p((executor_globals.This));
    }
    if (zval_refcount_p((executor_globals.This)) == 1) {
     zend_object_store_ctor_failed((executor_globals.This) );
    }
   }
   i_zval_ptr_dtor(*(&(executor_globals.This)) );
  }
  (executor_globals.This) = execute_data->current_this;
  (executor_globals.scope) = execute_data->current_scope;
  (executor_globals.called_scope) = execute_data->current_called_scope;
 }

 execute_data->object = execute_data->current_object;
 execute_data->called_scope = ((zend_class_entry*)(((zend_uintptr_t)(execute_data->called_scope)) & ~(0x1|0x2)));

 zend_vm_stack_clear_multiple();

 if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
  zend_throw_exception_internal(((void *)0) );
  if ((!((opline)->result_type & (1<<5))) && (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr) {
   i_zval_ptr_dtor(*(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr) );
  }
  ; return 0;
 }

 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER(zend_execute_data *execute_data )
{
 execute_data->function_state.function = execute_data->fbc;
 return zend_do_fcall_common_helper_SPEC(execute_data );
}

static int __attribute__((fastcall)) ZEND_RECV_SPEC_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_uint arg_num = opline->op1.num;
 zval **param = zend_vm_stack_get_arg(arg_num );

 ;
 if (__builtin_expect(param == ((void *)0), 0)) {
  if (zend_verify_arg_type((zend_function *) (executor_globals.active_op_array), arg_num, ((void *)0), opline->extended_value )) {
   char *space;
   char *class_name;
   zend_execute_data *ptr;

   if ((executor_globals.active_op_array)->scope) {
    class_name = (executor_globals.active_op_array)->scope->name;
    space = "::";
   } else {
    class_name = space = "";
   }
   ptr = execute_data->prev_execute_data;

   if(ptr && ptr->op_array) {
    zend_error((1<<1L), "Missing argument %u for %s%s%s(), called in %s on line %d and defined", opline->op1.num, class_name, space, get_active_function_name(), ptr->op_array->filename, ptr->opline->lineno);
   } else {
    zend_error((1<<1L), "Missing argument %u for %s%s%s()", opline->op1.num, class_name, space, get_active_function_name());
   }
  }
 } else {
  zval **var_ptr;

  zend_verify_arg_type((zend_function *) (executor_globals.active_op_array), arg_num, *param, opline->extended_value );
  var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->result.var );
  zval_delref_p(*(var_ptr));
  *var_ptr = *param;
  zval_addref_p(*(var_ptr));
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_NEW_SPEC_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *object_zval;
 zend_function *constructor;

 ;
 if (__builtin_expect(((*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).class_entry->ce_flags & (0x80|0x10|0x20)) != 0, 0)) {
  if ((*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).class_entry->ce_flags & 0x80) {
   zend_error_noreturn((1<<0L), "Cannot instantiate interface %s", (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).class_entry->name);
  } else if (((*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).class_entry->ce_flags & 0x120) == 0x120) {
   zend_error_noreturn((1<<0L), "Cannot instantiate trait %s", (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).class_entry->name);
  } else {
   zend_error_noreturn((1<<0L), "Cannot instantiate abstract class %s", (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).class_entry->name);
  }
 }
 do { (object_zval) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(object_zval))->u.buffered = ((void *)0); } while (0);
 _object_init_ex((object_zval), ((*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).class_entry) );
 (object_zval)->refcount__gc = 1; (object_zval)->is_ref__gc = 0;;

 constructor = (*object_zval).value.obj.handlers->get_constructor(object_zval );

 if (constructor == ((void *)0)) {
  if ((!((opline)->result_type & (1<<5)))) {
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (object_zval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  } else {
   i_zval_ptr_dtor(*(&object_zval) );
  }
  if (__builtin_expect(!(executor_globals.exception), 1)) { execute_data->opline = execute_data->op_array->opcodes + opline->op2.opline_num; } else { ; } return 0;
 } else {
  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((object_zval));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (object_zval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }

  zend_ptr_stack_3_push(&(executor_globals.arg_types_stack), execute_data->fbc, execute_data->object, ((zend_class_entry*)(((zend_uintptr_t)(execute_data->called_scope)) | 0x1 | (((!((opline)->result_type & (1<<5)))) ? 0x2 : 0))));


  execute_data->object = object_zval;
  execute_data->fbc = constructor;
  execute_data->called_scope = (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).class_entry;

  ;
  execute_data->opline++; return 0;
 }
}

static int __attribute__((fastcall)) ZEND_BEGIN_SILENCE_SPEC_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 ;
 ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.lval = (executor_globals.error_reporting);
 ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).type = 1;
 if (execute_data->old_error_reporting == ((void *)0)) {
  execute_data->old_error_reporting = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;
 }

 if ((executor_globals.error_reporting)) {
  do {
   (executor_globals.error_reporting) = 0;
   if (!(executor_globals.error_reporting_ini_entry)) {
    if (__builtin_expect(zend_hash_find((executor_globals.ini_directives), "error_reporting", sizeof("error_reporting"), (void **) &(executor_globals.error_reporting_ini_entry)) == -1, 0)) {
     break;
    }
   }
   if (!(executor_globals.error_reporting_ini_entry)->modified) {
    if (!(executor_globals.modified_ini_directives)) {
     ((executor_globals.modified_ini_directives)) = (HashTable *) _emalloc((sizeof(HashTable)) );
     _zend_hash_init(((executor_globals.modified_ini_directives)), (8), (((void *)0)), (((void *)0)), (0) );
    }
    if (__builtin_expect(_zend_hash_add_or_update((executor_globals.modified_ini_directives), "error_reporting", sizeof("error_reporting"), &(executor_globals.error_reporting_ini_entry), sizeof(zend_ini_entry*), ((void *)0), (1<<1) ) == 0, 1)) {
     (executor_globals.error_reporting_ini_entry)->orig_value = (executor_globals.error_reporting_ini_entry)->value;
     (executor_globals.error_reporting_ini_entry)->orig_value_length = (executor_globals.error_reporting_ini_entry)->value_length;
     (executor_globals.error_reporting_ini_entry)->orig_modifiable = (executor_globals.error_reporting_ini_entry)->modifiable;
     (executor_globals.error_reporting_ini_entry)->modified = 1;
    }
   } else if ((executor_globals.error_reporting_ini_entry)->value != (executor_globals.error_reporting_ini_entry)->orig_value) {
    _efree(((executor_globals.error_reporting_ini_entry)->value) );
   }
   (executor_globals.error_reporting_ini_entry)->value = _estrndup(("0"), (sizeof("0")-1) );
   (executor_globals.error_reporting_ini_entry)->value_length = sizeof("0")-1;
  } while (0);
 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER(zend_execute_data *execute_data )
{
 ;
 zend_error_noreturn((1<<0L), "Cannot call abstract method %s::%s()", (executor_globals.scope)->name, execute_data->op_array->function_name);
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_EXT_STMT_SPEC_HANDLER(zend_execute_data *execute_data )
{
 ;
 if (!(executor_globals.no_extensions)) {
  zend_llist_apply_with_argument(&zend_extensions, (llist_apply_with_arg_func_t) zend_extension_statement_handler, execute_data->op_array );
 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER(zend_execute_data *execute_data )
{
 ;
 if (!(executor_globals.no_extensions)) {
  zend_llist_apply_with_argument(&zend_extensions, (llist_apply_with_arg_func_t) zend_extension_fcall_begin_handler, execute_data->op_array );
 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_EXT_FCALL_END_SPEC_HANDLER(zend_execute_data *execute_data )
{
 ;
 if (!(executor_globals.no_extensions)) {
  zend_llist_apply_with_argument(&zend_extensions, (llist_apply_with_arg_func_t) zend_extension_fcall_end_handler, execute_data->op_array );
 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_DECLARE_CLASS_SPEC_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 ;
 (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).class_entry = do_bind_class(execute_data->op_array, opline, (executor_globals.class_table), 0 );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 ;
 (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).class_entry = do_bind_inherited_class(execute_data->op_array, opline, (executor_globals.class_table), (*(temp_variable *)((char *) execute_data->Ts + opline->extended_value)).class_entry, 0 );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_class_entry **pce, **pce_orig;

 ;
 if (zend_hash_quick_find((executor_globals.class_table), (*opline->op2.zv).value.str.val, (*opline->op2.zv).value.str.len+1, (((zend_literal*)(opline->op2.zv))->hash_value), (void**)&pce) == -1 ||
     (zend_hash_quick_find((executor_globals.class_table), (*opline->op1.zv).value.str.val, (*opline->op1.zv).value.str.len, (((zend_literal*)(opline->op1.zv))->hash_value), (void**)&pce_orig) == 0 &&
      *pce != *pce_orig)) {
  do_bind_inherited_class(execute_data->op_array, opline, (executor_globals.class_table), (*(temp_variable *)((char *) execute_data->Ts + opline->extended_value)).class_entry, 0 );
 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_DECLARE_FUNCTION_SPEC_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 ;
 do_bind_function(execute_data->op_array, opline, (executor_globals.function_table), 0);
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_TICKS_SPEC_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 ;
 if (++(executor_globals.ticks_count)>=opline->extended_value) {
  (executor_globals.ticks_count)=0;
  if (zend_ticks_function) {
   zend_ticks_function(opline->extended_value);
  }
 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_EXT_NOP_SPEC_HANDLER(zend_execute_data *execute_data )
{
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_NOP_SPEC_HANDLER(zend_execute_data *execute_data )
{
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ADD_TRAIT_SPEC_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_class_entry *ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).class_entry;
 zend_class_entry *trait;

 if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
  trait = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
 } else {
  trait = zend_fetch_class_by_name((*opline->op2.zv).value.str.val,
                                   (*opline->op2.zv).value.str.len,
                                   opline->op2.literal + 1,
                                   opline->extended_value );
  if (__builtin_expect(trait == ((void *)0), 0)) {
   ;
   execute_data->opline++; return 0;
  }
  if (!((trait->ce_flags & 0x120) == 0x120)) {
   zend_error_noreturn((1<<0L), "%s cannot use %s - it is not a trait", ce->name, trait->name);
  }
  do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (trait); } while (0);
 }

 zend_do_implement_trait(ce, trait );

  ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BIND_TRAITS_SPEC_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_class_entry *ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).class_entry;

 zend_do_bind_traits(ce );

 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_HANDLE_EXCEPTION_SPEC_HANDLER(zend_execute_data *execute_data )
{
 zend_uint op_num = (executor_globals.opline_before_exception)-(executor_globals.active_op_array)->opcodes;
 int i;
 zend_uint catch_op_num = 0;
 int catched = 0;
 zval restored_error_reporting;

 void **stack_frame = (void**)(((char*)execute_data->Ts) +
  ((((sizeof(temp_variable)) + 4 - 1) & ~(4 -1)) * execute_data->op_array->T));

 while (zend_vm_stack_top() != stack_frame) {
  zval *stack_zval_p = zend_vm_stack_pop();
  i_zval_ptr_dtor(*(&stack_zval_p) );
 }

 for (i=0; i<(executor_globals.active_op_array)->last_try_catch; i++) {
  if ((executor_globals.active_op_array)->try_catch_array[i].try_op > op_num) {

   break;
  } else if (op_num < (executor_globals.active_op_array)->try_catch_array[i].catch_op) {
   catch_op_num = execute_data->op_array->try_catch_array[i].catch_op;
   catched = 1;
  }
 }

 while (execute_data->fbc) {
  execute_data->called_scope = (zend_class_entry*)zend_ptr_stack_pop(&(executor_globals.arg_types_stack));
  if (execute_data->object) {
   if ((((zend_uintptr_t)(execute_data->called_scope)) & 0x1)) {
    if ((((zend_uintptr_t)(execute_data->called_scope)) & 0x2)) {
     zval_delref_p(execute_data->object);
    }
    if (zval_refcount_p(execute_data->object) == 1) {
     zend_object_store_ctor_failed(execute_data->object );
    }
   }
   i_zval_ptr_dtor(*(&execute_data->object) );
  }
  execute_data->called_scope = ((zend_class_entry*)(((zend_uintptr_t)(execute_data->called_scope)) & ~(0x1|0x2)));
  zend_arg_types_stack_2_pop(&(executor_globals.arg_types_stack), &execute_data->object, &execute_data->fbc);
 }

 for (i=0; i<execute_data->op_array->last_brk_cont; i++) {
  if (execute_data->op_array->brk_cont_array[i].start < 0) {
   continue;
  } else if (execute_data->op_array->brk_cont_array[i].start > op_num) {

   break;
  } else if (op_num < execute_data->op_array->brk_cont_array[i].brk) {
   if (!catched ||
       catch_op_num >= execute_data->op_array->brk_cont_array[i].brk) {
    zend_op *brk_opline = &execute_data->op_array->opcodes[execute_data->op_array->brk_cont_array[i].brk];

    switch (brk_opline->opcode) {
     case 49:
      if (!(brk_opline->extended_value & (1<<2))) {
       i_zval_ptr_dtor(*(&(*(temp_variable *)((char *) execute_data->Ts + brk_opline->op1.var)).var.ptr) );
      }
      break;
     case 70:
      if (!(brk_opline->extended_value & (1<<2))) {
       _zval_dtor((&((*(temp_variable *)((char *) execute_data->Ts + brk_opline->op1.var)).tmp_var)) );
      }
      break;
    }
   }
  }
 }


 if (!(executor_globals.error_reporting) && execute_data->old_error_reporting != ((void *)0) && (*execute_data->old_error_reporting).value.lval != 0) {
  (restored_error_reporting).type = 1;
  (restored_error_reporting).value.lval = (*execute_data->old_error_reporting).value.lval;
  if ((&restored_error_reporting)->type != 6) { _convert_to_string((&restored_error_reporting) ); };
  zend_alter_ini_entry_ex("error_reporting", sizeof("error_reporting"), (restored_error_reporting).value.str.val, (restored_error_reporting).value.str.len, (1<<0), (1<<4), 1 );
  _zval_dtor((&(restored_error_reporting)) );
 }
 execute_data->old_error_reporting = ((void *)0);

 if (!catched) {
  return zend_leave_helper_SPEC(execute_data );
  } else {
  execute_data->opline = &execute_data->op_array->opcodes[catch_op_num];
   return 0;
  }
}

static int __attribute__((fastcall)) ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 ;
 zend_verify_abstract_class((*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).class_entry );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_USER_OPCODE_SPEC_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 int ret;

 ;
 ret = zend_user_opcode_handlers[opline->opcode](execute_data );
 ;

 switch (ret) {
  case 0:
   return 0;
  case 1:
   return zend_leave_helper_SPEC(execute_data );
  case 3:
   return 2;
  case 4:
   return 3;
  case 2:
   return zend_vm_get_opcode_handler(opline->opcode, opline)(execute_data );;
  default:
   return zend_vm_get_opcode_handler((zend_uchar)(ret & 0xff), opline)(execute_data );;
 }
}

static int __attribute__((fastcall)) ZEND_FETCH_CLASS_SPEC_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 ;
 (executor_globals.exception) = ((void *)0);
 if ((1<<0) == (1<<3)) {
  (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).class_entry = zend_fetch_class(((void *)0), 0, opline->extended_value );
  ;
  execute_data->opline++; return 0;
 } else {

  zval *class_name = opline->op2.zv;

  if ((1<<0) == (1<<0)) {
   if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
    (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).class_entry = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
   } else {
    (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).class_entry = zend_fetch_class_by_name((*class_name).value.str.val, (*class_name).value.str.len, opline->op2.literal + 1, opline->extended_value );
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).class_entry); } while (0);
   }
  } else if ((*class_name).type == 5) {
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).class_entry = zend_get_class_entry(&(*class_name) );
  } else if ((*class_name).type == 6) {
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).class_entry = zend_fetch_class((*class_name).value.str.val, (*class_name).value.str.len, opline->extended_value );
  } else {
   zend_error_noreturn((1<<0L), "Class name must be a valid object or a string");
  }

  ;
  execute_data->opline++; return 0;
 }
}

static int __attribute__((fastcall)) ZEND_INIT_FCALL_BY_NAME_SPEC_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *function_name;
 zend_ptr_stack_3_push(&(executor_globals.arg_types_stack), execute_data->fbc, execute_data->object, execute_data->called_scope);

 if ((1<<0) == (1<<0)) {
  function_name = (zval*)(opline->op2.literal+1);
  if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
   execute_data->fbc = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
  } else if (__builtin_expect(zend_hash_quick_find((executor_globals.function_table), (*function_name).value.str.val, (*function_name).value.str.len+1, (((zend_literal*)(function_name))->hash_value), (void **) &execute_data->fbc) == -1, 0)) {
   ;
   zend_error_noreturn((1<<0L), "Call to undefined function %s()", (*opline->op2.zv).value.str.val);
  } else {
   do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (execute_data->fbc); } while (0);
  }
  execute_data->object = ((void *)0);

  execute_data->opline++; return 0;
 } else {
  char *function_name_strval, *lcname;
  int function_name_strlen;


  ;
  function_name = opline->op2.zv;

  if (__builtin_expect((*function_name).type == 6, 1)) {
   function_name_strval = (*function_name).value.str.val;
   function_name_strlen = (*function_name).value.str.len;
   if (function_name_strval[0] == '\\') {
       function_name_strlen -= 1;
    lcname = zend_str_tolower_dup(function_name_strval + 1, function_name_strlen);
   } else {
    lcname = zend_str_tolower_dup(function_name_strval, function_name_strlen);
   }
   if (__builtin_expect(zend_hash_find((executor_globals.function_table), lcname, function_name_strlen+1, (void **) &execute_data->fbc) == -1, 0)) {
    zend_error_noreturn((1<<0L), "Call to undefined function %s()", function_name_strval);
   }
   _efree((lcname) );

   execute_data->object = ((void *)0);
   ;
   execute_data->opline++; return 0;
  } else if ((1<<0) != (1<<0) &&
      __builtin_expect((*function_name).type == 5, 1) &&
   ((*function_name)).value.obj.handlers->get_closure &&
   ((*function_name)).value.obj.handlers->get_closure(function_name, &execute_data->called_scope, &execute_data->fbc, &execute_data->object ) == 0) {
   if (execute_data->object) {
    zval_addref_p(execute_data->object);
   }

   ;
   execute_data->opline++; return 0;
  } else {
   zend_error_noreturn((1<<0L), "Function name must be a string");
  }
 }
}


static int __attribute__((fastcall)) ZEND_INIT_NS_FCALL_BY_NAME_SPEC_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_literal *func_name;

 zend_ptr_stack_3_push(&(executor_globals.arg_types_stack), execute_data->fbc, execute_data->object, execute_data->called_scope);

 func_name = opline->op2.literal + 1;
 if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
  execute_data->fbc = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
 } else if (zend_hash_quick_find((executor_globals.function_table), (func_name->constant).value.str.val, (func_name->constant).value.str.len+1, func_name->hash_value, (void **) &execute_data->fbc)==-1) {
  func_name++;
  if (__builtin_expect(zend_hash_quick_find((executor_globals.function_table), (func_name->constant).value.str.val, (func_name->constant).value.str.len+1, func_name->hash_value, (void **) &execute_data->fbc)==-1, 0)) {
   ;
   zend_error_noreturn((1<<0L), "Call to undefined function %s()", (*opline->op2.zv).value.str.val);
  } else {
   do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (execute_data->fbc); } while (0);
  }
 } else {
  do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (execute_data->fbc); } while (0);
 }

 execute_data->object = ((void *)0);
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_RECV_INIT_SPEC_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *assignment_value;
 zend_uint arg_num = opline->op1.num;
 zval **param = zend_vm_stack_get_arg(arg_num );
 zval **var_ptr;

 ;
 if (param == ((void *)0)) {
  do { (assignment_value) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(assignment_value))->u.buffered = ((void *)0); } while (0);
  *assignment_value = *opline->op2.zv;
  if (((*assignment_value).type & 0x00f) == 8 ||
       (*assignment_value).type==9) {
   zval_set_refcount_p(assignment_value, 1);
   zval_update_constant(&assignment_value, 0 );
  } else {
   _zval_copy_ctor((assignment_value) );
  }
  (assignment_value)->refcount__gc = 1; (assignment_value)->is_ref__gc = 0;;
 } else {
  assignment_value = *param;
  zval_addref_p(assignment_value);
 }

 zend_verify_arg_type((zend_function *) (executor_globals.active_op_array), arg_num, assignment_value, opline->extended_value );
 var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->result.var );
 zval_delref_p(*(var_ptr));
 *var_ptr = assignment_value;

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BRK_SPEC_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_brk_cont_element *el;

 ;
 el = zend_brk_cont((*opline->op2.zv).value.lval, opline->op1.opline_num,
                    execute_data->op_array, execute_data->Ts );

 if (__builtin_expect(!(executor_globals.exception), 1)) { execute_data->opline = execute_data->op_array->opcodes + el->brk; } else { ; } return 0;
}

static int __attribute__((fastcall)) ZEND_CONT_SPEC_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_brk_cont_element *el;

 ;
 el = zend_brk_cont((*opline->op2.zv).value.lval, opline->op1.opline_num,
                    execute_data->op_array, execute_data->Ts );

 if (__builtin_expect(!(executor_globals.exception), 1)) { execute_data->opline = execute_data->op_array->opcodes + el->cont; } else { ; } return 0;
}

static int __attribute__((fastcall)) ZEND_GOTO_SPEC_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *brk_opline;
 zend_op *opline = execute_data->opline;
 zend_brk_cont_element *el;

 ;
 el = zend_brk_cont((*opline->op2.zv).value.lval, opline->extended_value,
                     execute_data->op_array, execute_data->Ts );

 brk_opline = execute_data->op_array->opcodes + el->brk;

 switch (brk_opline->opcode) {
  case 49:
   if (!(brk_opline->extended_value & (1<<2))) {
    i_zval_ptr_dtor(*(&(*(temp_variable *)((char *) execute_data->Ts + brk_opline->op1.var)).var.ptr) );
   }
   break;
  case 70:
   if (!(brk_opline->extended_value & (1<<2))) {
    _zval_dtor((&((*(temp_variable *)((char *) execute_data->Ts + brk_opline->op1.var)).tmp_var)) );
   }
   break;
 }
 if (__builtin_expect(!(executor_globals.exception), 1)) { execute_data->opline = opline->op1.jmp_addr; } else { ; } return 0;
}

static int __attribute__((fastcall)) ZEND_ADD_INTERFACE_SPEC_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_class_entry *ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).class_entry;
 zend_class_entry *iface;

 ;
 if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
  iface = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
 } else {
  iface = zend_fetch_class_by_name((*opline->op2.zv).value.str.val, (*opline->op2.zv).value.str.len, opline->op2.literal + 1, opline->extended_value );
  if (__builtin_expect(iface == ((void *)0), 0)) {
   ;
   execute_data->opline++; return 0;
  }
  do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); } while (0);
 }

 if (__builtin_expect((iface->ce_flags & 0x80) == 0, 0)) {
  zend_error_noreturn((1<<0L), "%s cannot implement %s - it is not an interface", ce->name, iface->name);
 }
 zend_do_implement_interface(ce, iface );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_CLASS_SPEC_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 ;
 (executor_globals.exception) = ((void *)0);
 if ((1<<1) == (1<<3)) {
  (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).class_entry = zend_fetch_class(((void *)0), 0, opline->extended_value );
  ;
  execute_data->opline++; return 0;
 } else {
  zend_free_op free_op2;
  zval *class_name = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );

  if ((1<<1) == (1<<0)) {
   if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
    (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).class_entry = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
   } else {
    (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).class_entry = zend_fetch_class_by_name((*class_name).value.str.val, (*class_name).value.str.len, opline->op2.literal + 1, opline->extended_value );
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).class_entry); } while (0);
   }
  } else if ((*class_name).type == 5) {
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).class_entry = zend_get_class_entry(&(*class_name) );
  } else if ((*class_name).type == 6) {
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).class_entry = zend_fetch_class((*class_name).value.str.val, (*class_name).value.str.len, opline->extended_value );
  } else {
   zend_error_noreturn((1<<0L), "Class name must be a valid object or a string");
  }

  _zval_dtor((free_op2.var) );
  ;
  execute_data->opline++; return 0;
 }
}

static int __attribute__((fastcall)) ZEND_INIT_FCALL_BY_NAME_SPEC_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *function_name;
 zend_ptr_stack_3_push(&(executor_globals.arg_types_stack), execute_data->fbc, execute_data->object, execute_data->called_scope);

 if ((1<<1) == (1<<0)) {
  function_name = (zval*)(opline->op2.literal+1);
  if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
   execute_data->fbc = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
  } else if (__builtin_expect(zend_hash_quick_find((executor_globals.function_table), (*function_name).value.str.val, (*function_name).value.str.len+1, (((zend_literal*)(function_name))->hash_value), (void **) &execute_data->fbc) == -1, 0)) {
   ;
   zend_error_noreturn((1<<0L), "Call to undefined function %s()", (*opline->op2.zv).value.str.val);
  } else {
   do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (execute_data->fbc); } while (0);
  }
  execute_data->object = ((void *)0);

  execute_data->opline++; return 0;
 } else {
  char *function_name_strval, *lcname;
  int function_name_strlen;
  zend_free_op free_op2;

  ;
  function_name = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );

  if (__builtin_expect((*function_name).type == 6, 1)) {
   function_name_strval = (*function_name).value.str.val;
   function_name_strlen = (*function_name).value.str.len;
   if (function_name_strval[0] == '\\') {
       function_name_strlen -= 1;
    lcname = zend_str_tolower_dup(function_name_strval + 1, function_name_strlen);
   } else {
    lcname = zend_str_tolower_dup(function_name_strval, function_name_strlen);
   }
   if (__builtin_expect(zend_hash_find((executor_globals.function_table), lcname, function_name_strlen+1, (void **) &execute_data->fbc) == -1, 0)) {
    zend_error_noreturn((1<<0L), "Call to undefined function %s()", function_name_strval);
   }
   _efree((lcname) );
   _zval_dtor((free_op2.var) );
   execute_data->object = ((void *)0);
   ;
   execute_data->opline++; return 0;
  } else if ((1<<1) != (1<<0) &&
      __builtin_expect((*function_name).type == 5, 1) &&
   ((*function_name)).value.obj.handlers->get_closure &&
   ((*function_name)).value.obj.handlers->get_closure(function_name, &execute_data->called_scope, &execute_data->fbc, &execute_data->object ) == 0) {
   if (execute_data->object) {
    zval_addref_p(execute_data->object);
   }
   _zval_dtor((free_op2.var) );
   ;
   execute_data->opline++; return 0;
  } else {
   zend_error_noreturn((1<<0L), "Function name must be a string");
  }
 }
}


static int __attribute__((fastcall)) ZEND_FETCH_CLASS_SPEC_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 ;
 (executor_globals.exception) = ((void *)0);
 if ((1<<2) == (1<<3)) {
  (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).class_entry = zend_fetch_class(((void *)0), 0, opline->extended_value );
  ;
  execute_data->opline++; return 0;
 } else {
  zend_free_op free_op2;
  zval *class_name = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );

  if ((1<<2) == (1<<0)) {
   if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
    (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).class_entry = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
   } else {
    (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).class_entry = zend_fetch_class_by_name((*class_name).value.str.val, (*class_name).value.str.len, opline->op2.literal + 1, opline->extended_value );
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).class_entry); } while (0);
   }
  } else if ((*class_name).type == 5) {
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).class_entry = zend_get_class_entry(&(*class_name) );
  } else if ((*class_name).type == 6) {
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).class_entry = zend_fetch_class((*class_name).value.str.val, (*class_name).value.str.len, opline->extended_value );
  } else {
   zend_error_noreturn((1<<0L), "Class name must be a valid object or a string");
  }

  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
  ;
  execute_data->opline++; return 0;
 }
}

static int __attribute__((fastcall)) ZEND_INIT_FCALL_BY_NAME_SPEC_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *function_name;
 zend_ptr_stack_3_push(&(executor_globals.arg_types_stack), execute_data->fbc, execute_data->object, execute_data->called_scope);

 if ((1<<2) == (1<<0)) {
  function_name = (zval*)(opline->op2.literal+1);
  if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
   execute_data->fbc = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
  } else if (__builtin_expect(zend_hash_quick_find((executor_globals.function_table), (*function_name).value.str.val, (*function_name).value.str.len+1, (((zend_literal*)(function_name))->hash_value), (void **) &execute_data->fbc) == -1, 0)) {
   ;
   zend_error_noreturn((1<<0L), "Call to undefined function %s()", (*opline->op2.zv).value.str.val);
  } else {
   do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (execute_data->fbc); } while (0);
  }
  execute_data->object = ((void *)0);

  execute_data->opline++; return 0;
 } else {
  char *function_name_strval, *lcname;
  int function_name_strlen;
  zend_free_op free_op2;

  ;
  function_name = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );

  if (__builtin_expect((*function_name).type == 6, 1)) {
   function_name_strval = (*function_name).value.str.val;
   function_name_strlen = (*function_name).value.str.len;
   if (function_name_strval[0] == '\\') {
       function_name_strlen -= 1;
    lcname = zend_str_tolower_dup(function_name_strval + 1, function_name_strlen);
   } else {
    lcname = zend_str_tolower_dup(function_name_strval, function_name_strlen);
   }
   if (__builtin_expect(zend_hash_find((executor_globals.function_table), lcname, function_name_strlen+1, (void **) &execute_data->fbc) == -1, 0)) {
    zend_error_noreturn((1<<0L), "Call to undefined function %s()", function_name_strval);
   }
   _efree((lcname) );
   if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
   execute_data->object = ((void *)0);
   ;
   execute_data->opline++; return 0;
  } else if ((1<<2) != (1<<0) &&
      __builtin_expect((*function_name).type == 5, 1) &&
   ((*function_name)).value.obj.handlers->get_closure &&
   ((*function_name)).value.obj.handlers->get_closure(function_name, &execute_data->called_scope, &execute_data->fbc, &execute_data->object ) == 0) {
   if (execute_data->object) {
    zval_addref_p(execute_data->object);
   }
   if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
   ;
   execute_data->opline++; return 0;
  } else {
   zend_error_noreturn((1<<0L), "Function name must be a string");
  }
 }
}


static int __attribute__((fastcall)) ZEND_FETCH_CLASS_SPEC_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 ;
 (executor_globals.exception) = ((void *)0);
 if ((1<<3) == (1<<3)) {
  (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).class_entry = zend_fetch_class(((void *)0), 0, opline->extended_value );
  ;
  execute_data->opline++; return 0;
 } else {

  zval *class_name = ((void *)0);

  if ((1<<3) == (1<<0)) {
   if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
    (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).class_entry = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
   } else {
    (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).class_entry = zend_fetch_class_by_name((*class_name).value.str.val, (*class_name).value.str.len, opline->op2.literal + 1, opline->extended_value );
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).class_entry); } while (0);
   }
  } else if ((*class_name).type == 5) {
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).class_entry = zend_get_class_entry(&(*class_name) );
  } else if ((*class_name).type == 6) {
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).class_entry = zend_fetch_class((*class_name).value.str.val, (*class_name).value.str.len, opline->extended_value );
  } else {
   zend_error_noreturn((1<<0L), "Class name must be a valid object or a string");
  }

  ;
  execute_data->opline++; return 0;
 }
}

static int __attribute__((fastcall)) ZEND_FETCH_CLASS_SPEC_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 ;
 (executor_globals.exception) = ((void *)0);
 if ((1<<4) == (1<<3)) {
  (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).class_entry = zend_fetch_class(((void *)0), 0, opline->extended_value );
  ;
  execute_data->opline++; return 0;
 } else {

  zval *class_name = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );

  if ((1<<4) == (1<<0)) {
   if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
    (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).class_entry = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
   } else {
    (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).class_entry = zend_fetch_class_by_name((*class_name).value.str.val, (*class_name).value.str.len, opline->op2.literal + 1, opline->extended_value );
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).class_entry); } while (0);
   }
  } else if ((*class_name).type == 5) {
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).class_entry = zend_get_class_entry(&(*class_name) );
  } else if ((*class_name).type == 6) {
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).class_entry = zend_fetch_class((*class_name).value.str.val, (*class_name).value.str.len, opline->extended_value );
  } else {
   zend_error_noreturn((1<<0L), "Class name must be a valid object or a string");
  }

  ;
  execute_data->opline++; return 0;
 }
}

static int __attribute__((fastcall)) ZEND_INIT_FCALL_BY_NAME_SPEC_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *function_name;
 zend_ptr_stack_3_push(&(executor_globals.arg_types_stack), execute_data->fbc, execute_data->object, execute_data->called_scope);

 if ((1<<4) == (1<<0)) {
  function_name = (zval*)(opline->op2.literal+1);
  if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
   execute_data->fbc = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
  } else if (__builtin_expect(zend_hash_quick_find((executor_globals.function_table), (*function_name).value.str.val, (*function_name).value.str.len+1, (((zend_literal*)(function_name))->hash_value), (void **) &execute_data->fbc) == -1, 0)) {
   ;
   zend_error_noreturn((1<<0L), "Call to undefined function %s()", (*opline->op2.zv).value.str.val);
  } else {
   do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (execute_data->fbc); } while (0);
  }
  execute_data->object = ((void *)0);

  execute_data->opline++; return 0;
 } else {
  char *function_name_strval, *lcname;
  int function_name_strlen;


  ;
  function_name = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );

  if (__builtin_expect((*function_name).type == 6, 1)) {
   function_name_strval = (*function_name).value.str.val;
   function_name_strlen = (*function_name).value.str.len;
   if (function_name_strval[0] == '\\') {
       function_name_strlen -= 1;
    lcname = zend_str_tolower_dup(function_name_strval + 1, function_name_strlen);
   } else {
    lcname = zend_str_tolower_dup(function_name_strval, function_name_strlen);
   }
   if (__builtin_expect(zend_hash_find((executor_globals.function_table), lcname, function_name_strlen+1, (void **) &execute_data->fbc) == -1, 0)) {
    zend_error_noreturn((1<<0L), "Call to undefined function %s()", function_name_strval);
   }
   _efree((lcname) );

   execute_data->object = ((void *)0);
   ;
   execute_data->opline++; return 0;
  } else if ((1<<4) != (1<<0) &&
      __builtin_expect((*function_name).type == 5, 1) &&
   ((*function_name)).value.obj.handlers->get_closure &&
   ((*function_name)).value.obj.handlers->get_closure(function_name, &execute_data->called_scope, &execute_data->fbc, &execute_data->object ) == 0) {
   if (execute_data->object) {
    zval_addref_p(execute_data->object);
   }

   ;
   execute_data->opline++; return 0;
  } else {
   zend_error_noreturn((1<<0L), "Function name must be a string");
  }
 }
}


static int __attribute__((fastcall)) ZEND_BW_NOT_SPEC_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 bitwise_not_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BOOL_NOT_SPEC_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 boolean_not_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ECHO_SPEC_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval z_copy;
 zval *z;

 ;
 z = opline->op1.zv;

 if ((1<<0) != (1<<0) &&
     __builtin_expect((*z).type == 5, 0) &&
     (*z).value.obj.handlers->get_method != ((void *)0) &&
  zend_std_cast_object_tostring(z, &z_copy, 6 ) == 0) {
  zend_print_variable(&z_copy);
  _zval_dtor((&z_copy) );
 } else {
  zend_print_variable(z);
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_PRINT_SPEC_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = 1; (*__z).type = 1; };
 return ZEND_ECHO_SPEC_CONST_HANDLER(execute_data );
}

static int __attribute__((fastcall)) ZEND_JMPZ_SPEC_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *val;
 int ret;

 ;
 val = opline->op1.zv;

 if ((1<<0) == (1<<1) && __builtin_expect((*val).type == 3, 1)) {
  ret = (*val).value.lval;
 } else {
  ret = i_zend_is_true(val);

  if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
   ; return 0;
  }
 }
 if (!ret) {



  execute_data->opline = opline->op2.jmp_addr;
  return 0;
 }

 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_JMPNZ_SPEC_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *val;
 int ret;

 ;
 val = opline->op1.zv;

 if ((1<<0) == (1<<1) && __builtin_expect((*val).type == 3, 1)) {
  ret = (*val).value.lval;
 } else {
  ret = i_zend_is_true(val);

  if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
   ; return 0;
  }
 }
 if (ret) {



  execute_data->opline = opline->op2.jmp_addr;
  return 0;
 }

 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_JMPZNZ_SPEC_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *val;
 int retval;

 ;
 val = opline->op1.zv;

 if ((1<<0) == (1<<1) && __builtin_expect((*val).type == 3, 1)) {
  retval = (*val).value.lval;
 } else {
  retval = i_zend_is_true(val);

  if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
   ; return 0;
  }
 }
 if (__builtin_expect(retval != 0, 1)) {



  execute_data->opline = &execute_data->op_array->opcodes[opline->extended_value];
  return 0;
 } else {



  execute_data->opline = &execute_data->op_array->opcodes[opline->op2.opline_num];
  return 0;
 }
}

static int __attribute__((fastcall)) ZEND_JMPZ_EX_SPEC_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *val;
 int retval;

 ;
 val = opline->op1.zv;

 if ((1<<0) == (1<<1) && __builtin_expect((*val).type == 3, 1)) {
  retval = (*val).value.lval;
 } else {
  retval = i_zend_is_true(val);

  if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
   ; return 0;
  }
 }
 ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.lval = retval;
 ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).type = 3;
 if (!retval) {



  execute_data->opline = opline->op2.jmp_addr;
  return 0;
 }
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_JMPNZ_EX_SPEC_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *val;
 int retval;

 ;
 val = opline->op1.zv;

 if ((1<<0) == (1<<1) && __builtin_expect((*val).type == 3, 1)) {
  retval = (*val).value.lval;
 } else {
  retval = i_zend_is_true(val);

  if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
   ; return 0;
  }
 }
 ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.lval = retval;
 ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).type = 3;
 if (retval) {



  execute_data->opline = opline->op2.jmp_addr;
  return 0;
 }
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_DO_FCALL_SPEC_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *fname = opline->op1.zv;

 zend_ptr_stack_3_push(&(executor_globals.arg_types_stack), execute_data->fbc, execute_data->object, execute_data->called_scope);

 if ((executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)]) {
  execute_data->function_state.function = (executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)];
 } else if (__builtin_expect(zend_hash_quick_find((executor_globals.function_table), (*fname).value.str.val, (*fname).value.str.len+1, (((zend_literal*)(fname))->hash_value), (void **) &execute_data->function_state.function)==-1, 0)) {
     ;
  zend_error_noreturn((1<<0L), "Call to undefined function %s()", fname->value.str.val);
 } else {
  do { (executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)] = (execute_data->function_state.function); } while (0);
 }
 execute_data->object = ((void *)0);

 return zend_do_fcall_common_helper_SPEC(execute_data );
}

static int __attribute__((fastcall)) ZEND_RETURN_SPEC_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *retval_ptr;


 ;
 retval_ptr = opline->op1.zv;

 if (!(executor_globals.return_value_ptr_ptr)) {
  if ((1<<0) == (1<<1)) {

  }
 } else if (!0) {
  if ((1<<0) == (1<<0) ||
      (zval_isref_p(retval_ptr) && zval_refcount_p(retval_ptr) > 0)) {
   zval *ret;

   do { (ret) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(ret))->u.buffered = ((void *)0); } while (0);
   do { do { (ret)->value = (retval_ptr)->value; (*ret).type = (*retval_ptr).type; } while (0); zval_set_refcount_p(ret, 1); zval_unset_isref_p(ret); } while (0);
   _zval_copy_ctor((ret) );
   *(executor_globals.return_value_ptr_ptr) = ret;
  } else if (((1<<0) == (1<<4) || (1<<0) == (1<<2)) &&
             retval_ptr == &(executor_globals.uninitialized_zval)) {
   zval *ret;

   do { (ret) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(ret))->u.buffered = ((void *)0); } while (0); *ret = zval_used_for_init;;;
   *(executor_globals.return_value_ptr_ptr) = ret;
  } else {
   *(executor_globals.return_value_ptr_ptr) = retval_ptr;
   zval_addref_p(retval_ptr);
  }
 } else {
  zval *ret;

  do { (ret) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(ret))->u.buffered = ((void *)0); } while (0);
  do { do { (ret)->value = (retval_ptr)->value; (*ret).type = (*retval_ptr).type; } while (0); zval_set_refcount_p(ret, 1); zval_unset_isref_p(ret); } while (0);
  *(executor_globals.return_value_ptr_ptr) = ret;
 }

 return zend_leave_helper_SPEC(execute_data );
}

static int __attribute__((fastcall)) ZEND_RETURN_BY_REF_SPEC_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *retval_ptr;
 zval **retval_ptr_ptr;


 ;

 do {
  if ((1<<0) == (1<<0) || (1<<0) == (1<<1)) {

   zend_error((1<<3L), "Only variable references should be returned by reference");

   retval_ptr = opline->op1.zv;
   if (!(executor_globals.return_value_ptr_ptr)) {
    if ((1<<0) == (1<<1)) {

    }
   } else if (!0) {
    zval *ret;

    do { (ret) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(ret))->u.buffered = ((void *)0); } while (0);
    do { do { (ret)->value = (retval_ptr)->value; (*ret).type = (*retval_ptr).type; } while (0); zval_set_refcount_p(ret, 1); zval_unset_isref_p(ret); } while (0);
    _zval_copy_ctor((ret) );
    *(executor_globals.return_value_ptr_ptr) = ret;
   } else {
    zval *ret;

    do { (ret) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(ret))->u.buffered = ((void *)0); } while (0);
    do { do { (ret)->value = (retval_ptr)->value; (*ret).type = (*retval_ptr).type; } while (0); zval_set_refcount_p(ret, 1); zval_unset_isref_p(ret); } while (0);
    *(executor_globals.return_value_ptr_ptr) = ret;
   }
   break;
  }

  retval_ptr_ptr = ((void *)0);

  if ((1<<0) == (1<<2) && __builtin_expect(retval_ptr_ptr == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot return string offsets by reference");
  }

  if ((1<<0) == (1<<2) && !zval_isref_p(*(retval_ptr_ptr))) {
   if (opline->extended_value == 1<<0 &&
       (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.fcall_returned_reference) {
   } else if ((*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr == &(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr) {
    zend_error((1<<3L), "Only variable references should be returned by reference");
    if ((executor_globals.return_value_ptr_ptr)) {
     retval_ptr = *retval_ptr_ptr;
     *(executor_globals.return_value_ptr_ptr) = retval_ptr;
     zval_addref_p(retval_ptr);
    }
    break;
   }
  }

  if ((executor_globals.return_value_ptr_ptr)) {
   if (!zval_isref_p(*retval_ptr_ptr)) { do { if (zval_refcount_p(*((retval_ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(retval_ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval_ptr_ptr))->value; (*new_zv).type = (**(retval_ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval_ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((retval_ptr_ptr))); };
   zval_addref_p(*(retval_ptr_ptr));

   *(executor_globals.return_value_ptr_ptr) = *retval_ptr_ptr;
  }
 } while (0);

 return zend_leave_helper_SPEC(execute_data );
}

static int __attribute__((fastcall)) ZEND_THROW_SPEC_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *value;
 zval *exception;


 ;
 value = opline->op1.zv;

 if ((1<<0) == (1<<0) || __builtin_expect((*value).type != 5, 0)) {
  zend_error_noreturn((1<<0L), "Can only throw objects");
 }
 zend_exception_save();

 do { (exception) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(exception))->u.buffered = ((void *)0); } while (0);
 do { do { (exception)->value = (value)->value; (*exception).type = (*value).type; } while (0); zval_set_refcount_p(exception, 1); zval_unset_isref_p(exception); } while (0);
 if (!0) {
  _zval_copy_ctor((exception) );
 }

 zend_throw_exception_object(exception );
 zend_exception_restore();

 ; return 0;
}

static int __attribute__((fastcall)) ZEND_SEND_VAL_SPEC_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 ;
 if (opline->extended_value==61
  && ((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && opline->op2.opline_num <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[opline->op2.opline_num-1].pass_by_reference & (1)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x1000000))))) {
   zend_error_noreturn((1<<0L), "Cannot pass parameter %d by reference", opline->op2.opline_num);
 }
 {
  zval *valptr;
  zval *value;


  value = opline->op1.zv;

  do { (valptr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(valptr))->u.buffered = ((void *)0); } while (0);
  do { do { (valptr)->value = (value)->value; (*valptr).type = (*value).type; } while (0); zval_set_refcount_p(valptr, 1); zval_unset_isref_p(valptr); } while (0);
  if (!0) {
   _zval_copy_ctor((valptr) );
  }
  zend_vm_stack_push(valptr );

 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BOOL_SPEC_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *retval = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;

 do { zval *__z = (retval); (*__z).value.lval = ((i_zend_is_true(opline->op1.zv)) != 0); (*__z).type = 3; } while (0);

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_CLONE_SPEC_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *obj;
 zend_class_entry *ce;
 zend_function *clone;
 zend_object_clone_obj_t clone_call;

 ;
 obj = opline->op1.zv;

 if ((1<<0) == (1<<0) ||
     __builtin_expect((*obj).type != 5, 0)) {
  zend_error_noreturn((1<<0L), "__clone method called on non-object");
 }

 ce = zend_get_class_entry(&(*obj) );
 clone = ce ? ce->clone : ((void *)0);
 clone_call = (*obj).value.obj.handlers->clone_obj;
 if (__builtin_expect(clone_call == ((void *)0), 0)) {
  if (ce) {
   zend_error_noreturn((1<<0L), "Trying to clone an uncloneable object of class %s", ce->name);
  } else {
   zend_error_noreturn((1<<0L), "Trying to clone an uncloneable object");
  }
 }

 if (ce && clone) {
  if (clone->op_array.fn_flags & 0x400) {


   if (__builtin_expect(ce != (executor_globals.scope), 0)) {
    zend_error_noreturn((1<<0L), "Call to private %s::__clone() from context '%s'", ce->name, (executor_globals.scope) ? (executor_globals.scope)->name : "");
   }
  } else if ((clone->common.fn_flags & 0x200)) {


   if (__builtin_expect(!zend_check_protected(clone->common.scope, (executor_globals.scope)), 0)) {
    zend_error_noreturn((1<<0L), "Call to protected %s::__clone() from context '%s'", ce->name, (executor_globals.scope) ? (executor_globals.scope)->name : "");
   }
  }
 }

 if (__builtin_expect((executor_globals.exception) == ((void *)0), 1)) {
  zval *retval;

  do { (retval) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(retval))->u.buffered = ((void *)0); } while (0);
  (*retval).value.obj = clone_call(obj );
  (*retval).type = 5;
  zval_set_refcount_p(retval, 1);
  zval_set_isref_p(retval);
  if (!(!((opline)->result_type & (1<<5))) || __builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
   i_zval_ptr_dtor(*(&retval) );
  } else {
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_CAST_SPEC_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *expr;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 expr = opline->op1.zv;

 if (opline->extended_value != 6) {
  do { (result)->value = (expr)->value; (*result).type = (*expr).type; } while (0);
  if (!0) {
   _zval_copy_ctor((&(*result)) );
  }
 }
 switch (opline->extended_value) {
  case 0:
   convert_to_null(result);
   break;
  case 3:
   convert_to_boolean(result);
   break;
  case 1:
   convert_to_long(result);
   break;
  case 2:
   convert_to_double(result);
   break;
  case 6: {
   zval var_copy;
   int use_copy;

   zend_make_printable_zval(expr, &var_copy, &use_copy);
   if (use_copy) {
    do { (result)->value = (&var_copy)->value; (*result).type = (*&var_copy).type; } while (0);
    if (0) {

    }
   } else {
    do { (result)->value = (expr)->value; (*result).type = (*expr).type; } while (0);
    if (!0) {
     _zval_copy_ctor((&(*result)) );
    }
   }
   break;
  }
  case 4:
   convert_to_array(result);
   break;
  case 5:
   convert_to_object(result);
   break;
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INCLUDE_OR_EVAL_SPEC_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_op_array *new_op_array=((void *)0);

 zval *inc_filename;
 zval tmp_inc_filename;
 zend_bool failure_retval=0;

 ;
 inc_filename = opline->op1.zv;

 if (inc_filename->type!=6) {
  do { (&tmp_inc_filename)->value = (inc_filename)->value; (*&tmp_inc_filename).type = (*inc_filename).type; } while (0);
  _zval_copy_ctor((&tmp_inc_filename) );
  if ((&tmp_inc_filename)->type != 6) { _convert_to_string((&tmp_inc_filename) ); };
  inc_filename = &tmp_inc_filename;
 }

 switch (opline->extended_value) {
  case (1<<2):
  case (1<<4): {
    zend_file_handle file_handle;
    char *resolved_path;

    resolved_path = zend_resolve_path((*inc_filename).value.str.val, (*inc_filename).value.str.len );
    if (resolved_path) {
     failure_retval = zend_hash_exists(&(executor_globals.included_files), resolved_path, strlen(resolved_path)+1);
    } else {
     resolved_path = (*inc_filename).value.str.val;
    }

    if (failure_retval) {

    } else if (0 == zend_stream_open(resolved_path, &file_handle )) {

     if (!file_handle.opened_path) {
      file_handle.opened_path = _estrdup((resolved_path) );
     }

     if (zend_hash_add_empty_element(&(executor_globals.included_files), file_handle.opened_path, strlen(file_handle.opened_path)+1)==0) {
      new_op_array = zend_compile_file(&file_handle, (opline->extended_value==(1<<2)?(1<<1):(1<<3)) );
      zend_destroy_file_handle(&file_handle );
     } else {
      zend_file_handle_dtor(&file_handle );
      failure_retval=1;
     }
    } else {
     if (opline->extended_value == (1<<2)) {
      zend_message_dispatcher(1L, (*inc_filename).value.str.val );
     } else {
      zend_message_dispatcher(2L, (*inc_filename).value.str.val );
     }
    }
    if (resolved_path != (*inc_filename).value.str.val) {
     _efree((resolved_path) );
    }
   }
   break;
  case (1<<1):
  case (1<<3):
   new_op_array = compile_filename(opline->extended_value, inc_filename );
   break;
  case (1<<0): {
    char *eval_desc = zend_make_compiled_string_description("eval()'d code" );

    new_op_array = zend_compile_string(inc_filename, eval_desc );
    _efree((eval_desc) );
   }
   break;
 
 }
 if (inc_filename==&tmp_inc_filename) {
  _zval_dtor((&tmp_inc_filename) );
 }

 if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
  ; return 0;
 } else if (__builtin_expect(new_op_array != ((void *)0), 1)) {
  execute_data->original_return_value = (executor_globals.return_value_ptr_ptr);
  (executor_globals.active_op_array) = new_op_array;
  if ((!((opline)->result_type & (1<<5)))) {
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = ((void *)0);
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr;
   (executor_globals.return_value_ptr_ptr) = (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr;
  } else {
   (executor_globals.return_value_ptr_ptr) = ((void *)0);
  }

  execute_data->current_object = execute_data->object;

  execute_data->function_state.function = (zend_function *) new_op_array;
  execute_data->object = ((void *)0);

  if (!(executor_globals.active_symbol_table)) {
   zend_rebuild_symbol_table();
  }

  if (__builtin_expect(zend_execute == execute, 1)) {
   return 2;
  } else {
   zend_execute(new_op_array );
  }

  execute_data->function_state.function = (zend_function *) execute_data->op_array;
  execute_data->object = execute_data->current_object;

  (executor_globals.opline_ptr) = &execute_data->opline;
  (executor_globals.active_op_array) = execute_data->op_array;
  (executor_globals.return_value_ptr_ptr) = execute_data->original_return_value;
  destroy_op_array(new_op_array );
  _efree((new_op_array) );
  if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
   zend_throw_exception_internal(((void *)0) );
   ; return 0;
  } else if ((!((opline)->result_type & (1<<5)))) {
   if (!(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr) {
    zval *retval;

    do { (retval) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(retval))->u.buffered = ((void *)0); } while (0);
    do { zval *__z = (retval); (*__z).value.lval = ((1) != 0); (*__z).type = 3; } while (0);
    (retval)->refcount__gc = 1; (retval)->is_ref__gc = 0;;
    (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = retval;
   }
  }

 } else if ((!((opline)->result_type & (1<<5)))) {
  zval *retval;

  do { (retval) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(retval))->u.buffered = ((void *)0); } while (0);
  do { zval *__z = (retval); (*__z).value.lval = ((failure_retval) != 0); (*__z).type = 3; } while (0);
  (retval)->refcount__gc = 1; (retval)->is_ref__gc = 0;;
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
 }
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FE_RESET_SPEC_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *array_ptr, **array_ptr_ptr;
 HashTable *fe_ht;
 zend_object_iterator *iter = ((void *)0);
 zend_class_entry *ce = ((void *)0);
 zend_bool is_empty = 0;

 ;

 if (((1<<0) == (1<<4) || (1<<0) == (1<<2)) &&
     (opline->extended_value & (1<<0))) {
  array_ptr_ptr = ((void *)0);
  if (array_ptr_ptr == ((void *)0) || array_ptr_ptr == &(executor_globals.uninitialized_zval_ptr)) {
   do { (array_ptr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(array_ptr))->u.buffered = ((void *)0); } while (0); (array_ptr)->refcount__gc = 1; (array_ptr)->is_ref__gc = 0;;;
   { (*array_ptr).type = 0; };
  } else if ((**array_ptr_ptr).type == 5) {
   if((**array_ptr_ptr).value.obj.handlers->get_class_entry == ((void *)0)) {
    zend_error((1<<1L), "foreach() cannot iterate over objects without PHP class");
    if (__builtin_expect(!(executor_globals.exception), 1)) { execute_data->opline = execute_data->op_array->opcodes+opline->op2.opline_num; } else { ; } return 0;
   }

   ce = zend_get_class_entry(&(**array_ptr_ptr) );
   if (!ce || ce->get_iterator == ((void *)0)) {
    if (!zval_isref_p(*array_ptr_ptr)) { do { if (zval_refcount_p(*((array_ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(array_ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(array_ptr_ptr))->value; (*new_zv).type = (**(array_ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(array_ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
    zval_addref_p(*(array_ptr_ptr));
   }
   array_ptr = *array_ptr_ptr;
  } else {
   if ((**array_ptr_ptr).type == 4) {
    if (!zval_isref_p(*array_ptr_ptr)) { do { if (zval_refcount_p(*((array_ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(array_ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(array_ptr_ptr))->value; (*new_zv).type = (**(array_ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(array_ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
    if (opline->extended_value & 1) {
     zval_set_isref_p(*(array_ptr_ptr));
    }
   }
   array_ptr = *array_ptr_ptr;
   zval_addref_p(array_ptr);
  }
 } else {
  array_ptr = opline->op1.zv;
  if (0) {
   zval *tmp;

   do { (tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(tmp))->u.buffered = ((void *)0); } while (0);
   do { do { (tmp)->value = (array_ptr)->value; (*tmp).type = (*array_ptr).type; } while (0); zval_set_refcount_p(tmp, 1); zval_unset_isref_p(tmp); } while (0);
   array_ptr = tmp;
   if ((*array_ptr).type == 5) {
    ce = zend_get_class_entry(&(*array_ptr) );
    if (ce && ce->get_iterator) {
     zval_delref_p(array_ptr);
    }
   }
  } else if ((*array_ptr).type == 5) {
   ce = zend_get_class_entry(&(*array_ptr) );
   if (!ce || !ce->get_iterator) {
    zval_addref_p(array_ptr);
   }
  } else if ((1<<0) == (1<<0) ||
             (((1<<0) == (1<<4) || (1<<0) == (1<<2)) &&
              !zval_isref_p(array_ptr) &&
              zval_refcount_p(array_ptr) > 1)) {
   zval *tmp;

   do { (tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(tmp))->u.buffered = ((void *)0); } while (0);
   do { do { (tmp)->value = (array_ptr)->value; (*tmp).type = (*array_ptr).type; } while (0); zval_set_refcount_p(tmp, 1); zval_unset_isref_p(tmp); } while (0);
   _zval_copy_ctor((tmp) );
   array_ptr = tmp;
  } else {
   zval_addref_p(array_ptr);
  }
 }

 if (ce && ce->get_iterator) {
  iter = ce->get_iterator(ce, array_ptr, opline->extended_value & (1<<1) );

  if (iter && __builtin_expect((executor_globals.exception) == ((void *)0), 1)) {
   array_ptr = zend_iterator_wrap(iter );
  } else {

   if (!(executor_globals.exception)) {
    zend_throw_exception_ex(((void *)0), 0 , "Object of type %s did not create an Iterator", ce->name);
   }
   zend_throw_exception_internal(((void *)0) );
   ; return 0;
  }
 }

 (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).fe.ptr = array_ptr;

 if (iter) {
  iter->index = 0;
  if (iter->funcs->rewind) {
   iter->funcs->rewind(iter );
   if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
    i_zval_ptr_dtor(*(&array_ptr) );

    ; return 0;
   }
  }
  is_empty = iter->funcs->valid(iter ) != 0;
  if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
   i_zval_ptr_dtor(*(&array_ptr) );

   ; return 0;
  }
  iter->index = -1;
 } else if ((fe_ht = ((*array_ptr).type==4 ? (*array_ptr).value.ht : (((*array_ptr).type==5 ? (*array_ptr).value.obj.handlers->get_properties((array_ptr) ) : ((void *)0))))) != ((void *)0)) {
  zend_hash_internal_pointer_reset_ex(fe_ht, ((void *)0));
  if (ce) {
   zend_object *zobj = zend_objects_get_address(array_ptr );
   while ((zend_hash_get_current_key_type_ex(fe_ht, ((void *)0)) == 3 ? -1 : 0) == 0) {
    char *str_key;
    uint str_key_len;
    ulong int_key;
    zend_uchar key_type;

    key_type = zend_hash_get_current_key_ex(fe_ht, &str_key, &str_key_len, &int_key, 0, ((void *)0));
    if (key_type != 3 &&
     (key_type == 2 ||
         zend_check_property_access(zobj, str_key, str_key_len-1 ) == 0)) {
     break;
    }
    zend_hash_move_forward_ex(fe_ht, ((void *)0));
   }
  }
  is_empty = (zend_hash_get_current_key_type_ex(fe_ht, ((void *)0)) == 3 ? -1 : 0) != 0;
  zend_hash_get_pointer(fe_ht, &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).fe.fe_pos);
 } else {
  zend_error((1<<1L), "Invalid argument supplied for foreach()");
  is_empty = 1;
 }

 if (is_empty) {
  if (__builtin_expect(!(executor_globals.exception), 1)) { execute_data->opline = execute_data->op_array->opcodes+opline->op2.opline_num; } else { ; } return 0;
 } else {
  ;
  execute_data->opline++; return 0;
 }
}

static int __attribute__((fastcall)) ZEND_EXIT_SPEC_CONST_HANDLER(zend_execute_data *execute_data )
{

 zend_op *opline = execute_data->opline;

 ;
 if ((1<<0) != (1<<3)) {

  zval *ptr = opline->op1.zv;

  if ((*ptr).type == 1) {
   (executor_globals.exit_status) = (*ptr).value.lval;
  } else {
   zend_print_variable(ptr);
  }

 }

 _zend_bailout("/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_vm_execute.h", 2536);
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_JMP_SET_SPEC_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *value;

 ;
 value = opline->op1.zv;

 if (i_zend_is_true(value)) {
  do { (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var)->value = (value)->value; (*&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).type = (*value).type; } while (0);
  _zval_copy_ctor((&((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var)) );




  if (__builtin_expect(!(executor_globals.exception), 1)) { execute_data->opline = opline->op2.jmp_addr; } else { ; } return 0;
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_QM_ASSIGN_SPEC_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *value;

 ;
 value = opline->op1.zv;

 do { (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var)->value = (value)->value; (*&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).type = (*value).type; } while (0);
 if (!0) {
  _zval_copy_ctor((&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var) );
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ADD_SPEC_CONST_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 add_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  opline->op2.zv );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SUB_SPEC_CONST_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 sub_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  opline->op2.zv );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_MUL_SPEC_CONST_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 mul_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  opline->op2.zv );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_DIV_SPEC_CONST_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 div_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  opline->op2.zv );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_MOD_SPEC_CONST_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 mod_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  opline->op2.zv );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SL_SPEC_CONST_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 shift_left_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  opline->op2.zv );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SR_SPEC_CONST_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 shift_right_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  opline->op2.zv );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_CONCAT_SPEC_CONST_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 concat_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  opline->op2.zv );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_IDENTICAL_SPEC_CONST_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 is_identical_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  opline->op2.zv );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_NOT_IDENTICAL_SPEC_CONST_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 is_identical_function(result,
  opline->op1.zv,
  opline->op2.zv );
 (*result).value.lval = !(*result).value.lval;


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_EQUAL_SPEC_CONST_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  opline->op1.zv,
  opline->op2.zv );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval == 0)) != 0); (*__z).type = 3; } while (0);


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_NOT_EQUAL_SPEC_CONST_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  opline->op1.zv,
  opline->op2.zv );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval != 0)) != 0); (*__z).type = 3; } while (0);


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_SMALLER_SPEC_CONST_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  opline->op1.zv,
  opline->op2.zv );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval < 0)) != 0); (*__z).type = 3; } while (0);


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  opline->op1.zv,
  opline->op2.zv );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval <= 0)) != 0); (*__z).type = 3; } while (0);


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_OR_SPEC_CONST_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 bitwise_or_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  opline->op2.zv );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_AND_SPEC_CONST_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 bitwise_and_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  opline->op2.zv );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_XOR_SPEC_CONST_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 bitwise_xor_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  opline->op2.zv );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BOOL_XOR_SPEC_CONST_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 boolean_xor_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  opline->op2.zv );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_fetch_var_address_helper_SPEC_CONST_CONST(int type, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *varname;
 zval **retval;
 zval tmp_varname;
 HashTable *target_symbol_table;
 ulong hash_value;

 ;
 varname = opline->op1.zv;

  if ((1<<0) != (1<<0) && __builtin_expect((*varname).type != 6, 0)) {
  do { (&tmp_varname)->value = (varname)->value; (*&tmp_varname).type = (*varname).type; } while (0);
  _zval_copy_ctor((&tmp_varname) );
  if ((&tmp_varname)->type != 6) { _convert_to_string((&tmp_varname) ); };
  varname = &tmp_varname;
 }

 if ((1<<0) != (1<<3)) {
  zend_class_entry *ce;

  if ((1<<0) == (1<<0)) {
   if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
    ce = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
   } else {
    ce = zend_fetch_class_by_name((*opline->op2.zv).value.str.val, (*opline->op2.zv).value.str.len, opline->op2.literal + 1, 0 );
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); } while (0);
   }
  } else {
   ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).class_entry;
  }
  retval = zend_std_get_static_property(ce, (*varname).value.str.val, (*varname).value.str.len, 0, (((1<<0) == (1<<0)) ? opline->op1.literal : ((void *)0)) );

 } else {
  target_symbol_table = zend_get_target_symbol_table(opline->extended_value & 0x70000000 );






  if ((1<<0) == (1<<0)) {
   hash_value = (((zend_literal*)(varname))->hash_value);
  } else if (((((*varname).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*varname).value.str.val) < (compiler_globals.interned_strings_end)))) {
   hash_value = (((Bucket*)(((char*)((*varname).value.str.val))-sizeof(Bucket)))->h);
  } else {
   hash_value = zend_hash_func((*varname).value.str.val, (*varname).value.str.len+1);
  }

  if (zend_hash_quick_find(target_symbol_table, (*varname).value.str.val, (*varname).value.str.len+1, hash_value, (void **) &retval) == -1) {
   switch (type) {
    case 0:
    case 6:
     zend_error((1<<3L),"Undefined variable: %s", (*varname).value.str.val);

    case 3:
     retval = &(executor_globals.uninitialized_zval_ptr);
     break;
    case 2:
     zend_error((1<<3L),"Undefined variable: %s", (*varname).value.str.val);

    case 1:
     zval_addref_p(&(executor_globals.uninitialized_zval));
     _zend_hash_quick_add_or_update(target_symbol_table, (*varname).value.str.val, (*varname).value.str.len+1, hash_value, &(executor_globals.uninitialized_zval_ptr), sizeof(zval *), (void **) &retval, (1<<0) );
     break;
   
   }
  }
  switch (opline->extended_value & 0x70000000) {
   case 0x00000000:
    if ((1<<0) != (1<<1)) {

    }
    break;
   case 0x10000000:

    break;
   case 0x20000000:
    zval_update_constant(retval, (void*) 1 );
    break;
   case 0x40000000:
    if ((1<<0) == (1<<2) && !free_op1.var) {
     zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr));
    }
    break;
  }
 }


 if ((1<<0) != (1<<0) && varname == &tmp_varname) {
  _zval_dtor((&tmp_varname) );
 }
 if (opline->extended_value & 0x04000000) {
  if (!zval_isref_p(*retval)) { do { if (zval_refcount_p(*((retval))) > 1) { zval *new_zv; zval_delref_p(*(retval)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval))->value; (*new_zv).type = (**(retval)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((retval))); };
 }
 zval_addref_p((*retval));
 switch (type) {
  case 0:
  case 3:
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (*retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   break;
  case 6: {
   zend_free_op free_res;

   zend_pzval_unlock_func(*retval, &free_res, 1 );
   if (retval != &(executor_globals.uninitialized_zval_ptr)) {
    if (!zval_isref_p(*retval)) { do { if (zval_refcount_p(*((retval))) > 1) { zval *new_zv; zval_delref_p(*(retval)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval))->value; (*new_zv).type = (**(retval)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
   }
   zval_addref_p((*retval));
   if (free_res.var) { i_zval_ptr_dtor(*(&free_res.var) ); };
  }

  default:
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = retval;
   break;
 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_R_SPEC_CONST_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_CONST_CONST(0, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_W_SPEC_CONST_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_CONST_CONST(1, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_RW_SPEC_CONST_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_CONST_CONST(2, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_FUNC_ARG_SPEC_CONST_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 return zend_fetch_var_address_helper_SPEC_CONST_CONST(((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && (opline->extended_value & 0x000fffff) <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[(opline->extended_value & 0x000fffff)-1].pass_by_reference & (1|2)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x1000000|0x2000000))))?1:0, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_UNSET_SPEC_CONST_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_CONST_CONST(6, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_IS_SPEC_CONST_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_CONST_CONST(3, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_TMP_VAR_SPEC_CONST_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *container;

 ;
 container = opline->op1.zv;

 if (__builtin_expect((*container).type != 4, 0)) {
  zval_addref_p((&(executor_globals.uninitialized_zval)));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
 } else {

  zval *value = *zend_fetch_dimension_address_inner((*container).value.ht, opline->op2.zv, (1<<0), 0 );

  zval_addref_p((value));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (value); __t->var.ptr_ptr = &__t->var.ptr; } while (0);

 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *function_name;
 zend_class_entry *ce;

 ;
 zend_ptr_stack_3_push(&(executor_globals.arg_types_stack), execute_data->fbc, execute_data->object, execute_data->called_scope);

 if ((1<<0) == (1<<0)) {

  if ((executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)]) {
   ce = (executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)];
  } else {
   ce = zend_fetch_class_by_name((*opline->op1.zv).value.str.val, (*opline->op1.zv).value.str.len, opline->op1.literal + 1, opline->extended_value );
   if (__builtin_expect(ce == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Class '%s' not found", (*opline->op1.zv).value.str.val);
   }
   do { (executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)] = (ce); } while (0);
  }
  execute_data->called_scope = ce;
 } else {
  ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).class_entry;

  if (opline->extended_value == 2 || opline->extended_value == 1) {
   execute_data->called_scope = (executor_globals.called_scope);
  } else {
   execute_data->called_scope = ce;
  }
 }

 if ((1<<0) == (1<<0) &&
     (1<<0) == (1<<0) &&
     (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
  execute_data->fbc = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
 } else if ((1<<0) != (1<<0) &&
            (1<<0) == (1<<0) &&
            (execute_data->fbc = (((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] == (ce)) ? (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] : ((void *)0)))) {

 } else if ((1<<0) != (1<<3)) {
  char *function_name_strval = ((void *)0);
  int function_name_strlen = 0;


  if ((1<<0) == (1<<0)) {
   function_name_strval = (*opline->op2.zv).value.str.val;
   function_name_strlen = (*opline->op2.zv).value.str.len;
  } else {
   function_name = opline->op2.zv;

   if (__builtin_expect((*function_name).type != 6, 0)) {
    zend_error_noreturn((1<<0L), "Function name must be a string");
   } else {
    function_name_strval = (*function_name).value.str.val;
    function_name_strlen = (*function_name).value.str.len;
    }
  }

  if (function_name_strval) {
   if (ce->get_static_method) {
    execute_data->fbc = ce->get_static_method(ce, function_name_strval, function_name_strlen );
   } else {
    execute_data->fbc = zend_std_get_static_method(ce, function_name_strval, function_name_strlen, (((1<<0) == (1<<0)) ? (opline->op2.literal + 1) : ((void *)0)) );
   }
   if (__builtin_expect(execute_data->fbc == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Call to undefined method %s::%s()", ce->name, function_name_strval);
   }
   if ((1<<0) == (1<<0) && __builtin_expect((execute_data->fbc->common.fn_flags & 0x200000) == 0, 1)) {
    if ((1<<0) == (1<<0)) {
     do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (execute_data->fbc); } while (0);
    } else {
     do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] = (execute_data->fbc); } while (0);
    }
   }
  }
  if ((1<<0) != (1<<0)) {

  }
 } else {
  if (__builtin_expect(ce->constructor == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot call constructor");
  }
  if ((executor_globals.This) && zend_get_class_entry(&(*(executor_globals.This)) ) != ce->constructor->common.scope && (ce->constructor->common.fn_flags & 0x400)) {
   zend_error_noreturn((1<<0L), "Cannot call private %s::__construct()", ce->name);
  }
  execute_data->fbc = ce->constructor;
 }

 if (execute_data->fbc->common.fn_flags & 0x01) {
  execute_data->object = ((void *)0);
 } else {
  if ((executor_globals.This) &&
      (*(executor_globals.This)).value.obj.handlers->get_class_entry &&
      !instanceof_function(zend_get_class_entry(&(*(executor_globals.This)) ), ce )) {


   if (execute_data->fbc->common.fn_flags & 0x10000) {
    zend_error((1<<11L), "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", execute_data->fbc->common.scope->name, execute_data->fbc->common.function_name);
   } else {

    zend_error_noreturn((1<<0L), "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", execute_data->fbc->common.scope->name, execute_data->fbc->common.function_name);
   }
  }
  if ((execute_data->object = (executor_globals.This))) {
   zval_addref_p(execute_data->object);
   execute_data->called_scope = zend_get_class_entry(&(*execute_data->object) );
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_CASE_SPEC_CONST_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 if ((1<<0)==(1<<2)) {
  zval_addref_p(((*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr));
 }
 is_equal_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
     opline->op1.zv,
     opline->op2.zv );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_CONSTANT_SPEC_CONST_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 ;
 if ((1<<0) == (1<<3)) {
  zend_constant *c;
  zval *retval;

  if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
   c = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
  } else if ((c = zend_quick_get_constant(opline->op2.literal + 1, opline->extended_value )) == ((void *)0)) {
   if ((opline->extended_value & 0x010) != 0) {
    char *actual = (char *)zend_memrchr((*opline->op2.zv).value.str.val, '\\', (*opline->op2.zv).value.str.len);
    if(!actual) {
     actual = (*opline->op2.zv).value.str.val;
    } else {
     actual++;
    }

    zend_error((1<<3L), "Use of undefined constant %s - assumed '%s'", actual, actual);
    do { const char *__s=(actual); int __l=(*opline->op2.zv).value.str.len-(actual - (*opline->op2.zv).value.str.val); zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.str.len = __l; (*__z).value.str.val = (1?_estrndup((__s), (__l) ):(char*)__s); (*__z).type = 6; } while (0);
    ;
    execute_data->opline++; return 0;
   } else {
    zend_error_noreturn((1<<0L), "Undefined constant '%s'", (*opline->op2.zv).value.str.val);
   }
  } else {
   do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (c); } while (0);
  }
  retval = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;
  do { (retval)->value = (&c->value)->value; (*retval).type = (*&c->value).type; } while (0);
  _zval_copy_ctor((retval) );
  ;
  execute_data->opline++; return 0;
 } else {

  zend_class_entry *ce;
  zval **value;

  if ((1<<0) == (1<<0)) {
   if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
    value = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
    do { (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var)->value = (*value)->value; (*&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).type = (**value).type; } while (0);
    _zval_copy_ctor((&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var) );
    ;
    execute_data->opline++; return 0;
   } else if ((executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)]) {
    ce = (executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)];
   } else {
    ce = zend_fetch_class_by_name((*opline->op1.zv).value.str.val, (*opline->op1.zv).value.str.len, opline->op1.literal + 1, opline->extended_value );
    if (__builtin_expect(ce == ((void *)0), 0)) {
     zend_error_noreturn((1<<0L), "Undefined class constant '%s'", (*opline->op2.zv).value.str.val);
    }
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)] = (ce); } while (0);
   }
  } else {
   ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).class_entry;
   if ((value = (((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] == (ce)) ? (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] : ((void *)0))) != ((void *)0)) {
    do { (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var)->value = (*value)->value; (*&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).type = (**value).type; } while (0);
    _zval_copy_ctor((&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var) );
    ;
    execute_data->opline++; return 0;
   }
  }

  if (__builtin_expect(zend_hash_quick_find(&ce->constants_table, (*opline->op2.zv).value.str.val, (*opline->op2.zv).value.str.len+1, (((zend_literal*)(opline->op2.zv))->hash_value), (void **) &value) == 0, 1)) {
   if ((**value).type == 9 ||
       ((**value).type & 0x00f) == 8) {
    zend_class_entry *old_scope = (executor_globals.scope);

    (executor_globals.scope) = ce;
    zval_update_constant(value, (void *) 1 );
    (executor_globals.scope) = old_scope;
   }
   if ((1<<0) == (1<<0)) {
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (value); } while (0);
   } else {
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] = (value); } while (0);
   }
   do { (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var)->value = (*value)->value; (*&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).type = (**value).type; } while (0);
   _zval_copy_ctor((&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var) );
  } else {
   zend_error_noreturn((1<<0L), "Undefined class constant '%s'", (*opline->op2.zv).value.str.val);
  }

  ;
  execute_data->opline++; return 0;
 }
}

static int __attribute__((fastcall)) ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *expr_ptr;

 ;
 if (((1<<0) == (1<<2) || (1<<0) == (1<<4)) && opline->extended_value) {
  zval **expr_ptr_ptr = ((void *)0);

  if ((1<<0) == (1<<2) && __builtin_expect(expr_ptr_ptr == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot create references to/from string offsets");
  }
  if (!zval_isref_p(*expr_ptr_ptr)) { do { if (zval_refcount_p(*((expr_ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(expr_ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(expr_ptr_ptr))->value; (*new_zv).type = (**(expr_ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(expr_ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((expr_ptr_ptr))); };
  expr_ptr = *expr_ptr_ptr;
  zval_addref_p(expr_ptr);
 } else {
  expr_ptr=opline->op1.zv;
  if (0) {
   zval *new_expr;

   do { (new_expr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_expr))->u.buffered = ((void *)0); } while (0);
   do { do { (new_expr)->value = (expr_ptr)->value; (*new_expr).type = (*expr_ptr).type; } while (0); zval_set_refcount_p(new_expr, 1); zval_unset_isref_p(new_expr); } while (0);
   expr_ptr = new_expr;
  } else if ((1<<0) == (1<<0) || zval_isref_p(expr_ptr)) {
   zval *new_expr;

   do { (new_expr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_expr))->u.buffered = ((void *)0); } while (0);
   do { do { (new_expr)->value = (expr_ptr)->value; (*new_expr).type = (*expr_ptr).type; } while (0); zval_set_refcount_p(new_expr, 1); zval_unset_isref_p(new_expr); } while (0);
   expr_ptr = new_expr;
   _zval_copy_ctor((&(*expr_ptr)) );
  } else {
   zval_addref_p(expr_ptr);
  }
 }

 if ((1<<0) != (1<<3)) {

  zval *offset = opline->op2.zv;
  ulong hval;

  switch ((*offset).type) {
   case 2:
    hval = zend_dval_to_lval((*offset).value.dval);
    goto num_index;
   case 1:
   case 3:
    hval = (*offset).value.lval;
num_index:
    _zend_hash_index_update_or_next_insert(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, hval, &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   case 6:
    if ((1<<0) == (1<<0)) {
     hval = (((zend_literal*)(offset))->hash_value);
    } else {
     do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index; } } } while (0);
     if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
      hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
     } else {
      hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
     }
    }
    _zend_hash_quick_add_or_update(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   case 0:
    _zend_hash_add_or_update(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, "", sizeof(""), &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   default:
    zend_error((1<<1L), "Illegal offset type");
    i_zval_ptr_dtor(*(&expr_ptr) );

    break;
  }

 } else {
  _zend_hash_index_update_or_next_insert(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, 0, &expr_ptr, sizeof(zval *), ((void *)0), (1<<2) );
 }
 if (((1<<0) == (1<<2) || (1<<0) == (1<<4)) && opline->extended_value) {

 } else {

 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_ARRAY_SPEC_CONST_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 _array_init((&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var), 0 );
 if ((1<<0) == (1<<3)) {
  execute_data->opline++; return 0;

 } else {
  return ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CONST_HANDLER(execute_data );

 }
}

static int __attribute__((fastcall)) ZEND_UNSET_VAR_SPEC_CONST_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval tmp, *varname;
 HashTable *target_symbol_table;


 ;
 if ((1<<0) == (1<<4) &&
     (1<<0) == (1<<3) &&
     (opline->extended_value & 0x00800000)) {
  if ((executor_globals.active_symbol_table)) {
   zend_compiled_variable *cv = &((executor_globals.active_op_array)->vars[opline->op1.var]);

   zend_delete_variable(execute_data->prev_execute_data, (executor_globals.active_symbol_table), cv->name, cv->name_len+1, cv->hash_value );
   execute_data->CVs[opline->op1.var] = ((void *)0);
  } else if (execute_data->CVs[opline->op1.var]) {
   i_zval_ptr_dtor(*(execute_data->CVs[opline->op1.var]) );
   execute_data->CVs[opline->op1.var] = ((void *)0);
  }
  ;
  execute_data->opline++; return 0;
 }

 varname = opline->op1.zv;

 if ((1<<0) != (1<<0) && (*varname).type != 6) {
  do { (&tmp)->value = (varname)->value; (*&tmp).type = (*varname).type; } while (0);
  _zval_copy_ctor((&tmp) );
  if ((&tmp)->type != 6) { _convert_to_string((&tmp) ); };
  varname = &tmp;
 } else if ((1<<0) == (1<<2) || (1<<0) == (1<<4)) {
  zval_addref_p(varname);
 }

 if ((1<<0) != (1<<3)) {
  zend_class_entry *ce;

  if ((1<<0) == (1<<0)) {
   if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
    ce = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
   } else {
    ce = zend_fetch_class_by_name((*opline->op2.zv).value.str.val, (*opline->op2.zv).value.str.len, opline->op2.literal + 1, 0 );
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); } while (0);
   }
  } else {
   ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).class_entry;
  }
  zend_std_unset_static_property(ce, (*varname).value.str.val, (*varname).value.str.len, (((1<<0) == (1<<0)) ? opline->op1.literal : ((void *)0)) );
 } else {
  ulong hash_value = zend_inline_hash_func(varname->value.str.val, varname->value.str.len+1);

  target_symbol_table = zend_get_target_symbol_table(opline->extended_value & 0x70000000 );
  zend_delete_variable(execute_data, target_symbol_table, varname->value.str.val, varname->value.str.len+1, hash_value );
 }

 if ((1<<0) != (1<<0) && varname == &tmp) {
  _zval_dtor((&tmp) );
 } else if ((1<<0) == (1<<2) || (1<<0) == (1<<4)) {
  i_zval_ptr_dtor(*(&varname) );
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ISSET_ISEMPTY_VAR_SPEC_CONST_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval **value;
 zend_bool isset = 1;

 ;
 if ((1<<0) == (1<<4) &&
     (1<<0) == (1<<3) &&
     (opline->extended_value & 0x00800000)) {
  if (execute_data->CVs[opline->op1.var]) {
   value = execute_data->CVs[opline->op1.var];
  } else if ((executor_globals.active_symbol_table)) {
   zend_compiled_variable *cv = &((executor_globals.active_op_array)->vars[opline->op1.var]);

   if (zend_hash_quick_find((executor_globals.active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, (void **) &value) == -1) {
    isset = 0;
   }
  } else {
   isset = 0;
  }
 } else {
  HashTable *target_symbol_table;

  zval tmp, *varname = opline->op1.zv;

  if ((1<<0) != (1<<0) && (*varname).type != 6) {
   do { (&tmp)->value = (varname)->value; (*&tmp).type = (*varname).type; } while (0);
   _zval_copy_ctor((&tmp) );
   if ((&tmp)->type != 6) { _convert_to_string((&tmp) ); };
   varname = &tmp;
  }

  if ((1<<0) != (1<<3)) {
   zend_class_entry *ce;

   if ((1<<0) == (1<<0)) {
    if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
     ce = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
    } else {
     ce = zend_fetch_class_by_name((*opline->op2.zv).value.str.val, (*opline->op2.zv).value.str.len, opline->op2.literal + 1, 0 );
     do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); } while (0);
    }
   } else {
    ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).class_entry;
   }
   value = zend_std_get_static_property(ce, (*varname).value.str.val, (*varname).value.str.len, 1, (((1<<0) == (1<<0)) ? opline->op1.literal : ((void *)0)) );
   if (!value) {
    isset = 0;
   }
  } else {
   target_symbol_table = zend_get_target_symbol_table(opline->extended_value & 0x70000000 );
   if (zend_hash_find(target_symbol_table, varname->value.str.val, varname->value.str.len+1, (void **) &value) == -1) {
    isset = 0;
   }
  }

  if ((1<<0) != (1<<0) && varname == &tmp) {
   _zval_dtor((&tmp) );
  }

 }

 if (opline->extended_value & 0x02000000) {
  if (isset && (**value).type != 0) {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((1) != 0); (*__z).type = 3; } while (0);
  } else {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((0) != 0); (*__z).type = 3; } while (0);
  }
 } else {
  if (!isset || !i_zend_is_true(*value)) {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((1) != 0); (*__z).type = 3; } while (0);
  } else {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((0) != 0); (*__z).type = 3; } while (0);
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_DECLARE_CONST_SPEC_CONST_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *name;
 zval *val;
 zend_constant c;

 ;
 name = opline->op1.zv;
 val = opline->op2.zv;

 if (((*val).type & 0x00f) == 8 || (*val).type == 9) {
  zval tmp;
  zval *tmp_ptr = &tmp;

  do { (&tmp)->value = (val)->value; (*&tmp).type = (*val).type; } while (0);
  if ((*val).type == 9) {
   _zval_copy_ctor((&tmp) );
  }
  (&tmp)->refcount__gc = 1; (&tmp)->is_ref__gc = 0;;
  zval_update_constant(&tmp_ptr, ((void *)0) );
  c.value = *tmp_ptr;
 } else {
  do { do { (&c.value)->value = (val)->value; (*&c.value).type = (*val).type; } while (0); zval_set_refcount_p(&c.value, 1); zval_unset_isref_p(&c.value); } while (0);
  _zval_copy_ctor((&c.value) );
 }
 c.flags = (1<<0);
 c.name = ((((*name).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*name).value.str.val) < (compiler_globals.interned_strings_end))) ? (*name).value.str.val : zend_strndup((*name).value.str.val, (*name).value.str.len);
 c.name_len = (*name).value.str.len+1;
 c.module_number = 2147483647;

 if (zend_register_constant(&c ) == -1) {
 }


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ADD_SPEC_CONST_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 add_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );

 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SUB_SPEC_CONST_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 sub_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );

 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_MUL_SPEC_CONST_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 mul_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );

 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_DIV_SPEC_CONST_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 div_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );

 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_MOD_SPEC_CONST_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 mod_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );

 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SL_SPEC_CONST_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 shift_left_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );

 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SR_SPEC_CONST_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 shift_right_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );

 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_CONCAT_SPEC_CONST_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 concat_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );

 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_IDENTICAL_SPEC_CONST_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 is_identical_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );

 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_NOT_IDENTICAL_SPEC_CONST_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 is_identical_function(result,
  opline->op1.zv,
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 (*result).value.lval = !(*result).value.lval;

 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_EQUAL_SPEC_CONST_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  opline->op1.zv,
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval == 0)) != 0); (*__z).type = 3; } while (0);

 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_NOT_EQUAL_SPEC_CONST_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  opline->op1.zv,
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval != 0)) != 0); (*__z).type = 3; } while (0);

 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_SMALLER_SPEC_CONST_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  opline->op1.zv,
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval < 0)) != 0); (*__z).type = 3; } while (0);

 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  opline->op1.zv,
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval <= 0)) != 0); (*__z).type = 3; } while (0);

 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_OR_SPEC_CONST_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 bitwise_or_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );

 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_AND_SPEC_CONST_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 bitwise_and_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );

 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_XOR_SPEC_CONST_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 bitwise_xor_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );

 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BOOL_XOR_SPEC_CONST_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 boolean_xor_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );

 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *function_name;
 zend_class_entry *ce;

 ;
 zend_ptr_stack_3_push(&(executor_globals.arg_types_stack), execute_data->fbc, execute_data->object, execute_data->called_scope);

 if ((1<<0) == (1<<0)) {

  if ((executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)]) {
   ce = (executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)];
  } else {
   ce = zend_fetch_class_by_name((*opline->op1.zv).value.str.val, (*opline->op1.zv).value.str.len, opline->op1.literal + 1, opline->extended_value );
   if (__builtin_expect(ce == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Class '%s' not found", (*opline->op1.zv).value.str.val);
   }
   do { (executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)] = (ce); } while (0);
  }
  execute_data->called_scope = ce;
 } else {
  ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).class_entry;

  if (opline->extended_value == 2 || opline->extended_value == 1) {
   execute_data->called_scope = (executor_globals.called_scope);
  } else {
   execute_data->called_scope = ce;
  }
 }

 if ((1<<0) == (1<<0) &&
     (1<<1) == (1<<0) &&
     (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
  execute_data->fbc = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
 } else if ((1<<0) != (1<<0) &&
            (1<<1) == (1<<0) &&
            (execute_data->fbc = (((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] == (ce)) ? (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] : ((void *)0)))) {

 } else if ((1<<1) != (1<<3)) {
  char *function_name_strval = ((void *)0);
  int function_name_strlen = 0;
  zend_free_op free_op2;

  if ((1<<1) == (1<<0)) {
   function_name_strval = (*opline->op2.zv).value.str.val;
   function_name_strlen = (*opline->op2.zv).value.str.len;
  } else {
   function_name = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );

   if (__builtin_expect((*function_name).type != 6, 0)) {
    zend_error_noreturn((1<<0L), "Function name must be a string");
   } else {
    function_name_strval = (*function_name).value.str.val;
    function_name_strlen = (*function_name).value.str.len;
    }
  }

  if (function_name_strval) {
   if (ce->get_static_method) {
    execute_data->fbc = ce->get_static_method(ce, function_name_strval, function_name_strlen );
   } else {
    execute_data->fbc = zend_std_get_static_method(ce, function_name_strval, function_name_strlen, (((1<<1) == (1<<0)) ? (opline->op2.literal + 1) : ((void *)0)) );
   }
   if (__builtin_expect(execute_data->fbc == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Call to undefined method %s::%s()", ce->name, function_name_strval);
   }
   if ((1<<1) == (1<<0) && __builtin_expect((execute_data->fbc->common.fn_flags & 0x200000) == 0, 1)) {
    if ((1<<0) == (1<<0)) {
     do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (execute_data->fbc); } while (0);
    } else {
     do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] = (execute_data->fbc); } while (0);
    }
   }
  }
  if ((1<<1) != (1<<0)) {
   _zval_dtor((free_op2.var) );
  }
 } else {
  if (__builtin_expect(ce->constructor == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot call constructor");
  }
  if ((executor_globals.This) && zend_get_class_entry(&(*(executor_globals.This)) ) != ce->constructor->common.scope && (ce->constructor->common.fn_flags & 0x400)) {
   zend_error_noreturn((1<<0L), "Cannot call private %s::__construct()", ce->name);
  }
  execute_data->fbc = ce->constructor;
 }

 if (execute_data->fbc->common.fn_flags & 0x01) {
  execute_data->object = ((void *)0);
 } else {
  if ((executor_globals.This) &&
      (*(executor_globals.This)).value.obj.handlers->get_class_entry &&
      !instanceof_function(zend_get_class_entry(&(*(executor_globals.This)) ), ce )) {


   if (execute_data->fbc->common.fn_flags & 0x10000) {
    zend_error((1<<11L), "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", execute_data->fbc->common.scope->name, execute_data->fbc->common.function_name);
   } else {

    zend_error_noreturn((1<<0L), "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", execute_data->fbc->common.scope->name, execute_data->fbc->common.function_name);
   }
  }
  if ((execute_data->object = (executor_globals.This))) {
   zval_addref_p(execute_data->object);
   execute_data->called_scope = zend_get_class_entry(&(*execute_data->object) );
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_CASE_SPEC_CONST_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 if ((1<<0)==(1<<2)) {
  zval_addref_p(((*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr));
 }
 is_equal_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
     opline->op1.zv,
     _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );

 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *expr_ptr;

 ;
 if (((1<<0) == (1<<2) || (1<<0) == (1<<4)) && opline->extended_value) {
  zval **expr_ptr_ptr = ((void *)0);

  if ((1<<0) == (1<<2) && __builtin_expect(expr_ptr_ptr == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot create references to/from string offsets");
  }
  if (!zval_isref_p(*expr_ptr_ptr)) { do { if (zval_refcount_p(*((expr_ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(expr_ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(expr_ptr_ptr))->value; (*new_zv).type = (**(expr_ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(expr_ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((expr_ptr_ptr))); };
  expr_ptr = *expr_ptr_ptr;
  zval_addref_p(expr_ptr);
 } else {
  expr_ptr=opline->op1.zv;
  if (0) {
   zval *new_expr;

   do { (new_expr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_expr))->u.buffered = ((void *)0); } while (0);
   do { do { (new_expr)->value = (expr_ptr)->value; (*new_expr).type = (*expr_ptr).type; } while (0); zval_set_refcount_p(new_expr, 1); zval_unset_isref_p(new_expr); } while (0);
   expr_ptr = new_expr;
  } else if ((1<<0) == (1<<0) || zval_isref_p(expr_ptr)) {
   zval *new_expr;

   do { (new_expr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_expr))->u.buffered = ((void *)0); } while (0);
   do { do { (new_expr)->value = (expr_ptr)->value; (*new_expr).type = (*expr_ptr).type; } while (0); zval_set_refcount_p(new_expr, 1); zval_unset_isref_p(new_expr); } while (0);
   expr_ptr = new_expr;
   _zval_copy_ctor((&(*expr_ptr)) );
  } else {
   zval_addref_p(expr_ptr);
  }
 }

 if ((1<<1) != (1<<3)) {
  zend_free_op free_op2;
  zval *offset = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );
  ulong hval;

  switch ((*offset).type) {
   case 2:
    hval = zend_dval_to_lval((*offset).value.dval);
    goto num_index;
   case 1:
   case 3:
    hval = (*offset).value.lval;
num_index:
    _zend_hash_index_update_or_next_insert(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, hval, &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   case 6:
    if ((1<<1) == (1<<0)) {
     hval = (((zend_literal*)(offset))->hash_value);
    } else {
     do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index; } } } while (0);
     if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
      hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
     } else {
      hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
     }
    }
    _zend_hash_quick_add_or_update(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   case 0:
    _zend_hash_add_or_update(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, "", sizeof(""), &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   default:
    zend_error((1<<1L), "Illegal offset type");
    i_zval_ptr_dtor(*(&expr_ptr) );

    break;
  }
  _zval_dtor((free_op2.var) );
 } else {
  _zend_hash_index_update_or_next_insert(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, 0, &expr_ptr, sizeof(zval *), ((void *)0), (1<<2) );
 }
 if (((1<<0) == (1<<2) || (1<<0) == (1<<4)) && opline->extended_value) {

 } else {

 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_ARRAY_SPEC_CONST_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 _array_init((&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var), 0 );
 if ((1<<0) == (1<<3)) {
  execute_data->opline++; return 0;

 } else {
  return ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_TMP_HANDLER(execute_data );

 }
}

static int __attribute__((fastcall)) ZEND_ADD_SPEC_CONST_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 add_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SUB_SPEC_CONST_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 sub_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_MUL_SPEC_CONST_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 mul_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_DIV_SPEC_CONST_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 div_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_MOD_SPEC_CONST_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 mod_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SL_SPEC_CONST_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 shift_left_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SR_SPEC_CONST_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 shift_right_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_CONCAT_SPEC_CONST_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 concat_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_IDENTICAL_SPEC_CONST_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 is_identical_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_NOT_IDENTICAL_SPEC_CONST_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 is_identical_function(result,
  opline->op1.zv,
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 (*result).value.lval = !(*result).value.lval;

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_EQUAL_SPEC_CONST_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  opline->op1.zv,
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval == 0)) != 0); (*__z).type = 3; } while (0);

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_NOT_EQUAL_SPEC_CONST_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  opline->op1.zv,
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval != 0)) != 0); (*__z).type = 3; } while (0);

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_SMALLER_SPEC_CONST_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  opline->op1.zv,
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval < 0)) != 0); (*__z).type = 3; } while (0);

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  opline->op1.zv,
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval <= 0)) != 0); (*__z).type = 3; } while (0);

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_OR_SPEC_CONST_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 bitwise_or_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_AND_SPEC_CONST_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 bitwise_and_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_XOR_SPEC_CONST_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 bitwise_xor_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BOOL_XOR_SPEC_CONST_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 boolean_xor_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_fetch_var_address_helper_SPEC_CONST_VAR(int type, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *varname;
 zval **retval;
 zval tmp_varname;
 HashTable *target_symbol_table;
 ulong hash_value;

 ;
 varname = opline->op1.zv;

  if ((1<<0) != (1<<0) && __builtin_expect((*varname).type != 6, 0)) {
  do { (&tmp_varname)->value = (varname)->value; (*&tmp_varname).type = (*varname).type; } while (0);
  _zval_copy_ctor((&tmp_varname) );
  if ((&tmp_varname)->type != 6) { _convert_to_string((&tmp_varname) ); };
  varname = &tmp_varname;
 }

 if ((1<<2) != (1<<3)) {
  zend_class_entry *ce;

  if ((1<<2) == (1<<0)) {
   if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
    ce = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
   } else {
    ce = zend_fetch_class_by_name((*opline->op2.zv).value.str.val, (*opline->op2.zv).value.str.len, opline->op2.literal + 1, 0 );
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); } while (0);
   }
  } else {
   ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).class_entry;
  }
  retval = zend_std_get_static_property(ce, (*varname).value.str.val, (*varname).value.str.len, 0, (((1<<0) == (1<<0)) ? opline->op1.literal : ((void *)0)) );

 } else {
  target_symbol_table = zend_get_target_symbol_table(opline->extended_value & 0x70000000 );






  if ((1<<0) == (1<<0)) {
   hash_value = (((zend_literal*)(varname))->hash_value);
  } else if (((((*varname).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*varname).value.str.val) < (compiler_globals.interned_strings_end)))) {
   hash_value = (((Bucket*)(((char*)((*varname).value.str.val))-sizeof(Bucket)))->h);
  } else {
   hash_value = zend_hash_func((*varname).value.str.val, (*varname).value.str.len+1);
  }

  if (zend_hash_quick_find(target_symbol_table, (*varname).value.str.val, (*varname).value.str.len+1, hash_value, (void **) &retval) == -1) {
   switch (type) {
    case 0:
    case 6:
     zend_error((1<<3L),"Undefined variable: %s", (*varname).value.str.val);

    case 3:
     retval = &(executor_globals.uninitialized_zval_ptr);
     break;
    case 2:
     zend_error((1<<3L),"Undefined variable: %s", (*varname).value.str.val);

    case 1:
     zval_addref_p(&(executor_globals.uninitialized_zval));
     _zend_hash_quick_add_or_update(target_symbol_table, (*varname).value.str.val, (*varname).value.str.len+1, hash_value, &(executor_globals.uninitialized_zval_ptr), sizeof(zval *), (void **) &retval, (1<<0) );
     break;
   
   }
  }
  switch (opline->extended_value & 0x70000000) {
   case 0x00000000:
    if ((1<<0) != (1<<1)) {

    }
    break;
   case 0x10000000:

    break;
   case 0x20000000:
    zval_update_constant(retval, (void*) 1 );
    break;
   case 0x40000000:
    if ((1<<0) == (1<<2) && !free_op1.var) {
     zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr));
    }
    break;
  }
 }


 if ((1<<0) != (1<<0) && varname == &tmp_varname) {
  _zval_dtor((&tmp_varname) );
 }
 if (opline->extended_value & 0x04000000) {
  if (!zval_isref_p(*retval)) { do { if (zval_refcount_p(*((retval))) > 1) { zval *new_zv; zval_delref_p(*(retval)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval))->value; (*new_zv).type = (**(retval)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((retval))); };
 }
 zval_addref_p((*retval));
 switch (type) {
  case 0:
  case 3:
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (*retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   break;
  case 6: {
   zend_free_op free_res;

   zend_pzval_unlock_func(*retval, &free_res, 1 );
   if (retval != &(executor_globals.uninitialized_zval_ptr)) {
    if (!zval_isref_p(*retval)) { do { if (zval_refcount_p(*((retval))) > 1) { zval *new_zv; zval_delref_p(*(retval)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval))->value; (*new_zv).type = (**(retval)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
   }
   zval_addref_p((*retval));
   if (free_res.var) { i_zval_ptr_dtor(*(&free_res.var) ); };
  }

  default:
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = retval;
   break;
 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_R_SPEC_CONST_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_CONST_VAR(0, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_W_SPEC_CONST_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_CONST_VAR(1, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_RW_SPEC_CONST_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_CONST_VAR(2, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_FUNC_ARG_SPEC_CONST_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 return zend_fetch_var_address_helper_SPEC_CONST_VAR(((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && (opline->extended_value & 0x000fffff) <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[(opline->extended_value & 0x000fffff)-1].pass_by_reference & (1|2)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x1000000|0x2000000))))?1:0, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_UNSET_SPEC_CONST_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_CONST_VAR(6, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_IS_SPEC_CONST_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_CONST_VAR(3, execute_data );
}

static int __attribute__((fastcall)) ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *function_name;
 zend_class_entry *ce;

 ;
 zend_ptr_stack_3_push(&(executor_globals.arg_types_stack), execute_data->fbc, execute_data->object, execute_data->called_scope);

 if ((1<<0) == (1<<0)) {

  if ((executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)]) {
   ce = (executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)];
  } else {
   ce = zend_fetch_class_by_name((*opline->op1.zv).value.str.val, (*opline->op1.zv).value.str.len, opline->op1.literal + 1, opline->extended_value );
   if (__builtin_expect(ce == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Class '%s' not found", (*opline->op1.zv).value.str.val);
   }
   do { (executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)] = (ce); } while (0);
  }
  execute_data->called_scope = ce;
 } else {
  ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).class_entry;

  if (opline->extended_value == 2 || opline->extended_value == 1) {
   execute_data->called_scope = (executor_globals.called_scope);
  } else {
   execute_data->called_scope = ce;
  }
 }

 if ((1<<0) == (1<<0) &&
     (1<<2) == (1<<0) &&
     (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
  execute_data->fbc = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
 } else if ((1<<0) != (1<<0) &&
            (1<<2) == (1<<0) &&
            (execute_data->fbc = (((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] == (ce)) ? (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] : ((void *)0)))) {

 } else if ((1<<2) != (1<<3)) {
  char *function_name_strval = ((void *)0);
  int function_name_strlen = 0;
  zend_free_op free_op2;

  if ((1<<2) == (1<<0)) {
   function_name_strval = (*opline->op2.zv).value.str.val;
   function_name_strlen = (*opline->op2.zv).value.str.len;
  } else {
   function_name = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );

   if (__builtin_expect((*function_name).type != 6, 0)) {
    zend_error_noreturn((1<<0L), "Function name must be a string");
   } else {
    function_name_strval = (*function_name).value.str.val;
    function_name_strlen = (*function_name).value.str.len;
    }
  }

  if (function_name_strval) {
   if (ce->get_static_method) {
    execute_data->fbc = ce->get_static_method(ce, function_name_strval, function_name_strlen );
   } else {
    execute_data->fbc = zend_std_get_static_method(ce, function_name_strval, function_name_strlen, (((1<<2) == (1<<0)) ? (opline->op2.literal + 1) : ((void *)0)) );
   }
   if (__builtin_expect(execute_data->fbc == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Call to undefined method %s::%s()", ce->name, function_name_strval);
   }
   if ((1<<2) == (1<<0) && __builtin_expect((execute_data->fbc->common.fn_flags & 0x200000) == 0, 1)) {
    if ((1<<0) == (1<<0)) {
     do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (execute_data->fbc); } while (0);
    } else {
     do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] = (execute_data->fbc); } while (0);
    }
   }
  }
  if ((1<<2) != (1<<0)) {
   if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
  }
 } else {
  if (__builtin_expect(ce->constructor == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot call constructor");
  }
  if ((executor_globals.This) && zend_get_class_entry(&(*(executor_globals.This)) ) != ce->constructor->common.scope && (ce->constructor->common.fn_flags & 0x400)) {
   zend_error_noreturn((1<<0L), "Cannot call private %s::__construct()", ce->name);
  }
  execute_data->fbc = ce->constructor;
 }

 if (execute_data->fbc->common.fn_flags & 0x01) {
  execute_data->object = ((void *)0);
 } else {
  if ((executor_globals.This) &&
      (*(executor_globals.This)).value.obj.handlers->get_class_entry &&
      !instanceof_function(zend_get_class_entry(&(*(executor_globals.This)) ), ce )) {


   if (execute_data->fbc->common.fn_flags & 0x10000) {
    zend_error((1<<11L), "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", execute_data->fbc->common.scope->name, execute_data->fbc->common.function_name);
   } else {

    zend_error_noreturn((1<<0L), "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", execute_data->fbc->common.scope->name, execute_data->fbc->common.function_name);
   }
  }
  if ((execute_data->object = (executor_globals.This))) {
   zval_addref_p(execute_data->object);
   execute_data->called_scope = zend_get_class_entry(&(*execute_data->object) );
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_CASE_SPEC_CONST_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 if ((1<<0)==(1<<2)) {
  zval_addref_p(((*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr));
 }
 is_equal_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
     opline->op1.zv,
     _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *expr_ptr;

 ;
 if (((1<<0) == (1<<2) || (1<<0) == (1<<4)) && opline->extended_value) {
  zval **expr_ptr_ptr = ((void *)0);

  if ((1<<0) == (1<<2) && __builtin_expect(expr_ptr_ptr == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot create references to/from string offsets");
  }
  if (!zval_isref_p(*expr_ptr_ptr)) { do { if (zval_refcount_p(*((expr_ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(expr_ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(expr_ptr_ptr))->value; (*new_zv).type = (**(expr_ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(expr_ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((expr_ptr_ptr))); };
  expr_ptr = *expr_ptr_ptr;
  zval_addref_p(expr_ptr);
 } else {
  expr_ptr=opline->op1.zv;
  if (0) {
   zval *new_expr;

   do { (new_expr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_expr))->u.buffered = ((void *)0); } while (0);
   do { do { (new_expr)->value = (expr_ptr)->value; (*new_expr).type = (*expr_ptr).type; } while (0); zval_set_refcount_p(new_expr, 1); zval_unset_isref_p(new_expr); } while (0);
   expr_ptr = new_expr;
  } else if ((1<<0) == (1<<0) || zval_isref_p(expr_ptr)) {
   zval *new_expr;

   do { (new_expr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_expr))->u.buffered = ((void *)0); } while (0);
   do { do { (new_expr)->value = (expr_ptr)->value; (*new_expr).type = (*expr_ptr).type; } while (0); zval_set_refcount_p(new_expr, 1); zval_unset_isref_p(new_expr); } while (0);
   expr_ptr = new_expr;
   _zval_copy_ctor((&(*expr_ptr)) );
  } else {
   zval_addref_p(expr_ptr);
  }
 }

 if ((1<<2) != (1<<3)) {
  zend_free_op free_op2;
  zval *offset = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );
  ulong hval;

  switch ((*offset).type) {
   case 2:
    hval = zend_dval_to_lval((*offset).value.dval);
    goto num_index;
   case 1:
   case 3:
    hval = (*offset).value.lval;
num_index:
    _zend_hash_index_update_or_next_insert(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, hval, &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   case 6:
    if ((1<<2) == (1<<0)) {
     hval = (((zend_literal*)(offset))->hash_value);
    } else {
     do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index; } } } while (0);
     if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
      hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
     } else {
      hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
     }
    }
    _zend_hash_quick_add_or_update(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   case 0:
    _zend_hash_add_or_update(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, "", sizeof(""), &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   default:
    zend_error((1<<1L), "Illegal offset type");
    i_zval_ptr_dtor(*(&expr_ptr) );

    break;
  }
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 } else {
  _zend_hash_index_update_or_next_insert(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, 0, &expr_ptr, sizeof(zval *), ((void *)0), (1<<2) );
 }
 if (((1<<0) == (1<<2) || (1<<0) == (1<<4)) && opline->extended_value) {

 } else {

 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_ARRAY_SPEC_CONST_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 _array_init((&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var), 0 );
 if ((1<<0) == (1<<3)) {
  execute_data->opline++; return 0;

 } else {
  return ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_VAR_HANDLER(execute_data );

 }
}

static int __attribute__((fastcall)) ZEND_UNSET_VAR_SPEC_CONST_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval tmp, *varname;
 HashTable *target_symbol_table;


 ;
 if ((1<<0) == (1<<4) &&
     (1<<2) == (1<<3) &&
     (opline->extended_value & 0x00800000)) {
  if ((executor_globals.active_symbol_table)) {
   zend_compiled_variable *cv = &((executor_globals.active_op_array)->vars[opline->op1.var]);

   zend_delete_variable(execute_data->prev_execute_data, (executor_globals.active_symbol_table), cv->name, cv->name_len+1, cv->hash_value );
   execute_data->CVs[opline->op1.var] = ((void *)0);
  } else if (execute_data->CVs[opline->op1.var]) {
   i_zval_ptr_dtor(*(execute_data->CVs[opline->op1.var]) );
   execute_data->CVs[opline->op1.var] = ((void *)0);
  }
  ;
  execute_data->opline++; return 0;
 }

 varname = opline->op1.zv;

 if ((1<<0) != (1<<0) && (*varname).type != 6) {
  do { (&tmp)->value = (varname)->value; (*&tmp).type = (*varname).type; } while (0);
  _zval_copy_ctor((&tmp) );
  if ((&tmp)->type != 6) { _convert_to_string((&tmp) ); };
  varname = &tmp;
 } else if ((1<<0) == (1<<2) || (1<<0) == (1<<4)) {
  zval_addref_p(varname);
 }

 if ((1<<2) != (1<<3)) {
  zend_class_entry *ce;

  if ((1<<2) == (1<<0)) {
   if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
    ce = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
   } else {
    ce = zend_fetch_class_by_name((*opline->op2.zv).value.str.val, (*opline->op2.zv).value.str.len, opline->op2.literal + 1, 0 );
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); } while (0);
   }
  } else {
   ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).class_entry;
  }
  zend_std_unset_static_property(ce, (*varname).value.str.val, (*varname).value.str.len, (((1<<0) == (1<<0)) ? opline->op1.literal : ((void *)0)) );
 } else {
  ulong hash_value = zend_inline_hash_func(varname->value.str.val, varname->value.str.len+1);

  target_symbol_table = zend_get_target_symbol_table(opline->extended_value & 0x70000000 );
  zend_delete_variable(execute_data, target_symbol_table, varname->value.str.val, varname->value.str.len+1, hash_value );
 }

 if ((1<<0) != (1<<0) && varname == &tmp) {
  _zval_dtor((&tmp) );
 } else if ((1<<0) == (1<<2) || (1<<0) == (1<<4)) {
  i_zval_ptr_dtor(*(&varname) );
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ISSET_ISEMPTY_VAR_SPEC_CONST_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval **value;
 zend_bool isset = 1;

 ;
 if ((1<<0) == (1<<4) &&
     (1<<2) == (1<<3) &&
     (opline->extended_value & 0x00800000)) {
  if (execute_data->CVs[opline->op1.var]) {
   value = execute_data->CVs[opline->op1.var];
  } else if ((executor_globals.active_symbol_table)) {
   zend_compiled_variable *cv = &((executor_globals.active_op_array)->vars[opline->op1.var]);

   if (zend_hash_quick_find((executor_globals.active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, (void **) &value) == -1) {
    isset = 0;
   }
  } else {
   isset = 0;
  }
 } else {
  HashTable *target_symbol_table;

  zval tmp, *varname = opline->op1.zv;

  if ((1<<0) != (1<<0) && (*varname).type != 6) {
   do { (&tmp)->value = (varname)->value; (*&tmp).type = (*varname).type; } while (0);
   _zval_copy_ctor((&tmp) );
   if ((&tmp)->type != 6) { _convert_to_string((&tmp) ); };
   varname = &tmp;
  }

  if ((1<<2) != (1<<3)) {
   zend_class_entry *ce;

   if ((1<<2) == (1<<0)) {
    if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
     ce = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
    } else {
     ce = zend_fetch_class_by_name((*opline->op2.zv).value.str.val, (*opline->op2.zv).value.str.len, opline->op2.literal + 1, 0 );
     do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); } while (0);
    }
   } else {
    ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).class_entry;
   }
   value = zend_std_get_static_property(ce, (*varname).value.str.val, (*varname).value.str.len, 1, (((1<<0) == (1<<0)) ? opline->op1.literal : ((void *)0)) );
   if (!value) {
    isset = 0;
   }
  } else {
   target_symbol_table = zend_get_target_symbol_table(opline->extended_value & 0x70000000 );
   if (zend_hash_find(target_symbol_table, varname->value.str.val, varname->value.str.len+1, (void **) &value) == -1) {
    isset = 0;
   }
  }

  if ((1<<0) != (1<<0) && varname == &tmp) {
   _zval_dtor((&tmp) );
  }

 }

 if (opline->extended_value & 0x02000000) {
  if (isset && (**value).type != 0) {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((1) != 0); (*__z).type = 3; } while (0);
  } else {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((0) != 0); (*__z).type = 3; } while (0);
  }
 } else {
  if (!isset || !i_zend_is_true(*value)) {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((1) != 0); (*__z).type = 3; } while (0);
  } else {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((0) != 0); (*__z).type = 3; } while (0);
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_fetch_var_address_helper_SPEC_CONST_UNUSED(int type, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *varname;
 zval **retval;
 zval tmp_varname;
 HashTable *target_symbol_table;
 ulong hash_value;

 ;
 varname = opline->op1.zv;

  if ((1<<0) != (1<<0) && __builtin_expect((*varname).type != 6, 0)) {
  do { (&tmp_varname)->value = (varname)->value; (*&tmp_varname).type = (*varname).type; } while (0);
  _zval_copy_ctor((&tmp_varname) );
  if ((&tmp_varname)->type != 6) { _convert_to_string((&tmp_varname) ); };
  varname = &tmp_varname;
 }

 if ((1<<3) != (1<<3)) {
  zend_class_entry *ce;

  if ((1<<3) == (1<<0)) {
   if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
    ce = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
   } else {
    ce = zend_fetch_class_by_name((*opline->op2.zv).value.str.val, (*opline->op2.zv).value.str.len, opline->op2.literal + 1, 0 );
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); } while (0);
   }
  } else {
   ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).class_entry;
  }
  retval = zend_std_get_static_property(ce, (*varname).value.str.val, (*varname).value.str.len, 0, (((1<<0) == (1<<0)) ? opline->op1.literal : ((void *)0)) );

 } else {
  target_symbol_table = zend_get_target_symbol_table(opline->extended_value & 0x70000000 );






  if ((1<<0) == (1<<0)) {
   hash_value = (((zend_literal*)(varname))->hash_value);
  } else if (((((*varname).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*varname).value.str.val) < (compiler_globals.interned_strings_end)))) {
   hash_value = (((Bucket*)(((char*)((*varname).value.str.val))-sizeof(Bucket)))->h);
  } else {
   hash_value = zend_hash_func((*varname).value.str.val, (*varname).value.str.len+1);
  }

  if (zend_hash_quick_find(target_symbol_table, (*varname).value.str.val, (*varname).value.str.len+1, hash_value, (void **) &retval) == -1) {
   switch (type) {
    case 0:
    case 6:
     zend_error((1<<3L),"Undefined variable: %s", (*varname).value.str.val);

    case 3:
     retval = &(executor_globals.uninitialized_zval_ptr);
     break;
    case 2:
     zend_error((1<<3L),"Undefined variable: %s", (*varname).value.str.val);

    case 1:
     zval_addref_p(&(executor_globals.uninitialized_zval));
     _zend_hash_quick_add_or_update(target_symbol_table, (*varname).value.str.val, (*varname).value.str.len+1, hash_value, &(executor_globals.uninitialized_zval_ptr), sizeof(zval *), (void **) &retval, (1<<0) );
     break;
   
   }
  }
  switch (opline->extended_value & 0x70000000) {
   case 0x00000000:
    if ((1<<0) != (1<<1)) {

    }
    break;
   case 0x10000000:

    break;
   case 0x20000000:
    zval_update_constant(retval, (void*) 1 );
    break;
   case 0x40000000:
    if ((1<<0) == (1<<2) && !free_op1.var) {
     zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr));
    }
    break;
  }
 }


 if ((1<<0) != (1<<0) && varname == &tmp_varname) {
  _zval_dtor((&tmp_varname) );
 }
 if (opline->extended_value & 0x04000000) {
  if (!zval_isref_p(*retval)) { do { if (zval_refcount_p(*((retval))) > 1) { zval *new_zv; zval_delref_p(*(retval)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval))->value; (*new_zv).type = (**(retval)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((retval))); };
 }
 zval_addref_p((*retval));
 switch (type) {
  case 0:
  case 3:
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (*retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   break;
  case 6: {
   zend_free_op free_res;

   zend_pzval_unlock_func(*retval, &free_res, 1 );
   if (retval != &(executor_globals.uninitialized_zval_ptr)) {
    if (!zval_isref_p(*retval)) { do { if (zval_refcount_p(*((retval))) > 1) { zval *new_zv; zval_delref_p(*(retval)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval))->value; (*new_zv).type = (**(retval)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
   }
   zval_addref_p((*retval));
   if (free_res.var) { i_zval_ptr_dtor(*(&free_res.var) ); };
  }

  default:
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = retval;
   break;
 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_R_SPEC_CONST_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_CONST_UNUSED(0, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_W_SPEC_CONST_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_CONST_UNUSED(1, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_RW_SPEC_CONST_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_CONST_UNUSED(2, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_FUNC_ARG_SPEC_CONST_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 return zend_fetch_var_address_helper_SPEC_CONST_UNUSED(((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && (opline->extended_value & 0x000fffff) <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[(opline->extended_value & 0x000fffff)-1].pass_by_reference & (1|2)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x1000000|0x2000000))))?1:0, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_UNSET_SPEC_CONST_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_CONST_UNUSED(6, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_IS_SPEC_CONST_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_CONST_UNUSED(3, execute_data );
}

static int __attribute__((fastcall)) ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *function_name;
 zend_class_entry *ce;

 ;
 zend_ptr_stack_3_push(&(executor_globals.arg_types_stack), execute_data->fbc, execute_data->object, execute_data->called_scope);

 if ((1<<0) == (1<<0)) {

  if ((executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)]) {
   ce = (executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)];
  } else {
   ce = zend_fetch_class_by_name((*opline->op1.zv).value.str.val, (*opline->op1.zv).value.str.len, opline->op1.literal + 1, opline->extended_value );
   if (__builtin_expect(ce == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Class '%s' not found", (*opline->op1.zv).value.str.val);
   }
   do { (executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)] = (ce); } while (0);
  }
  execute_data->called_scope = ce;
 } else {
  ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).class_entry;

  if (opline->extended_value == 2 || opline->extended_value == 1) {
   execute_data->called_scope = (executor_globals.called_scope);
  } else {
   execute_data->called_scope = ce;
  }
 }

 if ((1<<0) == (1<<0) &&
     (1<<3) == (1<<0) &&
     (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
  execute_data->fbc = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
 } else if ((1<<0) != (1<<0) &&
            (1<<3) == (1<<0) &&
            (execute_data->fbc = (((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] == (ce)) ? (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] : ((void *)0)))) {

 } else if ((1<<3) != (1<<3)) {
  char *function_name_strval = ((void *)0);
  int function_name_strlen = 0;


  if ((1<<3) == (1<<0)) {
   function_name_strval = (*opline->op2.zv).value.str.val;
   function_name_strlen = (*opline->op2.zv).value.str.len;
  } else {
   function_name = ((void *)0);

   if (__builtin_expect((*function_name).type != 6, 0)) {
    zend_error_noreturn((1<<0L), "Function name must be a string");
   } else {
    function_name_strval = (*function_name).value.str.val;
    function_name_strlen = (*function_name).value.str.len;
    }
  }

  if (function_name_strval) {
   if (ce->get_static_method) {
    execute_data->fbc = ce->get_static_method(ce, function_name_strval, function_name_strlen );
   } else {
    execute_data->fbc = zend_std_get_static_method(ce, function_name_strval, function_name_strlen, (((1<<3) == (1<<0)) ? (opline->op2.literal + 1) : ((void *)0)) );
   }
   if (__builtin_expect(execute_data->fbc == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Call to undefined method %s::%s()", ce->name, function_name_strval);
   }
   if ((1<<3) == (1<<0) && __builtin_expect((execute_data->fbc->common.fn_flags & 0x200000) == 0, 1)) {
    if ((1<<0) == (1<<0)) {
     do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (execute_data->fbc); } while (0);
    } else {
     do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] = (execute_data->fbc); } while (0);
    }
   }
  }
  if ((1<<3) != (1<<0)) {

  }
 } else {
  if (__builtin_expect(ce->constructor == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot call constructor");
  }
  if ((executor_globals.This) && zend_get_class_entry(&(*(executor_globals.This)) ) != ce->constructor->common.scope && (ce->constructor->common.fn_flags & 0x400)) {
   zend_error_noreturn((1<<0L), "Cannot call private %s::__construct()", ce->name);
  }
  execute_data->fbc = ce->constructor;
 }

 if (execute_data->fbc->common.fn_flags & 0x01) {
  execute_data->object = ((void *)0);
 } else {
  if ((executor_globals.This) &&
      (*(executor_globals.This)).value.obj.handlers->get_class_entry &&
      !instanceof_function(zend_get_class_entry(&(*(executor_globals.This)) ), ce )) {


   if (execute_data->fbc->common.fn_flags & 0x10000) {
    zend_error((1<<11L), "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", execute_data->fbc->common.scope->name, execute_data->fbc->common.function_name);
   } else {

    zend_error_noreturn((1<<0L), "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", execute_data->fbc->common.scope->name, execute_data->fbc->common.function_name);
   }
  }
  if ((execute_data->object = (executor_globals.This))) {
   zval_addref_p(execute_data->object);
   execute_data->called_scope = zend_get_class_entry(&(*execute_data->object) );
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *expr_ptr;

 ;
 if (((1<<0) == (1<<2) || (1<<0) == (1<<4)) && opline->extended_value) {
  zval **expr_ptr_ptr = ((void *)0);

  if ((1<<0) == (1<<2) && __builtin_expect(expr_ptr_ptr == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot create references to/from string offsets");
  }
  if (!zval_isref_p(*expr_ptr_ptr)) { do { if (zval_refcount_p(*((expr_ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(expr_ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(expr_ptr_ptr))->value; (*new_zv).type = (**(expr_ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(expr_ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((expr_ptr_ptr))); };
  expr_ptr = *expr_ptr_ptr;
  zval_addref_p(expr_ptr);
 } else {
  expr_ptr=opline->op1.zv;
  if (0) {
   zval *new_expr;

   do { (new_expr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_expr))->u.buffered = ((void *)0); } while (0);
   do { do { (new_expr)->value = (expr_ptr)->value; (*new_expr).type = (*expr_ptr).type; } while (0); zval_set_refcount_p(new_expr, 1); zval_unset_isref_p(new_expr); } while (0);
   expr_ptr = new_expr;
  } else if ((1<<0) == (1<<0) || zval_isref_p(expr_ptr)) {
   zval *new_expr;

   do { (new_expr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_expr))->u.buffered = ((void *)0); } while (0);
   do { do { (new_expr)->value = (expr_ptr)->value; (*new_expr).type = (*expr_ptr).type; } while (0); zval_set_refcount_p(new_expr, 1); zval_unset_isref_p(new_expr); } while (0);
   expr_ptr = new_expr;
   _zval_copy_ctor((&(*expr_ptr)) );
  } else {
   zval_addref_p(expr_ptr);
  }
 }

 if ((1<<3) != (1<<3)) {

  zval *offset = ((void *)0);
  ulong hval;

  switch ((*offset).type) {
   case 2:
    hval = zend_dval_to_lval((*offset).value.dval);
    goto num_index;
   case 1:
   case 3:
    hval = (*offset).value.lval;
num_index:
    _zend_hash_index_update_or_next_insert(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, hval, &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   case 6:
    if ((1<<3) == (1<<0)) {
     hval = (((zend_literal*)(offset))->hash_value);
    } else {
     do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index; } } } while (0);
     if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
      hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
     } else {
      hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
     }
    }
    _zend_hash_quick_add_or_update(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   case 0:
    _zend_hash_add_or_update(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, "", sizeof(""), &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   default:
    zend_error((1<<1L), "Illegal offset type");
    i_zval_ptr_dtor(*(&expr_ptr) );

    break;
  }

 } else {
  _zend_hash_index_update_or_next_insert(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, 0, &expr_ptr, sizeof(zval *), ((void *)0), (1<<2) );
 }
 if (((1<<0) == (1<<2) || (1<<0) == (1<<4)) && opline->extended_value) {

 } else {

 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_ARRAY_SPEC_CONST_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 _array_init((&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var), 0 );
 if ((1<<0) == (1<<3)) {
  execute_data->opline++; return 0;

 } else {
  return ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_UNUSED_HANDLER(execute_data );

 }
}

static int __attribute__((fastcall)) ZEND_UNSET_VAR_SPEC_CONST_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval tmp, *varname;
 HashTable *target_symbol_table;


 ;
 if ((1<<0) == (1<<4) &&
     (1<<3) == (1<<3) &&
     (opline->extended_value & 0x00800000)) {
  if ((executor_globals.active_symbol_table)) {
   zend_compiled_variable *cv = &((executor_globals.active_op_array)->vars[opline->op1.var]);

   zend_delete_variable(execute_data->prev_execute_data, (executor_globals.active_symbol_table), cv->name, cv->name_len+1, cv->hash_value );
   execute_data->CVs[opline->op1.var] = ((void *)0);
  } else if (execute_data->CVs[opline->op1.var]) {
   i_zval_ptr_dtor(*(execute_data->CVs[opline->op1.var]) );
   execute_data->CVs[opline->op1.var] = ((void *)0);
  }
  ;
  execute_data->opline++; return 0;
 }

 varname = opline->op1.zv;

 if ((1<<0) != (1<<0) && (*varname).type != 6) {
  do { (&tmp)->value = (varname)->value; (*&tmp).type = (*varname).type; } while (0);
  _zval_copy_ctor((&tmp) );
  if ((&tmp)->type != 6) { _convert_to_string((&tmp) ); };
  varname = &tmp;
 } else if ((1<<0) == (1<<2) || (1<<0) == (1<<4)) {
  zval_addref_p(varname);
 }

 if ((1<<3) != (1<<3)) {
  zend_class_entry *ce;

  if ((1<<3) == (1<<0)) {
   if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
    ce = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
   } else {
    ce = zend_fetch_class_by_name((*opline->op2.zv).value.str.val, (*opline->op2.zv).value.str.len, opline->op2.literal + 1, 0 );
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); } while (0);
   }
  } else {
   ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).class_entry;
  }
  zend_std_unset_static_property(ce, (*varname).value.str.val, (*varname).value.str.len, (((1<<0) == (1<<0)) ? opline->op1.literal : ((void *)0)) );
 } else {
  ulong hash_value = zend_inline_hash_func(varname->value.str.val, varname->value.str.len+1);

  target_symbol_table = zend_get_target_symbol_table(opline->extended_value & 0x70000000 );
  zend_delete_variable(execute_data, target_symbol_table, varname->value.str.val, varname->value.str.len+1, hash_value );
 }

 if ((1<<0) != (1<<0) && varname == &tmp) {
  _zval_dtor((&tmp) );
 } else if ((1<<0) == (1<<2) || (1<<0) == (1<<4)) {
  i_zval_ptr_dtor(*(&varname) );
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ISSET_ISEMPTY_VAR_SPEC_CONST_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval **value;
 zend_bool isset = 1;

 ;
 if ((1<<0) == (1<<4) &&
     (1<<3) == (1<<3) &&
     (opline->extended_value & 0x00800000)) {
  if (execute_data->CVs[opline->op1.var]) {
   value = execute_data->CVs[opline->op1.var];
  } else if ((executor_globals.active_symbol_table)) {
   zend_compiled_variable *cv = &((executor_globals.active_op_array)->vars[opline->op1.var]);

   if (zend_hash_quick_find((executor_globals.active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, (void **) &value) == -1) {
    isset = 0;
   }
  } else {
   isset = 0;
  }
 } else {
  HashTable *target_symbol_table;

  zval tmp, *varname = opline->op1.zv;

  if ((1<<0) != (1<<0) && (*varname).type != 6) {
   do { (&tmp)->value = (varname)->value; (*&tmp).type = (*varname).type; } while (0);
   _zval_copy_ctor((&tmp) );
   if ((&tmp)->type != 6) { _convert_to_string((&tmp) ); };
   varname = &tmp;
  }

  if ((1<<3) != (1<<3)) {
   zend_class_entry *ce;

   if ((1<<3) == (1<<0)) {
    if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
     ce = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
    } else {
     ce = zend_fetch_class_by_name((*opline->op2.zv).value.str.val, (*opline->op2.zv).value.str.len, opline->op2.literal + 1, 0 );
     do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); } while (0);
    }
   } else {
    ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).class_entry;
   }
   value = zend_std_get_static_property(ce, (*varname).value.str.val, (*varname).value.str.len, 1, (((1<<0) == (1<<0)) ? opline->op1.literal : ((void *)0)) );
   if (!value) {
    isset = 0;
   }
  } else {
   target_symbol_table = zend_get_target_symbol_table(opline->extended_value & 0x70000000 );
   if (zend_hash_find(target_symbol_table, varname->value.str.val, varname->value.str.len+1, (void **) &value) == -1) {
    isset = 0;
   }
  }

  if ((1<<0) != (1<<0) && varname == &tmp) {
   _zval_dtor((&tmp) );
  }

 }

 if (opline->extended_value & 0x02000000) {
  if (isset && (**value).type != 0) {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((1) != 0); (*__z).type = 3; } while (0);
  } else {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((0) != 0); (*__z).type = 3; } while (0);
  }
 } else {
  if (!isset || !i_zend_is_true(*value)) {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((1) != 0); (*__z).type = 3; } while (0);
  } else {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((0) != 0); (*__z).type = 3; } while (0);
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_DECLARE_LAMBDA_FUNCTION_SPEC_CONST_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_function *op_array;

 ;

 if (__builtin_expect(zend_hash_quick_find((executor_globals.function_table), (*opline->op1.zv).value.str.val, (*opline->op1.zv).value.str.len, (((zend_literal*)(opline->op1.zv))->hash_value), (void *) &op_array) == -1, 0) ||
     __builtin_expect(op_array->type != 2, 0)) {
  zend_error_noreturn((1<<0L), "Base lambda function for closure not found");
 }

 zend_create_closure(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var, op_array, (executor_globals.scope), (executor_globals.This) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ADD_SPEC_CONST_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 add_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SUB_SPEC_CONST_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 sub_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_MUL_SPEC_CONST_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 mul_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_DIV_SPEC_CONST_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 div_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_MOD_SPEC_CONST_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 mod_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SL_SPEC_CONST_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 shift_left_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SR_SPEC_CONST_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 shift_right_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_CONCAT_SPEC_CONST_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 concat_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_IDENTICAL_SPEC_CONST_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 is_identical_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_NOT_IDENTICAL_SPEC_CONST_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 is_identical_function(result,
  opline->op1.zv,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 (*result).value.lval = !(*result).value.lval;


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_EQUAL_SPEC_CONST_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  opline->op1.zv,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval == 0)) != 0); (*__z).type = 3; } while (0);


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_NOT_EQUAL_SPEC_CONST_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  opline->op1.zv,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval != 0)) != 0); (*__z).type = 3; } while (0);


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_SMALLER_SPEC_CONST_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  opline->op1.zv,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval < 0)) != 0); (*__z).type = 3; } while (0);


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  opline->op1.zv,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval <= 0)) != 0); (*__z).type = 3; } while (0);


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_OR_SPEC_CONST_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 bitwise_or_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_AND_SPEC_CONST_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 bitwise_and_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_XOR_SPEC_CONST_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 bitwise_xor_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BOOL_XOR_SPEC_CONST_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 boolean_xor_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  opline->op1.zv,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *function_name;
 zend_class_entry *ce;

 ;
 zend_ptr_stack_3_push(&(executor_globals.arg_types_stack), execute_data->fbc, execute_data->object, execute_data->called_scope);

 if ((1<<0) == (1<<0)) {

  if ((executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)]) {
   ce = (executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)];
  } else {
   ce = zend_fetch_class_by_name((*opline->op1.zv).value.str.val, (*opline->op1.zv).value.str.len, opline->op1.literal + 1, opline->extended_value );
   if (__builtin_expect(ce == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Class '%s' not found", (*opline->op1.zv).value.str.val);
   }
   do { (executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)] = (ce); } while (0);
  }
  execute_data->called_scope = ce;
 } else {
  ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).class_entry;

  if (opline->extended_value == 2 || opline->extended_value == 1) {
   execute_data->called_scope = (executor_globals.called_scope);
  } else {
   execute_data->called_scope = ce;
  }
 }

 if ((1<<0) == (1<<0) &&
     (1<<4) == (1<<0) &&
     (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
  execute_data->fbc = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
 } else if ((1<<0) != (1<<0) &&
            (1<<4) == (1<<0) &&
            (execute_data->fbc = (((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] == (ce)) ? (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] : ((void *)0)))) {

 } else if ((1<<4) != (1<<3)) {
  char *function_name_strval = ((void *)0);
  int function_name_strlen = 0;


  if ((1<<4) == (1<<0)) {
   function_name_strval = (*opline->op2.zv).value.str.val;
   function_name_strlen = (*opline->op2.zv).value.str.len;
  } else {
   function_name = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );

   if (__builtin_expect((*function_name).type != 6, 0)) {
    zend_error_noreturn((1<<0L), "Function name must be a string");
   } else {
    function_name_strval = (*function_name).value.str.val;
    function_name_strlen = (*function_name).value.str.len;
    }
  }

  if (function_name_strval) {
   if (ce->get_static_method) {
    execute_data->fbc = ce->get_static_method(ce, function_name_strval, function_name_strlen );
   } else {
    execute_data->fbc = zend_std_get_static_method(ce, function_name_strval, function_name_strlen, (((1<<4) == (1<<0)) ? (opline->op2.literal + 1) : ((void *)0)) );
   }
   if (__builtin_expect(execute_data->fbc == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Call to undefined method %s::%s()", ce->name, function_name_strval);
   }
   if ((1<<4) == (1<<0) && __builtin_expect((execute_data->fbc->common.fn_flags & 0x200000) == 0, 1)) {
    if ((1<<0) == (1<<0)) {
     do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (execute_data->fbc); } while (0);
    } else {
     do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] = (execute_data->fbc); } while (0);
    }
   }
  }
  if ((1<<4) != (1<<0)) {

  }
 } else {
  if (__builtin_expect(ce->constructor == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot call constructor");
  }
  if ((executor_globals.This) && zend_get_class_entry(&(*(executor_globals.This)) ) != ce->constructor->common.scope && (ce->constructor->common.fn_flags & 0x400)) {
   zend_error_noreturn((1<<0L), "Cannot call private %s::__construct()", ce->name);
  }
  execute_data->fbc = ce->constructor;
 }

 if (execute_data->fbc->common.fn_flags & 0x01) {
  execute_data->object = ((void *)0);
 } else {
  if ((executor_globals.This) &&
      (*(executor_globals.This)).value.obj.handlers->get_class_entry &&
      !instanceof_function(zend_get_class_entry(&(*(executor_globals.This)) ), ce )) {


   if (execute_data->fbc->common.fn_flags & 0x10000) {
    zend_error((1<<11L), "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", execute_data->fbc->common.scope->name, execute_data->fbc->common.function_name);
   } else {

    zend_error_noreturn((1<<0L), "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", execute_data->fbc->common.scope->name, execute_data->fbc->common.function_name);
   }
  }
  if ((execute_data->object = (executor_globals.This))) {
   zval_addref_p(execute_data->object);
   execute_data->called_scope = zend_get_class_entry(&(*execute_data->object) );
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_CATCH_SPEC_CONST_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_class_entry *ce, *catch_ce;
 zval *exception;

 ;

 zend_exception_restore();
 if ((executor_globals.exception) == ((void *)0)) {
  execute_data->opline = &execute_data->op_array->opcodes[opline->extended_value];
  return 0;
 }
 if ((executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)]) {
  catch_ce = (executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)];
 } else {
  catch_ce = zend_fetch_class_by_name((*opline->op1.zv).value.str.val, (*opline->op1.zv).value.str.len, opline->op1.literal + 1, 0x80 );
  do { (executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)] = (catch_ce); } while (0);
 }
 ce = zend_get_class_entry(&(*(executor_globals.exception)) );







 if (ce != catch_ce) {
  if (!instanceof_function(ce, catch_ce )) {
   if (opline->result.num) {
    zend_throw_exception_internal(((void *)0) );
    ; return 0;
   }
   execute_data->opline = &execute_data->op_array->opcodes[opline->extended_value];
   return 0;
  }
 }

 exception = (executor_globals.exception);
 if (!(executor_globals.active_symbol_table)) {
  if (execute_data->CVs[opline->op2.var]) {
   i_zval_ptr_dtor(*(execute_data->CVs[opline->op2.var]) );
  }
  execute_data->CVs[opline->op2.var] = (zval**)execute_data->CVs + (execute_data->op_array->last_var + opline->op2.var);
  *execute_data->CVs[opline->op2.var] = (executor_globals.exception);
 } else {
  zend_compiled_variable *cv = &((executor_globals.active_op_array)->vars[opline->op2.var]);
  _zend_hash_quick_add_or_update((executor_globals.active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, &(executor_globals.exception), sizeof(zval *), (void**)&execute_data->CVs[opline->op2.var], (1<<0) )
                                                                      ;
 }
 if (__builtin_expect((executor_globals.exception) != exception, 0)) {
  zval_addref_p((executor_globals.exception));
  ; return 0;
 } else {
  (executor_globals.exception) = ((void *)0);
  execute_data->opline++; return 0;
 }
}

static int __attribute__((fastcall)) ZEND_CASE_SPEC_CONST_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 if ((1<<0)==(1<<2)) {
  zval_addref_p(((*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr));
 }
 is_equal_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
     opline->op1.zv,
     _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *expr_ptr;

 ;
 if (((1<<0) == (1<<2) || (1<<0) == (1<<4)) && opline->extended_value) {
  zval **expr_ptr_ptr = ((void *)0);

  if ((1<<0) == (1<<2) && __builtin_expect(expr_ptr_ptr == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot create references to/from string offsets");
  }
  if (!zval_isref_p(*expr_ptr_ptr)) { do { if (zval_refcount_p(*((expr_ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(expr_ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(expr_ptr_ptr))->value; (*new_zv).type = (**(expr_ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(expr_ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((expr_ptr_ptr))); };
  expr_ptr = *expr_ptr_ptr;
  zval_addref_p(expr_ptr);
 } else {
  expr_ptr=opline->op1.zv;
  if (0) {
   zval *new_expr;

   do { (new_expr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_expr))->u.buffered = ((void *)0); } while (0);
   do { do { (new_expr)->value = (expr_ptr)->value; (*new_expr).type = (*expr_ptr).type; } while (0); zval_set_refcount_p(new_expr, 1); zval_unset_isref_p(new_expr); } while (0);
   expr_ptr = new_expr;
  } else if ((1<<0) == (1<<0) || zval_isref_p(expr_ptr)) {
   zval *new_expr;

   do { (new_expr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_expr))->u.buffered = ((void *)0); } while (0);
   do { do { (new_expr)->value = (expr_ptr)->value; (*new_expr).type = (*expr_ptr).type; } while (0); zval_set_refcount_p(new_expr, 1); zval_unset_isref_p(new_expr); } while (0);
   expr_ptr = new_expr;
   _zval_copy_ctor((&(*expr_ptr)) );
  } else {
   zval_addref_p(expr_ptr);
  }
 }

 if ((1<<4) != (1<<3)) {

  zval *offset = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );
  ulong hval;

  switch ((*offset).type) {
   case 2:
    hval = zend_dval_to_lval((*offset).value.dval);
    goto num_index;
   case 1:
   case 3:
    hval = (*offset).value.lval;
num_index:
    _zend_hash_index_update_or_next_insert(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, hval, &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   case 6:
    if ((1<<4) == (1<<0)) {
     hval = (((zend_literal*)(offset))->hash_value);
    } else {
     do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index; } } } while (0);
     if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
      hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
     } else {
      hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
     }
    }
    _zend_hash_quick_add_or_update(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   case 0:
    _zend_hash_add_or_update(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, "", sizeof(""), &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   default:
    zend_error((1<<1L), "Illegal offset type");
    i_zval_ptr_dtor(*(&expr_ptr) );

    break;
  }

 } else {
  _zend_hash_index_update_or_next_insert(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, 0, &expr_ptr, sizeof(zval *), ((void *)0), (1<<2) );
 }
 if (((1<<0) == (1<<2) || (1<<0) == (1<<4)) && opline->extended_value) {

 } else {

 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_ARRAY_SPEC_CONST_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 _array_init((&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var), 0 );
 if ((1<<0) == (1<<3)) {
  execute_data->opline++; return 0;

 } else {
  return ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CV_HANDLER(execute_data );

 }
}

static int __attribute__((fastcall)) ZEND_BW_NOT_SPEC_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 bitwise_not_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ) );
 _zval_dtor((free_op1.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BOOL_NOT_SPEC_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 boolean_not_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ) );
 _zval_dtor((free_op1.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ECHO_SPEC_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval z_copy;
 zval *z;

 ;
 z = _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<1) != (1<<0) &&
     __builtin_expect((*z).type == 5, 0) &&
     (*z).value.obj.handlers->get_method != ((void *)0) &&
  zend_std_cast_object_tostring(z, &z_copy, 6 ) == 0) {
  zend_print_variable(&z_copy);
  _zval_dtor((&z_copy) );
 } else {
  zend_print_variable(z);
 }

 _zval_dtor((free_op1.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_PRINT_SPEC_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = 1; (*__z).type = 1; };
 return ZEND_ECHO_SPEC_TMP_HANDLER(execute_data );
}

static int __attribute__((fastcall)) ZEND_JMPZ_SPEC_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *val;
 int ret;

 ;
 val = _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<1) == (1<<1) && __builtin_expect((*val).type == 3, 1)) {
  ret = (*val).value.lval;
 } else {
  ret = i_zend_is_true(val);
  _zval_dtor((free_op1.var) );
  if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
   ; return 0;
  }
 }
 if (!ret) {



  execute_data->opline = opline->op2.jmp_addr;
  return 0;
 }

 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_JMPNZ_SPEC_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *val;
 int ret;

 ;
 val = _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<1) == (1<<1) && __builtin_expect((*val).type == 3, 1)) {
  ret = (*val).value.lval;
 } else {
  ret = i_zend_is_true(val);
  _zval_dtor((free_op1.var) );
  if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
   ; return 0;
  }
 }
 if (ret) {



  execute_data->opline = opline->op2.jmp_addr;
  return 0;
 }

 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_JMPZNZ_SPEC_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *val;
 int retval;

 ;
 val = _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<1) == (1<<1) && __builtin_expect((*val).type == 3, 1)) {
  retval = (*val).value.lval;
 } else {
  retval = i_zend_is_true(val);
  _zval_dtor((free_op1.var) );
  if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
   ; return 0;
  }
 }
 if (__builtin_expect(retval != 0, 1)) {



  execute_data->opline = &execute_data->op_array->opcodes[opline->extended_value];
  return 0;
 } else {



  execute_data->opline = &execute_data->op_array->opcodes[opline->op2.opline_num];
  return 0;
 }
}

static int __attribute__((fastcall)) ZEND_JMPZ_EX_SPEC_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *val;
 int retval;

 ;
 val = _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<1) == (1<<1) && __builtin_expect((*val).type == 3, 1)) {
  retval = (*val).value.lval;
 } else {
  retval = i_zend_is_true(val);
  _zval_dtor((free_op1.var) );
  if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
   ; return 0;
  }
 }
 ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.lval = retval;
 ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).type = 3;
 if (!retval) {



  execute_data->opline = opline->op2.jmp_addr;
  return 0;
 }
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_JMPNZ_EX_SPEC_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *val;
 int retval;

 ;
 val = _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<1) == (1<<1) && __builtin_expect((*val).type == 3, 1)) {
  retval = (*val).value.lval;
 } else {
  retval = i_zend_is_true(val);
  _zval_dtor((free_op1.var) );
  if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
   ; return 0;
  }
 }
 ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.lval = retval;
 ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).type = 3;
 if (retval) {



  execute_data->opline = opline->op2.jmp_addr;
  return 0;
 }
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FREE_SPEC_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 ;
 if ((1<<1) == (1<<1)) {
  _zval_dtor((&((*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).tmp_var)) );
 } else {
  i_zval_ptr_dtor(*(&(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr) );
 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_RETURN_SPEC_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *retval_ptr;
 zend_free_op free_op1;

 ;
 retval_ptr = _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 );

 if (!(executor_globals.return_value_ptr_ptr)) {
  if ((1<<1) == (1<<1)) {
   _zval_dtor((free_op1.var) );
  }
 } else if (!1) {
  if ((1<<1) == (1<<0) ||
      (zval_isref_p(retval_ptr) && zval_refcount_p(retval_ptr) > 0)) {
   zval *ret;

   do { (ret) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(ret))->u.buffered = ((void *)0); } while (0);
   do { do { (ret)->value = (retval_ptr)->value; (*ret).type = (*retval_ptr).type; } while (0); zval_set_refcount_p(ret, 1); zval_unset_isref_p(ret); } while (0);
   _zval_copy_ctor((ret) );
   *(executor_globals.return_value_ptr_ptr) = ret;
  } else if (((1<<1) == (1<<4) || (1<<1) == (1<<2)) &&
             retval_ptr == &(executor_globals.uninitialized_zval)) {
   zval *ret;

   do { (ret) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(ret))->u.buffered = ((void *)0); } while (0); *ret = zval_used_for_init;;;
   *(executor_globals.return_value_ptr_ptr) = ret;
  } else {
   *(executor_globals.return_value_ptr_ptr) = retval_ptr;
   zval_addref_p(retval_ptr);
  }
 } else {
  zval *ret;

  do { (ret) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(ret))->u.buffered = ((void *)0); } while (0);
  do { do { (ret)->value = (retval_ptr)->value; (*ret).type = (*retval_ptr).type; } while (0); zval_set_refcount_p(ret, 1); zval_unset_isref_p(ret); } while (0);
  *(executor_globals.return_value_ptr_ptr) = ret;
 }

 return zend_leave_helper_SPEC(execute_data );
}

static int __attribute__((fastcall)) ZEND_RETURN_BY_REF_SPEC_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *retval_ptr;
 zval **retval_ptr_ptr;
 zend_free_op free_op1;

 ;

 do {
  if ((1<<1) == (1<<0) || (1<<1) == (1<<1)) {

   zend_error((1<<3L), "Only variable references should be returned by reference");

   retval_ptr = _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 );
   if (!(executor_globals.return_value_ptr_ptr)) {
    if ((1<<1) == (1<<1)) {
     _zval_dtor((free_op1.var) );
    }
   } else if (!1) {
    zval *ret;

    do { (ret) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(ret))->u.buffered = ((void *)0); } while (0);
    do { do { (ret)->value = (retval_ptr)->value; (*ret).type = (*retval_ptr).type; } while (0); zval_set_refcount_p(ret, 1); zval_unset_isref_p(ret); } while (0);
    _zval_copy_ctor((ret) );
    *(executor_globals.return_value_ptr_ptr) = ret;
   } else {
    zval *ret;

    do { (ret) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(ret))->u.buffered = ((void *)0); } while (0);
    do { do { (ret)->value = (retval_ptr)->value; (*ret).type = (*retval_ptr).type; } while (0); zval_set_refcount_p(ret, 1); zval_unset_isref_p(ret); } while (0);
    *(executor_globals.return_value_ptr_ptr) = ret;
   }
   break;
  }

  retval_ptr_ptr = ((void *)0);

  if ((1<<1) == (1<<2) && __builtin_expect(retval_ptr_ptr == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot return string offsets by reference");
  }

  if ((1<<1) == (1<<2) && !zval_isref_p(*(retval_ptr_ptr))) {
   if (opline->extended_value == 1<<0 &&
       (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.fcall_returned_reference) {
   } else if ((*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr == &(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr) {
    zend_error((1<<3L), "Only variable references should be returned by reference");
    if ((executor_globals.return_value_ptr_ptr)) {
     retval_ptr = *retval_ptr_ptr;
     *(executor_globals.return_value_ptr_ptr) = retval_ptr;
     zval_addref_p(retval_ptr);
    }
    break;
   }
  }

  if ((executor_globals.return_value_ptr_ptr)) {
   if (!zval_isref_p(*retval_ptr_ptr)) { do { if (zval_refcount_p(*((retval_ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(retval_ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval_ptr_ptr))->value; (*new_zv).type = (**(retval_ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval_ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((retval_ptr_ptr))); };
   zval_addref_p(*(retval_ptr_ptr));

   *(executor_globals.return_value_ptr_ptr) = *retval_ptr_ptr;
  }
 } while (0);

 return zend_leave_helper_SPEC(execute_data );
}

static int __attribute__((fastcall)) ZEND_THROW_SPEC_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *value;
 zval *exception;
 zend_free_op free_op1;

 ;
 value = _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<1) == (1<<0) || __builtin_expect((*value).type != 5, 0)) {
  zend_error_noreturn((1<<0L), "Can only throw objects");
 }
 zend_exception_save();

 do { (exception) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(exception))->u.buffered = ((void *)0); } while (0);
 do { do { (exception)->value = (value)->value; (*exception).type = (*value).type; } while (0); zval_set_refcount_p(exception, 1); zval_unset_isref_p(exception); } while (0);
 if (!1) {
  _zval_copy_ctor((exception) );
 }

 zend_throw_exception_object(exception );
 zend_exception_restore();

 ; return 0;
}

static int __attribute__((fastcall)) ZEND_SEND_VAL_SPEC_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 ;
 if (opline->extended_value==61
  && ((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && opline->op2.opline_num <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[opline->op2.opline_num-1].pass_by_reference & (1)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x1000000))))) {
   zend_error_noreturn((1<<0L), "Cannot pass parameter %d by reference", opline->op2.opline_num);
 }
 {
  zval *valptr;
  zval *value;
  zend_free_op free_op1;

  value = _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 );

  do { (valptr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(valptr))->u.buffered = ((void *)0); } while (0);
  do { do { (valptr)->value = (value)->value; (*valptr).type = (*value).type; } while (0); zval_set_refcount_p(valptr, 1); zval_unset_isref_p(valptr); } while (0);
  if (!1) {
   _zval_copy_ctor((valptr) );
  }
  zend_vm_stack_push(valptr );

 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BOOL_SPEC_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *retval = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;

 do { zval *__z = (retval); (*__z).value.lval = ((i_zend_is_true(_get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ))) != 0); (*__z).type = 3; } while (0);
 _zval_dtor((free_op1.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_CLONE_SPEC_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *obj;
 zend_class_entry *ce;
 zend_function *clone;
 zend_object_clone_obj_t clone_call;

 ;
 obj = _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<1) == (1<<0) ||
     __builtin_expect((*obj).type != 5, 0)) {
  zend_error_noreturn((1<<0L), "__clone method called on non-object");
 }

 ce = zend_get_class_entry(&(*obj) );
 clone = ce ? ce->clone : ((void *)0);
 clone_call = (*obj).value.obj.handlers->clone_obj;
 if (__builtin_expect(clone_call == ((void *)0), 0)) {
  if (ce) {
   zend_error_noreturn((1<<0L), "Trying to clone an uncloneable object of class %s", ce->name);
  } else {
   zend_error_noreturn((1<<0L), "Trying to clone an uncloneable object");
  }
 }

 if (ce && clone) {
  if (clone->op_array.fn_flags & 0x400) {


   if (__builtin_expect(ce != (executor_globals.scope), 0)) {
    zend_error_noreturn((1<<0L), "Call to private %s::__clone() from context '%s'", ce->name, (executor_globals.scope) ? (executor_globals.scope)->name : "");
   }
  } else if ((clone->common.fn_flags & 0x200)) {


   if (__builtin_expect(!zend_check_protected(clone->common.scope, (executor_globals.scope)), 0)) {
    zend_error_noreturn((1<<0L), "Call to protected %s::__clone() from context '%s'", ce->name, (executor_globals.scope) ? (executor_globals.scope)->name : "");
   }
  }
 }

 if (__builtin_expect((executor_globals.exception) == ((void *)0), 1)) {
  zval *retval;

  do { (retval) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(retval))->u.buffered = ((void *)0); } while (0);
  (*retval).value.obj = clone_call(obj );
  (*retval).type = 5;
  zval_set_refcount_p(retval, 1);
  zval_set_isref_p(retval);
  if (!(!((opline)->result_type & (1<<5))) || __builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
   i_zval_ptr_dtor(*(&retval) );
  } else {
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_CAST_SPEC_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *expr;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 expr = _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 );

 if (opline->extended_value != 6) {
  do { (result)->value = (expr)->value; (*result).type = (*expr).type; } while (0);
  if (!1) {
   _zval_copy_ctor((&(*result)) );
  }
 }
 switch (opline->extended_value) {
  case 0:
   convert_to_null(result);
   break;
  case 3:
   convert_to_boolean(result);
   break;
  case 1:
   convert_to_long(result);
   break;
  case 2:
   convert_to_double(result);
   break;
  case 6: {
   zval var_copy;
   int use_copy;

   zend_make_printable_zval(expr, &var_copy, &use_copy);
   if (use_copy) {
    do { (result)->value = (&var_copy)->value; (*result).type = (*&var_copy).type; } while (0);
    if (1) {
     _zval_dtor((free_op1.var) );
    }
   } else {
    do { (result)->value = (expr)->value; (*result).type = (*expr).type; } while (0);
    if (!1) {
     _zval_copy_ctor((&(*result)) );
    }
   }
   break;
  }
  case 4:
   convert_to_array(result);
   break;
  case 5:
   convert_to_object(result);
   break;
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INCLUDE_OR_EVAL_SPEC_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_op_array *new_op_array=((void *)0);
 zend_free_op free_op1;
 zval *inc_filename;
 zval tmp_inc_filename;
 zend_bool failure_retval=0;

 ;
 inc_filename = _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 );

 if (inc_filename->type!=6) {
  do { (&tmp_inc_filename)->value = (inc_filename)->value; (*&tmp_inc_filename).type = (*inc_filename).type; } while (0);
  _zval_copy_ctor((&tmp_inc_filename) );
  if ((&tmp_inc_filename)->type != 6) { _convert_to_string((&tmp_inc_filename) ); };
  inc_filename = &tmp_inc_filename;
 }

 switch (opline->extended_value) {
  case (1<<2):
  case (1<<4): {
    zend_file_handle file_handle;
    char *resolved_path;

    resolved_path = zend_resolve_path((*inc_filename).value.str.val, (*inc_filename).value.str.len );
    if (resolved_path) {
     failure_retval = zend_hash_exists(&(executor_globals.included_files), resolved_path, strlen(resolved_path)+1);
    } else {
     resolved_path = (*inc_filename).value.str.val;
    }

    if (failure_retval) {

    } else if (0 == zend_stream_open(resolved_path, &file_handle )) {

     if (!file_handle.opened_path) {
      file_handle.opened_path = _estrdup((resolved_path) );
     }

     if (zend_hash_add_empty_element(&(executor_globals.included_files), file_handle.opened_path, strlen(file_handle.opened_path)+1)==0) {
      new_op_array = zend_compile_file(&file_handle, (opline->extended_value==(1<<2)?(1<<1):(1<<3)) );
      zend_destroy_file_handle(&file_handle );
     } else {
      zend_file_handle_dtor(&file_handle );
      failure_retval=1;
     }
    } else {
     if (opline->extended_value == (1<<2)) {
      zend_message_dispatcher(1L, (*inc_filename).value.str.val );
     } else {
      zend_message_dispatcher(2L, (*inc_filename).value.str.val );
     }
    }
    if (resolved_path != (*inc_filename).value.str.val) {
     _efree((resolved_path) );
    }
   }
   break;
  case (1<<1):
  case (1<<3):
   new_op_array = compile_filename(opline->extended_value, inc_filename );
   break;
  case (1<<0): {
    char *eval_desc = zend_make_compiled_string_description("eval()'d code" );

    new_op_array = zend_compile_string(inc_filename, eval_desc );
    _efree((eval_desc) );
   }
   break;
 
 }
 if (inc_filename==&tmp_inc_filename) {
  _zval_dtor((&tmp_inc_filename) );
 }
 _zval_dtor((free_op1.var) );
 if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
  ; return 0;
 } else if (__builtin_expect(new_op_array != ((void *)0), 1)) {
  execute_data->original_return_value = (executor_globals.return_value_ptr_ptr);
  (executor_globals.active_op_array) = new_op_array;
  if ((!((opline)->result_type & (1<<5)))) {
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = ((void *)0);
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr;
   (executor_globals.return_value_ptr_ptr) = (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr;
  } else {
   (executor_globals.return_value_ptr_ptr) = ((void *)0);
  }

  execute_data->current_object = execute_data->object;

  execute_data->function_state.function = (zend_function *) new_op_array;
  execute_data->object = ((void *)0);

  if (!(executor_globals.active_symbol_table)) {
   zend_rebuild_symbol_table();
  }

  if (__builtin_expect(zend_execute == execute, 1)) {
   return 2;
  } else {
   zend_execute(new_op_array );
  }

  execute_data->function_state.function = (zend_function *) execute_data->op_array;
  execute_data->object = execute_data->current_object;

  (executor_globals.opline_ptr) = &execute_data->opline;
  (executor_globals.active_op_array) = execute_data->op_array;
  (executor_globals.return_value_ptr_ptr) = execute_data->original_return_value;
  destroy_op_array(new_op_array );
  _efree((new_op_array) );
  if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
   zend_throw_exception_internal(((void *)0) );
   ; return 0;
  } else if ((!((opline)->result_type & (1<<5)))) {
   if (!(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr) {
    zval *retval;

    do { (retval) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(retval))->u.buffered = ((void *)0); } while (0);
    do { zval *__z = (retval); (*__z).value.lval = ((1) != 0); (*__z).type = 3; } while (0);
    (retval)->refcount__gc = 1; (retval)->is_ref__gc = 0;;
    (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = retval;
   }
  }

 } else if ((!((opline)->result_type & (1<<5)))) {
  zval *retval;

  do { (retval) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(retval))->u.buffered = ((void *)0); } while (0);
  do { zval *__z = (retval); (*__z).value.lval = ((failure_retval) != 0); (*__z).type = 3; } while (0);
  (retval)->refcount__gc = 1; (retval)->is_ref__gc = 0;;
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
 }
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FE_RESET_SPEC_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *array_ptr, **array_ptr_ptr;
 HashTable *fe_ht;
 zend_object_iterator *iter = ((void *)0);
 zend_class_entry *ce = ((void *)0);
 zend_bool is_empty = 0;

 ;

 if (((1<<1) == (1<<4) || (1<<1) == (1<<2)) &&
     (opline->extended_value & (1<<0))) {
  array_ptr_ptr = ((void *)0);
  if (array_ptr_ptr == ((void *)0) || array_ptr_ptr == &(executor_globals.uninitialized_zval_ptr)) {
   do { (array_ptr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(array_ptr))->u.buffered = ((void *)0); } while (0); (array_ptr)->refcount__gc = 1; (array_ptr)->is_ref__gc = 0;;;
   { (*array_ptr).type = 0; };
  } else if ((**array_ptr_ptr).type == 5) {
   if((**array_ptr_ptr).value.obj.handlers->get_class_entry == ((void *)0)) {
    zend_error((1<<1L), "foreach() cannot iterate over objects without PHP class");
    if (__builtin_expect(!(executor_globals.exception), 1)) { execute_data->opline = execute_data->op_array->opcodes+opline->op2.opline_num; } else { ; } return 0;
   }

   ce = zend_get_class_entry(&(**array_ptr_ptr) );
   if (!ce || ce->get_iterator == ((void *)0)) {
    if (!zval_isref_p(*array_ptr_ptr)) { do { if (zval_refcount_p(*((array_ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(array_ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(array_ptr_ptr))->value; (*new_zv).type = (**(array_ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(array_ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
    zval_addref_p(*(array_ptr_ptr));
   }
   array_ptr = *array_ptr_ptr;
  } else {
   if ((**array_ptr_ptr).type == 4) {
    if (!zval_isref_p(*array_ptr_ptr)) { do { if (zval_refcount_p(*((array_ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(array_ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(array_ptr_ptr))->value; (*new_zv).type = (**(array_ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(array_ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
    if (opline->extended_value & 1) {
     zval_set_isref_p(*(array_ptr_ptr));
    }
   }
   array_ptr = *array_ptr_ptr;
   zval_addref_p(array_ptr);
  }
 } else {
  array_ptr = _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 );
  if (1) {
   zval *tmp;

   do { (tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(tmp))->u.buffered = ((void *)0); } while (0);
   do { do { (tmp)->value = (array_ptr)->value; (*tmp).type = (*array_ptr).type; } while (0); zval_set_refcount_p(tmp, 1); zval_unset_isref_p(tmp); } while (0);
   array_ptr = tmp;
   if ((*array_ptr).type == 5) {
    ce = zend_get_class_entry(&(*array_ptr) );
    if (ce && ce->get_iterator) {
     zval_delref_p(array_ptr);
    }
   }
  } else if ((*array_ptr).type == 5) {
   ce = zend_get_class_entry(&(*array_ptr) );
   if (!ce || !ce->get_iterator) {
    zval_addref_p(array_ptr);
   }
  } else if ((1<<1) == (1<<0) ||
             (((1<<1) == (1<<4) || (1<<1) == (1<<2)) &&
              !zval_isref_p(array_ptr) &&
              zval_refcount_p(array_ptr) > 1)) {
   zval *tmp;

   do { (tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(tmp))->u.buffered = ((void *)0); } while (0);
   do { do { (tmp)->value = (array_ptr)->value; (*tmp).type = (*array_ptr).type; } while (0); zval_set_refcount_p(tmp, 1); zval_unset_isref_p(tmp); } while (0);
   _zval_copy_ctor((tmp) );
   array_ptr = tmp;
  } else {
   zval_addref_p(array_ptr);
  }
 }

 if (ce && ce->get_iterator) {
  iter = ce->get_iterator(ce, array_ptr, opline->extended_value & (1<<1) );

  if (iter && __builtin_expect((executor_globals.exception) == ((void *)0), 1)) {
   array_ptr = zend_iterator_wrap(iter );
  } else {

   if (!(executor_globals.exception)) {
    zend_throw_exception_ex(((void *)0), 0 , "Object of type %s did not create an Iterator", ce->name);
   }
   zend_throw_exception_internal(((void *)0) );
   ; return 0;
  }
 }

 (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).fe.ptr = array_ptr;

 if (iter) {
  iter->index = 0;
  if (iter->funcs->rewind) {
   iter->funcs->rewind(iter );
   if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
    i_zval_ptr_dtor(*(&array_ptr) );

    ; return 0;
   }
  }
  is_empty = iter->funcs->valid(iter ) != 0;
  if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
   i_zval_ptr_dtor(*(&array_ptr) );

   ; return 0;
  }
  iter->index = -1;
 } else if ((fe_ht = ((*array_ptr).type==4 ? (*array_ptr).value.ht : (((*array_ptr).type==5 ? (*array_ptr).value.obj.handlers->get_properties((array_ptr) ) : ((void *)0))))) != ((void *)0)) {
  zend_hash_internal_pointer_reset_ex(fe_ht, ((void *)0));
  if (ce) {
   zend_object *zobj = zend_objects_get_address(array_ptr );
   while ((zend_hash_get_current_key_type_ex(fe_ht, ((void *)0)) == 3 ? -1 : 0) == 0) {
    char *str_key;
    uint str_key_len;
    ulong int_key;
    zend_uchar key_type;

    key_type = zend_hash_get_current_key_ex(fe_ht, &str_key, &str_key_len, &int_key, 0, ((void *)0));
    if (key_type != 3 &&
     (key_type == 2 ||
         zend_check_property_access(zobj, str_key, str_key_len-1 ) == 0)) {
     break;
    }
    zend_hash_move_forward_ex(fe_ht, ((void *)0));
   }
  }
  is_empty = (zend_hash_get_current_key_type_ex(fe_ht, ((void *)0)) == 3 ? -1 : 0) != 0;
  zend_hash_get_pointer(fe_ht, &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).fe.fe_pos);
 } else {
  zend_error((1<<1L), "Invalid argument supplied for foreach()");
  is_empty = 1;
 }

 if (is_empty) {
  if (__builtin_expect(!(executor_globals.exception), 1)) { execute_data->opline = execute_data->op_array->opcodes+opline->op2.opline_num; } else { ; } return 0;
 } else {
  ;
  execute_data->opline++; return 0;
 }
}

static int __attribute__((fastcall)) ZEND_EXIT_SPEC_TMP_HANDLER(zend_execute_data *execute_data )
{

 zend_op *opline = execute_data->opline;

 ;
 if ((1<<1) != (1<<3)) {
  zend_free_op free_op1;
  zval *ptr = _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 );

  if ((*ptr).type == 1) {
   (executor_globals.exit_status) = (*ptr).value.lval;
  } else {
   zend_print_variable(ptr);
  }
  _zval_dtor((free_op1.var) );
 }

 _zend_bailout("/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_vm_execute.h", 6799);
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_END_SILENCE_SPEC_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval restored_error_reporting;

 ;
 if (!(executor_globals.error_reporting) && ((*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).tmp_var).value.lval != 0) {
  (restored_error_reporting).type = 1;
  (restored_error_reporting).value.lval = ((*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).tmp_var).value.lval;
  (executor_globals.error_reporting) = (restored_error_reporting).value.lval;
  if ((&restored_error_reporting)->type != 6) { _convert_to_string((&restored_error_reporting) ); };
  if (__builtin_expect((executor_globals.error_reporting_ini_entry) != ((void *)0), 1)) {
   if (__builtin_expect((executor_globals.error_reporting_ini_entry)->modified && (executor_globals.error_reporting_ini_entry)->value != (executor_globals.error_reporting_ini_entry)->orig_value, 1)
                                                                                         ) {
    _efree(((executor_globals.error_reporting_ini_entry)->value) );
   }
   (executor_globals.error_reporting_ini_entry)->value = (restored_error_reporting).value.str.val;
   (executor_globals.error_reporting_ini_entry)->value_length = (restored_error_reporting).value.str.len;
  } else {
   _zval_dtor((&(restored_error_reporting)) );
  }
 }
 if (execute_data->old_error_reporting == &(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).tmp_var) {
  execute_data->old_error_reporting = ((void *)0);
 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_JMP_SET_SPEC_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *value;

 ;
 value = _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 );

 if (i_zend_is_true(value)) {
  do { (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var)->value = (value)->value; (*&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).type = (*value).type; } while (0);
  _zval_copy_ctor((&((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var)) );
  _zval_dtor((free_op1.var) );



  if (__builtin_expect(!(executor_globals.exception), 1)) { execute_data->opline = opline->op2.jmp_addr; } else { ; } return 0;
 }

 _zval_dtor((free_op1.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_QM_ASSIGN_SPEC_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *value;

 ;
 value = _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 );

 do { (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var)->value = (value)->value; (*&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).type = (*value).type; } while (0);
 if (!1) {
  _zval_copy_ctor((&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var) );
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INSTANCEOF_SPEC_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *expr;
 zend_bool result;

 ;
 expr = _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((*expr).type == 5 && (*expr).value.obj.handlers->get_class_entry) {
  result = instanceof_function(zend_get_class_entry(&(*expr) ), (*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).class_entry );
 } else {
  result = 0;
 }
 do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((result) != 0); (*__z).type = 3; } while (0);
 _zval_dtor((free_op1.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ADD_SPEC_TMP_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 add_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  opline->op2.zv );
 _zval_dtor((free_op1.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SUB_SPEC_TMP_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 sub_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  opline->op2.zv );
 _zval_dtor((free_op1.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_MUL_SPEC_TMP_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 mul_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  opline->op2.zv );
 _zval_dtor((free_op1.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_DIV_SPEC_TMP_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 div_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  opline->op2.zv );
 _zval_dtor((free_op1.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_MOD_SPEC_TMP_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 mod_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  opline->op2.zv );
 _zval_dtor((free_op1.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SL_SPEC_TMP_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 shift_left_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  opline->op2.zv );
 _zval_dtor((free_op1.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SR_SPEC_TMP_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 shift_right_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  opline->op2.zv );
 _zval_dtor((free_op1.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_CONCAT_SPEC_TMP_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 concat_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  opline->op2.zv );
 _zval_dtor((free_op1.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_IDENTICAL_SPEC_TMP_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 is_identical_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  opline->op2.zv );
 _zval_dtor((free_op1.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_NOT_IDENTICAL_SPEC_TMP_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 is_identical_function(result,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  opline->op2.zv );
 (*result).value.lval = !(*result).value.lval;
 _zval_dtor((free_op1.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_EQUAL_SPEC_TMP_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  opline->op2.zv );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval == 0)) != 0); (*__z).type = 3; } while (0);
 _zval_dtor((free_op1.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_NOT_EQUAL_SPEC_TMP_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  opline->op2.zv );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval != 0)) != 0); (*__z).type = 3; } while (0);
 _zval_dtor((free_op1.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_SMALLER_SPEC_TMP_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  opline->op2.zv );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval < 0)) != 0); (*__z).type = 3; } while (0);
 _zval_dtor((free_op1.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMP_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  opline->op2.zv );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval <= 0)) != 0); (*__z).type = 3; } while (0);
 _zval_dtor((free_op1.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_OR_SPEC_TMP_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 bitwise_or_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  opline->op2.zv );
 _zval_dtor((free_op1.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_AND_SPEC_TMP_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 bitwise_and_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  opline->op2.zv );
 _zval_dtor((free_op1.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_XOR_SPEC_TMP_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 bitwise_xor_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  opline->op2.zv );
 _zval_dtor((free_op1.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BOOL_XOR_SPEC_TMP_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 boolean_xor_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  opline->op2.zv );
 _zval_dtor((free_op1.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_fetch_var_address_helper_SPEC_TMP_CONST(int type, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *varname;
 zval **retval;
 zval tmp_varname;
 HashTable *target_symbol_table;
 ulong hash_value;

 ;
 varname = _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 );

  if ((1<<1) != (1<<0) && __builtin_expect((*varname).type != 6, 0)) {
  do { (&tmp_varname)->value = (varname)->value; (*&tmp_varname).type = (*varname).type; } while (0);
  _zval_copy_ctor((&tmp_varname) );
  if ((&tmp_varname)->type != 6) { _convert_to_string((&tmp_varname) ); };
  varname = &tmp_varname;
 }

 if ((1<<0) != (1<<3)) {
  zend_class_entry *ce;

  if ((1<<0) == (1<<0)) {
   if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
    ce = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
   } else {
    ce = zend_fetch_class_by_name((*opline->op2.zv).value.str.val, (*opline->op2.zv).value.str.len, opline->op2.literal + 1, 0 );
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); } while (0);
   }
  } else {
   ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).class_entry;
  }
  retval = zend_std_get_static_property(ce, (*varname).value.str.val, (*varname).value.str.len, 0, (((1<<1) == (1<<0)) ? opline->op1.literal : ((void *)0)) );
  _zval_dtor((free_op1.var) );
 } else {
  target_symbol_table = zend_get_target_symbol_table(opline->extended_value & 0x70000000 );






  if ((1<<1) == (1<<0)) {
   hash_value = (((zend_literal*)(varname))->hash_value);
  } else if (((((*varname).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*varname).value.str.val) < (compiler_globals.interned_strings_end)))) {
   hash_value = (((Bucket*)(((char*)((*varname).value.str.val))-sizeof(Bucket)))->h);
  } else {
   hash_value = zend_hash_func((*varname).value.str.val, (*varname).value.str.len+1);
  }

  if (zend_hash_quick_find(target_symbol_table, (*varname).value.str.val, (*varname).value.str.len+1, hash_value, (void **) &retval) == -1) {
   switch (type) {
    case 0:
    case 6:
     zend_error((1<<3L),"Undefined variable: %s", (*varname).value.str.val);

    case 3:
     retval = &(executor_globals.uninitialized_zval_ptr);
     break;
    case 2:
     zend_error((1<<3L),"Undefined variable: %s", (*varname).value.str.val);

    case 1:
     zval_addref_p(&(executor_globals.uninitialized_zval));
     _zend_hash_quick_add_or_update(target_symbol_table, (*varname).value.str.val, (*varname).value.str.len+1, hash_value, &(executor_globals.uninitialized_zval_ptr), sizeof(zval *), (void **) &retval, (1<<0) );
     break;
   
   }
  }
  switch (opline->extended_value & 0x70000000) {
   case 0x00000000:
    if ((1<<1) != (1<<1)) {
     _zval_dtor((free_op1.var) );
    }
    break;
   case 0x10000000:
    _zval_dtor((free_op1.var) );
    break;
   case 0x20000000:
    zval_update_constant(retval, (void*) 1 );
    break;
   case 0x40000000:
    if ((1<<1) == (1<<2) && !free_op1.var) {
     zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr));
    }
    break;
  }
 }


 if ((1<<1) != (1<<0) && varname == &tmp_varname) {
  _zval_dtor((&tmp_varname) );
 }
 if (opline->extended_value & 0x04000000) {
  if (!zval_isref_p(*retval)) { do { if (zval_refcount_p(*((retval))) > 1) { zval *new_zv; zval_delref_p(*(retval)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval))->value; (*new_zv).type = (**(retval)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((retval))); };
 }
 zval_addref_p((*retval));
 switch (type) {
  case 0:
  case 3:
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (*retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   break;
  case 6: {
   zend_free_op free_res;

   zend_pzval_unlock_func(*retval, &free_res, 1 );
   if (retval != &(executor_globals.uninitialized_zval_ptr)) {
    if (!zval_isref_p(*retval)) { do { if (zval_refcount_p(*((retval))) > 1) { zval *new_zv; zval_delref_p(*(retval)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval))->value; (*new_zv).type = (**(retval)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
   }
   zval_addref_p((*retval));
   if (free_res.var) { i_zval_ptr_dtor(*(&free_res.var) ); };
  }

  default:
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = retval;
   break;
 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_R_SPEC_TMP_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_TMP_CONST(0, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_W_SPEC_TMP_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_TMP_CONST(1, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_RW_SPEC_TMP_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_TMP_CONST(2, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_FUNC_ARG_SPEC_TMP_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 return zend_fetch_var_address_helper_SPEC_TMP_CONST(((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && (opline->extended_value & 0x000fffff) <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[(opline->extended_value & 0x000fffff)-1].pass_by_reference & (1|2)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x1000000|0x2000000))))?1:0, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_UNSET_SPEC_TMP_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_TMP_CONST(6, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_IS_SPEC_TMP_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_TMP_CONST(3, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_TMP_VAR_SPEC_TMP_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *container;

 ;
 container = _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 );

 if (__builtin_expect((*container).type != 4, 0)) {
  zval_addref_p((&(executor_globals.uninitialized_zval)));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
 } else {

  zval *value = *zend_fetch_dimension_address_inner((*container).value.ht, opline->op2.zv, (1<<0), 0 );

  zval_addref_p((value));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (value); __t->var.ptr_ptr = &__t->var.ptr; } while (0);

 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ADD_CHAR_SPEC_TMP_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *str = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;

 if ((1<<1) == (1<<3)) {

  (*str).value.str.val = ((void *)0);
  (*str).value.str.len = 0;
  (*str).type = 6;

  (str)->refcount__gc = 1; (str)->is_ref__gc = 0;;
 }

 add_char_to_string(str, str, opline->op2.zv);



 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ADD_STRING_SPEC_TMP_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *str = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;

 if ((1<<1) == (1<<3)) {

  (*str).value.str.val = ((void *)0);
  (*str).value.str.len = 0;
  (*str).type = 6;

  (str)->refcount__gc = 1; (str)->is_ref__gc = 0;;
 }

 add_string_to_string(str, str, opline->op2.zv);



 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_METHOD_CALL_SPEC_TMP_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *function_name;
 char *function_name_strval;
 int function_name_strlen;
 zend_free_op free_op1;

 ;
 zend_ptr_stack_3_push(&(executor_globals.arg_types_stack), execute_data->fbc, execute_data->object, execute_data->called_scope);

 function_name = opline->op2.zv;

 if ((1<<0) != (1<<0) &&
     __builtin_expect((*function_name).type != 6, 0)) {
  zend_error_noreturn((1<<0L), "Method name must be a string");
 }

 function_name_strval = (*function_name).value.str.val;
 function_name_strlen = (*function_name).value.str.len;

 execute_data->object = _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 );

 if (__builtin_expect(execute_data->object != ((void *)0), 1) &&
     __builtin_expect((*execute_data->object).type == 5, 1)) {
  execute_data->called_scope = zend_get_class_entry(&(*execute_data->object) );

  if ((1<<0) != (1<<0) ||
      (execute_data->fbc = (((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] == (execute_data->called_scope)) ? (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] : ((void *)0))) == ((void *)0)) {
      zval *object = execute_data->object;

   if (__builtin_expect((*execute_data->object).value.obj.handlers->get_method == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Object does not support method calls");
   }


   execute_data->fbc = (*execute_data->object).value.obj.handlers->get_method(&execute_data->object, function_name_strval, function_name_strlen, (((1<<0) == (1<<0)) ? (opline->op2.literal + 1) : ((void *)0)) );
   if (__builtin_expect(execute_data->fbc == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Call to undefined method %s::%s()", ((execute_data->object) && (*execute_data->object).type == 5 && (*execute_data->object).value.obj.handlers->get_class_entry != ((void *)0) && (*execute_data->object).value.obj.handlers->get_class_entry(execute_data->object ) ? (*execute_data->object).value.obj.handlers->get_class_entry(execute_data->object )->name : ""), function_name_strval);
   }
   if ((1<<0) == (1<<0) &&
       __builtin_expect((execute_data->fbc->common.fn_flags & 0x200000) == 0, 1) &&
       __builtin_expect(execute_data->object == object, 1)) {
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (execute_data->called_scope); (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] = (execute_data->fbc); } while (0);
   }
  }
 } else {
  zend_error_noreturn((1<<0L), "Call to a member function %s() on a non-object", function_name_strval);
 }

 if ((execute_data->fbc->common.fn_flags & 0x01) != 0) {
  execute_data->object = ((void *)0);
 } else {
  if (!zval_isref_p(execute_data->object)) {
   zval_addref_p(execute_data->object);
  } else {
   zval *this_ptr;
   do { (this_ptr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(this_ptr))->u.buffered = ((void *)0); } while (0);
   do { do { (this_ptr)->value = (execute_data->object)->value; (*this_ptr).type = (*execute_data->object).type; } while (0); zval_set_refcount_p(this_ptr, 1); zval_unset_isref_p(this_ptr); } while (0);
   _zval_copy_ctor((this_ptr) );
   execute_data->object = this_ptr;
  }
 }


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_CASE_SPEC_TMP_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 if ((1<<1)==(1<<2)) {
  zval_addref_p(((*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr));
 }
 is_equal_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
     _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
     opline->op2.zv );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *expr_ptr;

 ;
 if (((1<<1) == (1<<2) || (1<<1) == (1<<4)) && opline->extended_value) {
  zval **expr_ptr_ptr = ((void *)0);

  if ((1<<1) == (1<<2) && __builtin_expect(expr_ptr_ptr == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot create references to/from string offsets");
  }
  if (!zval_isref_p(*expr_ptr_ptr)) { do { if (zval_refcount_p(*((expr_ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(expr_ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(expr_ptr_ptr))->value; (*new_zv).type = (**(expr_ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(expr_ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((expr_ptr_ptr))); };
  expr_ptr = *expr_ptr_ptr;
  zval_addref_p(expr_ptr);
 } else {
  expr_ptr=_get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 );
  if (1) {
   zval *new_expr;

   do { (new_expr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_expr))->u.buffered = ((void *)0); } while (0);
   do { do { (new_expr)->value = (expr_ptr)->value; (*new_expr).type = (*expr_ptr).type; } while (0); zval_set_refcount_p(new_expr, 1); zval_unset_isref_p(new_expr); } while (0);
   expr_ptr = new_expr;
  } else if ((1<<1) == (1<<0) || zval_isref_p(expr_ptr)) {
   zval *new_expr;

   do { (new_expr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_expr))->u.buffered = ((void *)0); } while (0);
   do { do { (new_expr)->value = (expr_ptr)->value; (*new_expr).type = (*expr_ptr).type; } while (0); zval_set_refcount_p(new_expr, 1); zval_unset_isref_p(new_expr); } while (0);
   expr_ptr = new_expr;
   _zval_copy_ctor((&(*expr_ptr)) );
  } else {
   zval_addref_p(expr_ptr);
  }
 }

 if ((1<<0) != (1<<3)) {

  zval *offset = opline->op2.zv;
  ulong hval;

  switch ((*offset).type) {
   case 2:
    hval = zend_dval_to_lval((*offset).value.dval);
    goto num_index;
   case 1:
   case 3:
    hval = (*offset).value.lval;
num_index:
    _zend_hash_index_update_or_next_insert(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, hval, &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   case 6:
    if ((1<<0) == (1<<0)) {
     hval = (((zend_literal*)(offset))->hash_value);
    } else {
     do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index; } } } while (0);
     if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
      hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
     } else {
      hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
     }
    }
    _zend_hash_quick_add_or_update(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   case 0:
    _zend_hash_add_or_update(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, "", sizeof(""), &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   default:
    zend_error((1<<1L), "Illegal offset type");
    i_zval_ptr_dtor(*(&expr_ptr) );

    break;
  }

 } else {
  _zend_hash_index_update_or_next_insert(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, 0, &expr_ptr, sizeof(zval *), ((void *)0), (1<<2) );
 }
 if (((1<<1) == (1<<2) || (1<<1) == (1<<4)) && opline->extended_value) {

 } else {

 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_ARRAY_SPEC_TMP_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 _array_init((&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var), 0 );
 if ((1<<1) == (1<<3)) {
  execute_data->opline++; return 0;

 } else {
  return ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CONST_HANDLER(execute_data );

 }
}

static int __attribute__((fastcall)) ZEND_UNSET_VAR_SPEC_TMP_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval tmp, *varname;
 HashTable *target_symbol_table;
 zend_free_op free_op1;

 ;
 if ((1<<1) == (1<<4) &&
     (1<<0) == (1<<3) &&
     (opline->extended_value & 0x00800000)) {
  if ((executor_globals.active_symbol_table)) {
   zend_compiled_variable *cv = &((executor_globals.active_op_array)->vars[opline->op1.var]);

   zend_delete_variable(execute_data->prev_execute_data, (executor_globals.active_symbol_table), cv->name, cv->name_len+1, cv->hash_value );
   execute_data->CVs[opline->op1.var] = ((void *)0);
  } else if (execute_data->CVs[opline->op1.var]) {
   i_zval_ptr_dtor(*(execute_data->CVs[opline->op1.var]) );
   execute_data->CVs[opline->op1.var] = ((void *)0);
  }
  ;
  execute_data->opline++; return 0;
 }

 varname = _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<1) != (1<<0) && (*varname).type != 6) {
  do { (&tmp)->value = (varname)->value; (*&tmp).type = (*varname).type; } while (0);
  _zval_copy_ctor((&tmp) );
  if ((&tmp)->type != 6) { _convert_to_string((&tmp) ); };
  varname = &tmp;
 } else if ((1<<1) == (1<<2) || (1<<1) == (1<<4)) {
  zval_addref_p(varname);
 }

 if ((1<<0) != (1<<3)) {
  zend_class_entry *ce;

  if ((1<<0) == (1<<0)) {
   if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
    ce = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
   } else {
    ce = zend_fetch_class_by_name((*opline->op2.zv).value.str.val, (*opline->op2.zv).value.str.len, opline->op2.literal + 1, 0 );
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); } while (0);
   }
  } else {
   ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).class_entry;
  }
  zend_std_unset_static_property(ce, (*varname).value.str.val, (*varname).value.str.len, (((1<<1) == (1<<0)) ? opline->op1.literal : ((void *)0)) );
 } else {
  ulong hash_value = zend_inline_hash_func(varname->value.str.val, varname->value.str.len+1);

  target_symbol_table = zend_get_target_symbol_table(opline->extended_value & 0x70000000 );
  zend_delete_variable(execute_data, target_symbol_table, varname->value.str.val, varname->value.str.len+1, hash_value );
 }

 if ((1<<1) != (1<<0) && varname == &tmp) {
  _zval_dtor((&tmp) );
 } else if ((1<<1) == (1<<2) || (1<<1) == (1<<4)) {
  i_zval_ptr_dtor(*(&varname) );
 }
 _zval_dtor((free_op1.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ISSET_ISEMPTY_VAR_SPEC_TMP_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval **value;
 zend_bool isset = 1;

 ;
 if ((1<<1) == (1<<4) &&
     (1<<0) == (1<<3) &&
     (opline->extended_value & 0x00800000)) {
  if (execute_data->CVs[opline->op1.var]) {
   value = execute_data->CVs[opline->op1.var];
  } else if ((executor_globals.active_symbol_table)) {
   zend_compiled_variable *cv = &((executor_globals.active_op_array)->vars[opline->op1.var]);

   if (zend_hash_quick_find((executor_globals.active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, (void **) &value) == -1) {
    isset = 0;
   }
  } else {
   isset = 0;
  }
 } else {
  HashTable *target_symbol_table;
  zend_free_op free_op1;
  zval tmp, *varname = _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 );

  if ((1<<1) != (1<<0) && (*varname).type != 6) {
   do { (&tmp)->value = (varname)->value; (*&tmp).type = (*varname).type; } while (0);
   _zval_copy_ctor((&tmp) );
   if ((&tmp)->type != 6) { _convert_to_string((&tmp) ); };
   varname = &tmp;
  }

  if ((1<<0) != (1<<3)) {
   zend_class_entry *ce;

   if ((1<<0) == (1<<0)) {
    if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
     ce = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
    } else {
     ce = zend_fetch_class_by_name((*opline->op2.zv).value.str.val, (*opline->op2.zv).value.str.len, opline->op2.literal + 1, 0 );
     do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); } while (0);
    }
   } else {
    ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).class_entry;
   }
   value = zend_std_get_static_property(ce, (*varname).value.str.val, (*varname).value.str.len, 1, (((1<<1) == (1<<0)) ? opline->op1.literal : ((void *)0)) );
   if (!value) {
    isset = 0;
   }
  } else {
   target_symbol_table = zend_get_target_symbol_table(opline->extended_value & 0x70000000 );
   if (zend_hash_find(target_symbol_table, varname->value.str.val, varname->value.str.len+1, (void **) &value) == -1) {
    isset = 0;
   }
  }

  if ((1<<1) != (1<<0) && varname == &tmp) {
   _zval_dtor((&tmp) );
  }
  _zval_dtor((free_op1.var) );
 }

 if (opline->extended_value & 0x02000000) {
  if (isset && (**value).type != 0) {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((1) != 0); (*__z).type = 3; } while (0);
  } else {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((0) != 0); (*__z).type = 3; } while (0);
  }
 } else {
  if (!isset || !i_zend_is_true(*value)) {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((1) != 0); (*__z).type = 3; } while (0);
  } else {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((0) != 0); (*__z).type = 3; } while (0);
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ADD_SPEC_TMP_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 add_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 _zval_dtor((free_op1.var) );
 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SUB_SPEC_TMP_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 sub_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 _zval_dtor((free_op1.var) );
 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_MUL_SPEC_TMP_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 mul_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 _zval_dtor((free_op1.var) );
 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_DIV_SPEC_TMP_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 div_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 _zval_dtor((free_op1.var) );
 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_MOD_SPEC_TMP_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 mod_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 _zval_dtor((free_op1.var) );
 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SL_SPEC_TMP_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 shift_left_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 _zval_dtor((free_op1.var) );
 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SR_SPEC_TMP_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 shift_right_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 _zval_dtor((free_op1.var) );
 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_CONCAT_SPEC_TMP_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 concat_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 _zval_dtor((free_op1.var) );
 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_IDENTICAL_SPEC_TMP_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 is_identical_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 _zval_dtor((free_op1.var) );
 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_NOT_IDENTICAL_SPEC_TMP_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 is_identical_function(result,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 (*result).value.lval = !(*result).value.lval;
 _zval_dtor((free_op1.var) );
 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_EQUAL_SPEC_TMP_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval == 0)) != 0); (*__z).type = 3; } while (0);
 _zval_dtor((free_op1.var) );
 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_NOT_EQUAL_SPEC_TMP_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval != 0)) != 0); (*__z).type = 3; } while (0);
 _zval_dtor((free_op1.var) );
 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_SMALLER_SPEC_TMP_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval < 0)) != 0); (*__z).type = 3; } while (0);
 _zval_dtor((free_op1.var) );
 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMP_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval <= 0)) != 0); (*__z).type = 3; } while (0);
 _zval_dtor((free_op1.var) );
 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_OR_SPEC_TMP_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 bitwise_or_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 _zval_dtor((free_op1.var) );
 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_AND_SPEC_TMP_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 bitwise_and_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 _zval_dtor((free_op1.var) );
 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_XOR_SPEC_TMP_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 bitwise_xor_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 _zval_dtor((free_op1.var) );
 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BOOL_XOR_SPEC_TMP_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 boolean_xor_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 _zval_dtor((free_op1.var) );
 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ADD_VAR_SPEC_TMP_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval *str = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;
 zval *var;
 zval var_copy;
 int use_copy = 0;

 ;
 var = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((1<<1) == (1<<3)) {

  (*str).value.str.val = ((void *)0);
  (*str).value.str.len = 0;
  (*str).type = 6;

  (str)->refcount__gc = 1; (str)->is_ref__gc = 0;;
 }

 if ((*var).type != 6) {
  zend_make_printable_zval(var, &var_copy, &use_copy);

  if (use_copy) {
   var = &var_copy;
  }
 }
 add_string_to_string(str, str, var);

 if (use_copy) {
  _zval_dtor((var) );
 }






 _zval_dtor((free_op2.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_METHOD_CALL_SPEC_TMP_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *function_name;
 char *function_name_strval;
 int function_name_strlen;
 zend_free_op free_op1, free_op2;

 ;
 zend_ptr_stack_3_push(&(executor_globals.arg_types_stack), execute_data->fbc, execute_data->object, execute_data->called_scope);

 function_name = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((1<<1) != (1<<0) &&
     __builtin_expect((*function_name).type != 6, 0)) {
  zend_error_noreturn((1<<0L), "Method name must be a string");
 }

 function_name_strval = (*function_name).value.str.val;
 function_name_strlen = (*function_name).value.str.len;

 execute_data->object = _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 );

 if (__builtin_expect(execute_data->object != ((void *)0), 1) &&
     __builtin_expect((*execute_data->object).type == 5, 1)) {
  execute_data->called_scope = zend_get_class_entry(&(*execute_data->object) );

  if ((1<<1) != (1<<0) ||
      (execute_data->fbc = (((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] == (execute_data->called_scope)) ? (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] : ((void *)0))) == ((void *)0)) {
      zval *object = execute_data->object;

   if (__builtin_expect((*execute_data->object).value.obj.handlers->get_method == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Object does not support method calls");
   }


   execute_data->fbc = (*execute_data->object).value.obj.handlers->get_method(&execute_data->object, function_name_strval, function_name_strlen, (((1<<1) == (1<<0)) ? (opline->op2.literal + 1) : ((void *)0)) );
   if (__builtin_expect(execute_data->fbc == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Call to undefined method %s::%s()", ((execute_data->object) && (*execute_data->object).type == 5 && (*execute_data->object).value.obj.handlers->get_class_entry != ((void *)0) && (*execute_data->object).value.obj.handlers->get_class_entry(execute_data->object ) ? (*execute_data->object).value.obj.handlers->get_class_entry(execute_data->object )->name : ""), function_name_strval);
   }
   if ((1<<1) == (1<<0) &&
       __builtin_expect((execute_data->fbc->common.fn_flags & 0x200000) == 0, 1) &&
       __builtin_expect(execute_data->object == object, 1)) {
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (execute_data->called_scope); (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] = (execute_data->fbc); } while (0);
   }
  }
 } else {
  zend_error_noreturn((1<<0L), "Call to a member function %s() on a non-object", function_name_strval);
 }

 if ((execute_data->fbc->common.fn_flags & 0x01) != 0) {
  execute_data->object = ((void *)0);
 } else {
  if (!zval_isref_p(execute_data->object)) {
   zval_addref_p(execute_data->object);
  } else {
   zval *this_ptr;
   do { (this_ptr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(this_ptr))->u.buffered = ((void *)0); } while (0);
   do { do { (this_ptr)->value = (execute_data->object)->value; (*this_ptr).type = (*execute_data->object).type; } while (0); zval_set_refcount_p(this_ptr, 1); zval_unset_isref_p(this_ptr); } while (0);
   _zval_copy_ctor((this_ptr) );
   execute_data->object = this_ptr;
  }
 }

 _zval_dtor((free_op2.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_CASE_SPEC_TMP_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 if ((1<<1)==(1<<2)) {
  zval_addref_p(((*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr));
 }
 is_equal_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
     _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
     _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );

 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *expr_ptr;

 ;
 if (((1<<1) == (1<<2) || (1<<1) == (1<<4)) && opline->extended_value) {
  zval **expr_ptr_ptr = ((void *)0);

  if ((1<<1) == (1<<2) && __builtin_expect(expr_ptr_ptr == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot create references to/from string offsets");
  }
  if (!zval_isref_p(*expr_ptr_ptr)) { do { if (zval_refcount_p(*((expr_ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(expr_ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(expr_ptr_ptr))->value; (*new_zv).type = (**(expr_ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(expr_ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((expr_ptr_ptr))); };
  expr_ptr = *expr_ptr_ptr;
  zval_addref_p(expr_ptr);
 } else {
  expr_ptr=_get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 );
  if (1) {
   zval *new_expr;

   do { (new_expr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_expr))->u.buffered = ((void *)0); } while (0);
   do { do { (new_expr)->value = (expr_ptr)->value; (*new_expr).type = (*expr_ptr).type; } while (0); zval_set_refcount_p(new_expr, 1); zval_unset_isref_p(new_expr); } while (0);
   expr_ptr = new_expr;
  } else if ((1<<1) == (1<<0) || zval_isref_p(expr_ptr)) {
   zval *new_expr;

   do { (new_expr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_expr))->u.buffered = ((void *)0); } while (0);
   do { do { (new_expr)->value = (expr_ptr)->value; (*new_expr).type = (*expr_ptr).type; } while (0); zval_set_refcount_p(new_expr, 1); zval_unset_isref_p(new_expr); } while (0);
   expr_ptr = new_expr;
   _zval_copy_ctor((&(*expr_ptr)) );
  } else {
   zval_addref_p(expr_ptr);
  }
 }

 if ((1<<1) != (1<<3)) {
  zend_free_op free_op2;
  zval *offset = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );
  ulong hval;

  switch ((*offset).type) {
   case 2:
    hval = zend_dval_to_lval((*offset).value.dval);
    goto num_index;
   case 1:
   case 3:
    hval = (*offset).value.lval;
num_index:
    _zend_hash_index_update_or_next_insert(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, hval, &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   case 6:
    if ((1<<1) == (1<<0)) {
     hval = (((zend_literal*)(offset))->hash_value);
    } else {
     do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index; } } } while (0);
     if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
      hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
     } else {
      hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
     }
    }
    _zend_hash_quick_add_or_update(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   case 0:
    _zend_hash_add_or_update(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, "", sizeof(""), &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   default:
    zend_error((1<<1L), "Illegal offset type");
    i_zval_ptr_dtor(*(&expr_ptr) );

    break;
  }
  _zval_dtor((free_op2.var) );
 } else {
  _zend_hash_index_update_or_next_insert(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, 0, &expr_ptr, sizeof(zval *), ((void *)0), (1<<2) );
 }
 if (((1<<1) == (1<<2) || (1<<1) == (1<<4)) && opline->extended_value) {

 } else {

 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_ARRAY_SPEC_TMP_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 _array_init((&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var), 0 );
 if ((1<<1) == (1<<3)) {
  execute_data->opline++; return 0;

 } else {
  return ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_TMP_HANDLER(execute_data );

 }
}

static int __attribute__((fastcall)) ZEND_ADD_SPEC_TMP_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 add_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 _zval_dtor((free_op1.var) );
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SUB_SPEC_TMP_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 sub_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 _zval_dtor((free_op1.var) );
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_MUL_SPEC_TMP_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 mul_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 _zval_dtor((free_op1.var) );
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_DIV_SPEC_TMP_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 div_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 _zval_dtor((free_op1.var) );
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_MOD_SPEC_TMP_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 mod_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 _zval_dtor((free_op1.var) );
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SL_SPEC_TMP_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 shift_left_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 _zval_dtor((free_op1.var) );
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SR_SPEC_TMP_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 shift_right_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 _zval_dtor((free_op1.var) );
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_CONCAT_SPEC_TMP_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 concat_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 _zval_dtor((free_op1.var) );
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_IDENTICAL_SPEC_TMP_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 is_identical_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 _zval_dtor((free_op1.var) );
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_NOT_IDENTICAL_SPEC_TMP_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 is_identical_function(result,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 (*result).value.lval = !(*result).value.lval;
 _zval_dtor((free_op1.var) );
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_EQUAL_SPEC_TMP_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval == 0)) != 0); (*__z).type = 3; } while (0);
 _zval_dtor((free_op1.var) );
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_NOT_EQUAL_SPEC_TMP_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval != 0)) != 0); (*__z).type = 3; } while (0);
 _zval_dtor((free_op1.var) );
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_SMALLER_SPEC_TMP_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval < 0)) != 0); (*__z).type = 3; } while (0);
 _zval_dtor((free_op1.var) );
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMP_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval <= 0)) != 0); (*__z).type = 3; } while (0);
 _zval_dtor((free_op1.var) );
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_OR_SPEC_TMP_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 bitwise_or_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 _zval_dtor((free_op1.var) );
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_AND_SPEC_TMP_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 bitwise_and_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 _zval_dtor((free_op1.var) );
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_XOR_SPEC_TMP_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 bitwise_xor_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 _zval_dtor((free_op1.var) );
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BOOL_XOR_SPEC_TMP_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 boolean_xor_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 _zval_dtor((free_op1.var) );
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_fetch_var_address_helper_SPEC_TMP_VAR(int type, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *varname;
 zval **retval;
 zval tmp_varname;
 HashTable *target_symbol_table;
 ulong hash_value;

 ;
 varname = _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 );

  if ((1<<1) != (1<<0) && __builtin_expect((*varname).type != 6, 0)) {
  do { (&tmp_varname)->value = (varname)->value; (*&tmp_varname).type = (*varname).type; } while (0);
  _zval_copy_ctor((&tmp_varname) );
  if ((&tmp_varname)->type != 6) { _convert_to_string((&tmp_varname) ); };
  varname = &tmp_varname;
 }

 if ((1<<2) != (1<<3)) {
  zend_class_entry *ce;

  if ((1<<2) == (1<<0)) {
   if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
    ce = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
   } else {
    ce = zend_fetch_class_by_name((*opline->op2.zv).value.str.val, (*opline->op2.zv).value.str.len, opline->op2.literal + 1, 0 );
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); } while (0);
   }
  } else {
   ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).class_entry;
  }
  retval = zend_std_get_static_property(ce, (*varname).value.str.val, (*varname).value.str.len, 0, (((1<<1) == (1<<0)) ? opline->op1.literal : ((void *)0)) );
  _zval_dtor((free_op1.var) );
 } else {
  target_symbol_table = zend_get_target_symbol_table(opline->extended_value & 0x70000000 );






  if ((1<<1) == (1<<0)) {
   hash_value = (((zend_literal*)(varname))->hash_value);
  } else if (((((*varname).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*varname).value.str.val) < (compiler_globals.interned_strings_end)))) {
   hash_value = (((Bucket*)(((char*)((*varname).value.str.val))-sizeof(Bucket)))->h);
  } else {
   hash_value = zend_hash_func((*varname).value.str.val, (*varname).value.str.len+1);
  }

  if (zend_hash_quick_find(target_symbol_table, (*varname).value.str.val, (*varname).value.str.len+1, hash_value, (void **) &retval) == -1) {
   switch (type) {
    case 0:
    case 6:
     zend_error((1<<3L),"Undefined variable: %s", (*varname).value.str.val);

    case 3:
     retval = &(executor_globals.uninitialized_zval_ptr);
     break;
    case 2:
     zend_error((1<<3L),"Undefined variable: %s", (*varname).value.str.val);

    case 1:
     zval_addref_p(&(executor_globals.uninitialized_zval));
     _zend_hash_quick_add_or_update(target_symbol_table, (*varname).value.str.val, (*varname).value.str.len+1, hash_value, &(executor_globals.uninitialized_zval_ptr), sizeof(zval *), (void **) &retval, (1<<0) );
     break;
   
   }
  }
  switch (opline->extended_value & 0x70000000) {
   case 0x00000000:
    if ((1<<1) != (1<<1)) {
     _zval_dtor((free_op1.var) );
    }
    break;
   case 0x10000000:
    _zval_dtor((free_op1.var) );
    break;
   case 0x20000000:
    zval_update_constant(retval, (void*) 1 );
    break;
   case 0x40000000:
    if ((1<<1) == (1<<2) && !free_op1.var) {
     zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr));
    }
    break;
  }
 }


 if ((1<<1) != (1<<0) && varname == &tmp_varname) {
  _zval_dtor((&tmp_varname) );
 }
 if (opline->extended_value & 0x04000000) {
  if (!zval_isref_p(*retval)) { do { if (zval_refcount_p(*((retval))) > 1) { zval *new_zv; zval_delref_p(*(retval)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval))->value; (*new_zv).type = (**(retval)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((retval))); };
 }
 zval_addref_p((*retval));
 switch (type) {
  case 0:
  case 3:
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (*retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   break;
  case 6: {
   zend_free_op free_res;

   zend_pzval_unlock_func(*retval, &free_res, 1 );
   if (retval != &(executor_globals.uninitialized_zval_ptr)) {
    if (!zval_isref_p(*retval)) { do { if (zval_refcount_p(*((retval))) > 1) { zval *new_zv; zval_delref_p(*(retval)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval))->value; (*new_zv).type = (**(retval)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
   }
   zval_addref_p((*retval));
   if (free_res.var) { i_zval_ptr_dtor(*(&free_res.var) ); };
  }

  default:
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = retval;
   break;
 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_R_SPEC_TMP_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_TMP_VAR(0, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_W_SPEC_TMP_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_TMP_VAR(1, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_RW_SPEC_TMP_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_TMP_VAR(2, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_FUNC_ARG_SPEC_TMP_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 return zend_fetch_var_address_helper_SPEC_TMP_VAR(((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && (opline->extended_value & 0x000fffff) <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[(opline->extended_value & 0x000fffff)-1].pass_by_reference & (1|2)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x1000000|0x2000000))))?1:0, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_UNSET_SPEC_TMP_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_TMP_VAR(6, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_IS_SPEC_TMP_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_TMP_VAR(3, execute_data );
}

static int __attribute__((fastcall)) ZEND_ADD_VAR_SPEC_TMP_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval *str = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;
 zval *var;
 zval var_copy;
 int use_copy = 0;

 ;
 var = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((1<<1) == (1<<3)) {

  (*str).value.str.val = ((void *)0);
  (*str).value.str.len = 0;
  (*str).type = 6;

  (str)->refcount__gc = 1; (str)->is_ref__gc = 0;;
 }

 if ((*var).type != 6) {
  zend_make_printable_zval(var, &var_copy, &use_copy);

  if (use_copy) {
   var = &var_copy;
  }
 }
 add_string_to_string(str, str, var);

 if (use_copy) {
  _zval_dtor((var) );
 }






 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_METHOD_CALL_SPEC_TMP_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *function_name;
 char *function_name_strval;
 int function_name_strlen;
 zend_free_op free_op1, free_op2;

 ;
 zend_ptr_stack_3_push(&(executor_globals.arg_types_stack), execute_data->fbc, execute_data->object, execute_data->called_scope);

 function_name = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((1<<2) != (1<<0) &&
     __builtin_expect((*function_name).type != 6, 0)) {
  zend_error_noreturn((1<<0L), "Method name must be a string");
 }

 function_name_strval = (*function_name).value.str.val;
 function_name_strlen = (*function_name).value.str.len;

 execute_data->object = _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 );

 if (__builtin_expect(execute_data->object != ((void *)0), 1) &&
     __builtin_expect((*execute_data->object).type == 5, 1)) {
  execute_data->called_scope = zend_get_class_entry(&(*execute_data->object) );

  if ((1<<2) != (1<<0) ||
      (execute_data->fbc = (((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] == (execute_data->called_scope)) ? (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] : ((void *)0))) == ((void *)0)) {
      zval *object = execute_data->object;

   if (__builtin_expect((*execute_data->object).value.obj.handlers->get_method == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Object does not support method calls");
   }


   execute_data->fbc = (*execute_data->object).value.obj.handlers->get_method(&execute_data->object, function_name_strval, function_name_strlen, (((1<<2) == (1<<0)) ? (opline->op2.literal + 1) : ((void *)0)) );
   if (__builtin_expect(execute_data->fbc == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Call to undefined method %s::%s()", ((execute_data->object) && (*execute_data->object).type == 5 && (*execute_data->object).value.obj.handlers->get_class_entry != ((void *)0) && (*execute_data->object).value.obj.handlers->get_class_entry(execute_data->object ) ? (*execute_data->object).value.obj.handlers->get_class_entry(execute_data->object )->name : ""), function_name_strval);
   }
   if ((1<<2) == (1<<0) &&
       __builtin_expect((execute_data->fbc->common.fn_flags & 0x200000) == 0, 1) &&
       __builtin_expect(execute_data->object == object, 1)) {
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (execute_data->called_scope); (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] = (execute_data->fbc); } while (0);
   }
  }
 } else {
  zend_error_noreturn((1<<0L), "Call to a member function %s() on a non-object", function_name_strval);
 }

 if ((execute_data->fbc->common.fn_flags & 0x01) != 0) {
  execute_data->object = ((void *)0);
 } else {
  if (!zval_isref_p(execute_data->object)) {
   zval_addref_p(execute_data->object);
  } else {
   zval *this_ptr;
   do { (this_ptr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(this_ptr))->u.buffered = ((void *)0); } while (0);
   do { do { (this_ptr)->value = (execute_data->object)->value; (*this_ptr).type = (*execute_data->object).type; } while (0); zval_set_refcount_p(this_ptr, 1); zval_unset_isref_p(this_ptr); } while (0);
   _zval_copy_ctor((this_ptr) );
   execute_data->object = this_ptr;
  }
 }

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_CASE_SPEC_TMP_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 if ((1<<1)==(1<<2)) {
  zval_addref_p(((*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr));
 }
 is_equal_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
     _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
     _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *expr_ptr;

 ;
 if (((1<<1) == (1<<2) || (1<<1) == (1<<4)) && opline->extended_value) {
  zval **expr_ptr_ptr = ((void *)0);

  if ((1<<1) == (1<<2) && __builtin_expect(expr_ptr_ptr == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot create references to/from string offsets");
  }
  if (!zval_isref_p(*expr_ptr_ptr)) { do { if (zval_refcount_p(*((expr_ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(expr_ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(expr_ptr_ptr))->value; (*new_zv).type = (**(expr_ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(expr_ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((expr_ptr_ptr))); };
  expr_ptr = *expr_ptr_ptr;
  zval_addref_p(expr_ptr);
 } else {
  expr_ptr=_get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 );
  if (1) {
   zval *new_expr;

   do { (new_expr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_expr))->u.buffered = ((void *)0); } while (0);
   do { do { (new_expr)->value = (expr_ptr)->value; (*new_expr).type = (*expr_ptr).type; } while (0); zval_set_refcount_p(new_expr, 1); zval_unset_isref_p(new_expr); } while (0);
   expr_ptr = new_expr;
  } else if ((1<<1) == (1<<0) || zval_isref_p(expr_ptr)) {
   zval *new_expr;

   do { (new_expr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_expr))->u.buffered = ((void *)0); } while (0);
   do { do { (new_expr)->value = (expr_ptr)->value; (*new_expr).type = (*expr_ptr).type; } while (0); zval_set_refcount_p(new_expr, 1); zval_unset_isref_p(new_expr); } while (0);
   expr_ptr = new_expr;
   _zval_copy_ctor((&(*expr_ptr)) );
  } else {
   zval_addref_p(expr_ptr);
  }
 }

 if ((1<<2) != (1<<3)) {
  zend_free_op free_op2;
  zval *offset = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );
  ulong hval;

  switch ((*offset).type) {
   case 2:
    hval = zend_dval_to_lval((*offset).value.dval);
    goto num_index;
   case 1:
   case 3:
    hval = (*offset).value.lval;
num_index:
    _zend_hash_index_update_or_next_insert(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, hval, &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   case 6:
    if ((1<<2) == (1<<0)) {
     hval = (((zend_literal*)(offset))->hash_value);
    } else {
     do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index; } } } while (0);
     if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
      hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
     } else {
      hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
     }
    }
    _zend_hash_quick_add_or_update(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   case 0:
    _zend_hash_add_or_update(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, "", sizeof(""), &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   default:
    zend_error((1<<1L), "Illegal offset type");
    i_zval_ptr_dtor(*(&expr_ptr) );

    break;
  }
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 } else {
  _zend_hash_index_update_or_next_insert(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, 0, &expr_ptr, sizeof(zval *), ((void *)0), (1<<2) );
 }
 if (((1<<1) == (1<<2) || (1<<1) == (1<<4)) && opline->extended_value) {

 } else {

 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_ARRAY_SPEC_TMP_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 _array_init((&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var), 0 );
 if ((1<<1) == (1<<3)) {
  execute_data->opline++; return 0;

 } else {
  return ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_VAR_HANDLER(execute_data );

 }
}

static int __attribute__((fastcall)) ZEND_UNSET_VAR_SPEC_TMP_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval tmp, *varname;
 HashTable *target_symbol_table;
 zend_free_op free_op1;

 ;
 if ((1<<1) == (1<<4) &&
     (1<<2) == (1<<3) &&
     (opline->extended_value & 0x00800000)) {
  if ((executor_globals.active_symbol_table)) {
   zend_compiled_variable *cv = &((executor_globals.active_op_array)->vars[opline->op1.var]);

   zend_delete_variable(execute_data->prev_execute_data, (executor_globals.active_symbol_table), cv->name, cv->name_len+1, cv->hash_value );
   execute_data->CVs[opline->op1.var] = ((void *)0);
  } else if (execute_data->CVs[opline->op1.var]) {
   i_zval_ptr_dtor(*(execute_data->CVs[opline->op1.var]) );
   execute_data->CVs[opline->op1.var] = ((void *)0);
  }
  ;
  execute_data->opline++; return 0;
 }

 varname = _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<1) != (1<<0) && (*varname).type != 6) {
  do { (&tmp)->value = (varname)->value; (*&tmp).type = (*varname).type; } while (0);
  _zval_copy_ctor((&tmp) );
  if ((&tmp)->type != 6) { _convert_to_string((&tmp) ); };
  varname = &tmp;
 } else if ((1<<1) == (1<<2) || (1<<1) == (1<<4)) {
  zval_addref_p(varname);
 }

 if ((1<<2) != (1<<3)) {
  zend_class_entry *ce;

  if ((1<<2) == (1<<0)) {
   if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
    ce = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
   } else {
    ce = zend_fetch_class_by_name((*opline->op2.zv).value.str.val, (*opline->op2.zv).value.str.len, opline->op2.literal + 1, 0 );
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); } while (0);
   }
  } else {
   ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).class_entry;
  }
  zend_std_unset_static_property(ce, (*varname).value.str.val, (*varname).value.str.len, (((1<<1) == (1<<0)) ? opline->op1.literal : ((void *)0)) );
 } else {
  ulong hash_value = zend_inline_hash_func(varname->value.str.val, varname->value.str.len+1);

  target_symbol_table = zend_get_target_symbol_table(opline->extended_value & 0x70000000 );
  zend_delete_variable(execute_data, target_symbol_table, varname->value.str.val, varname->value.str.len+1, hash_value );
 }

 if ((1<<1) != (1<<0) && varname == &tmp) {
  _zval_dtor((&tmp) );
 } else if ((1<<1) == (1<<2) || (1<<1) == (1<<4)) {
  i_zval_ptr_dtor(*(&varname) );
 }
 _zval_dtor((free_op1.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ISSET_ISEMPTY_VAR_SPEC_TMP_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval **value;
 zend_bool isset = 1;

 ;
 if ((1<<1) == (1<<4) &&
     (1<<2) == (1<<3) &&
     (opline->extended_value & 0x00800000)) {
  if (execute_data->CVs[opline->op1.var]) {
   value = execute_data->CVs[opline->op1.var];
  } else if ((executor_globals.active_symbol_table)) {
   zend_compiled_variable *cv = &((executor_globals.active_op_array)->vars[opline->op1.var]);

   if (zend_hash_quick_find((executor_globals.active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, (void **) &value) == -1) {
    isset = 0;
   }
  } else {
   isset = 0;
  }
 } else {
  HashTable *target_symbol_table;
  zend_free_op free_op1;
  zval tmp, *varname = _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 );

  if ((1<<1) != (1<<0) && (*varname).type != 6) {
   do { (&tmp)->value = (varname)->value; (*&tmp).type = (*varname).type; } while (0);
   _zval_copy_ctor((&tmp) );
   if ((&tmp)->type != 6) { _convert_to_string((&tmp) ); };
   varname = &tmp;
  }

  if ((1<<2) != (1<<3)) {
   zend_class_entry *ce;

   if ((1<<2) == (1<<0)) {
    if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
     ce = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
    } else {
     ce = zend_fetch_class_by_name((*opline->op2.zv).value.str.val, (*opline->op2.zv).value.str.len, opline->op2.literal + 1, 0 );
     do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); } while (0);
    }
   } else {
    ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).class_entry;
   }
   value = zend_std_get_static_property(ce, (*varname).value.str.val, (*varname).value.str.len, 1, (((1<<1) == (1<<0)) ? opline->op1.literal : ((void *)0)) );
   if (!value) {
    isset = 0;
   }
  } else {
   target_symbol_table = zend_get_target_symbol_table(opline->extended_value & 0x70000000 );
   if (zend_hash_find(target_symbol_table, varname->value.str.val, varname->value.str.len+1, (void **) &value) == -1) {
    isset = 0;
   }
  }

  if ((1<<1) != (1<<0) && varname == &tmp) {
   _zval_dtor((&tmp) );
  }
  _zval_dtor((free_op1.var) );
 }

 if (opline->extended_value & 0x02000000) {
  if (isset && (**value).type != 0) {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((1) != 0); (*__z).type = 3; } while (0);
  } else {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((0) != 0); (*__z).type = 3; } while (0);
  }
 } else {
  if (!isset || !i_zend_is_true(*value)) {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((1) != 0); (*__z).type = 3; } while (0);
  } else {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((0) != 0); (*__z).type = 3; } while (0);
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_fetch_var_address_helper_SPEC_TMP_UNUSED(int type, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *varname;
 zval **retval;
 zval tmp_varname;
 HashTable *target_symbol_table;
 ulong hash_value;

 ;
 varname = _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 );

  if ((1<<1) != (1<<0) && __builtin_expect((*varname).type != 6, 0)) {
  do { (&tmp_varname)->value = (varname)->value; (*&tmp_varname).type = (*varname).type; } while (0);
  _zval_copy_ctor((&tmp_varname) );
  if ((&tmp_varname)->type != 6) { _convert_to_string((&tmp_varname) ); };
  varname = &tmp_varname;
 }

 if ((1<<3) != (1<<3)) {
  zend_class_entry *ce;

  if ((1<<3) == (1<<0)) {
   if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
    ce = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
   } else {
    ce = zend_fetch_class_by_name((*opline->op2.zv).value.str.val, (*opline->op2.zv).value.str.len, opline->op2.literal + 1, 0 );
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); } while (0);
   }
  } else {
   ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).class_entry;
  }
  retval = zend_std_get_static_property(ce, (*varname).value.str.val, (*varname).value.str.len, 0, (((1<<1) == (1<<0)) ? opline->op1.literal : ((void *)0)) );
  _zval_dtor((free_op1.var) );
 } else {
  target_symbol_table = zend_get_target_symbol_table(opline->extended_value & 0x70000000 );






  if ((1<<1) == (1<<0)) {
   hash_value = (((zend_literal*)(varname))->hash_value);
  } else if (((((*varname).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*varname).value.str.val) < (compiler_globals.interned_strings_end)))) {
   hash_value = (((Bucket*)(((char*)((*varname).value.str.val))-sizeof(Bucket)))->h);
  } else {
   hash_value = zend_hash_func((*varname).value.str.val, (*varname).value.str.len+1);
  }

  if (zend_hash_quick_find(target_symbol_table, (*varname).value.str.val, (*varname).value.str.len+1, hash_value, (void **) &retval) == -1) {
   switch (type) {
    case 0:
    case 6:
     zend_error((1<<3L),"Undefined variable: %s", (*varname).value.str.val);

    case 3:
     retval = &(executor_globals.uninitialized_zval_ptr);
     break;
    case 2:
     zend_error((1<<3L),"Undefined variable: %s", (*varname).value.str.val);

    case 1:
     zval_addref_p(&(executor_globals.uninitialized_zval));
     _zend_hash_quick_add_or_update(target_symbol_table, (*varname).value.str.val, (*varname).value.str.len+1, hash_value, &(executor_globals.uninitialized_zval_ptr), sizeof(zval *), (void **) &retval, (1<<0) );
     break;
   
   }
  }
  switch (opline->extended_value & 0x70000000) {
   case 0x00000000:
    if ((1<<1) != (1<<1)) {
     _zval_dtor((free_op1.var) );
    }
    break;
   case 0x10000000:
    _zval_dtor((free_op1.var) );
    break;
   case 0x20000000:
    zval_update_constant(retval, (void*) 1 );
    break;
   case 0x40000000:
    if ((1<<1) == (1<<2) && !free_op1.var) {
     zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr));
    }
    break;
  }
 }


 if ((1<<1) != (1<<0) && varname == &tmp_varname) {
  _zval_dtor((&tmp_varname) );
 }
 if (opline->extended_value & 0x04000000) {
  if (!zval_isref_p(*retval)) { do { if (zval_refcount_p(*((retval))) > 1) { zval *new_zv; zval_delref_p(*(retval)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval))->value; (*new_zv).type = (**(retval)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((retval))); };
 }
 zval_addref_p((*retval));
 switch (type) {
  case 0:
  case 3:
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (*retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   break;
  case 6: {
   zend_free_op free_res;

   zend_pzval_unlock_func(*retval, &free_res, 1 );
   if (retval != &(executor_globals.uninitialized_zval_ptr)) {
    if (!zval_isref_p(*retval)) { do { if (zval_refcount_p(*((retval))) > 1) { zval *new_zv; zval_delref_p(*(retval)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval))->value; (*new_zv).type = (**(retval)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
   }
   zval_addref_p((*retval));
   if (free_res.var) { i_zval_ptr_dtor(*(&free_res.var) ); };
  }

  default:
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = retval;
   break;
 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_R_SPEC_TMP_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_TMP_UNUSED(0, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_W_SPEC_TMP_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_TMP_UNUSED(1, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_RW_SPEC_TMP_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_TMP_UNUSED(2, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_FUNC_ARG_SPEC_TMP_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 return zend_fetch_var_address_helper_SPEC_TMP_UNUSED(((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && (opline->extended_value & 0x000fffff) <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[(opline->extended_value & 0x000fffff)-1].pass_by_reference & (1|2)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x1000000|0x2000000))))?1:0, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_UNSET_SPEC_TMP_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_TMP_UNUSED(6, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_IS_SPEC_TMP_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_TMP_UNUSED(3, execute_data );
}

static int __attribute__((fastcall)) ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *expr_ptr;

 ;
 if (((1<<1) == (1<<2) || (1<<1) == (1<<4)) && opline->extended_value) {
  zval **expr_ptr_ptr = ((void *)0);

  if ((1<<1) == (1<<2) && __builtin_expect(expr_ptr_ptr == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot create references to/from string offsets");
  }
  if (!zval_isref_p(*expr_ptr_ptr)) { do { if (zval_refcount_p(*((expr_ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(expr_ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(expr_ptr_ptr))->value; (*new_zv).type = (**(expr_ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(expr_ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((expr_ptr_ptr))); };
  expr_ptr = *expr_ptr_ptr;
  zval_addref_p(expr_ptr);
 } else {
  expr_ptr=_get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 );
  if (1) {
   zval *new_expr;

   do { (new_expr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_expr))->u.buffered = ((void *)0); } while (0);
   do { do { (new_expr)->value = (expr_ptr)->value; (*new_expr).type = (*expr_ptr).type; } while (0); zval_set_refcount_p(new_expr, 1); zval_unset_isref_p(new_expr); } while (0);
   expr_ptr = new_expr;
  } else if ((1<<1) == (1<<0) || zval_isref_p(expr_ptr)) {
   zval *new_expr;

   do { (new_expr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_expr))->u.buffered = ((void *)0); } while (0);
   do { do { (new_expr)->value = (expr_ptr)->value; (*new_expr).type = (*expr_ptr).type; } while (0); zval_set_refcount_p(new_expr, 1); zval_unset_isref_p(new_expr); } while (0);
   expr_ptr = new_expr;
   _zval_copy_ctor((&(*expr_ptr)) );
  } else {
   zval_addref_p(expr_ptr);
  }
 }

 if ((1<<3) != (1<<3)) {

  zval *offset = ((void *)0);
  ulong hval;

  switch ((*offset).type) {
   case 2:
    hval = zend_dval_to_lval((*offset).value.dval);
    goto num_index;
   case 1:
   case 3:
    hval = (*offset).value.lval;
num_index:
    _zend_hash_index_update_or_next_insert(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, hval, &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   case 6:
    if ((1<<3) == (1<<0)) {
     hval = (((zend_literal*)(offset))->hash_value);
    } else {
     do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index; } } } while (0);
     if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
      hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
     } else {
      hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
     }
    }
    _zend_hash_quick_add_or_update(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   case 0:
    _zend_hash_add_or_update(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, "", sizeof(""), &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   default:
    zend_error((1<<1L), "Illegal offset type");
    i_zval_ptr_dtor(*(&expr_ptr) );

    break;
  }

 } else {
  _zend_hash_index_update_or_next_insert(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, 0, &expr_ptr, sizeof(zval *), ((void *)0), (1<<2) );
 }
 if (((1<<1) == (1<<2) || (1<<1) == (1<<4)) && opline->extended_value) {

 } else {

 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_ARRAY_SPEC_TMP_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 _array_init((&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var), 0 );
 if ((1<<1) == (1<<3)) {
  execute_data->opline++; return 0;

 } else {
  return ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_UNUSED_HANDLER(execute_data );

 }
}

static int __attribute__((fastcall)) ZEND_UNSET_VAR_SPEC_TMP_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval tmp, *varname;
 HashTable *target_symbol_table;
 zend_free_op free_op1;

 ;
 if ((1<<1) == (1<<4) &&
     (1<<3) == (1<<3) &&
     (opline->extended_value & 0x00800000)) {
  if ((executor_globals.active_symbol_table)) {
   zend_compiled_variable *cv = &((executor_globals.active_op_array)->vars[opline->op1.var]);

   zend_delete_variable(execute_data->prev_execute_data, (executor_globals.active_symbol_table), cv->name, cv->name_len+1, cv->hash_value );
   execute_data->CVs[opline->op1.var] = ((void *)0);
  } else if (execute_data->CVs[opline->op1.var]) {
   i_zval_ptr_dtor(*(execute_data->CVs[opline->op1.var]) );
   execute_data->CVs[opline->op1.var] = ((void *)0);
  }
  ;
  execute_data->opline++; return 0;
 }

 varname = _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<1) != (1<<0) && (*varname).type != 6) {
  do { (&tmp)->value = (varname)->value; (*&tmp).type = (*varname).type; } while (0);
  _zval_copy_ctor((&tmp) );
  if ((&tmp)->type != 6) { _convert_to_string((&tmp) ); };
  varname = &tmp;
 } else if ((1<<1) == (1<<2) || (1<<1) == (1<<4)) {
  zval_addref_p(varname);
 }

 if ((1<<3) != (1<<3)) {
  zend_class_entry *ce;

  if ((1<<3) == (1<<0)) {
   if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
    ce = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
   } else {
    ce = zend_fetch_class_by_name((*opline->op2.zv).value.str.val, (*opline->op2.zv).value.str.len, opline->op2.literal + 1, 0 );
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); } while (0);
   }
  } else {
   ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).class_entry;
  }
  zend_std_unset_static_property(ce, (*varname).value.str.val, (*varname).value.str.len, (((1<<1) == (1<<0)) ? opline->op1.literal : ((void *)0)) );
 } else {
  ulong hash_value = zend_inline_hash_func(varname->value.str.val, varname->value.str.len+1);

  target_symbol_table = zend_get_target_symbol_table(opline->extended_value & 0x70000000 );
  zend_delete_variable(execute_data, target_symbol_table, varname->value.str.val, varname->value.str.len+1, hash_value );
 }

 if ((1<<1) != (1<<0) && varname == &tmp) {
  _zval_dtor((&tmp) );
 } else if ((1<<1) == (1<<2) || (1<<1) == (1<<4)) {
  i_zval_ptr_dtor(*(&varname) );
 }
 _zval_dtor((free_op1.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ISSET_ISEMPTY_VAR_SPEC_TMP_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval **value;
 zend_bool isset = 1;

 ;
 if ((1<<1) == (1<<4) &&
     (1<<3) == (1<<3) &&
     (opline->extended_value & 0x00800000)) {
  if (execute_data->CVs[opline->op1.var]) {
   value = execute_data->CVs[opline->op1.var];
  } else if ((executor_globals.active_symbol_table)) {
   zend_compiled_variable *cv = &((executor_globals.active_op_array)->vars[opline->op1.var]);

   if (zend_hash_quick_find((executor_globals.active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, (void **) &value) == -1) {
    isset = 0;
   }
  } else {
   isset = 0;
  }
 } else {
  HashTable *target_symbol_table;
  zend_free_op free_op1;
  zval tmp, *varname = _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 );

  if ((1<<1) != (1<<0) && (*varname).type != 6) {
   do { (&tmp)->value = (varname)->value; (*&tmp).type = (*varname).type; } while (0);
   _zval_copy_ctor((&tmp) );
   if ((&tmp)->type != 6) { _convert_to_string((&tmp) ); };
   varname = &tmp;
  }

  if ((1<<3) != (1<<3)) {
   zend_class_entry *ce;

   if ((1<<3) == (1<<0)) {
    if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
     ce = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
    } else {
     ce = zend_fetch_class_by_name((*opline->op2.zv).value.str.val, (*opline->op2.zv).value.str.len, opline->op2.literal + 1, 0 );
     do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); } while (0);
    }
   } else {
    ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).class_entry;
   }
   value = zend_std_get_static_property(ce, (*varname).value.str.val, (*varname).value.str.len, 1, (((1<<1) == (1<<0)) ? opline->op1.literal : ((void *)0)) );
   if (!value) {
    isset = 0;
   }
  } else {
   target_symbol_table = zend_get_target_symbol_table(opline->extended_value & 0x70000000 );
   if (zend_hash_find(target_symbol_table, varname->value.str.val, varname->value.str.len+1, (void **) &value) == -1) {
    isset = 0;
   }
  }

  if ((1<<1) != (1<<0) && varname == &tmp) {
   _zval_dtor((&tmp) );
  }
  _zval_dtor((free_op1.var) );
 }

 if (opline->extended_value & 0x02000000) {
  if (isset && (**value).type != 0) {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((1) != 0); (*__z).type = 3; } while (0);
  } else {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((0) != 0); (*__z).type = 3; } while (0);
  }
 } else {
  if (!isset || !i_zend_is_true(*value)) {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((1) != 0); (*__z).type = 3; } while (0);
  } else {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((0) != 0); (*__z).type = 3; } while (0);
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ADD_SPEC_TMP_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 add_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 _zval_dtor((free_op1.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SUB_SPEC_TMP_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 sub_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 _zval_dtor((free_op1.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_MUL_SPEC_TMP_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 mul_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 _zval_dtor((free_op1.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_DIV_SPEC_TMP_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 div_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 _zval_dtor((free_op1.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_MOD_SPEC_TMP_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 mod_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 _zval_dtor((free_op1.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SL_SPEC_TMP_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 shift_left_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 _zval_dtor((free_op1.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SR_SPEC_TMP_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 shift_right_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 _zval_dtor((free_op1.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_CONCAT_SPEC_TMP_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 concat_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 _zval_dtor((free_op1.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_IDENTICAL_SPEC_TMP_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 is_identical_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 _zval_dtor((free_op1.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_NOT_IDENTICAL_SPEC_TMP_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 is_identical_function(result,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 (*result).value.lval = !(*result).value.lval;
 _zval_dtor((free_op1.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_EQUAL_SPEC_TMP_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval == 0)) != 0); (*__z).type = 3; } while (0);
 _zval_dtor((free_op1.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_NOT_EQUAL_SPEC_TMP_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval != 0)) != 0); (*__z).type = 3; } while (0);
 _zval_dtor((free_op1.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_SMALLER_SPEC_TMP_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval < 0)) != 0); (*__z).type = 3; } while (0);
 _zval_dtor((free_op1.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMP_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval <= 0)) != 0); (*__z).type = 3; } while (0);
 _zval_dtor((free_op1.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_OR_SPEC_TMP_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 bitwise_or_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 _zval_dtor((free_op1.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_AND_SPEC_TMP_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 bitwise_and_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 _zval_dtor((free_op1.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_XOR_SPEC_TMP_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 bitwise_xor_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 _zval_dtor((free_op1.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BOOL_XOR_SPEC_TMP_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 boolean_xor_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 _zval_dtor((free_op1.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ADD_VAR_SPEC_TMP_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *str = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;
 zval *var;
 zval var_copy;
 int use_copy = 0;

 ;
 var = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );

 if ((1<<1) == (1<<3)) {

  (*str).value.str.val = ((void *)0);
  (*str).value.str.len = 0;
  (*str).type = 6;

  (str)->refcount__gc = 1; (str)->is_ref__gc = 0;;
 }

 if ((*var).type != 6) {
  zend_make_printable_zval(var, &var_copy, &use_copy);

  if (use_copy) {
   var = &var_copy;
  }
 }
 add_string_to_string(str, str, var);

 if (use_copy) {
  _zval_dtor((var) );
 }







 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_METHOD_CALL_SPEC_TMP_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *function_name;
 char *function_name_strval;
 int function_name_strlen;
 zend_free_op free_op1;

 ;
 zend_ptr_stack_3_push(&(executor_globals.arg_types_stack), execute_data->fbc, execute_data->object, execute_data->called_scope);

 function_name = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );

 if ((1<<4) != (1<<0) &&
     __builtin_expect((*function_name).type != 6, 0)) {
  zend_error_noreturn((1<<0L), "Method name must be a string");
 }

 function_name_strval = (*function_name).value.str.val;
 function_name_strlen = (*function_name).value.str.len;

 execute_data->object = _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 );

 if (__builtin_expect(execute_data->object != ((void *)0), 1) &&
     __builtin_expect((*execute_data->object).type == 5, 1)) {
  execute_data->called_scope = zend_get_class_entry(&(*execute_data->object) );

  if ((1<<4) != (1<<0) ||
      (execute_data->fbc = (((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] == (execute_data->called_scope)) ? (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] : ((void *)0))) == ((void *)0)) {
      zval *object = execute_data->object;

   if (__builtin_expect((*execute_data->object).value.obj.handlers->get_method == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Object does not support method calls");
   }


   execute_data->fbc = (*execute_data->object).value.obj.handlers->get_method(&execute_data->object, function_name_strval, function_name_strlen, (((1<<4) == (1<<0)) ? (opline->op2.literal + 1) : ((void *)0)) );
   if (__builtin_expect(execute_data->fbc == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Call to undefined method %s::%s()", ((execute_data->object) && (*execute_data->object).type == 5 && (*execute_data->object).value.obj.handlers->get_class_entry != ((void *)0) && (*execute_data->object).value.obj.handlers->get_class_entry(execute_data->object ) ? (*execute_data->object).value.obj.handlers->get_class_entry(execute_data->object )->name : ""), function_name_strval);
   }
   if ((1<<4) == (1<<0) &&
       __builtin_expect((execute_data->fbc->common.fn_flags & 0x200000) == 0, 1) &&
       __builtin_expect(execute_data->object == object, 1)) {
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (execute_data->called_scope); (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] = (execute_data->fbc); } while (0);
   }
  }
 } else {
  zend_error_noreturn((1<<0L), "Call to a member function %s() on a non-object", function_name_strval);
 }

 if ((execute_data->fbc->common.fn_flags & 0x01) != 0) {
  execute_data->object = ((void *)0);
 } else {
  if (!zval_isref_p(execute_data->object)) {
   zval_addref_p(execute_data->object);
  } else {
   zval *this_ptr;
   do { (this_ptr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(this_ptr))->u.buffered = ((void *)0); } while (0);
   do { do { (this_ptr)->value = (execute_data->object)->value; (*this_ptr).type = (*execute_data->object).type; } while (0); zval_set_refcount_p(this_ptr, 1); zval_unset_isref_p(this_ptr); } while (0);
   _zval_copy_ctor((this_ptr) );
   execute_data->object = this_ptr;
  }
 }


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_CASE_SPEC_TMP_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 if ((1<<1)==(1<<2)) {
  zval_addref_p(((*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr));
 }
 is_equal_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
     _get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 ),
     _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *expr_ptr;

 ;
 if (((1<<1) == (1<<2) || (1<<1) == (1<<4)) && opline->extended_value) {
  zval **expr_ptr_ptr = ((void *)0);

  if ((1<<1) == (1<<2) && __builtin_expect(expr_ptr_ptr == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot create references to/from string offsets");
  }
  if (!zval_isref_p(*expr_ptr_ptr)) { do { if (zval_refcount_p(*((expr_ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(expr_ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(expr_ptr_ptr))->value; (*new_zv).type = (**(expr_ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(expr_ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((expr_ptr_ptr))); };
  expr_ptr = *expr_ptr_ptr;
  zval_addref_p(expr_ptr);
 } else {
  expr_ptr=_get_zval_ptr_tmp(opline->op1.var, execute_data->Ts, &free_op1 );
  if (1) {
   zval *new_expr;

   do { (new_expr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_expr))->u.buffered = ((void *)0); } while (0);
   do { do { (new_expr)->value = (expr_ptr)->value; (*new_expr).type = (*expr_ptr).type; } while (0); zval_set_refcount_p(new_expr, 1); zval_unset_isref_p(new_expr); } while (0);
   expr_ptr = new_expr;
  } else if ((1<<1) == (1<<0) || zval_isref_p(expr_ptr)) {
   zval *new_expr;

   do { (new_expr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_expr))->u.buffered = ((void *)0); } while (0);
   do { do { (new_expr)->value = (expr_ptr)->value; (*new_expr).type = (*expr_ptr).type; } while (0); zval_set_refcount_p(new_expr, 1); zval_unset_isref_p(new_expr); } while (0);
   expr_ptr = new_expr;
   _zval_copy_ctor((&(*expr_ptr)) );
  } else {
   zval_addref_p(expr_ptr);
  }
 }

 if ((1<<4) != (1<<3)) {

  zval *offset = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );
  ulong hval;

  switch ((*offset).type) {
   case 2:
    hval = zend_dval_to_lval((*offset).value.dval);
    goto num_index;
   case 1:
   case 3:
    hval = (*offset).value.lval;
num_index:
    _zend_hash_index_update_or_next_insert(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, hval, &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   case 6:
    if ((1<<4) == (1<<0)) {
     hval = (((zend_literal*)(offset))->hash_value);
    } else {
     do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index; } } } while (0);
     if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
      hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
     } else {
      hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
     }
    }
    _zend_hash_quick_add_or_update(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   case 0:
    _zend_hash_add_or_update(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, "", sizeof(""), &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   default:
    zend_error((1<<1L), "Illegal offset type");
    i_zval_ptr_dtor(*(&expr_ptr) );

    break;
  }

 } else {
  _zend_hash_index_update_or_next_insert(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, 0, &expr_ptr, sizeof(zval *), ((void *)0), (1<<2) );
 }
 if (((1<<1) == (1<<2) || (1<<1) == (1<<4)) && opline->extended_value) {

 } else {

 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_ARRAY_SPEC_TMP_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 _array_init((&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var), 0 );
 if ((1<<1) == (1<<3)) {
  execute_data->opline++; return 0;

 } else {
  return ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CV_HANDLER(execute_data );

 }
}

static int __attribute__((fastcall)) ZEND_BW_NOT_SPEC_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 bitwise_not_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BOOL_NOT_SPEC_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 boolean_not_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_PRE_INC_SPEC_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **var_ptr;

 ;
 var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<2) == (1<<2) && __builtin_expect(var_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot increment/decrement overloaded objects nor string offsets");
 }
 if ((1<<2) == (1<<2) && __builtin_expect(*var_ptr == &(executor_globals.error_zval), 0)) {
  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
  ;
  execute_data->opline++; return 0;
 }

 if (!zval_isref_p(*var_ptr)) { do { if (zval_refcount_p(*((var_ptr))) > 1) { zval *new_zv; zval_delref_p(*(var_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(var_ptr))->value; (*new_zv).type = (**(var_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(var_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

 if (__builtin_expect((**var_ptr).type == 5, 0)
    && ((**var_ptr)).value.obj.handlers->get
    && ((**var_ptr)).value.obj.handlers->set) {

  zval *val = ((**var_ptr)).value.obj.handlers->get(*var_ptr );
  zval_addref_p(val);
  increment_function(val);
  ((**var_ptr)).value.obj.handlers->set(var_ptr, val );
  i_zval_ptr_dtor(*(&val) );
 } else {
  increment_function(*var_ptr);
 }

 if ((!((opline)->result_type & (1<<5)))) {
  zval_addref_p((*var_ptr));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (*var_ptr); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
 }

 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_PRE_DEC_SPEC_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **var_ptr;

 ;
 var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<2) == (1<<2) && __builtin_expect(var_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot increment/decrement overloaded objects nor string offsets");
 }
 if ((1<<2) == (1<<2) && __builtin_expect(*var_ptr == &(executor_globals.error_zval), 0)) {
  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
  ;
  execute_data->opline++; return 0;
 }

 if (!zval_isref_p(*var_ptr)) { do { if (zval_refcount_p(*((var_ptr))) > 1) { zval *new_zv; zval_delref_p(*(var_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(var_ptr))->value; (*new_zv).type = (**(var_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(var_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

 if (__builtin_expect((**var_ptr).type == 5, 0)
    && ((**var_ptr)).value.obj.handlers->get
    && ((**var_ptr)).value.obj.handlers->set) {

  zval *val = ((**var_ptr)).value.obj.handlers->get(*var_ptr );
  zval_addref_p(val);
  decrement_function(val);
  ((**var_ptr)).value.obj.handlers->set(var_ptr, val );
  i_zval_ptr_dtor(*(&val) );
 } else {
  decrement_function(*var_ptr);
 }

 if ((!((opline)->result_type & (1<<5)))) {
  zval_addref_p((*var_ptr));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (*var_ptr); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
 }

 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_POST_INC_SPEC_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **var_ptr, *retval;

 ;
 var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<2) == (1<<2) && __builtin_expect(var_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot increment/decrement overloaded objects nor string offsets");
 }
 if ((1<<2) == (1<<2) && __builtin_expect(*var_ptr == &(executor_globals.error_zval), 0)) {
  { (*&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).type = 0; };
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
  ;
  execute_data->opline++; return 0;
 }

 retval = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;
 do { (retval)->value = (*var_ptr)->value; (*retval).type = (**var_ptr).type; } while (0);
 _zval_copy_ctor((&(*retval)) );

 if (!zval_isref_p(*var_ptr)) { do { if (zval_refcount_p(*((var_ptr))) > 1) { zval *new_zv; zval_delref_p(*(var_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(var_ptr))->value; (*new_zv).type = (**(var_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(var_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

 if (__builtin_expect((**var_ptr).type == 5, 0)
    && ((**var_ptr)).value.obj.handlers->get
    && ((**var_ptr)).value.obj.handlers->set) {

  zval *val = ((**var_ptr)).value.obj.handlers->get(*var_ptr );
  zval_addref_p(val);
  increment_function(val);
  ((**var_ptr)).value.obj.handlers->set(var_ptr, val );
  i_zval_ptr_dtor(*(&val) );
 } else {
  increment_function(*var_ptr);
 }

 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_POST_DEC_SPEC_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **var_ptr, *retval;

 ;
 var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<2) == (1<<2) && __builtin_expect(var_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot increment/decrement overloaded objects nor string offsets");
 }
 if ((1<<2) == (1<<2) && __builtin_expect(*var_ptr == &(executor_globals.error_zval), 0)) {
  { (*&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).type = 0; };
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
  ;
  execute_data->opline++; return 0;
 }

 retval = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;
 do { (retval)->value = (*var_ptr)->value; (*retval).type = (**var_ptr).type; } while (0);
 _zval_copy_ctor((&(*retval)) );

 if (!zval_isref_p(*var_ptr)) { do { if (zval_refcount_p(*((var_ptr))) > 1) { zval *new_zv; zval_delref_p(*(var_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(var_ptr))->value; (*new_zv).type = (**(var_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(var_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

 if (__builtin_expect((**var_ptr).type == 5, 0)
    && ((**var_ptr)).value.obj.handlers->get
    && ((**var_ptr)).value.obj.handlers->set) {

  zval *val = ((**var_ptr)).value.obj.handlers->get(*var_ptr );
  zval_addref_p(val);
  decrement_function(val);
  ((**var_ptr)).value.obj.handlers->set(var_ptr, val );
  i_zval_ptr_dtor(*(&val) );
 } else {
  decrement_function(*var_ptr);
 }

 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ECHO_SPEC_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval z_copy;
 zval *z;

 ;
 z = _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<2) != (1<<0) &&
     __builtin_expect((*z).type == 5, 0) &&
     (*z).value.obj.handlers->get_method != ((void *)0) &&
  zend_std_cast_object_tostring(z, &z_copy, 6 ) == 0) {
  zend_print_variable(&z_copy);
  _zval_dtor((&z_copy) );
 } else {
  zend_print_variable(z);
 }

 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_PRINT_SPEC_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = 1; (*__z).type = 1; };
 return ZEND_ECHO_SPEC_VAR_HANDLER(execute_data );
}

static int __attribute__((fastcall)) ZEND_JMPZ_SPEC_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *val;
 int ret;

 ;
 val = _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<2) == (1<<1) && __builtin_expect((*val).type == 3, 1)) {
  ret = (*val).value.lval;
 } else {
  ret = i_zend_is_true(val);
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
  if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
   ; return 0;
  }
 }
 if (!ret) {



  execute_data->opline = opline->op2.jmp_addr;
  return 0;
 }

 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_JMPNZ_SPEC_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *val;
 int ret;

 ;
 val = _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<2) == (1<<1) && __builtin_expect((*val).type == 3, 1)) {
  ret = (*val).value.lval;
 } else {
  ret = i_zend_is_true(val);
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
  if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
   ; return 0;
  }
 }
 if (ret) {



  execute_data->opline = opline->op2.jmp_addr;
  return 0;
 }

 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_JMPZNZ_SPEC_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *val;
 int retval;

 ;
 val = _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<2) == (1<<1) && __builtin_expect((*val).type == 3, 1)) {
  retval = (*val).value.lval;
 } else {
  retval = i_zend_is_true(val);
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
  if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
   ; return 0;
  }
 }
 if (__builtin_expect(retval != 0, 1)) {



  execute_data->opline = &execute_data->op_array->opcodes[opline->extended_value];
  return 0;
 } else {



  execute_data->opline = &execute_data->op_array->opcodes[opline->op2.opline_num];
  return 0;
 }
}

static int __attribute__((fastcall)) ZEND_JMPZ_EX_SPEC_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *val;
 int retval;

 ;
 val = _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<2) == (1<<1) && __builtin_expect((*val).type == 3, 1)) {
  retval = (*val).value.lval;
 } else {
  retval = i_zend_is_true(val);
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
  if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
   ; return 0;
  }
 }
 ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.lval = retval;
 ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).type = 3;
 if (!retval) {



  execute_data->opline = opline->op2.jmp_addr;
  return 0;
 }
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_JMPNZ_EX_SPEC_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *val;
 int retval;

 ;
 val = _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<2) == (1<<1) && __builtin_expect((*val).type == 3, 1)) {
  retval = (*val).value.lval;
 } else {
  retval = i_zend_is_true(val);
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
  if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
   ; return 0;
  }
 }
 ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.lval = retval;
 ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).type = 3;
 if (retval) {



  execute_data->opline = opline->op2.jmp_addr;
  return 0;
 }
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FREE_SPEC_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 ;
 if ((1<<2) == (1<<1)) {
  _zval_dtor((&((*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).tmp_var)) );
 } else {
  i_zval_ptr_dtor(*(&(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr) );
 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_RETURN_SPEC_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *retval_ptr;
 zend_free_op free_op1;

 ;
 retval_ptr = _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if (!(executor_globals.return_value_ptr_ptr)) {
  if ((1<<2) == (1<<1)) {
   if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
  }
 } else if (!0) {
  if ((1<<2) == (1<<0) ||
      (zval_isref_p(retval_ptr) && zval_refcount_p(retval_ptr) > 0)) {
   zval *ret;

   do { (ret) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(ret))->u.buffered = ((void *)0); } while (0);
   do { do { (ret)->value = (retval_ptr)->value; (*ret).type = (*retval_ptr).type; } while (0); zval_set_refcount_p(ret, 1); zval_unset_isref_p(ret); } while (0);
   _zval_copy_ctor((ret) );
   *(executor_globals.return_value_ptr_ptr) = ret;
  } else if (((1<<2) == (1<<4) || (1<<2) == (1<<2)) &&
             retval_ptr == &(executor_globals.uninitialized_zval)) {
   zval *ret;

   do { (ret) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(ret))->u.buffered = ((void *)0); } while (0); *ret = zval_used_for_init;;;
   *(executor_globals.return_value_ptr_ptr) = ret;
  } else {
   *(executor_globals.return_value_ptr_ptr) = retval_ptr;
   zval_addref_p(retval_ptr);
  }
 } else {
  zval *ret;

  do { (ret) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(ret))->u.buffered = ((void *)0); } while (0);
  do { do { (ret)->value = (retval_ptr)->value; (*ret).type = (*retval_ptr).type; } while (0); zval_set_refcount_p(ret, 1); zval_unset_isref_p(ret); } while (0);
  *(executor_globals.return_value_ptr_ptr) = ret;
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 return zend_leave_helper_SPEC(execute_data );
}

static int __attribute__((fastcall)) ZEND_RETURN_BY_REF_SPEC_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *retval_ptr;
 zval **retval_ptr_ptr;
 zend_free_op free_op1;

 ;

 do {
  if ((1<<2) == (1<<0) || (1<<2) == (1<<1)) {

   zend_error((1<<3L), "Only variable references should be returned by reference");

   retval_ptr = _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
   if (!(executor_globals.return_value_ptr_ptr)) {
    if ((1<<2) == (1<<1)) {
     if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
    }
   } else if (!0) {
    zval *ret;

    do { (ret) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(ret))->u.buffered = ((void *)0); } while (0);
    do { do { (ret)->value = (retval_ptr)->value; (*ret).type = (*retval_ptr).type; } while (0); zval_set_refcount_p(ret, 1); zval_unset_isref_p(ret); } while (0);
    _zval_copy_ctor((ret) );
    *(executor_globals.return_value_ptr_ptr) = ret;
   } else {
    zval *ret;

    do { (ret) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(ret))->u.buffered = ((void *)0); } while (0);
    do { do { (ret)->value = (retval_ptr)->value; (*ret).type = (*retval_ptr).type; } while (0); zval_set_refcount_p(ret, 1); zval_unset_isref_p(ret); } while (0);
    *(executor_globals.return_value_ptr_ptr) = ret;
   }
   break;
  }

  retval_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

  if ((1<<2) == (1<<2) && __builtin_expect(retval_ptr_ptr == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot return string offsets by reference");
  }

  if ((1<<2) == (1<<2) && !zval_isref_p(*(retval_ptr_ptr))) {
   if (opline->extended_value == 1<<0 &&
       (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.fcall_returned_reference) {
   } else if ((*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr == &(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr) {
    zend_error((1<<3L), "Only variable references should be returned by reference");
    if ((executor_globals.return_value_ptr_ptr)) {
     retval_ptr = *retval_ptr_ptr;
     *(executor_globals.return_value_ptr_ptr) = retval_ptr;
     zval_addref_p(retval_ptr);
    }
    break;
   }
  }

  if ((executor_globals.return_value_ptr_ptr)) {
   if (!zval_isref_p(*retval_ptr_ptr)) { do { if (zval_refcount_p(*((retval_ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(retval_ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval_ptr_ptr))->value; (*new_zv).type = (**(retval_ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval_ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((retval_ptr_ptr))); };
   zval_addref_p(*(retval_ptr_ptr));

   *(executor_globals.return_value_ptr_ptr) = *retval_ptr_ptr;
  }
 } while (0);

 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 return zend_leave_helper_SPEC(execute_data );
}

static int __attribute__((fastcall)) ZEND_THROW_SPEC_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *value;
 zval *exception;
 zend_free_op free_op1;

 ;
 value = _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<2) == (1<<0) || __builtin_expect((*value).type != 5, 0)) {
  zend_error_noreturn((1<<0L), "Can only throw objects");
 }
 zend_exception_save();

 do { (exception) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(exception))->u.buffered = ((void *)0); } while (0);
 do { do { (exception)->value = (value)->value; (*exception).type = (*value).type; } while (0); zval_set_refcount_p(exception, 1); zval_unset_isref_p(exception); } while (0);
 if (!0) {
  _zval_copy_ctor((exception) );
 }

 zend_throw_exception_object(exception );
 zend_exception_restore();
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ; return 0;
}

static int __attribute__((fastcall)) zend_send_by_var_helper_SPEC_VAR(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *varptr;
 zend_free_op free_op1;
 varptr = _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if (varptr == &(executor_globals.uninitialized_zval)) {
  do { (varptr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(varptr))->u.buffered = ((void *)0); } while (0);
  *varptr = zval_used_for_init;;
  zval_set_refcount_p(varptr, 0);
 } else if (zval_isref_p(varptr)) {
  zval *original_var = varptr;

  do { (varptr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(varptr))->u.buffered = ((void *)0); } while (0);
  do { (varptr)->value = (original_var)->value; (*varptr).type = (*original_var).type; } while (0);
  zval_unset_isref_p(varptr);
  zval_set_refcount_p(varptr, 0);
  _zval_copy_ctor((varptr) );
 }
 zval_addref_p(varptr);
 zend_vm_stack_push(varptr );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SEND_VAR_NO_REF_SPEC_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *varptr;

 ;
 if (opline->extended_value & (1<<1)) {
  if (!(opline->extended_value & (1<<0))) {
   return zend_send_by_var_helper_SPEC_VAR(execute_data );
  }
 } else if (!((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && opline->op2.opline_num <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[opline->op2.opline_num-1].pass_by_reference & (1|2)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x1000000|0x2000000))))) {
  return zend_send_by_var_helper_SPEC_VAR(execute_data );
 }

 if ((1<<2) == (1<<2) &&
  (opline->extended_value & (1<<2)) &&
  (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.fcall_returned_reference &&
  (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr) {
  varptr = (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr;
  zend_pzval_unlock_func(varptr, &free_op1, 0 );
 } else {
  varptr = _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 }
 if ((!(opline->extended_value & (1<<2)) ||
      (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.fcall_returned_reference) &&
     varptr != &(executor_globals.uninitialized_zval) &&
     (zval_isref_p(varptr) ||
      (zval_refcount_p(varptr) == 1 && ((1<<2) == (1<<4) || free_op1.var)))) {
  zval_set_isref_p(varptr);
  zval_addref_p(varptr);
  zend_vm_stack_push(varptr );
 } else {
  zval *valptr;

  if ((opline->extended_value & (1<<1)) ?
   !(opline->extended_value & (1<<3)) :
   !((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && opline->op2.opline_num <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[opline->op2.opline_num-1].pass_by_reference & (2)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x2000000))))) {
   zend_error((1<<11L), "Only variables should be passed by reference");
  }
  do { (valptr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(valptr))->u.buffered = ((void *)0); } while (0);
  do { do { (valptr)->value = (varptr)->value; (*valptr).type = (*varptr).type; } while (0); zval_set_refcount_p(valptr, 1); zval_unset_isref_p(valptr); } while (0);
  if (!0) {
   _zval_copy_ctor((valptr) );
  }
  zend_vm_stack_push(valptr );
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SEND_REF_SPEC_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **varptr_ptr;
 zval *varptr;

 ;
 varptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<2) == (1<<2) && __builtin_expect(varptr_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Only variables can be passed by reference");
 }

 if ((1<<2) == (1<<2) && __builtin_expect(*varptr_ptr == &(executor_globals.error_zval), 0)) {
  zval_delref_p(*(varptr_ptr));
  do { (*varptr_ptr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(*varptr_ptr))->u.buffered = ((void *)0); } while (0);
  **varptr_ptr = zval_used_for_init;;
  zval_set_refcount_p(*(varptr_ptr), 0);
 }

 if (execute_data->function_state.function->type == 1 && !((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && opline->op2.opline_num <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[opline->op2.opline_num-1].pass_by_reference & (1|2)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x1000000|0x2000000))))) {
  return zend_send_by_var_helper_SPEC_VAR(execute_data );
 }

 if (!zval_isref_p(*varptr_ptr)) { do { if (zval_refcount_p(*((varptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(varptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(varptr_ptr))->value; (*new_zv).type = (**(varptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(varptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((varptr_ptr))); };
 varptr = *varptr_ptr;
 zval_addref_p(varptr);
 zend_vm_stack_push(varptr );

 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SEND_VAR_SPEC_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 if ((opline->extended_value == 61)
  && ((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && opline->op2.opline_num <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[opline->op2.opline_num-1].pass_by_reference & (1|2)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x1000000|0x2000000))))) {
  return ZEND_SEND_REF_SPEC_VAR_HANDLER(execute_data );
 }
 ;
 return zend_send_by_var_helper_SPEC_VAR(execute_data );
}

static int __attribute__((fastcall)) ZEND_BOOL_SPEC_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *retval = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;

 do { zval *__z = (retval); (*__z).value.lval = ((i_zend_is_true(_get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ))) != 0); (*__z).type = 3; } while (0);
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SWITCH_FREE_SPEC_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 ;
 i_zval_ptr_dtor(*(&(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_CLONE_SPEC_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *obj;
 zend_class_entry *ce;
 zend_function *clone;
 zend_object_clone_obj_t clone_call;

 ;
 obj = _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<2) == (1<<0) ||
     __builtin_expect((*obj).type != 5, 0)) {
  zend_error_noreturn((1<<0L), "__clone method called on non-object");
 }

 ce = zend_get_class_entry(&(*obj) );
 clone = ce ? ce->clone : ((void *)0);
 clone_call = (*obj).value.obj.handlers->clone_obj;
 if (__builtin_expect(clone_call == ((void *)0), 0)) {
  if (ce) {
   zend_error_noreturn((1<<0L), "Trying to clone an uncloneable object of class %s", ce->name);
  } else {
   zend_error_noreturn((1<<0L), "Trying to clone an uncloneable object");
  }
 }

 if (ce && clone) {
  if (clone->op_array.fn_flags & 0x400) {


   if (__builtin_expect(ce != (executor_globals.scope), 0)) {
    zend_error_noreturn((1<<0L), "Call to private %s::__clone() from context '%s'", ce->name, (executor_globals.scope) ? (executor_globals.scope)->name : "");
   }
  } else if ((clone->common.fn_flags & 0x200)) {


   if (__builtin_expect(!zend_check_protected(clone->common.scope, (executor_globals.scope)), 0)) {
    zend_error_noreturn((1<<0L), "Call to protected %s::__clone() from context '%s'", ce->name, (executor_globals.scope) ? (executor_globals.scope)->name : "");
   }
  }
 }

 if (__builtin_expect((executor_globals.exception) == ((void *)0), 1)) {
  zval *retval;

  do { (retval) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(retval))->u.buffered = ((void *)0); } while (0);
  (*retval).value.obj = clone_call(obj );
  (*retval).type = 5;
  zval_set_refcount_p(retval, 1);
  zval_set_isref_p(retval);
  if (!(!((opline)->result_type & (1<<5))) || __builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
   i_zval_ptr_dtor(*(&retval) );
  } else {
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_CAST_SPEC_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *expr;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 expr = _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if (opline->extended_value != 6) {
  do { (result)->value = (expr)->value; (*result).type = (*expr).type; } while (0);
  if (!0) {
   _zval_copy_ctor((&(*result)) );
  }
 }
 switch (opline->extended_value) {
  case 0:
   convert_to_null(result);
   break;
  case 3:
   convert_to_boolean(result);
   break;
  case 1:
   convert_to_long(result);
   break;
  case 2:
   convert_to_double(result);
   break;
  case 6: {
   zval var_copy;
   int use_copy;

   zend_make_printable_zval(expr, &var_copy, &use_copy);
   if (use_copy) {
    do { (result)->value = (&var_copy)->value; (*result).type = (*&var_copy).type; } while (0);
    if (0) {
     if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
    }
   } else {
    do { (result)->value = (expr)->value; (*result).type = (*expr).type; } while (0);
    if (!0) {
     _zval_copy_ctor((&(*result)) );
    }
   }
   break;
  }
  case 4:
   convert_to_array(result);
   break;
  case 5:
   convert_to_object(result);
   break;
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INCLUDE_OR_EVAL_SPEC_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_op_array *new_op_array=((void *)0);
 zend_free_op free_op1;
 zval *inc_filename;
 zval tmp_inc_filename;
 zend_bool failure_retval=0;

 ;
 inc_filename = _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if (inc_filename->type!=6) {
  do { (&tmp_inc_filename)->value = (inc_filename)->value; (*&tmp_inc_filename).type = (*inc_filename).type; } while (0);
  _zval_copy_ctor((&tmp_inc_filename) );
  if ((&tmp_inc_filename)->type != 6) { _convert_to_string((&tmp_inc_filename) ); };
  inc_filename = &tmp_inc_filename;
 }

 switch (opline->extended_value) {
  case (1<<2):
  case (1<<4): {
    zend_file_handle file_handle;
    char *resolved_path;

    resolved_path = zend_resolve_path((*inc_filename).value.str.val, (*inc_filename).value.str.len );
    if (resolved_path) {
     failure_retval = zend_hash_exists(&(executor_globals.included_files), resolved_path, strlen(resolved_path)+1);
    } else {
     resolved_path = (*inc_filename).value.str.val;
    }

    if (failure_retval) {

    } else if (0 == zend_stream_open(resolved_path, &file_handle )) {

     if (!file_handle.opened_path) {
      file_handle.opened_path = _estrdup((resolved_path) );
     }

     if (zend_hash_add_empty_element(&(executor_globals.included_files), file_handle.opened_path, strlen(file_handle.opened_path)+1)==0) {
      new_op_array = zend_compile_file(&file_handle, (opline->extended_value==(1<<2)?(1<<1):(1<<3)) );
      zend_destroy_file_handle(&file_handle );
     } else {
      zend_file_handle_dtor(&file_handle );
      failure_retval=1;
     }
    } else {
     if (opline->extended_value == (1<<2)) {
      zend_message_dispatcher(1L, (*inc_filename).value.str.val );
     } else {
      zend_message_dispatcher(2L, (*inc_filename).value.str.val );
     }
    }
    if (resolved_path != (*inc_filename).value.str.val) {
     _efree((resolved_path) );
    }
   }
   break;
  case (1<<1):
  case (1<<3):
   new_op_array = compile_filename(opline->extended_value, inc_filename );
   break;
  case (1<<0): {
    char *eval_desc = zend_make_compiled_string_description("eval()'d code" );

    new_op_array = zend_compile_string(inc_filename, eval_desc );
    _efree((eval_desc) );
   }
   break;
 
 }
 if (inc_filename==&tmp_inc_filename) {
  _zval_dtor((&tmp_inc_filename) );
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
  ; return 0;
 } else if (__builtin_expect(new_op_array != ((void *)0), 1)) {
  execute_data->original_return_value = (executor_globals.return_value_ptr_ptr);
  (executor_globals.active_op_array) = new_op_array;
  if ((!((opline)->result_type & (1<<5)))) {
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = ((void *)0);
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr;
   (executor_globals.return_value_ptr_ptr) = (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr;
  } else {
   (executor_globals.return_value_ptr_ptr) = ((void *)0);
  }

  execute_data->current_object = execute_data->object;

  execute_data->function_state.function = (zend_function *) new_op_array;
  execute_data->object = ((void *)0);

  if (!(executor_globals.active_symbol_table)) {
   zend_rebuild_symbol_table();
  }

  if (__builtin_expect(zend_execute == execute, 1)) {
   return 2;
  } else {
   zend_execute(new_op_array );
  }

  execute_data->function_state.function = (zend_function *) execute_data->op_array;
  execute_data->object = execute_data->current_object;

  (executor_globals.opline_ptr) = &execute_data->opline;
  (executor_globals.active_op_array) = execute_data->op_array;
  (executor_globals.return_value_ptr_ptr) = execute_data->original_return_value;
  destroy_op_array(new_op_array );
  _efree((new_op_array) );
  if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
   zend_throw_exception_internal(((void *)0) );
   ; return 0;
  } else if ((!((opline)->result_type & (1<<5)))) {
   if (!(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr) {
    zval *retval;

    do { (retval) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(retval))->u.buffered = ((void *)0); } while (0);
    do { zval *__z = (retval); (*__z).value.lval = ((1) != 0); (*__z).type = 3; } while (0);
    (retval)->refcount__gc = 1; (retval)->is_ref__gc = 0;;
    (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = retval;
   }
  }

 } else if ((!((opline)->result_type & (1<<5)))) {
  zval *retval;

  do { (retval) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(retval))->u.buffered = ((void *)0); } while (0);
  do { zval *__z = (retval); (*__z).value.lval = ((failure_retval) != 0); (*__z).type = 3; } while (0);
  (retval)->refcount__gc = 1; (retval)->is_ref__gc = 0;;
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
 }
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FE_RESET_SPEC_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *array_ptr, **array_ptr_ptr;
 HashTable *fe_ht;
 zend_object_iterator *iter = ((void *)0);
 zend_class_entry *ce = ((void *)0);
 zend_bool is_empty = 0;

 ;

 if (((1<<2) == (1<<4) || (1<<2) == (1<<2)) &&
     (opline->extended_value & (1<<0))) {
  array_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
  if (array_ptr_ptr == ((void *)0) || array_ptr_ptr == &(executor_globals.uninitialized_zval_ptr)) {
   do { (array_ptr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(array_ptr))->u.buffered = ((void *)0); } while (0); (array_ptr)->refcount__gc = 1; (array_ptr)->is_ref__gc = 0;;;
   { (*array_ptr).type = 0; };
  } else if ((**array_ptr_ptr).type == 5) {
   if((**array_ptr_ptr).value.obj.handlers->get_class_entry == ((void *)0)) {
    zend_error((1<<1L), "foreach() cannot iterate over objects without PHP class");
    if (__builtin_expect(!(executor_globals.exception), 1)) { execute_data->opline = execute_data->op_array->opcodes+opline->op2.opline_num; } else { ; } return 0;
   }

   ce = zend_get_class_entry(&(**array_ptr_ptr) );
   if (!ce || ce->get_iterator == ((void *)0)) {
    if (!zval_isref_p(*array_ptr_ptr)) { do { if (zval_refcount_p(*((array_ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(array_ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(array_ptr_ptr))->value; (*new_zv).type = (**(array_ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(array_ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
    zval_addref_p(*(array_ptr_ptr));
   }
   array_ptr = *array_ptr_ptr;
  } else {
   if ((**array_ptr_ptr).type == 4) {
    if (!zval_isref_p(*array_ptr_ptr)) { do { if (zval_refcount_p(*((array_ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(array_ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(array_ptr_ptr))->value; (*new_zv).type = (**(array_ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(array_ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
    if (opline->extended_value & 1) {
     zval_set_isref_p(*(array_ptr_ptr));
    }
   }
   array_ptr = *array_ptr_ptr;
   zval_addref_p(array_ptr);
  }
 } else {
  array_ptr = _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
  if (0) {
   zval *tmp;

   do { (tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(tmp))->u.buffered = ((void *)0); } while (0);
   do { do { (tmp)->value = (array_ptr)->value; (*tmp).type = (*array_ptr).type; } while (0); zval_set_refcount_p(tmp, 1); zval_unset_isref_p(tmp); } while (0);
   array_ptr = tmp;
   if ((*array_ptr).type == 5) {
    ce = zend_get_class_entry(&(*array_ptr) );
    if (ce && ce->get_iterator) {
     zval_delref_p(array_ptr);
    }
   }
  } else if ((*array_ptr).type == 5) {
   ce = zend_get_class_entry(&(*array_ptr) );
   if (!ce || !ce->get_iterator) {
    zval_addref_p(array_ptr);
   }
  } else if ((1<<2) == (1<<0) ||
             (((1<<2) == (1<<4) || (1<<2) == (1<<2)) &&
              !zval_isref_p(array_ptr) &&
              zval_refcount_p(array_ptr) > 1)) {
   zval *tmp;

   do { (tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(tmp))->u.buffered = ((void *)0); } while (0);
   do { do { (tmp)->value = (array_ptr)->value; (*tmp).type = (*array_ptr).type; } while (0); zval_set_refcount_p(tmp, 1); zval_unset_isref_p(tmp); } while (0);
   _zval_copy_ctor((tmp) );
   array_ptr = tmp;
  } else {
   zval_addref_p(array_ptr);
  }
 }

 if (ce && ce->get_iterator) {
  iter = ce->get_iterator(ce, array_ptr, opline->extended_value & (1<<1) );

  if (iter && __builtin_expect((executor_globals.exception) == ((void *)0), 1)) {
   array_ptr = zend_iterator_wrap(iter );
  } else {
   if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
   if (!(executor_globals.exception)) {
    zend_throw_exception_ex(((void *)0), 0 , "Object of type %s did not create an Iterator", ce->name);
   }
   zend_throw_exception_internal(((void *)0) );
   ; return 0;
  }
 }

 (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).fe.ptr = array_ptr;

 if (iter) {
  iter->index = 0;
  if (iter->funcs->rewind) {
   iter->funcs->rewind(iter );
   if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
    i_zval_ptr_dtor(*(&array_ptr) );
    if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
    ; return 0;
   }
  }
  is_empty = iter->funcs->valid(iter ) != 0;
  if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
   i_zval_ptr_dtor(*(&array_ptr) );
   if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
   ; return 0;
  }
  iter->index = -1;
 } else if ((fe_ht = ((*array_ptr).type==4 ? (*array_ptr).value.ht : (((*array_ptr).type==5 ? (*array_ptr).value.obj.handlers->get_properties((array_ptr) ) : ((void *)0))))) != ((void *)0)) {
  zend_hash_internal_pointer_reset_ex(fe_ht, ((void *)0));
  if (ce) {
   zend_object *zobj = zend_objects_get_address(array_ptr );
   while ((zend_hash_get_current_key_type_ex(fe_ht, ((void *)0)) == 3 ? -1 : 0) == 0) {
    char *str_key;
    uint str_key_len;
    ulong int_key;
    zend_uchar key_type;

    key_type = zend_hash_get_current_key_ex(fe_ht, &str_key, &str_key_len, &int_key, 0, ((void *)0));
    if (key_type != 3 &&
     (key_type == 2 ||
         zend_check_property_access(zobj, str_key, str_key_len-1 ) == 0)) {
     break;
    }
    zend_hash_move_forward_ex(fe_ht, ((void *)0));
   }
  }
  is_empty = (zend_hash_get_current_key_type_ex(fe_ht, ((void *)0)) == 3 ? -1 : 0) != 0;
  zend_hash_get_pointer(fe_ht, &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).fe.fe_pos);
 } else {
  zend_error((1<<1L), "Invalid argument supplied for foreach()");
  is_empty = 1;
 }

 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 if (is_empty) {
  if (__builtin_expect(!(executor_globals.exception), 1)) { execute_data->opline = execute_data->op_array->opcodes+opline->op2.opline_num; } else { ; } return 0;
 } else {
  ;
  execute_data->opline++; return 0;
 }
}

static int __attribute__((fastcall)) ZEND_FE_FETCH_SPEC_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *array = (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).fe.ptr;
 zval **value;
 char *str_key;
 uint str_key_len;
 ulong int_key;
 HashTable *fe_ht;
 zend_object_iterator *iter = ((void *)0);
 int key_type = 0;
 zend_bool use_key = (zend_bool)(opline->extended_value & 2);

 ;

 switch (zend_iterator_unwrap(array, &iter )) {
  default:
  case ZEND_ITER_INVALID:
   zend_error((1<<1L), "Invalid argument supplied for foreach()");
   if (__builtin_expect(!(executor_globals.exception), 1)) { execute_data->opline = execute_data->op_array->opcodes+opline->op2.opline_num; } else { ; } return 0;

  case ZEND_ITER_PLAIN_OBJECT: {
   char *class_name, *prop_name;
   zend_object *zobj = zend_objects_get_address(array );

   fe_ht = ((*array)).value.obj.handlers->get_properties(&(*array) );
   zend_hash_set_pointer(fe_ht, &(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).fe.fe_pos);
   do {
    if (zend_hash_get_current_data_ex(fe_ht, (void **) &value, ((void *)0))==-1) {

     if (__builtin_expect(!(executor_globals.exception), 1)) { execute_data->opline = execute_data->op_array->opcodes+opline->op2.opline_num; } else { ; } return 0;
    }
    key_type = zend_hash_get_current_key_ex(fe_ht, &str_key, &str_key_len, &int_key, 0, ((void *)0));

    zend_hash_move_forward_ex(fe_ht, ((void *)0));
   } while (key_type == 3 ||
            (key_type != 2 &&
             zend_check_property_access(zobj, str_key, str_key_len-1 ) != 0));
   zend_hash_get_pointer(fe_ht, &(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).fe.fe_pos);
   if (use_key && key_type != 2) {
    zend_unmangle_property_name(str_key, str_key_len-1, &class_name, &prop_name);
    str_key_len = strlen(prop_name);
    str_key = _estrndup((prop_name), (str_key_len) );
    str_key_len++;
   }
   break;
  }

  case ZEND_ITER_PLAIN_ARRAY:
   fe_ht = (*array).value.ht;
   zend_hash_set_pointer(fe_ht, &(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).fe.fe_pos);
   if (zend_hash_get_current_data_ex(fe_ht, (void **) &value, ((void *)0))==-1) {

    if (__builtin_expect(!(executor_globals.exception), 1)) { execute_data->opline = execute_data->op_array->opcodes+opline->op2.opline_num; } else { ; } return 0;
   }
   if (use_key) {
    key_type = zend_hash_get_current_key_ex(fe_ht, &str_key, &str_key_len, &int_key, 1, ((void *)0));
   }
   zend_hash_move_forward_ex(fe_ht, ((void *)0));
   zend_hash_get_pointer(fe_ht, &(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).fe.fe_pos);
   break;

  case ZEND_ITER_OBJECT:

   if (iter && ++iter->index > 0) {


    iter->funcs->move_forward(iter );
    if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
     i_zval_ptr_dtor(*(&array) );
     ; return 0;
    }
   }

   if (!iter || (iter->index > 0 && iter->funcs->valid(iter ) == -1)) {

    if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
     i_zval_ptr_dtor(*(&array) );
     ; return 0;
    }
    if (__builtin_expect(!(executor_globals.exception), 1)) { execute_data->opline = execute_data->op_array->opcodes+opline->op2.opline_num; } else { ; } return 0;
   }
   iter->funcs->get_current_data(iter, &value );
   if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
    i_zval_ptr_dtor(*(&array) );
    ; return 0;
   }
   if (!value) {

    if (__builtin_expect(!(executor_globals.exception), 1)) { execute_data->opline = execute_data->op_array->opcodes+opline->op2.opline_num; } else { ; } return 0;
   }
   if (use_key) {
    if (iter->funcs->get_current_key) {
     key_type = iter->funcs->get_current_key(iter, &str_key, &str_key_len, &int_key );
     if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
      i_zval_ptr_dtor(*(&array) );
      ; return 0;
     }
    } else {
     key_type = 2;
     int_key = iter->index;
    }
   }
   break;
 }

 if (opline->extended_value & 1) {
  if (!zval_isref_p(*value)) { do { if (zval_refcount_p(*((value))) > 1) { zval *new_zv; zval_delref_p(*(value)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(value))->value; (*new_zv).type = (**(value)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(value) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  zval_set_isref_p(*(value));
  (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = value;
  zval_addref_p(*(value));
 } else {
  zval_addref_p((*value));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (*value); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
 }

 if (use_key) {
  zval *key = &(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->result.var)).tmp_var;

  switch (key_type) {
   case 1:
    (*key).value.str.val = str_key;
    (*key).value.str.len = str_key_len-1;
    (*key).type = 6;
    break;
   case 2:
    (*key).value.lval = int_key;
    (*key).type = 1;
    break;
   default:
   case 3:
    { (*key).type = 0; };
    break;
  }
 }

 ;
 execute_data->opline++;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_EXIT_SPEC_VAR_HANDLER(zend_execute_data *execute_data )
{

 zend_op *opline = execute_data->opline;

 ;
 if ((1<<2) != (1<<3)) {
  zend_free_op free_op1;
  zval *ptr = _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

  if ((*ptr).type == 1) {
   (executor_globals.exit_status) = (*ptr).value.lval;
  } else {
   zend_print_variable(ptr);
  }
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 }

 _zend_bailout("/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_vm_execute.h", 11231);
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_JMP_SET_SPEC_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *value;

 ;
 value = _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if (i_zend_is_true(value)) {
  do { (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var)->value = (value)->value; (*&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).type = (*value).type; } while (0);
  _zval_copy_ctor((&((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var)) );
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};



  if (__builtin_expect(!(executor_globals.exception), 1)) { execute_data->opline = opline->op2.jmp_addr; } else { ; } return 0;
 }

 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_QM_ASSIGN_SPEC_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *value;

 ;
 value = _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 do { (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var)->value = (value)->value; (*&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).type = (*value).type; } while (0);
 if (!0) {
  _zval_copy_ctor((&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var) );
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INSTANCEOF_SPEC_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *expr;
 zend_bool result;

 ;
 expr = _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((*expr).type == 5 && (*expr).value.obj.handlers->get_class_entry) {
  result = instanceof_function(zend_get_class_entry(&(*expr) ), (*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).class_entry );
 } else {
  result = 0;
 }
 do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((result) != 0); (*__z).type = 3; } while (0);
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ADD_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 add_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  opline->op2.zv );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SUB_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 sub_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  opline->op2.zv );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_MUL_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 mul_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  opline->op2.zv );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_DIV_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 div_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  opline->op2.zv );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_MOD_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 mod_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  opline->op2.zv );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SL_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 shift_left_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  opline->op2.zv );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SR_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 shift_right_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  opline->op2.zv );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_CONCAT_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 concat_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  opline->op2.zv );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_IDENTICAL_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 is_identical_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  opline->op2.zv );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_NOT_IDENTICAL_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 is_identical_function(result,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  opline->op2.zv );
 (*result).value.lval = !(*result).value.lval;
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_EQUAL_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  opline->op2.zv );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval == 0)) != 0); (*__z).type = 3; } while (0);
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_NOT_EQUAL_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  opline->op2.zv );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval != 0)) != 0); (*__z).type = 3; } while (0);
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_SMALLER_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  opline->op2.zv );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval < 0)) != 0); (*__z).type = 3; } while (0);
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_SMALLER_OR_EQUAL_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  opline->op2.zv );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval <= 0)) != 0); (*__z).type = 3; } while (0);
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_OR_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 bitwise_or_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  opline->op2.zv );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_AND_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 bitwise_and_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  opline->op2.zv );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_XOR_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 bitwise_xor_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  opline->op2.zv );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BOOL_XOR_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 boolean_xor_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  opline->op2.zv );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_binary_assign_op_obj_helper_SPEC_VAR_CONST(int (*binary_op)(zval *result, zval *op1, zval *op2 ), zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op_data1;
 zval **object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 zval *object;
 zval *property = opline->op2.zv;
 zval *value = _get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, &free_op_data1, 0 );
 int have_get_ptr = 0;

 if ((1<<2) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }

 make_real_object(object_ptr );
 object = *object_ptr;

 if (__builtin_expect((*object).type != 5, 0)) {
  zend_error((1<<1L), "Attempt to assign property of non-object");

  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };

  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = &(executor_globals.uninitialized_zval);
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
  }
 } else {

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
  }


  if (opline->extended_value == 136
   && (*object).value.obj.handlers->get_property_ptr_ptr) {
   zval **zptr = (*object).value.obj.handlers->get_property_ptr_ptr(object, property, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   if (zptr != ((void *)0)) {
    if (!zval_isref_p(*zptr)) { do { if (zval_refcount_p(*((zptr))) > 1) { zval *new_zv; zval_delref_p(*(zptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(zptr))->value; (*new_zv).type = (**(zptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(zptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

    have_get_ptr = 1;
    binary_op(*zptr, *zptr, value );
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((*zptr));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = *zptr;
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
   }
  }

  if (!have_get_ptr) {
   zval *z = ((void *)0);

   if (opline->extended_value == 136) {
    if ((*object).value.obj.handlers->read_property) {
     z = (*object).value.obj.handlers->read_property(object, property, 0, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
    }
   } else {
    if ((*object).value.obj.handlers->read_dimension) {
     z = (*object).value.obj.handlers->read_dimension(object, property, 0 );
    }
   }
   if (z) {
    if ((*z).type == 5 && (*z).value.obj.handlers->get) {
     zval *value = (*z).value.obj.handlers->get(z );

     if (zval_refcount_p(z) == 0) {
      if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); };
      _zval_dtor((z) );
      do { if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); }; _efree((z) ); } while (0);
     }
     z = value;
    }
    zval_addref_p(z);
    if (!zval_isref_p(*&z)) { do { if (zval_refcount_p(*((&z))) > 1) { zval *new_zv; zval_delref_p(*(&z)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(&z))->value; (*new_zv).type = (**(&z)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(&z) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
    binary_op(z, z, value );
    if (opline->extended_value == 136) {
     (*object).value.obj.handlers->write_property(object, property, z, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
    } else {
     (*object).value.obj.handlers->write_dimension(object, property, z );
    }
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((z));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = z;
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
    i_zval_ptr_dtor(*(&z) );
   } else {
    zend_error((1<<1L), "Attempt to assign property of non-object");
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((&(executor_globals.uninitialized_zval)));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = &(executor_globals.uninitialized_zval);
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
   }
  }

  if (0) {
   i_zval_ptr_dtor(*(&property) );
  } else {

  }
  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };
 }

 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_binary_assign_op_helper_SPEC_VAR_CONST(int (*binary_op)(zval *result, zval *op1, zval *op2 ), zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op_data2, free_op_data1;
 zval **var_ptr;
 zval *value;

 ;
 switch (opline->extended_value) {
  case 136:
   return zend_binary_assign_op_obj_helper_SPEC_VAR_CONST(binary_op, execute_data );
   break;
  case 147: {
    zval **container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

    if ((1<<2) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
     zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
    } else if (__builtin_expect((**container).type == 5, 0)) {
     if ((1<<2) == (1<<2) && !(free_op1.var != ((void *)0))) {
      zval_addref_p(*(container));
     }
     return zend_binary_assign_op_obj_helper_SPEC_VAR_CONST(binary_op, execute_data );
    } else {
     zval *dim = opline->op2.zv;

     zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)), container, dim, (1<<0), 2 );
     value = _get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, &free_op_data1, 0 );
     var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data->Ts, &free_op_data2 );
    }
   }
   break;
  default:
   value = opline->op2.zv;
   var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

   break;
 }

 if (__builtin_expect(var_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use assign-op operators with overloaded objects nor string offsets");
 }

 if (__builtin_expect(*var_ptr == &(executor_globals.error_zval), 0)) {
  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }

  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
  ;
  if (opline->extended_value == 147) {
   execute_data->opline++;
  }
  execute_data->opline++; return 0;
 }

 if (!zval_isref_p(*var_ptr)) { do { if (zval_refcount_p(*((var_ptr))) > 1) { zval *new_zv; zval_delref_p(*(var_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(var_ptr))->value; (*new_zv).type = (**(var_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(var_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

 if (__builtin_expect((**var_ptr).type == 5, 0)
    && ((**var_ptr)).value.obj.handlers->get
    && ((**var_ptr)).value.obj.handlers->set) {

  zval *objval = ((**var_ptr)).value.obj.handlers->get(*var_ptr );
  zval_addref_p(objval);
  binary_op(objval, objval, value );
  ((**var_ptr)).value.obj.handlers->set(var_ptr, objval );
  i_zval_ptr_dtor(*(&objval) );
 } else {
  binary_op(*var_ptr, *var_ptr, value );
 }

 if ((!((opline)->result_type & (1<<5)))) {
  zval_addref_p((*var_ptr));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (*var_ptr); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
 }

 if (opline->extended_value == 147) {
  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };
  if (free_op_data2.var) { i_zval_ptr_dtor(*(&free_op_data2.var) ); };
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
  ;
  execute_data->opline++;
 } else {
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
  ;
 }
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_ADD_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_CONST(add_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SUB_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_CONST(sub_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_MUL_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_CONST(mul_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_DIV_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_CONST(div_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_MOD_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_CONST(mod_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SL_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_CONST(shift_left_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SR_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_CONST(shift_right_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_CONCAT_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_CONST(concat_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_OR_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_CONST(bitwise_or_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_AND_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_CONST(bitwise_and_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_XOR_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_CONST(bitwise_xor_function, execute_data );
}

static int __attribute__((fastcall)) zend_pre_incdec_property_helper_SPEC_VAR_CONST(incdec_t incdec_op, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **object_ptr;
 zval *object;
 zval *property;
 zval **retval;
 int have_get_ptr = 0;

 ;
 object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 property = opline->op2.zv;
 retval = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr;

 if ((1<<2) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot increment/decrement overloaded objects nor string offsets");
 }

 make_real_object(object_ptr );
 object = *object_ptr;

 if (__builtin_expect((*object).type != 5, 0)) {
  zend_error((1<<1L), "Attempt to increment/decrement property of non-object");

  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   *retval = &(executor_globals.uninitialized_zval);
  }
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
  ;
  execute_data->opline++; return 0;
 }



 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }

 if ((*object).value.obj.handlers->get_property_ptr_ptr) {
  zval **zptr = (*object).value.obj.handlers->get_property_ptr_ptr(object, property, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
  if (zptr != ((void *)0)) {
   if (!zval_isref_p(*zptr)) { do { if (zval_refcount_p(*((zptr))) > 1) { zval *new_zv; zval_delref_p(*(zptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(zptr))->value; (*new_zv).type = (**(zptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(zptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

   have_get_ptr = 1;
   incdec_op(*zptr);
   if ((!((opline)->result_type & (1<<5)))) {
    *retval = *zptr;
    zval_addref_p((*retval));
   }
  }
 }

 if (!have_get_ptr) {
  if ((*object).value.obj.handlers->read_property && (*object).value.obj.handlers->write_property) {
   zval *z = (*object).value.obj.handlers->read_property(object, property, 0, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );

   if (__builtin_expect((*z).type == 5, 0) && (*z).value.obj.handlers->get) {
    zval *value = (*z).value.obj.handlers->get(z );

    if (zval_refcount_p(z) == 0) {
     if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); };
     _zval_dtor((z) );
     do { if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); }; _efree((z) ); } while (0);
    }
    z = value;
   }
   zval_addref_p(z);
   if (!zval_isref_p(*&z)) { do { if (zval_refcount_p(*((&z))) > 1) { zval *new_zv; zval_delref_p(*(&z)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(&z))->value; (*new_zv).type = (**(&z)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(&z) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
   incdec_op(z);
   *retval = z;
   (*object).value.obj.handlers->write_property(object, property, z, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   if ((!((opline)->result_type & (1<<5)))) { zval_addref_p((*retval)); };
   i_zval_ptr_dtor(*(&z) );
  } else {
   zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
   if ((!((opline)->result_type & (1<<5)))) {
    zval_addref_p((&(executor_globals.uninitialized_zval)));
    *retval = &(executor_globals.uninitialized_zval);
   }
  }
 }

 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {

 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_PRE_INC_OBJ_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_pre_incdec_property_helper_SPEC_VAR_CONST(increment_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_PRE_DEC_OBJ_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_pre_incdec_property_helper_SPEC_VAR_CONST(decrement_function, execute_data );
}

static int __attribute__((fastcall)) zend_post_incdec_property_helper_SPEC_VAR_CONST(incdec_t incdec_op, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **object_ptr;
 zval *object;
 zval *property;
 zval *retval;
 int have_get_ptr = 0;

 ;
 object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 property = opline->op2.zv;
 retval = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 if ((1<<2) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot increment/decrement overloaded objects nor string offsets");
 }

 make_real_object(object_ptr );
 object = *object_ptr;

 if (__builtin_expect((*object).type != 5, 0)) {
  zend_error((1<<1L), "Attempt to increment/decrement property of non-object");

  { (*retval).type = 0; };
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
  ;
  execute_data->opline++; return 0;
 }



 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }

 if ((*object).value.obj.handlers->get_property_ptr_ptr) {
  zval **zptr = (*object).value.obj.handlers->get_property_ptr_ptr(object, property, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
  if (zptr != ((void *)0)) {
   have_get_ptr = 1;
   if (!zval_isref_p(*zptr)) { do { if (zval_refcount_p(*((zptr))) > 1) { zval *new_zv; zval_delref_p(*(zptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(zptr))->value; (*new_zv).type = (**(zptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(zptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

   do { (retval)->value = (*zptr)->value; (*retval).type = (**zptr).type; } while (0);
   _zval_copy_ctor((&(*retval)) );

   incdec_op(*zptr);

  }
 }

 if (!have_get_ptr) {
  if ((*object).value.obj.handlers->read_property && (*object).value.obj.handlers->write_property) {
   zval *z = (*object).value.obj.handlers->read_property(object, property, 0, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   zval *z_copy;

   if (__builtin_expect((*z).type == 5, 0) && (*z).value.obj.handlers->get) {
    zval *value = (*z).value.obj.handlers->get(z );

    if (zval_refcount_p(z) == 0) {
     if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); };
     _zval_dtor((z) );
     do { if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); }; _efree((z) ); } while (0);
    }
    z = value;
   }
   do { (retval)->value = (z)->value; (*retval).type = (*z).type; } while (0);
   _zval_copy_ctor((&(*retval)) );
   do { (z_copy) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(z_copy))->u.buffered = ((void *)0); } while (0);
   do { do { (z_copy)->value = (z)->value; (*z_copy).type = (*z).type; } while (0); zval_set_refcount_p(z_copy, 1); zval_unset_isref_p(z_copy); } while (0);
   _zval_copy_ctor((&(*z_copy)) );
   incdec_op(z_copy);
   zval_addref_p(z);
   (*object).value.obj.handlers->write_property(object, property, z_copy, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   i_zval_ptr_dtor(*(&z_copy) );
   i_zval_ptr_dtor(*(&z) );
  } else {
   zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
   { (*retval).type = 0; };
  }
 }

 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {

 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_POST_INC_OBJ_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_post_incdec_property_helper_SPEC_VAR_CONST(increment_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_POST_DEC_OBJ_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_post_incdec_property_helper_SPEC_VAR_CONST(decrement_function, execute_data );
}

static int __attribute__((fastcall)) zend_fetch_var_address_helper_SPEC_VAR_CONST(int type, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *varname;
 zval **retval;
 zval tmp_varname;
 HashTable *target_symbol_table;
 ulong hash_value;

 ;
 varname = _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

  if ((1<<2) != (1<<0) && __builtin_expect((*varname).type != 6, 0)) {
  do { (&tmp_varname)->value = (varname)->value; (*&tmp_varname).type = (*varname).type; } while (0);
  _zval_copy_ctor((&tmp_varname) );
  if ((&tmp_varname)->type != 6) { _convert_to_string((&tmp_varname) ); };
  varname = &tmp_varname;
 }

 if ((1<<0) != (1<<3)) {
  zend_class_entry *ce;

  if ((1<<0) == (1<<0)) {
   if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
    ce = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
   } else {
    ce = zend_fetch_class_by_name((*opline->op2.zv).value.str.val, (*opline->op2.zv).value.str.len, opline->op2.literal + 1, 0 );
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); } while (0);
   }
  } else {
   ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).class_entry;
  }
  retval = zend_std_get_static_property(ce, (*varname).value.str.val, (*varname).value.str.len, 0, (((1<<2) == (1<<0)) ? opline->op1.literal : ((void *)0)) );
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 } else {
  target_symbol_table = zend_get_target_symbol_table(opline->extended_value & 0x70000000 );






  if ((1<<2) == (1<<0)) {
   hash_value = (((zend_literal*)(varname))->hash_value);
  } else if (((((*varname).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*varname).value.str.val) < (compiler_globals.interned_strings_end)))) {
   hash_value = (((Bucket*)(((char*)((*varname).value.str.val))-sizeof(Bucket)))->h);
  } else {
   hash_value = zend_hash_func((*varname).value.str.val, (*varname).value.str.len+1);
  }

  if (zend_hash_quick_find(target_symbol_table, (*varname).value.str.val, (*varname).value.str.len+1, hash_value, (void **) &retval) == -1) {
   switch (type) {
    case 0:
    case 6:
     zend_error((1<<3L),"Undefined variable: %s", (*varname).value.str.val);

    case 3:
     retval = &(executor_globals.uninitialized_zval_ptr);
     break;
    case 2:
     zend_error((1<<3L),"Undefined variable: %s", (*varname).value.str.val);

    case 1:
     zval_addref_p(&(executor_globals.uninitialized_zval));
     _zend_hash_quick_add_or_update(target_symbol_table, (*varname).value.str.val, (*varname).value.str.len+1, hash_value, &(executor_globals.uninitialized_zval_ptr), sizeof(zval *), (void **) &retval, (1<<0) );
     break;
   
   }
  }
  switch (opline->extended_value & 0x70000000) {
   case 0x00000000:
    if ((1<<2) != (1<<1)) {
     if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
    }
    break;
   case 0x10000000:
    if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
    break;
   case 0x20000000:
    zval_update_constant(retval, (void*) 1 );
    break;
   case 0x40000000:
    if ((1<<2) == (1<<2) && !free_op1.var) {
     zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr));
    }
    break;
  }
 }


 if ((1<<2) != (1<<0) && varname == &tmp_varname) {
  _zval_dtor((&tmp_varname) );
 }
 if (opline->extended_value & 0x04000000) {
  if (!zval_isref_p(*retval)) { do { if (zval_refcount_p(*((retval))) > 1) { zval *new_zv; zval_delref_p(*(retval)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval))->value; (*new_zv).type = (**(retval)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((retval))); };
 }
 zval_addref_p((*retval));
 switch (type) {
  case 0:
  case 3:
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (*retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   break;
  case 6: {
   zend_free_op free_res;

   zend_pzval_unlock_func(*retval, &free_res, 1 );
   if (retval != &(executor_globals.uninitialized_zval_ptr)) {
    if (!zval_isref_p(*retval)) { do { if (zval_refcount_p(*((retval))) > 1) { zval *new_zv; zval_delref_p(*(retval)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval))->value; (*new_zv).type = (**(retval)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
   }
   zval_addref_p((*retval));
   if (free_res.var) { i_zval_ptr_dtor(*(&free_res.var) ); };
  }

  default:
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = retval;
   break;
 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_R_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_VAR_CONST(0, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_W_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_VAR_CONST(1, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_RW_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_VAR_CONST(2, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_FUNC_ARG_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 return zend_fetch_var_address_helper_SPEC_VAR_CONST(((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && (opline->extended_value & 0x000fffff) <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[(opline->extended_value & 0x000fffff)-1].pass_by_reference & (1|2)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x1000000|0x2000000))))?1:0, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_UNSET_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_VAR_CONST(6, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_IS_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_VAR_CONST(3, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_R_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **container;

 ;

 if ((opline->extended_value & 0x08000000) &&
     (1<<2) != (1<<4) &&
     (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr) {
  zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr));
 }
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 zend_fetch_dimension_address_read(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, opline->op2.zv, (1<<0), 0 );

 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_W_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **container;

 ;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<2) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, opline->op2.zv, (1<<0), 1 );

 if ((1<<2) == (1<<2) && (free_op1.var != ((void *)0)) && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};


 if (__builtin_expect(opline->extended_value != 0, 0)) {
  zval **retval_ptr = (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr;

  if (retval_ptr) {
   zval_delref_p(*(retval_ptr));
   if (!zval_isref_p(*retval_ptr)) { do { if (zval_refcount_p(*((retval_ptr))) > 1) { zval *new_zv; zval_delref_p(*(retval_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval_ptr))->value; (*new_zv).type = (**(retval_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((retval_ptr))); };
   zval_addref_p(*(retval_ptr));
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_RW_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **container;

 ;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<2) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, opline->op2.zv, (1<<0), 2 );

 if ((1<<2) == (1<<2) && (free_op1.var != ((void *)0)) && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_IS_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **container;

 ;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 zend_fetch_dimension_address_read(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, opline->op2.zv, (1<<0), 3 );

 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **container;

 ;

 if (((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && (opline->extended_value & 0x000fffff) <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[(opline->extended_value & 0x000fffff)-1].pass_by_reference & (1|2)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x1000000|0x2000000))))) {
  container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
  if ((1<<2) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
  }
  zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, opline->op2.zv, (1<<0), 1 );
  if ((1<<2) == (1<<2) && (free_op1.var != ((void *)0)) && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
  }
 } else {
  if ((1<<0) == (1<<3)) {
   zend_error_noreturn((1<<0L), "Cannot use [] for reading");
  }
  container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
  zend_fetch_dimension_address_read(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, opline->op2.zv, (1<<0), 0 );
 }

 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_UNSET_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **container;

 ;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<2) == (1<<4)) {
  if (container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
 }
 if ((1<<2) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, opline->op2.zv, (1<<0), 6 );

 if ((1<<2) == (1<<2) && (free_op1.var != ((void *)0)) && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 if (__builtin_expect((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot unset string offsets");
 } else {
  zend_free_op free_res;
  zval **retval_ptr = (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr;

  zend_pzval_unlock_func(*retval_ptr, &free_res, 1 );
  if (retval_ptr != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*retval_ptr)) { do { if (zval_refcount_p(*((retval_ptr))) > 1) { zval *new_zv; zval_delref_p(*(retval_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval_ptr))->value; (*new_zv).type = (**(retval_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
  zval_addref_p((*retval_ptr));
  if (free_res.var) { i_zval_ptr_dtor(*(&free_res.var) ); };
  ;
  execute_data->opline++; return 0;
 }
}

static int __attribute__((fastcall)) zend_fetch_property_address_read_helper_SPEC_VAR_CONST(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *container;

 zval *offset;

 ;
 container = _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 offset = opline->op2.zv;

 if (__builtin_expect((*container).type != 5, 0) ||
     __builtin_expect((*container).value.obj.handlers->read_property == ((void *)0), 0)) {
  zend_error((1<<3L), "Trying to get property of non-object");
  zval_addref_p((&(executor_globals.uninitialized_zval)));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);

 } else {
  zval *retval;

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
  }


  retval = (*container).value.obj.handlers->read_property(container, offset, 0, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );

  zval_addref_p((retval));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);

  if (0) {
   i_zval_ptr_dtor(*(&offset) );
  } else {

  }
 }

 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_R_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_property_address_read_helper_SPEC_VAR_CONST(execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_W_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *property;
 zval **container;

 ;
 property = opline->op2.zv;

 if ((1<<2) == (1<<2) && (opline->extended_value & 0x08000000)) {
  zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr));
  (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr = *(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr;
 }

 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 if ((1<<2) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }

 zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)), 1 );
 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {

 }
 if ((1<<2) == (1<<2) && (free_op1.var != ((void *)0)) && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};


 if (opline->extended_value & 0x04000000) {
  zval **retval_ptr = (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr;

  zval_delref_p(*(retval_ptr));
  if (!zval_isref_p(*retval_ptr)) { do { if (zval_refcount_p(*((retval_ptr))) > 1) { zval *new_zv; zval_delref_p(*(retval_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval_ptr))->value; (*new_zv).type = (**(retval_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((retval_ptr))); };
  zval_addref_p(*(retval_ptr));
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_RW_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *property;
 zval **container;

 ;
 property = opline->op2.zv;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }
 if ((1<<2) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }
 zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)), 2 );
 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {

 }
 if ((1<<2) == (1<<2) && (free_op1.var != ((void *)0)) && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_IS_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *container;

 zval *offset;

 ;
 container = _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 offset = opline->op2.zv;

 if (__builtin_expect((*container).type != 5, 0) ||
     __builtin_expect((*container).value.obj.handlers->read_property == ((void *)0), 0)) {
  zval_addref_p((&(executor_globals.uninitialized_zval)));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);

 } else {
  zval *retval;

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
  }


  retval = (*container).value.obj.handlers->read_property(container, offset, 3, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );

  zval_addref_p((retval));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);

  if (0) {
   i_zval_ptr_dtor(*(&offset) );
  } else {

  }
 }

 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 if (((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && (opline->extended_value & 0x000fffff) <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[(opline->extended_value & 0x000fffff)-1].pass_by_reference & (1|2)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x1000000|0x2000000))))) {

  zend_free_op free_op1;
  zval *property;
  zval **container;

  ;
  property = opline->op2.zv;
  container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
  }
  if ((1<<2) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
  }
  zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)), 1 );
  if (0) {
   i_zval_ptr_dtor(*(&property) );
  } else {

  }
  if ((1<<2) == (1<<2) && (free_op1.var != ((void *)0)) && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
  }
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
  ;
  execute_data->opline++; return 0;
 } else {
  return zend_fetch_property_address_read_helper_SPEC_VAR_CONST(execute_data );
 }
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_UNSET_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_res;
 zval **container;
 zval *property;

 ;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 property = opline->op2.zv;

 if ((1<<2) == (1<<4)) {
  if (container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
 }
 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }
 if ((1<<2) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }
 zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)), 6 );
 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {

 }
 if ((1<<2) == (1<<2) && (free_op1.var != ((void *)0)) && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 zend_pzval_unlock_func(*(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr, &free_res, 1 );
 if ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr != &(executor_globals.uninitialized_zval_ptr)) {
  if (!zval_isref_p(*(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr)) { do { if (zval_refcount_p(*(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr))->value; (*new_zv).type = (**((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
 }
 zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr));
 if (free_res.var) { i_zval_ptr_dtor(*(&free_res.var) ); };
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_OBJ_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **object_ptr;
 zval *property_name;

 ;
 object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 property_name = opline->op2.zv;

 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property_name))->value; (*_tmp).type = (*(property_name)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property_name) = _tmp; } while (0);
 }
 if ((1<<2) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 zend_assign_to_object((!((opline)->result_type & (1<<5)))?&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr:((void *)0), object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, 136, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
 if (0) {
  i_zval_ptr_dtor(*(&property_name) );
 } else {

 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_DIM_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **object_ptr;

 ;
 object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<2) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 if ((**object_ptr).type == 5) {

  zval *property_name = opline->op2.zv;

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property_name))->value; (*_tmp).type = (*(property_name)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property_name) = _tmp; } while (0);
  }
  zend_assign_to_object((!((opline)->result_type & (1<<5)))?&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr:((void *)0), object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, 147, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
  if (0) {
   i_zval_ptr_dtor(*(&property_name) );
  } else {

  }
 } else {
  zend_free_op free_op_data1, free_op_data2;
  zval *value;
  zval *dim = opline->op2.zv;
  zval **variable_ptr_ptr;

  zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)), object_ptr, dim, (1<<0), 1 );

  value = _get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, &free_op_data1, 0 );
  variable_ptr_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data->Ts, &free_op_data2 );
  if (__builtin_expect(variable_ptr_ptr == ((void *)0), 0)) {
   if (zend_assign_to_string_offset(&(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)), value, (opline+1)->op1_type )) {
    if ((!((opline)->result_type & (1<<5)))) {
     zval *retval;

     do { (retval) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(retval))->u.buffered = ((void *)0); } while (0);
     do { const char *__s=((*(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)).str_offset.str).value.str.val+(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)).str_offset.offset); int __l=1; zval *__z = (retval); (*__z).value.str.len = __l; (*__z).value.str.val = (1?_estrndup((__s), (__l) ):(char*)__s); (*__z).type = 6; } while (0);
     (retval)->refcount__gc = 1; (retval)->is_ref__gc = 0;;
     do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
    }
   } else if ((!((opline)->result_type & (1<<5)))) {
    zval_addref_p((&(executor_globals.uninitialized_zval)));
    do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   }
  } else if (__builtin_expect(*variable_ptr_ptr == &(executor_globals.error_zval), 0)) {
   if (((zend_uintptr_t)free_op_data1.var & 1L)) {
    _zval_dtor((value) );
   }
   if ((!((opline)->result_type & (1<<5)))) {
    zval_addref_p((&(executor_globals.uninitialized_zval)));
    do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   }
  } else {
   if ((opline+1)->op1_type == (1<<1)) {
     value = zend_assign_tmp_to_variable(variable_ptr_ptr, value );
   } else if ((opline+1)->op1_type == (1<<0)) {
     value = zend_assign_const_to_variable(variable_ptr_ptr, value );
   } else {
     value = zend_assign_to_variable(variable_ptr_ptr, value );
   }
   if ((!((opline)->result_type & (1<<5)))) {
    zval_addref_p((value));
    do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (value); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   }
  }
  if (free_op_data2.var) { i_zval_ptr_dtor(*(&free_op_data2.var) ); };
   if (free_op_data1.var != ((void *)0) && (((zend_uintptr_t)free_op_data1.var & 1L) == 0)) { i_zval_ptr_dtor(*(&free_op_data1.var) ); };
 }
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *value;
 zval **variable_ptr_ptr;

 ;
 value = opline->op2.zv;
 variable_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<2) == (1<<2) && __builtin_expect(variable_ptr_ptr == ((void *)0), 0)) {
  if (zend_assign_to_string_offset(&(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)), value, (1<<0) )) {
   if ((!((opline)->result_type & (1<<5)))) {
    zval *retval;

    do { (retval) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(retval))->u.buffered = ((void *)0); } while (0);
    do { const char *__s=((*(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).str_offset.str).value.str.val+(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).str_offset.offset); int __l=1; zval *__z = (retval); (*__z).value.str.len = __l; (*__z).value.str.val = (1?_estrndup((__s), (__l) ):(char*)__s); (*__z).type = 6; } while (0);
    (retval)->refcount__gc = 1; (retval)->is_ref__gc = 0;;
    do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   }
  } else if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }
 } else if ((1<<2) == (1<<2) && __builtin_expect(*variable_ptr_ptr == &(executor_globals.error_zval), 0)) {
  if (0) {
   _zval_dtor((value) );
  }
  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }
 } else {
  if ((1<<0) == (1<<1)) {
    value = zend_assign_tmp_to_variable(variable_ptr_ptr, value );
  } else if ((1<<0) == (1<<0)) {
    value = zend_assign_const_to_variable(variable_ptr_ptr, value );
  } else {
    value = zend_assign_to_variable(variable_ptr_ptr, value );
  }
  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((value));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (value); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }
 }

 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};



 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_METHOD_CALL_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *function_name;
 char *function_name_strval;
 int function_name_strlen;
 zend_free_op free_op1;

 ;
 zend_ptr_stack_3_push(&(executor_globals.arg_types_stack), execute_data->fbc, execute_data->object, execute_data->called_scope);

 function_name = opline->op2.zv;

 if ((1<<0) != (1<<0) &&
     __builtin_expect((*function_name).type != 6, 0)) {
  zend_error_noreturn((1<<0L), "Method name must be a string");
 }

 function_name_strval = (*function_name).value.str.val;
 function_name_strlen = (*function_name).value.str.len;

 execute_data->object = _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if (__builtin_expect(execute_data->object != ((void *)0), 1) &&
     __builtin_expect((*execute_data->object).type == 5, 1)) {
  execute_data->called_scope = zend_get_class_entry(&(*execute_data->object) );

  if ((1<<0) != (1<<0) ||
      (execute_data->fbc = (((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] == (execute_data->called_scope)) ? (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] : ((void *)0))) == ((void *)0)) {
      zval *object = execute_data->object;

   if (__builtin_expect((*execute_data->object).value.obj.handlers->get_method == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Object does not support method calls");
   }


   execute_data->fbc = (*execute_data->object).value.obj.handlers->get_method(&execute_data->object, function_name_strval, function_name_strlen, (((1<<0) == (1<<0)) ? (opline->op2.literal + 1) : ((void *)0)) );
   if (__builtin_expect(execute_data->fbc == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Call to undefined method %s::%s()", ((execute_data->object) && (*execute_data->object).type == 5 && (*execute_data->object).value.obj.handlers->get_class_entry != ((void *)0) && (*execute_data->object).value.obj.handlers->get_class_entry(execute_data->object ) ? (*execute_data->object).value.obj.handlers->get_class_entry(execute_data->object )->name : ""), function_name_strval);
   }
   if ((1<<0) == (1<<0) &&
       __builtin_expect((execute_data->fbc->common.fn_flags & 0x200000) == 0, 1) &&
       __builtin_expect(execute_data->object == object, 1)) {
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (execute_data->called_scope); (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] = (execute_data->fbc); } while (0);
   }
  }
 } else {
  zend_error_noreturn((1<<0L), "Call to a member function %s() on a non-object", function_name_strval);
 }

 if ((execute_data->fbc->common.fn_flags & 0x01) != 0) {
  execute_data->object = ((void *)0);
 } else {
  if (!zval_isref_p(execute_data->object)) {
   zval_addref_p(execute_data->object);
  } else {
   zval *this_ptr;
   do { (this_ptr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(this_ptr))->u.buffered = ((void *)0); } while (0);
   do { do { (this_ptr)->value = (execute_data->object)->value; (*this_ptr).type = (*execute_data->object).type; } while (0); zval_set_refcount_p(this_ptr, 1); zval_unset_isref_p(this_ptr); } while (0);
   _zval_copy_ctor((this_ptr) );
   execute_data->object = this_ptr;
  }
 }

 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *function_name;
 zend_class_entry *ce;

 ;
 zend_ptr_stack_3_push(&(executor_globals.arg_types_stack), execute_data->fbc, execute_data->object, execute_data->called_scope);

 if ((1<<2) == (1<<0)) {

  if ((executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)]) {
   ce = (executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)];
  } else {
   ce = zend_fetch_class_by_name((*opline->op1.zv).value.str.val, (*opline->op1.zv).value.str.len, opline->op1.literal + 1, opline->extended_value );
   if (__builtin_expect(ce == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Class '%s' not found", (*opline->op1.zv).value.str.val);
   }
   do { (executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)] = (ce); } while (0);
  }
  execute_data->called_scope = ce;
 } else {
  ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).class_entry;

  if (opline->extended_value == 2 || opline->extended_value == 1) {
   execute_data->called_scope = (executor_globals.called_scope);
  } else {
   execute_data->called_scope = ce;
  }
 }

 if ((1<<2) == (1<<0) &&
     (1<<0) == (1<<0) &&
     (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
  execute_data->fbc = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
 } else if ((1<<2) != (1<<0) &&
            (1<<0) == (1<<0) &&
            (execute_data->fbc = (((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] == (ce)) ? (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] : ((void *)0)))) {

 } else if ((1<<0) != (1<<3)) {
  char *function_name_strval = ((void *)0);
  int function_name_strlen = 0;


  if ((1<<0) == (1<<0)) {
   function_name_strval = (*opline->op2.zv).value.str.val;
   function_name_strlen = (*opline->op2.zv).value.str.len;
  } else {
   function_name = opline->op2.zv;

   if (__builtin_expect((*function_name).type != 6, 0)) {
    zend_error_noreturn((1<<0L), "Function name must be a string");
   } else {
    function_name_strval = (*function_name).value.str.val;
    function_name_strlen = (*function_name).value.str.len;
    }
  }

  if (function_name_strval) {
   if (ce->get_static_method) {
    execute_data->fbc = ce->get_static_method(ce, function_name_strval, function_name_strlen );
   } else {
    execute_data->fbc = zend_std_get_static_method(ce, function_name_strval, function_name_strlen, (((1<<0) == (1<<0)) ? (opline->op2.literal + 1) : ((void *)0)) );
   }
   if (__builtin_expect(execute_data->fbc == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Call to undefined method %s::%s()", ce->name, function_name_strval);
   }
   if ((1<<0) == (1<<0) && __builtin_expect((execute_data->fbc->common.fn_flags & 0x200000) == 0, 1)) {
    if ((1<<2) == (1<<0)) {
     do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (execute_data->fbc); } while (0);
    } else {
     do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] = (execute_data->fbc); } while (0);
    }
   }
  }
  if ((1<<0) != (1<<0)) {

  }
 } else {
  if (__builtin_expect(ce->constructor == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot call constructor");
  }
  if ((executor_globals.This) && zend_get_class_entry(&(*(executor_globals.This)) ) != ce->constructor->common.scope && (ce->constructor->common.fn_flags & 0x400)) {
   zend_error_noreturn((1<<0L), "Cannot call private %s::__construct()", ce->name);
  }
  execute_data->fbc = ce->constructor;
 }

 if (execute_data->fbc->common.fn_flags & 0x01) {
  execute_data->object = ((void *)0);
 } else {
  if ((executor_globals.This) &&
      (*(executor_globals.This)).value.obj.handlers->get_class_entry &&
      !instanceof_function(zend_get_class_entry(&(*(executor_globals.This)) ), ce )) {


   if (execute_data->fbc->common.fn_flags & 0x10000) {
    zend_error((1<<11L), "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", execute_data->fbc->common.scope->name, execute_data->fbc->common.function_name);
   } else {

    zend_error_noreturn((1<<0L), "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", execute_data->fbc->common.scope->name, execute_data->fbc->common.function_name);
   }
  }
  if ((execute_data->object = (executor_globals.This))) {
   zval_addref_p(execute_data->object);
   execute_data->called_scope = zend_get_class_entry(&(*execute_data->object) );
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_CASE_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 if ((1<<2)==(1<<2)) {
  zval_addref_p(((*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr));
 }
 is_equal_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
     _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
     opline->op2.zv );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_CONSTANT_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 ;
 if ((1<<2) == (1<<3)) {
  zend_constant *c;
  zval *retval;

  if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
   c = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
  } else if ((c = zend_quick_get_constant(opline->op2.literal + 1, opline->extended_value )) == ((void *)0)) {
   if ((opline->extended_value & 0x010) != 0) {
    char *actual = (char *)zend_memrchr((*opline->op2.zv).value.str.val, '\\', (*opline->op2.zv).value.str.len);
    if(!actual) {
     actual = (*opline->op2.zv).value.str.val;
    } else {
     actual++;
    }

    zend_error((1<<3L), "Use of undefined constant %s - assumed '%s'", actual, actual);
    do { const char *__s=(actual); int __l=(*opline->op2.zv).value.str.len-(actual - (*opline->op2.zv).value.str.val); zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.str.len = __l; (*__z).value.str.val = (1?_estrndup((__s), (__l) ):(char*)__s); (*__z).type = 6; } while (0);
    ;
    execute_data->opline++; return 0;
   } else {
    zend_error_noreturn((1<<0L), "Undefined constant '%s'", (*opline->op2.zv).value.str.val);
   }
  } else {
   do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (c); } while (0);
  }
  retval = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;
  do { (retval)->value = (&c->value)->value; (*retval).type = (*&c->value).type; } while (0);
  _zval_copy_ctor((retval) );
  ;
  execute_data->opline++; return 0;
 } else {

  zend_class_entry *ce;
  zval **value;

  if ((1<<2) == (1<<0)) {
   if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
    value = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
    do { (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var)->value = (*value)->value; (*&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).type = (**value).type; } while (0);
    _zval_copy_ctor((&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var) );
    ;
    execute_data->opline++; return 0;
   } else if ((executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)]) {
    ce = (executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)];
   } else {
    ce = zend_fetch_class_by_name((*opline->op1.zv).value.str.val, (*opline->op1.zv).value.str.len, opline->op1.literal + 1, opline->extended_value );
    if (__builtin_expect(ce == ((void *)0), 0)) {
     zend_error_noreturn((1<<0L), "Undefined class constant '%s'", (*opline->op2.zv).value.str.val);
    }
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)] = (ce); } while (0);
   }
  } else {
   ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).class_entry;
   if ((value = (((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] == (ce)) ? (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] : ((void *)0))) != ((void *)0)) {
    do { (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var)->value = (*value)->value; (*&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).type = (**value).type; } while (0);
    _zval_copy_ctor((&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var) );
    ;
    execute_data->opline++; return 0;
   }
  }

  if (__builtin_expect(zend_hash_quick_find(&ce->constants_table, (*opline->op2.zv).value.str.val, (*opline->op2.zv).value.str.len+1, (((zend_literal*)(opline->op2.zv))->hash_value), (void **) &value) == 0, 1)) {
   if ((**value).type == 9 ||
       ((**value).type & 0x00f) == 8) {
    zend_class_entry *old_scope = (executor_globals.scope);

    (executor_globals.scope) = ce;
    zval_update_constant(value, (void *) 1 );
    (executor_globals.scope) = old_scope;
   }
   if ((1<<2) == (1<<0)) {
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (value); } while (0);
   } else {
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] = (value); } while (0);
   }
   do { (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var)->value = (*value)->value; (*&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).type = (**value).type; } while (0);
   _zval_copy_ctor((&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var) );
  } else {
   zend_error_noreturn((1<<0L), "Undefined class constant '%s'", (*opline->op2.zv).value.str.val);
  }

  ;
  execute_data->opline++; return 0;
 }
}

static int __attribute__((fastcall)) ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *expr_ptr;

 ;
 if (((1<<2) == (1<<2) || (1<<2) == (1<<4)) && opline->extended_value) {
  zval **expr_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

  if ((1<<2) == (1<<2) && __builtin_expect(expr_ptr_ptr == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot create references to/from string offsets");
  }
  if (!zval_isref_p(*expr_ptr_ptr)) { do { if (zval_refcount_p(*((expr_ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(expr_ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(expr_ptr_ptr))->value; (*new_zv).type = (**(expr_ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(expr_ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((expr_ptr_ptr))); };
  expr_ptr = *expr_ptr_ptr;
  zval_addref_p(expr_ptr);
 } else {
  expr_ptr=_get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
  if (0) {
   zval *new_expr;

   do { (new_expr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_expr))->u.buffered = ((void *)0); } while (0);
   do { do { (new_expr)->value = (expr_ptr)->value; (*new_expr).type = (*expr_ptr).type; } while (0); zval_set_refcount_p(new_expr, 1); zval_unset_isref_p(new_expr); } while (0);
   expr_ptr = new_expr;
  } else if ((1<<2) == (1<<0) || zval_isref_p(expr_ptr)) {
   zval *new_expr;

   do { (new_expr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_expr))->u.buffered = ((void *)0); } while (0);
   do { do { (new_expr)->value = (expr_ptr)->value; (*new_expr).type = (*expr_ptr).type; } while (0); zval_set_refcount_p(new_expr, 1); zval_unset_isref_p(new_expr); } while (0);
   expr_ptr = new_expr;
   _zval_copy_ctor((&(*expr_ptr)) );
  } else {
   zval_addref_p(expr_ptr);
  }
 }

 if ((1<<0) != (1<<3)) {

  zval *offset = opline->op2.zv;
  ulong hval;

  switch ((*offset).type) {
   case 2:
    hval = zend_dval_to_lval((*offset).value.dval);
    goto num_index;
   case 1:
   case 3:
    hval = (*offset).value.lval;
num_index:
    _zend_hash_index_update_or_next_insert(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, hval, &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   case 6:
    if ((1<<0) == (1<<0)) {
     hval = (((zend_literal*)(offset))->hash_value);
    } else {
     do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index; } } } while (0);
     if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
      hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
     } else {
      hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
     }
    }
    _zend_hash_quick_add_or_update(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   case 0:
    _zend_hash_add_or_update(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, "", sizeof(""), &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   default:
    zend_error((1<<1L), "Illegal offset type");
    i_zval_ptr_dtor(*(&expr_ptr) );

    break;
  }

 } else {
  _zend_hash_index_update_or_next_insert(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, 0, &expr_ptr, sizeof(zval *), ((void *)0), (1<<2) );
 }
 if (((1<<2) == (1<<2) || (1<<2) == (1<<4)) && opline->extended_value) {
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 } else {
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_ARRAY_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 _array_init((&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var), 0 );
 if ((1<<2) == (1<<3)) {
  execute_data->opline++; return 0;

 } else {
  return ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CONST_HANDLER(execute_data );

 }
}

static int __attribute__((fastcall)) ZEND_UNSET_VAR_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval tmp, *varname;
 HashTable *target_symbol_table;
 zend_free_op free_op1;

 ;
 if ((1<<2) == (1<<4) &&
     (1<<0) == (1<<3) &&
     (opline->extended_value & 0x00800000)) {
  if ((executor_globals.active_symbol_table)) {
   zend_compiled_variable *cv = &((executor_globals.active_op_array)->vars[opline->op1.var]);

   zend_delete_variable(execute_data->prev_execute_data, (executor_globals.active_symbol_table), cv->name, cv->name_len+1, cv->hash_value );
   execute_data->CVs[opline->op1.var] = ((void *)0);
  } else if (execute_data->CVs[opline->op1.var]) {
   i_zval_ptr_dtor(*(execute_data->CVs[opline->op1.var]) );
   execute_data->CVs[opline->op1.var] = ((void *)0);
  }
  ;
  execute_data->opline++; return 0;
 }

 varname = _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<2) != (1<<0) && (*varname).type != 6) {
  do { (&tmp)->value = (varname)->value; (*&tmp).type = (*varname).type; } while (0);
  _zval_copy_ctor((&tmp) );
  if ((&tmp)->type != 6) { _convert_to_string((&tmp) ); };
  varname = &tmp;
 } else if ((1<<2) == (1<<2) || (1<<2) == (1<<4)) {
  zval_addref_p(varname);
 }

 if ((1<<0) != (1<<3)) {
  zend_class_entry *ce;

  if ((1<<0) == (1<<0)) {
   if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
    ce = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
   } else {
    ce = zend_fetch_class_by_name((*opline->op2.zv).value.str.val, (*opline->op2.zv).value.str.len, opline->op2.literal + 1, 0 );
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); } while (0);
   }
  } else {
   ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).class_entry;
  }
  zend_std_unset_static_property(ce, (*varname).value.str.val, (*varname).value.str.len, (((1<<2) == (1<<0)) ? opline->op1.literal : ((void *)0)) );
 } else {
  ulong hash_value = zend_inline_hash_func(varname->value.str.val, varname->value.str.len+1);

  target_symbol_table = zend_get_target_symbol_table(opline->extended_value & 0x70000000 );
  zend_delete_variable(execute_data, target_symbol_table, varname->value.str.val, varname->value.str.len+1, hash_value );
 }

 if ((1<<2) != (1<<0) && varname == &tmp) {
  _zval_dtor((&tmp) );
 } else if ((1<<2) == (1<<2) || (1<<2) == (1<<4)) {
  i_zval_ptr_dtor(*(&varname) );
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_UNSET_DIM_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **container;
 zval *offset;
 ulong hval;

 ;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 offset = opline->op2.zv;

 if ((1<<2) != (1<<2) || container) {
  if ((1<<2) == (1<<4) && container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
  switch ((**container).type) {
   case 4: {
    HashTable *ht = (**container).value.ht;

    switch ((*offset).type) {
     case 2:
      hval = zend_dval_to_lval((*offset).value.dval);
      goto num_index_dim;
     case 7:
     case 3:
     case 1:
num_index_dim:
      hval = (*offset).value.lval;
      zend_hash_del_key_or_index(ht, ((void *)0), 0, hval, 1);
      break;
     case 6:
      if ((1<<0) == (1<<4) || (1<<0) == (1<<2)) {
       zval_addref_p(offset);
      }
      if ((1<<0) == (1<<0)) {
       hval = (((zend_literal*)(offset))->hash_value);
      } else {
       do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index_dim; } } } while (0);
       if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
        hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
       } else {
        hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
       }
      }
      if (ht == &(executor_globals.symbol_table)) {
       zend_delete_global_variable_ex(offset->value.str.val, offset->value.str.len, hval );
      } else {
       zend_hash_del_key_or_index(ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, 2);
      }
      if ((1<<0) == (1<<4) || (1<<0) == (1<<2)) {
       i_zval_ptr_dtor(*(&offset) );
      }
      break;
     case 0:
      zend_hash_del_key_or_index(ht, "", sizeof(""), 0, 0);
      break;
     default:
      zend_error((1<<1L), "Illegal offset type in unset");
      break;
    }

    break;
   }
   case 5:
    if (__builtin_expect((**container).value.obj.handlers->unset_dimension == ((void *)0), 0)) {
     zend_error_noreturn((1<<0L), "Cannot use object as array");
    }
    if (0) {
     do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
    }
    (**container).value.obj.handlers->unset_dimension(*container, offset );
    if (0) {
     i_zval_ptr_dtor(*(&offset) );
    } else {

    }
    break;
   case 6:
    zend_error_noreturn((1<<0L), "Cannot unset string offsets");
    return 0;
   default:

    break;
  }
 } else {

 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_UNSET_OBJ_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **container;
 zval *offset;

 ;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 offset = opline->op2.zv;

 if ((1<<2) != (1<<2) || container) {
  if ((1<<2) == (1<<4) && container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
  if ((**container).type == 5) {
   if (0) {
    do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
   }
   if ((**container).value.obj.handlers->unset_property) {
    (**container).value.obj.handlers->unset_property(*container, offset, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   } else {
    zend_error((1<<3L), "Trying to unset property of non-object");
   }
   if (0) {
    i_zval_ptr_dtor(*(&offset) );
   } else {

   }
  } else {

  }
 } else {

 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ISSET_ISEMPTY_VAR_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval **value;
 zend_bool isset = 1;

 ;
 if ((1<<2) == (1<<4) &&
     (1<<0) == (1<<3) &&
     (opline->extended_value & 0x00800000)) {
  if (execute_data->CVs[opline->op1.var]) {
   value = execute_data->CVs[opline->op1.var];
  } else if ((executor_globals.active_symbol_table)) {
   zend_compiled_variable *cv = &((executor_globals.active_op_array)->vars[opline->op1.var]);

   if (zend_hash_quick_find((executor_globals.active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, (void **) &value) == -1) {
    isset = 0;
   }
  } else {
   isset = 0;
  }
 } else {
  HashTable *target_symbol_table;
  zend_free_op free_op1;
  zval tmp, *varname = _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

  if ((1<<2) != (1<<0) && (*varname).type != 6) {
   do { (&tmp)->value = (varname)->value; (*&tmp).type = (*varname).type; } while (0);
   _zval_copy_ctor((&tmp) );
   if ((&tmp)->type != 6) { _convert_to_string((&tmp) ); };
   varname = &tmp;
  }

  if ((1<<0) != (1<<3)) {
   zend_class_entry *ce;

   if ((1<<0) == (1<<0)) {
    if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
     ce = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
    } else {
     ce = zend_fetch_class_by_name((*opline->op2.zv).value.str.val, (*opline->op2.zv).value.str.len, opline->op2.literal + 1, 0 );
     do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); } while (0);
    }
   } else {
    ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).class_entry;
   }
   value = zend_std_get_static_property(ce, (*varname).value.str.val, (*varname).value.str.len, 1, (((1<<2) == (1<<0)) ? opline->op1.literal : ((void *)0)) );
   if (!value) {
    isset = 0;
   }
  } else {
   target_symbol_table = zend_get_target_symbol_table(opline->extended_value & 0x70000000 );
   if (zend_hash_find(target_symbol_table, varname->value.str.val, varname->value.str.len+1, (void **) &value) == -1) {
    isset = 0;
   }
  }

  if ((1<<2) != (1<<0) && varname == &tmp) {
   _zval_dtor((&tmp) );
  }
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 }

 if (opline->extended_value & 0x02000000) {
  if (isset && (**value).type != 0) {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((1) != 0); (*__z).type = 3; } while (0);
  } else {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((0) != 0); (*__z).type = 3; } while (0);
  }
 } else {
  if (!isset || !i_zend_is_true(*value)) {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((1) != 0); (*__z).type = 3; } while (0);
  } else {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((0) != 0); (*__z).type = 3; } while (0);
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_CONST(int prop_dim, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **container;
 zval **value = ((void *)0);
 int result = 0;
 ulong hval;
 zval *offset;

 ;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 offset = opline->op2.zv;

 if ((**container).type == 4 && !prop_dim) {
  HashTable *ht;
  int isset = 0;

  ht = (**container).value.ht;

  switch ((*offset).type) {
   case 2:
    hval = zend_dval_to_lval((*offset).value.dval);
    goto num_index_prop;
   case 7:
   case 3:
   case 1:
    hval = (*offset).value.lval;
num_index_prop:
    if (zend_hash_index_find(ht, hval, (void **) &value) == 0) {
     isset = 1;
    }
    break;
   case 6:
    if ((1<<0) == (1<<0)) {
     hval = (((zend_literal*)(offset))->hash_value);
    } else {
     if (!prop_dim) {
      do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index_prop; } } } while (0);
     }
     if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
      hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
     } else {
      hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
     }
    }
    if (zend_hash_quick_find(ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, (void **) &value) == 0) {
     isset = 1;
    }
    break;
   case 0:
    if (zend_hash_find(ht, "", sizeof(""), (void **) &value) == 0) {
     isset = 1;
    }
    break;
   default:
    zend_error((1<<1L), "Illegal offset type in isset or empty");
    break;
  }

  if (opline->extended_value & 0x02000000) {
   if (isset && (**value).type == 0) {
    result = 0;
   } else {
    result = isset;
   }
  } else {
   if (!isset || !i_zend_is_true(*value)) {
    result = 0;
   } else {
    result = 1;
   }
  }

 } else if ((**container).type == 5) {
  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
  }
  if (prop_dim) {
   if ((**container).value.obj.handlers->has_property) {
    result = (**container).value.obj.handlers->has_property(*container, offset, (opline->extended_value & 0x01000000) != 0, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   } else {
    zend_error((1<<3L), "Trying to check property of non-object");
    result = 0;
   }
  } else {
   if ((**container).value.obj.handlers->has_dimension) {
    result = (**container).value.obj.handlers->has_dimension(*container, offset, (opline->extended_value & 0x01000000) != 0 );
   } else {
    zend_error((1<<3L), "Trying to check element of non-array");
    result = 0;
   }
  }
  if (0) {
   i_zval_ptr_dtor(*(&offset) );
  } else {

  }
 } else if ((*container)->type == 6 && !prop_dim) {
  zval tmp;

  if ((*offset).type != 1) {
   do { (&tmp)->value = (offset)->value; (*&tmp).type = (*offset).type; } while (0);
   _zval_copy_ctor((&tmp) );
   convert_to_long(&tmp);
   offset = &tmp;
  }
  if ((*offset).type == 1) {
   if (opline->extended_value & 0x02000000) {
    if (offset->value.lval >= 0 && offset->value.lval < (**container).value.str.len) {
     result = 1;
    }
   } else {
    if (offset->value.lval >= 0 && offset->value.lval < (**container).value.str.len && (**container).value.str.val[offset->value.lval] != '0') {
     result = 1;
    }
   }
  }

 } else {

 }

 ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).type = 3;
 if (opline->extended_value & 0x02000000) {
  ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.lval = result;
 } else {
  ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.lval = !result;
 }

 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_CONST(0, execute_data );
}

static int __attribute__((fastcall)) ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_VAR_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_CONST(1, execute_data );
}

static int __attribute__((fastcall)) ZEND_ADD_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 add_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SUB_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 sub_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_MUL_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 mul_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_DIV_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 div_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_MOD_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 mod_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SL_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 shift_left_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SR_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 shift_right_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_CONCAT_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 concat_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_IDENTICAL_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 is_identical_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_NOT_IDENTICAL_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 is_identical_function(result,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 (*result).value.lval = !(*result).value.lval;
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_EQUAL_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval == 0)) != 0); (*__z).type = 3; } while (0);
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_NOT_EQUAL_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval != 0)) != 0); (*__z).type = 3; } while (0);
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_SMALLER_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval < 0)) != 0); (*__z).type = 3; } while (0);
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_SMALLER_OR_EQUAL_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval <= 0)) != 0); (*__z).type = 3; } while (0);
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_OR_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 bitwise_or_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_AND_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 bitwise_and_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_XOR_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 bitwise_xor_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BOOL_XOR_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 boolean_xor_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_binary_assign_op_obj_helper_SPEC_VAR_TMP(int (*binary_op)(zval *result, zval *op1, zval *op2 ), zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2, free_op_data1;
 zval **object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 zval *object;
 zval *property = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );
 zval *value = _get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, &free_op_data1, 0 );
 int have_get_ptr = 0;

 if ((1<<2) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }

 make_real_object(object_ptr );
 object = *object_ptr;

 if (__builtin_expect((*object).type != 5, 0)) {
  zend_error((1<<1L), "Attempt to assign property of non-object");
  _zval_dtor((free_op2.var) );
  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };

  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = &(executor_globals.uninitialized_zval);
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
  }
 } else {

  if (1) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
  }


  if (opline->extended_value == 136
   && (*object).value.obj.handlers->get_property_ptr_ptr) {
   zval **zptr = (*object).value.obj.handlers->get_property_ptr_ptr(object, property, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   if (zptr != ((void *)0)) {
    if (!zval_isref_p(*zptr)) { do { if (zval_refcount_p(*((zptr))) > 1) { zval *new_zv; zval_delref_p(*(zptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(zptr))->value; (*new_zv).type = (**(zptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(zptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

    have_get_ptr = 1;
    binary_op(*zptr, *zptr, value );
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((*zptr));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = *zptr;
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
   }
  }

  if (!have_get_ptr) {
   zval *z = ((void *)0);

   if (opline->extended_value == 136) {
    if ((*object).value.obj.handlers->read_property) {
     z = (*object).value.obj.handlers->read_property(object, property, 0, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
    }
   } else {
    if ((*object).value.obj.handlers->read_dimension) {
     z = (*object).value.obj.handlers->read_dimension(object, property, 0 );
    }
   }
   if (z) {
    if ((*z).type == 5 && (*z).value.obj.handlers->get) {
     zval *value = (*z).value.obj.handlers->get(z );

     if (zval_refcount_p(z) == 0) {
      if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); };
      _zval_dtor((z) );
      do { if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); }; _efree((z) ); } while (0);
     }
     z = value;
    }
    zval_addref_p(z);
    if (!zval_isref_p(*&z)) { do { if (zval_refcount_p(*((&z))) > 1) { zval *new_zv; zval_delref_p(*(&z)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(&z))->value; (*new_zv).type = (**(&z)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(&z) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
    binary_op(z, z, value );
    if (opline->extended_value == 136) {
     (*object).value.obj.handlers->write_property(object, property, z, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
    } else {
     (*object).value.obj.handlers->write_dimension(object, property, z );
    }
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((z));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = z;
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
    i_zval_ptr_dtor(*(&z) );
   } else {
    zend_error((1<<1L), "Attempt to assign property of non-object");
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((&(executor_globals.uninitialized_zval)));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = &(executor_globals.uninitialized_zval);
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
   }
  }

  if (1) {
   i_zval_ptr_dtor(*(&property) );
  } else {
   _zval_dtor((free_op2.var) );
  }
  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };
 }

 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_binary_assign_op_helper_SPEC_VAR_TMP(int (*binary_op)(zval *result, zval *op1, zval *op2 ), zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2, free_op_data2, free_op_data1;
 zval **var_ptr;
 zval *value;

 ;
 switch (opline->extended_value) {
  case 136:
   return zend_binary_assign_op_obj_helper_SPEC_VAR_TMP(binary_op, execute_data );
   break;
  case 147: {
    zval **container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

    if ((1<<2) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
     zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
    } else if (__builtin_expect((**container).type == 5, 0)) {
     if ((1<<2) == (1<<2) && !(free_op1.var != ((void *)0))) {
      zval_addref_p(*(container));
     }
     return zend_binary_assign_op_obj_helper_SPEC_VAR_TMP(binary_op, execute_data );
    } else {
     zval *dim = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );

     zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)), container, dim, (1<<1), 2 );
     value = _get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, &free_op_data1, 0 );
     var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data->Ts, &free_op_data2 );
    }
   }
   break;
  default:
   value = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );
   var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

   break;
 }

 if (__builtin_expect(var_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use assign-op operators with overloaded objects nor string offsets");
 }

 if (__builtin_expect(*var_ptr == &(executor_globals.error_zval), 0)) {
  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }
  _zval_dtor((free_op2.var) );
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
  ;
  if (opline->extended_value == 147) {
   execute_data->opline++;
  }
  execute_data->opline++; return 0;
 }

 if (!zval_isref_p(*var_ptr)) { do { if (zval_refcount_p(*((var_ptr))) > 1) { zval *new_zv; zval_delref_p(*(var_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(var_ptr))->value; (*new_zv).type = (**(var_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(var_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

 if (__builtin_expect((**var_ptr).type == 5, 0)
    && ((**var_ptr)).value.obj.handlers->get
    && ((**var_ptr)).value.obj.handlers->set) {

  zval *objval = ((**var_ptr)).value.obj.handlers->get(*var_ptr );
  zval_addref_p(objval);
  binary_op(objval, objval, value );
  ((**var_ptr)).value.obj.handlers->set(var_ptr, objval );
  i_zval_ptr_dtor(*(&objval) );
 } else {
  binary_op(*var_ptr, *var_ptr, value );
 }

 if ((!((opline)->result_type & (1<<5)))) {
  zval_addref_p((*var_ptr));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (*var_ptr); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
 }
 _zval_dtor((free_op2.var) );

 if (opline->extended_value == 147) {
  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };
  if (free_op_data2.var) { i_zval_ptr_dtor(*(&free_op_data2.var) ); };
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
  ;
  execute_data->opline++;
 } else {
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
  ;
 }
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_ADD_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_TMP(add_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SUB_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_TMP(sub_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_MUL_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_TMP(mul_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_DIV_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_TMP(div_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_MOD_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_TMP(mod_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SL_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_TMP(shift_left_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SR_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_TMP(shift_right_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_CONCAT_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_TMP(concat_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_OR_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_TMP(bitwise_or_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_AND_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_TMP(bitwise_and_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_XOR_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_TMP(bitwise_xor_function, execute_data );
}

static int __attribute__((fastcall)) zend_pre_incdec_property_helper_SPEC_VAR_TMP(incdec_t incdec_op, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval **object_ptr;
 zval *object;
 zval *property;
 zval **retval;
 int have_get_ptr = 0;

 ;
 object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 property = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );
 retval = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr;

 if ((1<<2) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot increment/decrement overloaded objects nor string offsets");
 }

 make_real_object(object_ptr );
 object = *object_ptr;

 if (__builtin_expect((*object).type != 5, 0)) {
  zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
  _zval_dtor((free_op2.var) );
  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   *retval = &(executor_globals.uninitialized_zval);
  }
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
  ;
  execute_data->opline++; return 0;
 }



 if (1) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }

 if ((*object).value.obj.handlers->get_property_ptr_ptr) {
  zval **zptr = (*object).value.obj.handlers->get_property_ptr_ptr(object, property, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
  if (zptr != ((void *)0)) {
   if (!zval_isref_p(*zptr)) { do { if (zval_refcount_p(*((zptr))) > 1) { zval *new_zv; zval_delref_p(*(zptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(zptr))->value; (*new_zv).type = (**(zptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(zptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

   have_get_ptr = 1;
   incdec_op(*zptr);
   if ((!((opline)->result_type & (1<<5)))) {
    *retval = *zptr;
    zval_addref_p((*retval));
   }
  }
 }

 if (!have_get_ptr) {
  if ((*object).value.obj.handlers->read_property && (*object).value.obj.handlers->write_property) {
   zval *z = (*object).value.obj.handlers->read_property(object, property, 0, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );

   if (__builtin_expect((*z).type == 5, 0) && (*z).value.obj.handlers->get) {
    zval *value = (*z).value.obj.handlers->get(z );

    if (zval_refcount_p(z) == 0) {
     if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); };
     _zval_dtor((z) );
     do { if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); }; _efree((z) ); } while (0);
    }
    z = value;
   }
   zval_addref_p(z);
   if (!zval_isref_p(*&z)) { do { if (zval_refcount_p(*((&z))) > 1) { zval *new_zv; zval_delref_p(*(&z)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(&z))->value; (*new_zv).type = (**(&z)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(&z) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
   incdec_op(z);
   *retval = z;
   (*object).value.obj.handlers->write_property(object, property, z, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   if ((!((opline)->result_type & (1<<5)))) { zval_addref_p((*retval)); };
   i_zval_ptr_dtor(*(&z) );
  } else {
   zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
   if ((!((opline)->result_type & (1<<5)))) {
    zval_addref_p((&(executor_globals.uninitialized_zval)));
    *retval = &(executor_globals.uninitialized_zval);
   }
  }
 }

 if (1) {
  i_zval_ptr_dtor(*(&property) );
 } else {
  _zval_dtor((free_op2.var) );
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_PRE_INC_OBJ_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_pre_incdec_property_helper_SPEC_VAR_TMP(increment_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_PRE_DEC_OBJ_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_pre_incdec_property_helper_SPEC_VAR_TMP(decrement_function, execute_data );
}

static int __attribute__((fastcall)) zend_post_incdec_property_helper_SPEC_VAR_TMP(incdec_t incdec_op, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval **object_ptr;
 zval *object;
 zval *property;
 zval *retval;
 int have_get_ptr = 0;

 ;
 object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 property = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );
 retval = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 if ((1<<2) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot increment/decrement overloaded objects nor string offsets");
 }

 make_real_object(object_ptr );
 object = *object_ptr;

 if (__builtin_expect((*object).type != 5, 0)) {
  zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
  _zval_dtor((free_op2.var) );
  { (*retval).type = 0; };
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
  ;
  execute_data->opline++; return 0;
 }



 if (1) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }

 if ((*object).value.obj.handlers->get_property_ptr_ptr) {
  zval **zptr = (*object).value.obj.handlers->get_property_ptr_ptr(object, property, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
  if (zptr != ((void *)0)) {
   have_get_ptr = 1;
   if (!zval_isref_p(*zptr)) { do { if (zval_refcount_p(*((zptr))) > 1) { zval *new_zv; zval_delref_p(*(zptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(zptr))->value; (*new_zv).type = (**(zptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(zptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

   do { (retval)->value = (*zptr)->value; (*retval).type = (**zptr).type; } while (0);
   _zval_copy_ctor((&(*retval)) );

   incdec_op(*zptr);

  }
 }

 if (!have_get_ptr) {
  if ((*object).value.obj.handlers->read_property && (*object).value.obj.handlers->write_property) {
   zval *z = (*object).value.obj.handlers->read_property(object, property, 0, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   zval *z_copy;

   if (__builtin_expect((*z).type == 5, 0) && (*z).value.obj.handlers->get) {
    zval *value = (*z).value.obj.handlers->get(z );

    if (zval_refcount_p(z) == 0) {
     if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); };
     _zval_dtor((z) );
     do { if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); }; _efree((z) ); } while (0);
    }
    z = value;
   }
   do { (retval)->value = (z)->value; (*retval).type = (*z).type; } while (0);
   _zval_copy_ctor((&(*retval)) );
   do { (z_copy) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(z_copy))->u.buffered = ((void *)0); } while (0);
   do { do { (z_copy)->value = (z)->value; (*z_copy).type = (*z).type; } while (0); zval_set_refcount_p(z_copy, 1); zval_unset_isref_p(z_copy); } while (0);
   _zval_copy_ctor((&(*z_copy)) );
   incdec_op(z_copy);
   zval_addref_p(z);
   (*object).value.obj.handlers->write_property(object, property, z_copy, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   i_zval_ptr_dtor(*(&z_copy) );
   i_zval_ptr_dtor(*(&z) );
  } else {
   zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
   { (*retval).type = 0; };
  }
 }

 if (1) {
  i_zval_ptr_dtor(*(&property) );
 } else {
  _zval_dtor((free_op2.var) );
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_POST_INC_OBJ_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_post_incdec_property_helper_SPEC_VAR_TMP(increment_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_POST_DEC_OBJ_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_post_incdec_property_helper_SPEC_VAR_TMP(decrement_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_R_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval **container;

 ;

 if ((opline->extended_value & 0x08000000) &&
     (1<<2) != (1<<4) &&
     (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr) {
  zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr));
 }
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 zend_fetch_dimension_address_read(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ), (1<<1), 0 );
 _zval_dtor((free_op2.var) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_W_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval **container;

 ;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<2) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ), (1<<1), 1 );
 _zval_dtor((free_op2.var) );
 if ((1<<2) == (1<<2) && (free_op1.var != ((void *)0)) && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};


 if (__builtin_expect(opline->extended_value != 0, 0)) {
  zval **retval_ptr = (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr;

  if (retval_ptr) {
   zval_delref_p(*(retval_ptr));
   if (!zval_isref_p(*retval_ptr)) { do { if (zval_refcount_p(*((retval_ptr))) > 1) { zval *new_zv; zval_delref_p(*(retval_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval_ptr))->value; (*new_zv).type = (**(retval_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((retval_ptr))); };
   zval_addref_p(*(retval_ptr));
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_RW_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval **container;

 ;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<2) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ), (1<<1), 2 );
 _zval_dtor((free_op2.var) );
 if ((1<<2) == (1<<2) && (free_op1.var != ((void *)0)) && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_IS_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval **container;

 ;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 zend_fetch_dimension_address_read(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ), (1<<1), 3 );
 _zval_dtor((free_op2.var) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval **container;

 ;

 if (((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && (opline->extended_value & 0x000fffff) <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[(opline->extended_value & 0x000fffff)-1].pass_by_reference & (1|2)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x1000000|0x2000000))))) {
  container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
  if ((1<<2) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
  }
  zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ), (1<<1), 1 );
  if ((1<<2) == (1<<2) && (free_op1.var != ((void *)0)) && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
  }
 } else {
  if ((1<<1) == (1<<3)) {
   zend_error_noreturn((1<<0L), "Cannot use [] for reading");
  }
  container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
  zend_fetch_dimension_address_read(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ), (1<<1), 0 );
 }
 _zval_dtor((free_op2.var) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_UNSET_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval **container;

 ;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<2) == (1<<4)) {
  if (container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
 }
 if ((1<<2) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ), (1<<1), 6 );
 _zval_dtor((free_op2.var) );
 if ((1<<2) == (1<<2) && (free_op1.var != ((void *)0)) && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 if (__builtin_expect((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot unset string offsets");
 } else {
  zend_free_op free_res;
  zval **retval_ptr = (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr;

  zend_pzval_unlock_func(*retval_ptr, &free_res, 1 );
  if (retval_ptr != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*retval_ptr)) { do { if (zval_refcount_p(*((retval_ptr))) > 1) { zval *new_zv; zval_delref_p(*(retval_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval_ptr))->value; (*new_zv).type = (**(retval_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
  zval_addref_p((*retval_ptr));
  if (free_res.var) { i_zval_ptr_dtor(*(&free_res.var) ); };
  ;
  execute_data->opline++; return 0;
 }
}

static int __attribute__((fastcall)) zend_fetch_property_address_read_helper_SPEC_VAR_TMP(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *container;
 zend_free_op free_op2;
 zval *offset;

 ;
 container = _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 offset = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );

 if (__builtin_expect((*container).type != 5, 0) ||
     __builtin_expect((*container).value.obj.handlers->read_property == ((void *)0), 0)) {
  zend_error((1<<3L), "Trying to get property of non-object");
  zval_addref_p((&(executor_globals.uninitialized_zval)));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  _zval_dtor((free_op2.var) );
 } else {
  zval *retval;

  if (1) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
  }


  retval = (*container).value.obj.handlers->read_property(container, offset, 0, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );

  zval_addref_p((retval));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);

  if (1) {
   i_zval_ptr_dtor(*(&offset) );
  } else {
   _zval_dtor((free_op2.var) );
  }
 }

 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_R_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_property_address_read_helper_SPEC_VAR_TMP(execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_W_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval *property;
 zval **container;

 ;
 property = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((1<<2) == (1<<2) && (opline->extended_value & 0x08000000)) {
  zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr));
  (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr = *(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr;
 }

 if (1) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 if ((1<<2) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }

 zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)), 1 );
 if (1) {
  i_zval_ptr_dtor(*(&property) );
 } else {
  _zval_dtor((free_op2.var) );
 }
 if ((1<<2) == (1<<2) && (free_op1.var != ((void *)0)) && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};


 if (opline->extended_value & 0x04000000) {
  zval **retval_ptr = (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr;

  zval_delref_p(*(retval_ptr));
  if (!zval_isref_p(*retval_ptr)) { do { if (zval_refcount_p(*((retval_ptr))) > 1) { zval *new_zv; zval_delref_p(*(retval_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval_ptr))->value; (*new_zv).type = (**(retval_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((retval_ptr))); };
  zval_addref_p(*(retval_ptr));
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_RW_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval *property;
 zval **container;

 ;
 property = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if (1) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }
 if ((1<<2) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }
 zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)), 2 );
 if (1) {
  i_zval_ptr_dtor(*(&property) );
 } else {
  _zval_dtor((free_op2.var) );
 }
 if ((1<<2) == (1<<2) && (free_op1.var != ((void *)0)) && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_IS_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *container;
 zend_free_op free_op2;
 zval *offset;

 ;
 container = _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 offset = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );

 if (__builtin_expect((*container).type != 5, 0) ||
     __builtin_expect((*container).value.obj.handlers->read_property == ((void *)0), 0)) {
  zval_addref_p((&(executor_globals.uninitialized_zval)));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  _zval_dtor((free_op2.var) );
 } else {
  zval *retval;

  if (1) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
  }


  retval = (*container).value.obj.handlers->read_property(container, offset, 3, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );

  zval_addref_p((retval));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);

  if (1) {
   i_zval_ptr_dtor(*(&offset) );
  } else {
   _zval_dtor((free_op2.var) );
  }
 }

 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 if (((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && (opline->extended_value & 0x000fffff) <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[(opline->extended_value & 0x000fffff)-1].pass_by_reference & (1|2)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x1000000|0x2000000))))) {

  zend_free_op free_op1, free_op2;
  zval *property;
  zval **container;

  ;
  property = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );
  container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

  if (1) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
  }
  if ((1<<2) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
  }
  zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)), 1 );
  if (1) {
   i_zval_ptr_dtor(*(&property) );
  } else {
   _zval_dtor((free_op2.var) );
  }
  if ((1<<2) == (1<<2) && (free_op1.var != ((void *)0)) && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
  }
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
  ;
  execute_data->opline++; return 0;
 } else {
  return zend_fetch_property_address_read_helper_SPEC_VAR_TMP(execute_data );
 }
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_UNSET_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2, free_res;
 zval **container;
 zval *property;

 ;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 property = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((1<<2) == (1<<4)) {
  if (container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
 }
 if (1) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }
 if ((1<<2) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }
 zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)), 6 );
 if (1) {
  i_zval_ptr_dtor(*(&property) );
 } else {
  _zval_dtor((free_op2.var) );
 }
 if ((1<<2) == (1<<2) && (free_op1.var != ((void *)0)) && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 zend_pzval_unlock_func(*(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr, &free_res, 1 );
 if ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr != &(executor_globals.uninitialized_zval_ptr)) {
  if (!zval_isref_p(*(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr)) { do { if (zval_refcount_p(*(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr))->value; (*new_zv).type = (**((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
 }
 zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr));
 if (free_res.var) { i_zval_ptr_dtor(*(&free_res.var) ); };
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_OBJ_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval **object_ptr;
 zval *property_name;

 ;
 object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 property_name = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );

 if (1) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property_name))->value; (*_tmp).type = (*(property_name)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property_name) = _tmp; } while (0);
 }
 if ((1<<2) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 zend_assign_to_object((!((opline)->result_type & (1<<5)))?&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr:((void *)0), object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, 136, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
 if (1) {
  i_zval_ptr_dtor(*(&property_name) );
 } else {
  _zval_dtor((free_op2.var) );
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_DIM_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **object_ptr;

 ;
 object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<2) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 if ((**object_ptr).type == 5) {
  zend_free_op free_op2;
  zval *property_name = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );

  if (1) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property_name))->value; (*_tmp).type = (*(property_name)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property_name) = _tmp; } while (0);
  }
  zend_assign_to_object((!((opline)->result_type & (1<<5)))?&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr:((void *)0), object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, 147, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
  if (1) {
   i_zval_ptr_dtor(*(&property_name) );
  } else {
   _zval_dtor((free_op2.var) );
  }
 } else {
  zend_free_op free_op2, free_op_data1, free_op_data2;
  zval *value;
  zval *dim = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );
  zval **variable_ptr_ptr;

  zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)), object_ptr, dim, (1<<1), 1 );
  _zval_dtor((free_op2.var) );

  value = _get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, &free_op_data1, 0 );
  variable_ptr_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data->Ts, &free_op_data2 );
  if (__builtin_expect(variable_ptr_ptr == ((void *)0), 0)) {
   if (zend_assign_to_string_offset(&(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)), value, (opline+1)->op1_type )) {
    if ((!((opline)->result_type & (1<<5)))) {
     zval *retval;

     do { (retval) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(retval))->u.buffered = ((void *)0); } while (0);
     do { const char *__s=((*(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)).str_offset.str).value.str.val+(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)).str_offset.offset); int __l=1; zval *__z = (retval); (*__z).value.str.len = __l; (*__z).value.str.val = (1?_estrndup((__s), (__l) ):(char*)__s); (*__z).type = 6; } while (0);
     (retval)->refcount__gc = 1; (retval)->is_ref__gc = 0;;
     do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
    }
   } else if ((!((opline)->result_type & (1<<5)))) {
    zval_addref_p((&(executor_globals.uninitialized_zval)));
    do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   }
  } else if (__builtin_expect(*variable_ptr_ptr == &(executor_globals.error_zval), 0)) {
   if (((zend_uintptr_t)free_op_data1.var & 1L)) {
    _zval_dtor((value) );
   }
   if ((!((opline)->result_type & (1<<5)))) {
    zval_addref_p((&(executor_globals.uninitialized_zval)));
    do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   }
  } else {
   if ((opline+1)->op1_type == (1<<1)) {
     value = zend_assign_tmp_to_variable(variable_ptr_ptr, value );
   } else if ((opline+1)->op1_type == (1<<0)) {
     value = zend_assign_const_to_variable(variable_ptr_ptr, value );
   } else {
     value = zend_assign_to_variable(variable_ptr_ptr, value );
   }
   if ((!((opline)->result_type & (1<<5)))) {
    zval_addref_p((value));
    do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (value); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   }
  }
  if (free_op_data2.var) { i_zval_ptr_dtor(*(&free_op_data2.var) ); };
   if (free_op_data1.var != ((void *)0) && (((zend_uintptr_t)free_op_data1.var & 1L) == 0)) { i_zval_ptr_dtor(*(&free_op_data1.var) ); };
 }
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval *value;
 zval **variable_ptr_ptr;

 ;
 value = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );
 variable_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<2) == (1<<2) && __builtin_expect(variable_ptr_ptr == ((void *)0), 0)) {
  if (zend_assign_to_string_offset(&(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)), value, (1<<1) )) {
   if ((!((opline)->result_type & (1<<5)))) {
    zval *retval;

    do { (retval) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(retval))->u.buffered = ((void *)0); } while (0);
    do { const char *__s=((*(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).str_offset.str).value.str.val+(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).str_offset.offset); int __l=1; zval *__z = (retval); (*__z).value.str.len = __l; (*__z).value.str.val = (1?_estrndup((__s), (__l) ):(char*)__s); (*__z).type = 6; } while (0);
    (retval)->refcount__gc = 1; (retval)->is_ref__gc = 0;;
    do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   }
  } else if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }
 } else if ((1<<2) == (1<<2) && __builtin_expect(*variable_ptr_ptr == &(executor_globals.error_zval), 0)) {
  if (1) {
   _zval_dtor((value) );
  }
  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }
 } else {
  if ((1<<1) == (1<<1)) {
    value = zend_assign_tmp_to_variable(variable_ptr_ptr, value );
  } else if ((1<<1) == (1<<0)) {
    value = zend_assign_const_to_variable(variable_ptr_ptr, value );
  } else {
    value = zend_assign_to_variable(variable_ptr_ptr, value );
  }
  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((value));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (value); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }
 }

 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};



 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_METHOD_CALL_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *function_name;
 char *function_name_strval;
 int function_name_strlen;
 zend_free_op free_op1, free_op2;

 ;
 zend_ptr_stack_3_push(&(executor_globals.arg_types_stack), execute_data->fbc, execute_data->object, execute_data->called_scope);

 function_name = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((1<<1) != (1<<0) &&
     __builtin_expect((*function_name).type != 6, 0)) {
  zend_error_noreturn((1<<0L), "Method name must be a string");
 }

 function_name_strval = (*function_name).value.str.val;
 function_name_strlen = (*function_name).value.str.len;

 execute_data->object = _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if (__builtin_expect(execute_data->object != ((void *)0), 1) &&
     __builtin_expect((*execute_data->object).type == 5, 1)) {
  execute_data->called_scope = zend_get_class_entry(&(*execute_data->object) );

  if ((1<<1) != (1<<0) ||
      (execute_data->fbc = (((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] == (execute_data->called_scope)) ? (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] : ((void *)0))) == ((void *)0)) {
      zval *object = execute_data->object;

   if (__builtin_expect((*execute_data->object).value.obj.handlers->get_method == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Object does not support method calls");
   }


   execute_data->fbc = (*execute_data->object).value.obj.handlers->get_method(&execute_data->object, function_name_strval, function_name_strlen, (((1<<1) == (1<<0)) ? (opline->op2.literal + 1) : ((void *)0)) );
   if (__builtin_expect(execute_data->fbc == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Call to undefined method %s::%s()", ((execute_data->object) && (*execute_data->object).type == 5 && (*execute_data->object).value.obj.handlers->get_class_entry != ((void *)0) && (*execute_data->object).value.obj.handlers->get_class_entry(execute_data->object ) ? (*execute_data->object).value.obj.handlers->get_class_entry(execute_data->object )->name : ""), function_name_strval);
   }
   if ((1<<1) == (1<<0) &&
       __builtin_expect((execute_data->fbc->common.fn_flags & 0x200000) == 0, 1) &&
       __builtin_expect(execute_data->object == object, 1)) {
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (execute_data->called_scope); (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] = (execute_data->fbc); } while (0);
   }
  }
 } else {
  zend_error_noreturn((1<<0L), "Call to a member function %s() on a non-object", function_name_strval);
 }

 if ((execute_data->fbc->common.fn_flags & 0x01) != 0) {
  execute_data->object = ((void *)0);
 } else {
  if (!zval_isref_p(execute_data->object)) {
   zval_addref_p(execute_data->object);
  } else {
   zval *this_ptr;
   do { (this_ptr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(this_ptr))->u.buffered = ((void *)0); } while (0);
   do { do { (this_ptr)->value = (execute_data->object)->value; (*this_ptr).type = (*execute_data->object).type; } while (0); zval_set_refcount_p(this_ptr, 1); zval_unset_isref_p(this_ptr); } while (0);
   _zval_copy_ctor((this_ptr) );
   execute_data->object = this_ptr;
  }
 }

 _zval_dtor((free_op2.var) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *function_name;
 zend_class_entry *ce;

 ;
 zend_ptr_stack_3_push(&(executor_globals.arg_types_stack), execute_data->fbc, execute_data->object, execute_data->called_scope);

 if ((1<<2) == (1<<0)) {

  if ((executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)]) {
   ce = (executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)];
  } else {
   ce = zend_fetch_class_by_name((*opline->op1.zv).value.str.val, (*opline->op1.zv).value.str.len, opline->op1.literal + 1, opline->extended_value );
   if (__builtin_expect(ce == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Class '%s' not found", (*opline->op1.zv).value.str.val);
   }
   do { (executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)] = (ce); } while (0);
  }
  execute_data->called_scope = ce;
 } else {
  ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).class_entry;

  if (opline->extended_value == 2 || opline->extended_value == 1) {
   execute_data->called_scope = (executor_globals.called_scope);
  } else {
   execute_data->called_scope = ce;
  }
 }

 if ((1<<2) == (1<<0) &&
     (1<<1) == (1<<0) &&
     (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
  execute_data->fbc = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
 } else if ((1<<2) != (1<<0) &&
            (1<<1) == (1<<0) &&
            (execute_data->fbc = (((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] == (ce)) ? (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] : ((void *)0)))) {

 } else if ((1<<1) != (1<<3)) {
  char *function_name_strval = ((void *)0);
  int function_name_strlen = 0;
  zend_free_op free_op2;

  if ((1<<1) == (1<<0)) {
   function_name_strval = (*opline->op2.zv).value.str.val;
   function_name_strlen = (*opline->op2.zv).value.str.len;
  } else {
   function_name = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );

   if (__builtin_expect((*function_name).type != 6, 0)) {
    zend_error_noreturn((1<<0L), "Function name must be a string");
   } else {
    function_name_strval = (*function_name).value.str.val;
    function_name_strlen = (*function_name).value.str.len;
    }
  }

  if (function_name_strval) {
   if (ce->get_static_method) {
    execute_data->fbc = ce->get_static_method(ce, function_name_strval, function_name_strlen );
   } else {
    execute_data->fbc = zend_std_get_static_method(ce, function_name_strval, function_name_strlen, (((1<<1) == (1<<0)) ? (opline->op2.literal + 1) : ((void *)0)) );
   }
   if (__builtin_expect(execute_data->fbc == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Call to undefined method %s::%s()", ce->name, function_name_strval);
   }
   if ((1<<1) == (1<<0) && __builtin_expect((execute_data->fbc->common.fn_flags & 0x200000) == 0, 1)) {
    if ((1<<2) == (1<<0)) {
     do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (execute_data->fbc); } while (0);
    } else {
     do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] = (execute_data->fbc); } while (0);
    }
   }
  }
  if ((1<<1) != (1<<0)) {
   _zval_dtor((free_op2.var) );
  }
 } else {
  if (__builtin_expect(ce->constructor == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot call constructor");
  }
  if ((executor_globals.This) && zend_get_class_entry(&(*(executor_globals.This)) ) != ce->constructor->common.scope && (ce->constructor->common.fn_flags & 0x400)) {
   zend_error_noreturn((1<<0L), "Cannot call private %s::__construct()", ce->name);
  }
  execute_data->fbc = ce->constructor;
 }

 if (execute_data->fbc->common.fn_flags & 0x01) {
  execute_data->object = ((void *)0);
 } else {
  if ((executor_globals.This) &&
      (*(executor_globals.This)).value.obj.handlers->get_class_entry &&
      !instanceof_function(zend_get_class_entry(&(*(executor_globals.This)) ), ce )) {


   if (execute_data->fbc->common.fn_flags & 0x10000) {
    zend_error((1<<11L), "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", execute_data->fbc->common.scope->name, execute_data->fbc->common.function_name);
   } else {

    zend_error_noreturn((1<<0L), "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", execute_data->fbc->common.scope->name, execute_data->fbc->common.function_name);
   }
  }
  if ((execute_data->object = (executor_globals.This))) {
   zval_addref_p(execute_data->object);
   execute_data->called_scope = zend_get_class_entry(&(*execute_data->object) );
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_CASE_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 if ((1<<2)==(1<<2)) {
  zval_addref_p(((*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr));
 }
 is_equal_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
     _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
     _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );

 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *expr_ptr;

 ;
 if (((1<<2) == (1<<2) || (1<<2) == (1<<4)) && opline->extended_value) {
  zval **expr_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

  if ((1<<2) == (1<<2) && __builtin_expect(expr_ptr_ptr == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot create references to/from string offsets");
  }
  if (!zval_isref_p(*expr_ptr_ptr)) { do { if (zval_refcount_p(*((expr_ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(expr_ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(expr_ptr_ptr))->value; (*new_zv).type = (**(expr_ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(expr_ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((expr_ptr_ptr))); };
  expr_ptr = *expr_ptr_ptr;
  zval_addref_p(expr_ptr);
 } else {
  expr_ptr=_get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
  if (0) {
   zval *new_expr;

   do { (new_expr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_expr))->u.buffered = ((void *)0); } while (0);
   do { do { (new_expr)->value = (expr_ptr)->value; (*new_expr).type = (*expr_ptr).type; } while (0); zval_set_refcount_p(new_expr, 1); zval_unset_isref_p(new_expr); } while (0);
   expr_ptr = new_expr;
  } else if ((1<<2) == (1<<0) || zval_isref_p(expr_ptr)) {
   zval *new_expr;

   do { (new_expr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_expr))->u.buffered = ((void *)0); } while (0);
   do { do { (new_expr)->value = (expr_ptr)->value; (*new_expr).type = (*expr_ptr).type; } while (0); zval_set_refcount_p(new_expr, 1); zval_unset_isref_p(new_expr); } while (0);
   expr_ptr = new_expr;
   _zval_copy_ctor((&(*expr_ptr)) );
  } else {
   zval_addref_p(expr_ptr);
  }
 }

 if ((1<<1) != (1<<3)) {
  zend_free_op free_op2;
  zval *offset = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );
  ulong hval;

  switch ((*offset).type) {
   case 2:
    hval = zend_dval_to_lval((*offset).value.dval);
    goto num_index;
   case 1:
   case 3:
    hval = (*offset).value.lval;
num_index:
    _zend_hash_index_update_or_next_insert(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, hval, &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   case 6:
    if ((1<<1) == (1<<0)) {
     hval = (((zend_literal*)(offset))->hash_value);
    } else {
     do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index; } } } while (0);
     if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
      hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
     } else {
      hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
     }
    }
    _zend_hash_quick_add_or_update(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   case 0:
    _zend_hash_add_or_update(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, "", sizeof(""), &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   default:
    zend_error((1<<1L), "Illegal offset type");
    i_zval_ptr_dtor(*(&expr_ptr) );

    break;
  }
  _zval_dtor((free_op2.var) );
 } else {
  _zend_hash_index_update_or_next_insert(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, 0, &expr_ptr, sizeof(zval *), ((void *)0), (1<<2) );
 }
 if (((1<<2) == (1<<2) || (1<<2) == (1<<4)) && opline->extended_value) {
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 } else {
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_ARRAY_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 _array_init((&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var), 0 );
 if ((1<<2) == (1<<3)) {
  execute_data->opline++; return 0;

 } else {
  return ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_TMP_HANDLER(execute_data );

 }
}

static int __attribute__((fastcall)) ZEND_UNSET_DIM_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval **container;
 zval *offset;
 ulong hval;

 ;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 offset = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((1<<2) != (1<<2) || container) {
  if ((1<<2) == (1<<4) && container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
  switch ((**container).type) {
   case 4: {
    HashTable *ht = (**container).value.ht;

    switch ((*offset).type) {
     case 2:
      hval = zend_dval_to_lval((*offset).value.dval);
      goto num_index_dim;
     case 7:
     case 3:
     case 1:
num_index_dim:
      hval = (*offset).value.lval;
      zend_hash_del_key_or_index(ht, ((void *)0), 0, hval, 1);
      break;
     case 6:
      if ((1<<1) == (1<<4) || (1<<1) == (1<<2)) {
       zval_addref_p(offset);
      }
      if ((1<<1) == (1<<0)) {
       hval = (((zend_literal*)(offset))->hash_value);
      } else {
       do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index_dim; } } } while (0);
       if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
        hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
       } else {
        hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
       }
      }
      if (ht == &(executor_globals.symbol_table)) {
       zend_delete_global_variable_ex(offset->value.str.val, offset->value.str.len, hval );
      } else {
       zend_hash_del_key_or_index(ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, 2);
      }
      if ((1<<1) == (1<<4) || (1<<1) == (1<<2)) {
       i_zval_ptr_dtor(*(&offset) );
      }
      break;
     case 0:
      zend_hash_del_key_or_index(ht, "", sizeof(""), 0, 0);
      break;
     default:
      zend_error((1<<1L), "Illegal offset type in unset");
      break;
    }
    _zval_dtor((free_op2.var) );
    break;
   }
   case 5:
    if (__builtin_expect((**container).value.obj.handlers->unset_dimension == ((void *)0), 0)) {
     zend_error_noreturn((1<<0L), "Cannot use object as array");
    }
    if (1) {
     do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
    }
    (**container).value.obj.handlers->unset_dimension(*container, offset );
    if (1) {
     i_zval_ptr_dtor(*(&offset) );
    } else {
     _zval_dtor((free_op2.var) );
    }
    break;
   case 6:
    zend_error_noreturn((1<<0L), "Cannot unset string offsets");
    return 0;
   default:
    _zval_dtor((free_op2.var) );
    break;
  }
 } else {
  _zval_dtor((free_op2.var) );
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_UNSET_OBJ_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval **container;
 zval *offset;

 ;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 offset = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((1<<2) != (1<<2) || container) {
  if ((1<<2) == (1<<4) && container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
  if ((**container).type == 5) {
   if (1) {
    do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
   }
   if ((**container).value.obj.handlers->unset_property) {
    (**container).value.obj.handlers->unset_property(*container, offset, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   } else {
    zend_error((1<<3L), "Trying to unset property of non-object");
   }
   if (1) {
    i_zval_ptr_dtor(*(&offset) );
   } else {
    _zval_dtor((free_op2.var) );
   }
  } else {
   _zval_dtor((free_op2.var) );
  }
 } else {
  _zval_dtor((free_op2.var) );
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_TMP(int prop_dim, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval **container;
 zval **value = ((void *)0);
 int result = 0;
 ulong hval;
 zval *offset;

 ;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 offset = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((**container).type == 4 && !prop_dim) {
  HashTable *ht;
  int isset = 0;

  ht = (**container).value.ht;

  switch ((*offset).type) {
   case 2:
    hval = zend_dval_to_lval((*offset).value.dval);
    goto num_index_prop;
   case 7:
   case 3:
   case 1:
    hval = (*offset).value.lval;
num_index_prop:
    if (zend_hash_index_find(ht, hval, (void **) &value) == 0) {
     isset = 1;
    }
    break;
   case 6:
    if ((1<<1) == (1<<0)) {
     hval = (((zend_literal*)(offset))->hash_value);
    } else {
     if (!prop_dim) {
      do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index_prop; } } } while (0);
     }
     if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
      hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
     } else {
      hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
     }
    }
    if (zend_hash_quick_find(ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, (void **) &value) == 0) {
     isset = 1;
    }
    break;
   case 0:
    if (zend_hash_find(ht, "", sizeof(""), (void **) &value) == 0) {
     isset = 1;
    }
    break;
   default:
    zend_error((1<<1L), "Illegal offset type in isset or empty");
    break;
  }

  if (opline->extended_value & 0x02000000) {
   if (isset && (**value).type == 0) {
    result = 0;
   } else {
    result = isset;
   }
  } else {
   if (!isset || !i_zend_is_true(*value)) {
    result = 0;
   } else {
    result = 1;
   }
  }
  _zval_dtor((free_op2.var) );
 } else if ((**container).type == 5) {
  if (1) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
  }
  if (prop_dim) {
   if ((**container).value.obj.handlers->has_property) {
    result = (**container).value.obj.handlers->has_property(*container, offset, (opline->extended_value & 0x01000000) != 0, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   } else {
    zend_error((1<<3L), "Trying to check property of non-object");
    result = 0;
   }
  } else {
   if ((**container).value.obj.handlers->has_dimension) {
    result = (**container).value.obj.handlers->has_dimension(*container, offset, (opline->extended_value & 0x01000000) != 0 );
   } else {
    zend_error((1<<3L), "Trying to check element of non-array");
    result = 0;
   }
  }
  if (1) {
   i_zval_ptr_dtor(*(&offset) );
  } else {
   _zval_dtor((free_op2.var) );
  }
 } else if ((*container)->type == 6 && !prop_dim) {
  zval tmp;

  if ((*offset).type != 1) {
   do { (&tmp)->value = (offset)->value; (*&tmp).type = (*offset).type; } while (0);
   _zval_copy_ctor((&tmp) );
   convert_to_long(&tmp);
   offset = &tmp;
  }
  if ((*offset).type == 1) {
   if (opline->extended_value & 0x02000000) {
    if (offset->value.lval >= 0 && offset->value.lval < (**container).value.str.len) {
     result = 1;
    }
   } else {
    if (offset->value.lval >= 0 && offset->value.lval < (**container).value.str.len && (**container).value.str.val[offset->value.lval] != '0') {
     result = 1;
    }
   }
  }
  _zval_dtor((free_op2.var) );
 } else {
  _zval_dtor((free_op2.var) );
 }

 ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).type = 3;
 if (opline->extended_value & 0x02000000) {
  ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.lval = result;
 } else {
  ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.lval = !result;
 }

 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_TMP(0, execute_data );
}

static int __attribute__((fastcall)) ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_VAR_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_TMP(1, execute_data );
}

static int __attribute__((fastcall)) ZEND_ADD_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 add_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SUB_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 sub_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_MUL_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 mul_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_DIV_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 div_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_MOD_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 mod_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SL_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 shift_left_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SR_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 shift_right_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_CONCAT_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 concat_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_IDENTICAL_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 is_identical_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_NOT_IDENTICAL_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 is_identical_function(result,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 (*result).value.lval = !(*result).value.lval;
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_EQUAL_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval == 0)) != 0); (*__z).type = 3; } while (0);
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_NOT_EQUAL_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval != 0)) != 0); (*__z).type = 3; } while (0);
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_SMALLER_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval < 0)) != 0); (*__z).type = 3; } while (0);
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_SMALLER_OR_EQUAL_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval <= 0)) != 0); (*__z).type = 3; } while (0);
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_OR_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 bitwise_or_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_AND_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 bitwise_and_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_XOR_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 bitwise_xor_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BOOL_XOR_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 boolean_xor_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_binary_assign_op_obj_helper_SPEC_VAR_VAR(int (*binary_op)(zval *result, zval *op1, zval *op2 ), zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2, free_op_data1;
 zval **object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 zval *object;
 zval *property = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );
 zval *value = _get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, &free_op_data1, 0 );
 int have_get_ptr = 0;

 if ((1<<2) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }

 make_real_object(object_ptr );
 object = *object_ptr;

 if (__builtin_expect((*object).type != 5, 0)) {
  zend_error((1<<1L), "Attempt to assign property of non-object");
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };

  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = &(executor_globals.uninitialized_zval);
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
  }
 } else {

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
  }


  if (opline->extended_value == 136
   && (*object).value.obj.handlers->get_property_ptr_ptr) {
   zval **zptr = (*object).value.obj.handlers->get_property_ptr_ptr(object, property, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   if (zptr != ((void *)0)) {
    if (!zval_isref_p(*zptr)) { do { if (zval_refcount_p(*((zptr))) > 1) { zval *new_zv; zval_delref_p(*(zptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(zptr))->value; (*new_zv).type = (**(zptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(zptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

    have_get_ptr = 1;
    binary_op(*zptr, *zptr, value );
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((*zptr));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = *zptr;
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
   }
  }

  if (!have_get_ptr) {
   zval *z = ((void *)0);

   if (opline->extended_value == 136) {
    if ((*object).value.obj.handlers->read_property) {
     z = (*object).value.obj.handlers->read_property(object, property, 0, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
    }
   } else {
    if ((*object).value.obj.handlers->read_dimension) {
     z = (*object).value.obj.handlers->read_dimension(object, property, 0 );
    }
   }
   if (z) {
    if ((*z).type == 5 && (*z).value.obj.handlers->get) {
     zval *value = (*z).value.obj.handlers->get(z );

     if (zval_refcount_p(z) == 0) {
      if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); };
      _zval_dtor((z) );
      do { if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); }; _efree((z) ); } while (0);
     }
     z = value;
    }
    zval_addref_p(z);
    if (!zval_isref_p(*&z)) { do { if (zval_refcount_p(*((&z))) > 1) { zval *new_zv; zval_delref_p(*(&z)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(&z))->value; (*new_zv).type = (**(&z)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(&z) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
    binary_op(z, z, value );
    if (opline->extended_value == 136) {
     (*object).value.obj.handlers->write_property(object, property, z, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
    } else {
     (*object).value.obj.handlers->write_dimension(object, property, z );
    }
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((z));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = z;
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
    i_zval_ptr_dtor(*(&z) );
   } else {
    zend_error((1<<1L), "Attempt to assign property of non-object");
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((&(executor_globals.uninitialized_zval)));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = &(executor_globals.uninitialized_zval);
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
   }
  }

  if (0) {
   i_zval_ptr_dtor(*(&property) );
  } else {
   if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
  }
  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };
 }

 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_binary_assign_op_helper_SPEC_VAR_VAR(int (*binary_op)(zval *result, zval *op1, zval *op2 ), zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2, free_op_data2, free_op_data1;
 zval **var_ptr;
 zval *value;

 ;
 switch (opline->extended_value) {
  case 136:
   return zend_binary_assign_op_obj_helper_SPEC_VAR_VAR(binary_op, execute_data );
   break;
  case 147: {
    zval **container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

    if ((1<<2) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
     zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
    } else if (__builtin_expect((**container).type == 5, 0)) {
     if ((1<<2) == (1<<2) && !(free_op1.var != ((void *)0))) {
      zval_addref_p(*(container));
     }
     return zend_binary_assign_op_obj_helper_SPEC_VAR_VAR(binary_op, execute_data );
    } else {
     zval *dim = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );

     zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)), container, dim, (1<<2), 2 );
     value = _get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, &free_op_data1, 0 );
     var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data->Ts, &free_op_data2 );
    }
   }
   break;
  default:
   value = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );
   var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

   break;
 }

 if (__builtin_expect(var_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use assign-op operators with overloaded objects nor string offsets");
 }

 if (__builtin_expect(*var_ptr == &(executor_globals.error_zval), 0)) {
  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
  ;
  if (opline->extended_value == 147) {
   execute_data->opline++;
  }
  execute_data->opline++; return 0;
 }

 if (!zval_isref_p(*var_ptr)) { do { if (zval_refcount_p(*((var_ptr))) > 1) { zval *new_zv; zval_delref_p(*(var_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(var_ptr))->value; (*new_zv).type = (**(var_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(var_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

 if (__builtin_expect((**var_ptr).type == 5, 0)
    && ((**var_ptr)).value.obj.handlers->get
    && ((**var_ptr)).value.obj.handlers->set) {

  zval *objval = ((**var_ptr)).value.obj.handlers->get(*var_ptr );
  zval_addref_p(objval);
  binary_op(objval, objval, value );
  ((**var_ptr)).value.obj.handlers->set(var_ptr, objval );
  i_zval_ptr_dtor(*(&objval) );
 } else {
  binary_op(*var_ptr, *var_ptr, value );
 }

 if ((!((opline)->result_type & (1<<5)))) {
  zval_addref_p((*var_ptr));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (*var_ptr); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
 }
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};

 if (opline->extended_value == 147) {
  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };
  if (free_op_data2.var) { i_zval_ptr_dtor(*(&free_op_data2.var) ); };
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
  ;
  execute_data->opline++;
 } else {
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
  ;
 }
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_ADD_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_VAR(add_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SUB_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_VAR(sub_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_MUL_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_VAR(mul_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_DIV_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_VAR(div_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_MOD_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_VAR(mod_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SL_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_VAR(shift_left_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SR_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_VAR(shift_right_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_CONCAT_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_VAR(concat_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_OR_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_VAR(bitwise_or_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_AND_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_VAR(bitwise_and_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_XOR_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_VAR(bitwise_xor_function, execute_data );
}

static int __attribute__((fastcall)) zend_pre_incdec_property_helper_SPEC_VAR_VAR(incdec_t incdec_op, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval **object_ptr;
 zval *object;
 zval *property;
 zval **retval;
 int have_get_ptr = 0;

 ;
 object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 property = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );
 retval = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr;

 if ((1<<2) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot increment/decrement overloaded objects nor string offsets");
 }

 make_real_object(object_ptr );
 object = *object_ptr;

 if (__builtin_expect((*object).type != 5, 0)) {
  zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   *retval = &(executor_globals.uninitialized_zval);
  }
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
  ;
  execute_data->opline++; return 0;
 }



 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }

 if ((*object).value.obj.handlers->get_property_ptr_ptr) {
  zval **zptr = (*object).value.obj.handlers->get_property_ptr_ptr(object, property, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
  if (zptr != ((void *)0)) {
   if (!zval_isref_p(*zptr)) { do { if (zval_refcount_p(*((zptr))) > 1) { zval *new_zv; zval_delref_p(*(zptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(zptr))->value; (*new_zv).type = (**(zptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(zptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

   have_get_ptr = 1;
   incdec_op(*zptr);
   if ((!((opline)->result_type & (1<<5)))) {
    *retval = *zptr;
    zval_addref_p((*retval));
   }
  }
 }

 if (!have_get_ptr) {
  if ((*object).value.obj.handlers->read_property && (*object).value.obj.handlers->write_property) {
   zval *z = (*object).value.obj.handlers->read_property(object, property, 0, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );

   if (__builtin_expect((*z).type == 5, 0) && (*z).value.obj.handlers->get) {
    zval *value = (*z).value.obj.handlers->get(z );

    if (zval_refcount_p(z) == 0) {
     if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); };
     _zval_dtor((z) );
     do { if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); }; _efree((z) ); } while (0);
    }
    z = value;
   }
   zval_addref_p(z);
   if (!zval_isref_p(*&z)) { do { if (zval_refcount_p(*((&z))) > 1) { zval *new_zv; zval_delref_p(*(&z)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(&z))->value; (*new_zv).type = (**(&z)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(&z) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
   incdec_op(z);
   *retval = z;
   (*object).value.obj.handlers->write_property(object, property, z, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   if ((!((opline)->result_type & (1<<5)))) { zval_addref_p((*retval)); };
   i_zval_ptr_dtor(*(&z) );
  } else {
   zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
   if ((!((opline)->result_type & (1<<5)))) {
    zval_addref_p((&(executor_globals.uninitialized_zval)));
    *retval = &(executor_globals.uninitialized_zval);
   }
  }
 }

 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_PRE_INC_OBJ_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_pre_incdec_property_helper_SPEC_VAR_VAR(increment_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_PRE_DEC_OBJ_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_pre_incdec_property_helper_SPEC_VAR_VAR(decrement_function, execute_data );
}

static int __attribute__((fastcall)) zend_post_incdec_property_helper_SPEC_VAR_VAR(incdec_t incdec_op, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval **object_ptr;
 zval *object;
 zval *property;
 zval *retval;
 int have_get_ptr = 0;

 ;
 object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 property = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );
 retval = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 if ((1<<2) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot increment/decrement overloaded objects nor string offsets");
 }

 make_real_object(object_ptr );
 object = *object_ptr;

 if (__builtin_expect((*object).type != 5, 0)) {
  zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
  { (*retval).type = 0; };
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
  ;
  execute_data->opline++; return 0;
 }



 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }

 if ((*object).value.obj.handlers->get_property_ptr_ptr) {
  zval **zptr = (*object).value.obj.handlers->get_property_ptr_ptr(object, property, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
  if (zptr != ((void *)0)) {
   have_get_ptr = 1;
   if (!zval_isref_p(*zptr)) { do { if (zval_refcount_p(*((zptr))) > 1) { zval *new_zv; zval_delref_p(*(zptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(zptr))->value; (*new_zv).type = (**(zptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(zptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

   do { (retval)->value = (*zptr)->value; (*retval).type = (**zptr).type; } while (0);
   _zval_copy_ctor((&(*retval)) );

   incdec_op(*zptr);

  }
 }

 if (!have_get_ptr) {
  if ((*object).value.obj.handlers->read_property && (*object).value.obj.handlers->write_property) {
   zval *z = (*object).value.obj.handlers->read_property(object, property, 0, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   zval *z_copy;

   if (__builtin_expect((*z).type == 5, 0) && (*z).value.obj.handlers->get) {
    zval *value = (*z).value.obj.handlers->get(z );

    if (zval_refcount_p(z) == 0) {
     if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); };
     _zval_dtor((z) );
     do { if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); }; _efree((z) ); } while (0);
    }
    z = value;
   }
   do { (retval)->value = (z)->value; (*retval).type = (*z).type; } while (0);
   _zval_copy_ctor((&(*retval)) );
   do { (z_copy) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(z_copy))->u.buffered = ((void *)0); } while (0);
   do { do { (z_copy)->value = (z)->value; (*z_copy).type = (*z).type; } while (0); zval_set_refcount_p(z_copy, 1); zval_unset_isref_p(z_copy); } while (0);
   _zval_copy_ctor((&(*z_copy)) );
   incdec_op(z_copy);
   zval_addref_p(z);
   (*object).value.obj.handlers->write_property(object, property, z_copy, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   i_zval_ptr_dtor(*(&z_copy) );
   i_zval_ptr_dtor(*(&z) );
  } else {
   zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
   { (*retval).type = 0; };
  }
 }

 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_POST_INC_OBJ_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_post_incdec_property_helper_SPEC_VAR_VAR(increment_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_POST_DEC_OBJ_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_post_incdec_property_helper_SPEC_VAR_VAR(decrement_function, execute_data );
}

static int __attribute__((fastcall)) zend_fetch_var_address_helper_SPEC_VAR_VAR(int type, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *varname;
 zval **retval;
 zval tmp_varname;
 HashTable *target_symbol_table;
 ulong hash_value;

 ;
 varname = _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

  if ((1<<2) != (1<<0) && __builtin_expect((*varname).type != 6, 0)) {
  do { (&tmp_varname)->value = (varname)->value; (*&tmp_varname).type = (*varname).type; } while (0);
  _zval_copy_ctor((&tmp_varname) );
  if ((&tmp_varname)->type != 6) { _convert_to_string((&tmp_varname) ); };
  varname = &tmp_varname;
 }

 if ((1<<2) != (1<<3)) {
  zend_class_entry *ce;

  if ((1<<2) == (1<<0)) {
   if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
    ce = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
   } else {
    ce = zend_fetch_class_by_name((*opline->op2.zv).value.str.val, (*opline->op2.zv).value.str.len, opline->op2.literal + 1, 0 );
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); } while (0);
   }
  } else {
   ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).class_entry;
  }
  retval = zend_std_get_static_property(ce, (*varname).value.str.val, (*varname).value.str.len, 0, (((1<<2) == (1<<0)) ? opline->op1.literal : ((void *)0)) );
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 } else {
  target_symbol_table = zend_get_target_symbol_table(opline->extended_value & 0x70000000 );






  if ((1<<2) == (1<<0)) {
   hash_value = (((zend_literal*)(varname))->hash_value);
  } else if (((((*varname).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*varname).value.str.val) < (compiler_globals.interned_strings_end)))) {
   hash_value = (((Bucket*)(((char*)((*varname).value.str.val))-sizeof(Bucket)))->h);
  } else {
   hash_value = zend_hash_func((*varname).value.str.val, (*varname).value.str.len+1);
  }

  if (zend_hash_quick_find(target_symbol_table, (*varname).value.str.val, (*varname).value.str.len+1, hash_value, (void **) &retval) == -1) {
   switch (type) {
    case 0:
    case 6:
     zend_error((1<<3L),"Undefined variable: %s", (*varname).value.str.val);

    case 3:
     retval = &(executor_globals.uninitialized_zval_ptr);
     break;
    case 2:
     zend_error((1<<3L),"Undefined variable: %s", (*varname).value.str.val);

    case 1:
     zval_addref_p(&(executor_globals.uninitialized_zval));
     _zend_hash_quick_add_or_update(target_symbol_table, (*varname).value.str.val, (*varname).value.str.len+1, hash_value, &(executor_globals.uninitialized_zval_ptr), sizeof(zval *), (void **) &retval, (1<<0) );
     break;
   
   }
  }
  switch (opline->extended_value & 0x70000000) {
   case 0x00000000:
    if ((1<<2) != (1<<1)) {
     if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
    }
    break;
   case 0x10000000:
    if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
    break;
   case 0x20000000:
    zval_update_constant(retval, (void*) 1 );
    break;
   case 0x40000000:
    if ((1<<2) == (1<<2) && !free_op1.var) {
     zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr));
    }
    break;
  }
 }


 if ((1<<2) != (1<<0) && varname == &tmp_varname) {
  _zval_dtor((&tmp_varname) );
 }
 if (opline->extended_value & 0x04000000) {
  if (!zval_isref_p(*retval)) { do { if (zval_refcount_p(*((retval))) > 1) { zval *new_zv; zval_delref_p(*(retval)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval))->value; (*new_zv).type = (**(retval)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((retval))); };
 }
 zval_addref_p((*retval));
 switch (type) {
  case 0:
  case 3:
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (*retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   break;
  case 6: {
   zend_free_op free_res;

   zend_pzval_unlock_func(*retval, &free_res, 1 );
   if (retval != &(executor_globals.uninitialized_zval_ptr)) {
    if (!zval_isref_p(*retval)) { do { if (zval_refcount_p(*((retval))) > 1) { zval *new_zv; zval_delref_p(*(retval)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval))->value; (*new_zv).type = (**(retval)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
   }
   zval_addref_p((*retval));
   if (free_res.var) { i_zval_ptr_dtor(*(&free_res.var) ); };
  }

  default:
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = retval;
   break;
 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_R_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_VAR_VAR(0, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_W_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_VAR_VAR(1, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_RW_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_VAR_VAR(2, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_FUNC_ARG_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 return zend_fetch_var_address_helper_SPEC_VAR_VAR(((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && (opline->extended_value & 0x000fffff) <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[(opline->extended_value & 0x000fffff)-1].pass_by_reference & (1|2)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x1000000|0x2000000))))?1:0, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_UNSET_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_VAR_VAR(6, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_IS_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_VAR_VAR(3, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_R_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval **container;

 ;

 if ((opline->extended_value & 0x08000000) &&
     (1<<2) != (1<<4) &&
     (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr) {
  zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr));
 }
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 zend_fetch_dimension_address_read(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ), (1<<2), 0 );
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_W_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval **container;

 ;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<2) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ), (1<<2), 1 );
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 if ((1<<2) == (1<<2) && (free_op1.var != ((void *)0)) && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};


 if (__builtin_expect(opline->extended_value != 0, 0)) {
  zval **retval_ptr = (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr;

  if (retval_ptr) {
   zval_delref_p(*(retval_ptr));
   if (!zval_isref_p(*retval_ptr)) { do { if (zval_refcount_p(*((retval_ptr))) > 1) { zval *new_zv; zval_delref_p(*(retval_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval_ptr))->value; (*new_zv).type = (**(retval_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((retval_ptr))); };
   zval_addref_p(*(retval_ptr));
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_RW_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval **container;

 ;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<2) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ), (1<<2), 2 );
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 if ((1<<2) == (1<<2) && (free_op1.var != ((void *)0)) && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_IS_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval **container;

 ;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 zend_fetch_dimension_address_read(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ), (1<<2), 3 );
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval **container;

 ;

 if (((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && (opline->extended_value & 0x000fffff) <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[(opline->extended_value & 0x000fffff)-1].pass_by_reference & (1|2)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x1000000|0x2000000))))) {
  container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
  if ((1<<2) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
  }
  zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ), (1<<2), 1 );
  if ((1<<2) == (1<<2) && (free_op1.var != ((void *)0)) && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
  }
 } else {
  if ((1<<2) == (1<<3)) {
   zend_error_noreturn((1<<0L), "Cannot use [] for reading");
  }
  container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
  zend_fetch_dimension_address_read(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ), (1<<2), 0 );
 }
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_UNSET_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval **container;

 ;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<2) == (1<<4)) {
  if (container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
 }
 if ((1<<2) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ), (1<<2), 6 );
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 if ((1<<2) == (1<<2) && (free_op1.var != ((void *)0)) && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 if (__builtin_expect((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot unset string offsets");
 } else {
  zend_free_op free_res;
  zval **retval_ptr = (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr;

  zend_pzval_unlock_func(*retval_ptr, &free_res, 1 );
  if (retval_ptr != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*retval_ptr)) { do { if (zval_refcount_p(*((retval_ptr))) > 1) { zval *new_zv; zval_delref_p(*(retval_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval_ptr))->value; (*new_zv).type = (**(retval_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
  zval_addref_p((*retval_ptr));
  if (free_res.var) { i_zval_ptr_dtor(*(&free_res.var) ); };
  ;
  execute_data->opline++; return 0;
 }
}

static int __attribute__((fastcall)) zend_fetch_property_address_read_helper_SPEC_VAR_VAR(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *container;
 zend_free_op free_op2;
 zval *offset;

 ;
 container = _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 offset = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );

 if (__builtin_expect((*container).type != 5, 0) ||
     __builtin_expect((*container).value.obj.handlers->read_property == ((void *)0), 0)) {
  zend_error((1<<3L), "Trying to get property of non-object");
  zval_addref_p((&(executor_globals.uninitialized_zval)));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 } else {
  zval *retval;

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
  }


  retval = (*container).value.obj.handlers->read_property(container, offset, 0, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );

  zval_addref_p((retval));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);

  if (0) {
   i_zval_ptr_dtor(*(&offset) );
  } else {
   if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
  }
 }

 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_R_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_property_address_read_helper_SPEC_VAR_VAR(execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_W_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval *property;
 zval **container;

 ;
 property = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((1<<2) == (1<<2) && (opline->extended_value & 0x08000000)) {
  zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr));
  (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr = *(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr;
 }

 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 if ((1<<2) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }

 zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)), 1 );
 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 }
 if ((1<<2) == (1<<2) && (free_op1.var != ((void *)0)) && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};


 if (opline->extended_value & 0x04000000) {
  zval **retval_ptr = (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr;

  zval_delref_p(*(retval_ptr));
  if (!zval_isref_p(*retval_ptr)) { do { if (zval_refcount_p(*((retval_ptr))) > 1) { zval *new_zv; zval_delref_p(*(retval_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval_ptr))->value; (*new_zv).type = (**(retval_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((retval_ptr))); };
  zval_addref_p(*(retval_ptr));
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_RW_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval *property;
 zval **container;

 ;
 property = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }
 if ((1<<2) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }
 zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)), 2 );
 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 }
 if ((1<<2) == (1<<2) && (free_op1.var != ((void *)0)) && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_IS_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *container;
 zend_free_op free_op2;
 zval *offset;

 ;
 container = _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 offset = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );

 if (__builtin_expect((*container).type != 5, 0) ||
     __builtin_expect((*container).value.obj.handlers->read_property == ((void *)0), 0)) {
  zval_addref_p((&(executor_globals.uninitialized_zval)));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 } else {
  zval *retval;

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
  }


  retval = (*container).value.obj.handlers->read_property(container, offset, 3, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );

  zval_addref_p((retval));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);

  if (0) {
   i_zval_ptr_dtor(*(&offset) );
  } else {
   if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
  }
 }

 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 if (((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && (opline->extended_value & 0x000fffff) <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[(opline->extended_value & 0x000fffff)-1].pass_by_reference & (1|2)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x1000000|0x2000000))))) {

  zend_free_op free_op1, free_op2;
  zval *property;
  zval **container;

  ;
  property = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );
  container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
  }
  if ((1<<2) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
  }
  zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)), 1 );
  if (0) {
   i_zval_ptr_dtor(*(&property) );
  } else {
   if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
  }
  if ((1<<2) == (1<<2) && (free_op1.var != ((void *)0)) && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
  }
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
  ;
  execute_data->opline++; return 0;
 } else {
  return zend_fetch_property_address_read_helper_SPEC_VAR_VAR(execute_data );
 }
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_UNSET_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2, free_res;
 zval **container;
 zval *property;

 ;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 property = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((1<<2) == (1<<4)) {
  if (container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
 }
 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }
 if ((1<<2) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }
 zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)), 6 );
 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 }
 if ((1<<2) == (1<<2) && (free_op1.var != ((void *)0)) && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 zend_pzval_unlock_func(*(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr, &free_res, 1 );
 if ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr != &(executor_globals.uninitialized_zval_ptr)) {
  if (!zval_isref_p(*(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr)) { do { if (zval_refcount_p(*(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr))->value; (*new_zv).type = (**((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
 }
 zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr));
 if (free_res.var) { i_zval_ptr_dtor(*(&free_res.var) ); };
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_OBJ_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval **object_ptr;
 zval *property_name;

 ;
 object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 property_name = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );

 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property_name))->value; (*_tmp).type = (*(property_name)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property_name) = _tmp; } while (0);
 }
 if ((1<<2) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 zend_assign_to_object((!((opline)->result_type & (1<<5)))?&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr:((void *)0), object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, 136, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
 if (0) {
  i_zval_ptr_dtor(*(&property_name) );
 } else {
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_DIM_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **object_ptr;

 ;
 object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<2) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 if ((**object_ptr).type == 5) {
  zend_free_op free_op2;
  zval *property_name = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property_name))->value; (*_tmp).type = (*(property_name)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property_name) = _tmp; } while (0);
  }
  zend_assign_to_object((!((opline)->result_type & (1<<5)))?&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr:((void *)0), object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, 147, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
  if (0) {
   i_zval_ptr_dtor(*(&property_name) );
  } else {
   if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
  }
 } else {
  zend_free_op free_op2, free_op_data1, free_op_data2;
  zval *value;
  zval *dim = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );
  zval **variable_ptr_ptr;

  zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)), object_ptr, dim, (1<<2), 1 );
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};

  value = _get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, &free_op_data1, 0 );
  variable_ptr_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data->Ts, &free_op_data2 );
  if (__builtin_expect(variable_ptr_ptr == ((void *)0), 0)) {
   if (zend_assign_to_string_offset(&(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)), value, (opline+1)->op1_type )) {
    if ((!((opline)->result_type & (1<<5)))) {
     zval *retval;

     do { (retval) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(retval))->u.buffered = ((void *)0); } while (0);
     do { const char *__s=((*(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)).str_offset.str).value.str.val+(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)).str_offset.offset); int __l=1; zval *__z = (retval); (*__z).value.str.len = __l; (*__z).value.str.val = (1?_estrndup((__s), (__l) ):(char*)__s); (*__z).type = 6; } while (0);
     (retval)->refcount__gc = 1; (retval)->is_ref__gc = 0;;
     do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
    }
   } else if ((!((opline)->result_type & (1<<5)))) {
    zval_addref_p((&(executor_globals.uninitialized_zval)));
    do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   }
  } else if (__builtin_expect(*variable_ptr_ptr == &(executor_globals.error_zval), 0)) {
   if (((zend_uintptr_t)free_op_data1.var & 1L)) {
    _zval_dtor((value) );
   }
   if ((!((opline)->result_type & (1<<5)))) {
    zval_addref_p((&(executor_globals.uninitialized_zval)));
    do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   }
  } else {
   if ((opline+1)->op1_type == (1<<1)) {
     value = zend_assign_tmp_to_variable(variable_ptr_ptr, value );
   } else if ((opline+1)->op1_type == (1<<0)) {
     value = zend_assign_const_to_variable(variable_ptr_ptr, value );
   } else {
     value = zend_assign_to_variable(variable_ptr_ptr, value );
   }
   if ((!((opline)->result_type & (1<<5)))) {
    zval_addref_p((value));
    do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (value); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   }
  }
  if (free_op_data2.var) { i_zval_ptr_dtor(*(&free_op_data2.var) ); };
   if (free_op_data1.var != ((void *)0) && (((zend_uintptr_t)free_op_data1.var & 1L) == 0)) { i_zval_ptr_dtor(*(&free_op_data1.var) ); };
 }
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval *value;
 zval **variable_ptr_ptr;

 ;
 value = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );
 variable_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<2) == (1<<2) && __builtin_expect(variable_ptr_ptr == ((void *)0), 0)) {
  if (zend_assign_to_string_offset(&(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)), value, (1<<2) )) {
   if ((!((opline)->result_type & (1<<5)))) {
    zval *retval;

    do { (retval) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(retval))->u.buffered = ((void *)0); } while (0);
    do { const char *__s=((*(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).str_offset.str).value.str.val+(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).str_offset.offset); int __l=1; zval *__z = (retval); (*__z).value.str.len = __l; (*__z).value.str.val = (1?_estrndup((__s), (__l) ):(char*)__s); (*__z).type = 6; } while (0);
    (retval)->refcount__gc = 1; (retval)->is_ref__gc = 0;;
    do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   }
  } else if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }
 } else if ((1<<2) == (1<<2) && __builtin_expect(*variable_ptr_ptr == &(executor_globals.error_zval), 0)) {
  if (0) {
   _zval_dtor((value) );
  }
  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }
 } else {
  if ((1<<2) == (1<<1)) {
    value = zend_assign_tmp_to_variable(variable_ptr_ptr, value );
  } else if ((1<<2) == (1<<0)) {
    value = zend_assign_const_to_variable(variable_ptr_ptr, value );
  } else {
    value = zend_assign_to_variable(variable_ptr_ptr, value );
  }
  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((value));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (value); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }
 }

 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};


  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_REF_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval **variable_ptr_ptr;
 zval **value_ptr_ptr;

 ;
 value_ptr_ptr = _get_zval_ptr_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((1<<2) == (1<<2) &&
     value_ptr_ptr &&
     !zval_isref_p(*(value_ptr_ptr)) &&
     opline->extended_value == 1<<0 &&
     !(*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).var.fcall_returned_reference) {
  if (free_op2.var == ((void *)0)) {
   zval_addref_p((*value_ptr_ptr));
  }
  zend_error((1<<11L), "Only variables should be assigned by reference");
  if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
   if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
   ; return 0;
  }
  return ZEND_ASSIGN_SPEC_VAR_VAR_HANDLER(execute_data );
 } else if ((1<<2) == (1<<2) && opline->extended_value == 1<<1) {
  zval_addref_p((*value_ptr_ptr));
 }
 if ((1<<2) == (1<<2) && __builtin_expect((*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr == &(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr, 0)) {
  zend_error_noreturn((1<<0L), "Cannot assign by reference to overloaded object");
 }

 variable_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 if (((1<<2) == (1<<2) && __builtin_expect(value_ptr_ptr == ((void *)0), 0)) ||
     ((1<<2) == (1<<2) && __builtin_expect(variable_ptr_ptr == ((void *)0), 0))) {
  zend_error_noreturn((1<<0L), "Cannot create references to/from string offsets nor overloaded objects");
 }
 zend_assign_to_variable_reference(variable_ptr_ptr, value_ptr_ptr );

 if ((1<<2) == (1<<2) && opline->extended_value == 1<<1) {
  zval_delref_p(*(variable_ptr_ptr));
 }

 if ((!((opline)->result_type & (1<<5)))) {
  zval_addref_p((*variable_ptr_ptr));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (*variable_ptr_ptr); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
 }

 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_METHOD_CALL_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *function_name;
 char *function_name_strval;
 int function_name_strlen;
 zend_free_op free_op1, free_op2;

 ;
 zend_ptr_stack_3_push(&(executor_globals.arg_types_stack), execute_data->fbc, execute_data->object, execute_data->called_scope);

 function_name = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((1<<2) != (1<<0) &&
     __builtin_expect((*function_name).type != 6, 0)) {
  zend_error_noreturn((1<<0L), "Method name must be a string");
 }

 function_name_strval = (*function_name).value.str.val;
 function_name_strlen = (*function_name).value.str.len;

 execute_data->object = _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if (__builtin_expect(execute_data->object != ((void *)0), 1) &&
     __builtin_expect((*execute_data->object).type == 5, 1)) {
  execute_data->called_scope = zend_get_class_entry(&(*execute_data->object) );

  if ((1<<2) != (1<<0) ||
      (execute_data->fbc = (((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] == (execute_data->called_scope)) ? (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] : ((void *)0))) == ((void *)0)) {
      zval *object = execute_data->object;

   if (__builtin_expect((*execute_data->object).value.obj.handlers->get_method == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Object does not support method calls");
   }


   execute_data->fbc = (*execute_data->object).value.obj.handlers->get_method(&execute_data->object, function_name_strval, function_name_strlen, (((1<<2) == (1<<0)) ? (opline->op2.literal + 1) : ((void *)0)) );
   if (__builtin_expect(execute_data->fbc == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Call to undefined method %s::%s()", ((execute_data->object) && (*execute_data->object).type == 5 && (*execute_data->object).value.obj.handlers->get_class_entry != ((void *)0) && (*execute_data->object).value.obj.handlers->get_class_entry(execute_data->object ) ? (*execute_data->object).value.obj.handlers->get_class_entry(execute_data->object )->name : ""), function_name_strval);
   }
   if ((1<<2) == (1<<0) &&
       __builtin_expect((execute_data->fbc->common.fn_flags & 0x200000) == 0, 1) &&
       __builtin_expect(execute_data->object == object, 1)) {
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (execute_data->called_scope); (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] = (execute_data->fbc); } while (0);
   }
  }
 } else {
  zend_error_noreturn((1<<0L), "Call to a member function %s() on a non-object", function_name_strval);
 }

 if ((execute_data->fbc->common.fn_flags & 0x01) != 0) {
  execute_data->object = ((void *)0);
 } else {
  if (!zval_isref_p(execute_data->object)) {
   zval_addref_p(execute_data->object);
  } else {
   zval *this_ptr;
   do { (this_ptr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(this_ptr))->u.buffered = ((void *)0); } while (0);
   do { do { (this_ptr)->value = (execute_data->object)->value; (*this_ptr).type = (*execute_data->object).type; } while (0); zval_set_refcount_p(this_ptr, 1); zval_unset_isref_p(this_ptr); } while (0);
   _zval_copy_ctor((this_ptr) );
   execute_data->object = this_ptr;
  }
 }

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *function_name;
 zend_class_entry *ce;

 ;
 zend_ptr_stack_3_push(&(executor_globals.arg_types_stack), execute_data->fbc, execute_data->object, execute_data->called_scope);

 if ((1<<2) == (1<<0)) {

  if ((executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)]) {
   ce = (executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)];
  } else {
   ce = zend_fetch_class_by_name((*opline->op1.zv).value.str.val, (*opline->op1.zv).value.str.len, opline->op1.literal + 1, opline->extended_value );
   if (__builtin_expect(ce == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Class '%s' not found", (*opline->op1.zv).value.str.val);
   }
   do { (executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)] = (ce); } while (0);
  }
  execute_data->called_scope = ce;
 } else {
  ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).class_entry;

  if (opline->extended_value == 2 || opline->extended_value == 1) {
   execute_data->called_scope = (executor_globals.called_scope);
  } else {
   execute_data->called_scope = ce;
  }
 }

 if ((1<<2) == (1<<0) &&
     (1<<2) == (1<<0) &&
     (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
  execute_data->fbc = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
 } else if ((1<<2) != (1<<0) &&
            (1<<2) == (1<<0) &&
            (execute_data->fbc = (((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] == (ce)) ? (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] : ((void *)0)))) {

 } else if ((1<<2) != (1<<3)) {
  char *function_name_strval = ((void *)0);
  int function_name_strlen = 0;
  zend_free_op free_op2;

  if ((1<<2) == (1<<0)) {
   function_name_strval = (*opline->op2.zv).value.str.val;
   function_name_strlen = (*opline->op2.zv).value.str.len;
  } else {
   function_name = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );

   if (__builtin_expect((*function_name).type != 6, 0)) {
    zend_error_noreturn((1<<0L), "Function name must be a string");
   } else {
    function_name_strval = (*function_name).value.str.val;
    function_name_strlen = (*function_name).value.str.len;
    }
  }

  if (function_name_strval) {
   if (ce->get_static_method) {
    execute_data->fbc = ce->get_static_method(ce, function_name_strval, function_name_strlen );
   } else {
    execute_data->fbc = zend_std_get_static_method(ce, function_name_strval, function_name_strlen, (((1<<2) == (1<<0)) ? (opline->op2.literal + 1) : ((void *)0)) );
   }
   if (__builtin_expect(execute_data->fbc == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Call to undefined method %s::%s()", ce->name, function_name_strval);
   }
   if ((1<<2) == (1<<0) && __builtin_expect((execute_data->fbc->common.fn_flags & 0x200000) == 0, 1)) {
    if ((1<<2) == (1<<0)) {
     do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (execute_data->fbc); } while (0);
    } else {
     do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] = (execute_data->fbc); } while (0);
    }
   }
  }
  if ((1<<2) != (1<<0)) {
   if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
  }
 } else {
  if (__builtin_expect(ce->constructor == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot call constructor");
  }
  if ((executor_globals.This) && zend_get_class_entry(&(*(executor_globals.This)) ) != ce->constructor->common.scope && (ce->constructor->common.fn_flags & 0x400)) {
   zend_error_noreturn((1<<0L), "Cannot call private %s::__construct()", ce->name);
  }
  execute_data->fbc = ce->constructor;
 }

 if (execute_data->fbc->common.fn_flags & 0x01) {
  execute_data->object = ((void *)0);
 } else {
  if ((executor_globals.This) &&
      (*(executor_globals.This)).value.obj.handlers->get_class_entry &&
      !instanceof_function(zend_get_class_entry(&(*(executor_globals.This)) ), ce )) {


   if (execute_data->fbc->common.fn_flags & 0x10000) {
    zend_error((1<<11L), "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", execute_data->fbc->common.scope->name, execute_data->fbc->common.function_name);
   } else {

    zend_error_noreturn((1<<0L), "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", execute_data->fbc->common.scope->name, execute_data->fbc->common.function_name);
   }
  }
  if ((execute_data->object = (executor_globals.This))) {
   zval_addref_p(execute_data->object);
   execute_data->called_scope = zend_get_class_entry(&(*execute_data->object) );
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_CASE_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;

 ;
 if ((1<<2)==(1<<2)) {
  zval_addref_p(((*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr));
 }
 is_equal_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
     _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
     _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *expr_ptr;

 ;
 if (((1<<2) == (1<<2) || (1<<2) == (1<<4)) && opline->extended_value) {
  zval **expr_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

  if ((1<<2) == (1<<2) && __builtin_expect(expr_ptr_ptr == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot create references to/from string offsets");
  }
  if (!zval_isref_p(*expr_ptr_ptr)) { do { if (zval_refcount_p(*((expr_ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(expr_ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(expr_ptr_ptr))->value; (*new_zv).type = (**(expr_ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(expr_ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((expr_ptr_ptr))); };
  expr_ptr = *expr_ptr_ptr;
  zval_addref_p(expr_ptr);
 } else {
  expr_ptr=_get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
  if (0) {
   zval *new_expr;

   do { (new_expr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_expr))->u.buffered = ((void *)0); } while (0);
   do { do { (new_expr)->value = (expr_ptr)->value; (*new_expr).type = (*expr_ptr).type; } while (0); zval_set_refcount_p(new_expr, 1); zval_unset_isref_p(new_expr); } while (0);
   expr_ptr = new_expr;
  } else if ((1<<2) == (1<<0) || zval_isref_p(expr_ptr)) {
   zval *new_expr;

   do { (new_expr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_expr))->u.buffered = ((void *)0); } while (0);
   do { do { (new_expr)->value = (expr_ptr)->value; (*new_expr).type = (*expr_ptr).type; } while (0); zval_set_refcount_p(new_expr, 1); zval_unset_isref_p(new_expr); } while (0);
   expr_ptr = new_expr;
   _zval_copy_ctor((&(*expr_ptr)) );
  } else {
   zval_addref_p(expr_ptr);
  }
 }

 if ((1<<2) != (1<<3)) {
  zend_free_op free_op2;
  zval *offset = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );
  ulong hval;

  switch ((*offset).type) {
   case 2:
    hval = zend_dval_to_lval((*offset).value.dval);
    goto num_index;
   case 1:
   case 3:
    hval = (*offset).value.lval;
num_index:
    _zend_hash_index_update_or_next_insert(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, hval, &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   case 6:
    if ((1<<2) == (1<<0)) {
     hval = (((zend_literal*)(offset))->hash_value);
    } else {
     do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index; } } } while (0);
     if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
      hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
     } else {
      hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
     }
    }
    _zend_hash_quick_add_or_update(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   case 0:
    _zend_hash_add_or_update(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, "", sizeof(""), &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   default:
    zend_error((1<<1L), "Illegal offset type");
    i_zval_ptr_dtor(*(&expr_ptr) );

    break;
  }
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 } else {
  _zend_hash_index_update_or_next_insert(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, 0, &expr_ptr, sizeof(zval *), ((void *)0), (1<<2) );
 }
 if (((1<<2) == (1<<2) || (1<<2) == (1<<4)) && opline->extended_value) {
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 } else {
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_ARRAY_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 _array_init((&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var), 0 );
 if ((1<<2) == (1<<3)) {
  execute_data->opline++; return 0;

 } else {
  return ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_VAR_HANDLER(execute_data );

 }
}

static int __attribute__((fastcall)) ZEND_UNSET_VAR_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval tmp, *varname;
 HashTable *target_symbol_table;
 zend_free_op free_op1;

 ;
 if ((1<<2) == (1<<4) &&
     (1<<2) == (1<<3) &&
     (opline->extended_value & 0x00800000)) {
  if ((executor_globals.active_symbol_table)) {
   zend_compiled_variable *cv = &((executor_globals.active_op_array)->vars[opline->op1.var]);

   zend_delete_variable(execute_data->prev_execute_data, (executor_globals.active_symbol_table), cv->name, cv->name_len+1, cv->hash_value );
   execute_data->CVs[opline->op1.var] = ((void *)0);
  } else if (execute_data->CVs[opline->op1.var]) {
   i_zval_ptr_dtor(*(execute_data->CVs[opline->op1.var]) );
   execute_data->CVs[opline->op1.var] = ((void *)0);
  }
  ;
  execute_data->opline++; return 0;
 }

 varname = _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<2) != (1<<0) && (*varname).type != 6) {
  do { (&tmp)->value = (varname)->value; (*&tmp).type = (*varname).type; } while (0);
  _zval_copy_ctor((&tmp) );
  if ((&tmp)->type != 6) { _convert_to_string((&tmp) ); };
  varname = &tmp;
 } else if ((1<<2) == (1<<2) || (1<<2) == (1<<4)) {
  zval_addref_p(varname);
 }

 if ((1<<2) != (1<<3)) {
  zend_class_entry *ce;

  if ((1<<2) == (1<<0)) {
   if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
    ce = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
   } else {
    ce = zend_fetch_class_by_name((*opline->op2.zv).value.str.val, (*opline->op2.zv).value.str.len, opline->op2.literal + 1, 0 );
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); } while (0);
   }
  } else {
   ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).class_entry;
  }
  zend_std_unset_static_property(ce, (*varname).value.str.val, (*varname).value.str.len, (((1<<2) == (1<<0)) ? opline->op1.literal : ((void *)0)) );
 } else {
  ulong hash_value = zend_inline_hash_func(varname->value.str.val, varname->value.str.len+1);

  target_symbol_table = zend_get_target_symbol_table(opline->extended_value & 0x70000000 );
  zend_delete_variable(execute_data, target_symbol_table, varname->value.str.val, varname->value.str.len+1, hash_value );
 }

 if ((1<<2) != (1<<0) && varname == &tmp) {
  _zval_dtor((&tmp) );
 } else if ((1<<2) == (1<<2) || (1<<2) == (1<<4)) {
  i_zval_ptr_dtor(*(&varname) );
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_UNSET_DIM_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval **container;
 zval *offset;
 ulong hval;

 ;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 offset = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((1<<2) != (1<<2) || container) {
  if ((1<<2) == (1<<4) && container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
  switch ((**container).type) {
   case 4: {
    HashTable *ht = (**container).value.ht;

    switch ((*offset).type) {
     case 2:
      hval = zend_dval_to_lval((*offset).value.dval);
      goto num_index_dim;
     case 7:
     case 3:
     case 1:
num_index_dim:
      hval = (*offset).value.lval;
      zend_hash_del_key_or_index(ht, ((void *)0), 0, hval, 1);
      break;
     case 6:
      if ((1<<2) == (1<<4) || (1<<2) == (1<<2)) {
       zval_addref_p(offset);
      }
      if ((1<<2) == (1<<0)) {
       hval = (((zend_literal*)(offset))->hash_value);
      } else {
       do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index_dim; } } } while (0);
       if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
        hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
       } else {
        hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
       }
      }
      if (ht == &(executor_globals.symbol_table)) {
       zend_delete_global_variable_ex(offset->value.str.val, offset->value.str.len, hval );
      } else {
       zend_hash_del_key_or_index(ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, 2);
      }
      if ((1<<2) == (1<<4) || (1<<2) == (1<<2)) {
       i_zval_ptr_dtor(*(&offset) );
      }
      break;
     case 0:
      zend_hash_del_key_or_index(ht, "", sizeof(""), 0, 0);
      break;
     default:
      zend_error((1<<1L), "Illegal offset type in unset");
      break;
    }
    if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
    break;
   }
   case 5:
    if (__builtin_expect((**container).value.obj.handlers->unset_dimension == ((void *)0), 0)) {
     zend_error_noreturn((1<<0L), "Cannot use object as array");
    }
    if (0) {
     do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
    }
    (**container).value.obj.handlers->unset_dimension(*container, offset );
    if (0) {
     i_zval_ptr_dtor(*(&offset) );
    } else {
     if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
    }
    break;
   case 6:
    zend_error_noreturn((1<<0L), "Cannot unset string offsets");
    return 0;
   default:
    if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
    break;
  }
 } else {
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_UNSET_OBJ_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval **container;
 zval *offset;

 ;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 offset = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((1<<2) != (1<<2) || container) {
  if ((1<<2) == (1<<4) && container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
  if ((**container).type == 5) {
   if (0) {
    do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
   }
   if ((**container).value.obj.handlers->unset_property) {
    (**container).value.obj.handlers->unset_property(*container, offset, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   } else {
    zend_error((1<<3L), "Trying to unset property of non-object");
   }
   if (0) {
    i_zval_ptr_dtor(*(&offset) );
   } else {
    if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
   }
  } else {
   if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
  }
 } else {
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ISSET_ISEMPTY_VAR_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval **value;
 zend_bool isset = 1;

 ;
 if ((1<<2) == (1<<4) &&
     (1<<2) == (1<<3) &&
     (opline->extended_value & 0x00800000)) {
  if (execute_data->CVs[opline->op1.var]) {
   value = execute_data->CVs[opline->op1.var];
  } else if ((executor_globals.active_symbol_table)) {
   zend_compiled_variable *cv = &((executor_globals.active_op_array)->vars[opline->op1.var]);

   if (zend_hash_quick_find((executor_globals.active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, (void **) &value) == -1) {
    isset = 0;
   }
  } else {
   isset = 0;
  }
 } else {
  HashTable *target_symbol_table;
  zend_free_op free_op1;
  zval tmp, *varname = _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

  if ((1<<2) != (1<<0) && (*varname).type != 6) {
   do { (&tmp)->value = (varname)->value; (*&tmp).type = (*varname).type; } while (0);
   _zval_copy_ctor((&tmp) );
   if ((&tmp)->type != 6) { _convert_to_string((&tmp) ); };
   varname = &tmp;
  }

  if ((1<<2) != (1<<3)) {
   zend_class_entry *ce;

   if ((1<<2) == (1<<0)) {
    if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
     ce = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
    } else {
     ce = zend_fetch_class_by_name((*opline->op2.zv).value.str.val, (*opline->op2.zv).value.str.len, opline->op2.literal + 1, 0 );
     do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); } while (0);
    }
   } else {
    ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).class_entry;
   }
   value = zend_std_get_static_property(ce, (*varname).value.str.val, (*varname).value.str.len, 1, (((1<<2) == (1<<0)) ? opline->op1.literal : ((void *)0)) );
   if (!value) {
    isset = 0;
   }
  } else {
   target_symbol_table = zend_get_target_symbol_table(opline->extended_value & 0x70000000 );
   if (zend_hash_find(target_symbol_table, varname->value.str.val, varname->value.str.len+1, (void **) &value) == -1) {
    isset = 0;
   }
  }

  if ((1<<2) != (1<<0) && varname == &tmp) {
   _zval_dtor((&tmp) );
  }
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 }

 if (opline->extended_value & 0x02000000) {
  if (isset && (**value).type != 0) {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((1) != 0); (*__z).type = 3; } while (0);
  } else {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((0) != 0); (*__z).type = 3; } while (0);
  }
 } else {
  if (!isset || !i_zend_is_true(*value)) {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((1) != 0); (*__z).type = 3; } while (0);
  } else {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((0) != 0); (*__z).type = 3; } while (0);
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_VAR(int prop_dim, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval **container;
 zval **value = ((void *)0);
 int result = 0;
 ulong hval;
 zval *offset;

 ;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 offset = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((**container).type == 4 && !prop_dim) {
  HashTable *ht;
  int isset = 0;

  ht = (**container).value.ht;

  switch ((*offset).type) {
   case 2:
    hval = zend_dval_to_lval((*offset).value.dval);
    goto num_index_prop;
   case 7:
   case 3:
   case 1:
    hval = (*offset).value.lval;
num_index_prop:
    if (zend_hash_index_find(ht, hval, (void **) &value) == 0) {
     isset = 1;
    }
    break;
   case 6:
    if ((1<<2) == (1<<0)) {
     hval = (((zend_literal*)(offset))->hash_value);
    } else {
     if (!prop_dim) {
      do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index_prop; } } } while (0);
     }
     if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
      hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
     } else {
      hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
     }
    }
    if (zend_hash_quick_find(ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, (void **) &value) == 0) {
     isset = 1;
    }
    break;
   case 0:
    if (zend_hash_find(ht, "", sizeof(""), (void **) &value) == 0) {
     isset = 1;
    }
    break;
   default:
    zend_error((1<<1L), "Illegal offset type in isset or empty");
    break;
  }

  if (opline->extended_value & 0x02000000) {
   if (isset && (**value).type == 0) {
    result = 0;
   } else {
    result = isset;
   }
  } else {
   if (!isset || !i_zend_is_true(*value)) {
    result = 0;
   } else {
    result = 1;
   }
  }
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 } else if ((**container).type == 5) {
  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
  }
  if (prop_dim) {
   if ((**container).value.obj.handlers->has_property) {
    result = (**container).value.obj.handlers->has_property(*container, offset, (opline->extended_value & 0x01000000) != 0, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   } else {
    zend_error((1<<3L), "Trying to check property of non-object");
    result = 0;
   }
  } else {
   if ((**container).value.obj.handlers->has_dimension) {
    result = (**container).value.obj.handlers->has_dimension(*container, offset, (opline->extended_value & 0x01000000) != 0 );
   } else {
    zend_error((1<<3L), "Trying to check element of non-array");
    result = 0;
   }
  }
  if (0) {
   i_zval_ptr_dtor(*(&offset) );
  } else {
   if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
  }
 } else if ((*container)->type == 6 && !prop_dim) {
  zval tmp;

  if ((*offset).type != 1) {
   do { (&tmp)->value = (offset)->value; (*&tmp).type = (*offset).type; } while (0);
   _zval_copy_ctor((&tmp) );
   convert_to_long(&tmp);
   offset = &tmp;
  }
  if ((*offset).type == 1) {
   if (opline->extended_value & 0x02000000) {
    if (offset->value.lval >= 0 && offset->value.lval < (**container).value.str.len) {
     result = 1;
    }
   } else {
    if (offset->value.lval >= 0 && offset->value.lval < (**container).value.str.len && (**container).value.str.val[offset->value.lval] != '0') {
     result = 1;
    }
   }
  }
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 } else {
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 }

 ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).type = 3;
 if (opline->extended_value & 0x02000000) {
  ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.lval = result;
 } else {
  ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.lval = !result;
 }

 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_VAR(0, execute_data );
}

static int __attribute__((fastcall)) ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_VAR_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_VAR(1, execute_data );
}

static int __attribute__((fastcall)) zend_binary_assign_op_obj_helper_SPEC_VAR_UNUSED(int (*binary_op)(zval *result, zval *op1, zval *op2 ), zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op_data1;
 zval **object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 zval *object;
 zval *property = ((void *)0);
 zval *value = _get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, &free_op_data1, 0 );
 int have_get_ptr = 0;

 if ((1<<2) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }

 make_real_object(object_ptr );
 object = *object_ptr;

 if (__builtin_expect((*object).type != 5, 0)) {
  zend_error((1<<1L), "Attempt to assign property of non-object");

  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };

  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = &(executor_globals.uninitialized_zval);
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
  }
 } else {

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
  }


  if (opline->extended_value == 136
   && (*object).value.obj.handlers->get_property_ptr_ptr) {
   zval **zptr = (*object).value.obj.handlers->get_property_ptr_ptr(object, property, (((1<<3) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   if (zptr != ((void *)0)) {
    if (!zval_isref_p(*zptr)) { do { if (zval_refcount_p(*((zptr))) > 1) { zval *new_zv; zval_delref_p(*(zptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(zptr))->value; (*new_zv).type = (**(zptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(zptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

    have_get_ptr = 1;
    binary_op(*zptr, *zptr, value );
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((*zptr));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = *zptr;
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
   }
  }

  if (!have_get_ptr) {
   zval *z = ((void *)0);

   if (opline->extended_value == 136) {
    if ((*object).value.obj.handlers->read_property) {
     z = (*object).value.obj.handlers->read_property(object, property, 0, (((1<<3) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
    }
   } else {
    if ((*object).value.obj.handlers->read_dimension) {
     z = (*object).value.obj.handlers->read_dimension(object, property, 0 );
    }
   }
   if (z) {
    if ((*z).type == 5 && (*z).value.obj.handlers->get) {
     zval *value = (*z).value.obj.handlers->get(z );

     if (zval_refcount_p(z) == 0) {
      if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); };
      _zval_dtor((z) );
      do { if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); }; _efree((z) ); } while (0);
     }
     z = value;
    }
    zval_addref_p(z);
    if (!zval_isref_p(*&z)) { do { if (zval_refcount_p(*((&z))) > 1) { zval *new_zv; zval_delref_p(*(&z)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(&z))->value; (*new_zv).type = (**(&z)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(&z) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
    binary_op(z, z, value );
    if (opline->extended_value == 136) {
     (*object).value.obj.handlers->write_property(object, property, z, (((1<<3) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
    } else {
     (*object).value.obj.handlers->write_dimension(object, property, z );
    }
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((z));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = z;
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
    i_zval_ptr_dtor(*(&z) );
   } else {
    zend_error((1<<1L), "Attempt to assign property of non-object");
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((&(executor_globals.uninitialized_zval)));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = &(executor_globals.uninitialized_zval);
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
   }
  }

  if (0) {
   i_zval_ptr_dtor(*(&property) );
  } else {

  }
  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };
 }

 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_binary_assign_op_helper_SPEC_VAR_UNUSED(int (*binary_op)(zval *result, zval *op1, zval *op2 ), zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op_data2, free_op_data1;
 zval **var_ptr;
 zval *value;

 ;
 switch (opline->extended_value) {
  case 136:
   return zend_binary_assign_op_obj_helper_SPEC_VAR_UNUSED(binary_op, execute_data );
   break;
  case 147: {
    zval **container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

    if ((1<<2) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
     zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
    } else if (__builtin_expect((**container).type == 5, 0)) {
     if ((1<<2) == (1<<2) && !(free_op1.var != ((void *)0))) {
      zval_addref_p(*(container));
     }
     return zend_binary_assign_op_obj_helper_SPEC_VAR_UNUSED(binary_op, execute_data );
    } else {
     zval *dim = ((void *)0);

     zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)), container, dim, (1<<3), 2 );
     value = _get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, &free_op_data1, 0 );
     var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data->Ts, &free_op_data2 );
    }
   }
   break;
  default:
   value = ((void *)0);
   var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

   break;
 }

 if (__builtin_expect(var_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use assign-op operators with overloaded objects nor string offsets");
 }

 if (__builtin_expect(*var_ptr == &(executor_globals.error_zval), 0)) {
  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }

  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
  ;
  if (opline->extended_value == 147) {
   execute_data->opline++;
  }
  execute_data->opline++; return 0;
 }

 if (!zval_isref_p(*var_ptr)) { do { if (zval_refcount_p(*((var_ptr))) > 1) { zval *new_zv; zval_delref_p(*(var_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(var_ptr))->value; (*new_zv).type = (**(var_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(var_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

 if (__builtin_expect((**var_ptr).type == 5, 0)
    && ((**var_ptr)).value.obj.handlers->get
    && ((**var_ptr)).value.obj.handlers->set) {

  zval *objval = ((**var_ptr)).value.obj.handlers->get(*var_ptr );
  zval_addref_p(objval);
  binary_op(objval, objval, value );
  ((**var_ptr)).value.obj.handlers->set(var_ptr, objval );
  i_zval_ptr_dtor(*(&objval) );
 } else {
  binary_op(*var_ptr, *var_ptr, value );
 }

 if ((!((opline)->result_type & (1<<5)))) {
  zval_addref_p((*var_ptr));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (*var_ptr); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
 }

 if (opline->extended_value == 147) {
  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };
  if (free_op_data2.var) { i_zval_ptr_dtor(*(&free_op_data2.var) ); };
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
  ;
  execute_data->opline++;
 } else {
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
  ;
 }
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_ADD_SPEC_VAR_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_UNUSED(add_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SUB_SPEC_VAR_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_UNUSED(sub_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_MUL_SPEC_VAR_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_UNUSED(mul_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_DIV_SPEC_VAR_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_UNUSED(div_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_MOD_SPEC_VAR_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_UNUSED(mod_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SL_SPEC_VAR_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_UNUSED(shift_left_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SR_SPEC_VAR_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_UNUSED(shift_right_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_CONCAT_SPEC_VAR_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_UNUSED(concat_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_OR_SPEC_VAR_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_UNUSED(bitwise_or_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_AND_SPEC_VAR_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_UNUSED(bitwise_and_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_XOR_SPEC_VAR_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_UNUSED(bitwise_xor_function, execute_data );
}

static int __attribute__((fastcall)) zend_fetch_var_address_helper_SPEC_VAR_UNUSED(int type, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *varname;
 zval **retval;
 zval tmp_varname;
 HashTable *target_symbol_table;
 ulong hash_value;

 ;
 varname = _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

  if ((1<<2) != (1<<0) && __builtin_expect((*varname).type != 6, 0)) {
  do { (&tmp_varname)->value = (varname)->value; (*&tmp_varname).type = (*varname).type; } while (0);
  _zval_copy_ctor((&tmp_varname) );
  if ((&tmp_varname)->type != 6) { _convert_to_string((&tmp_varname) ); };
  varname = &tmp_varname;
 }

 if ((1<<3) != (1<<3)) {
  zend_class_entry *ce;

  if ((1<<3) == (1<<0)) {
   if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
    ce = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
   } else {
    ce = zend_fetch_class_by_name((*opline->op2.zv).value.str.val, (*opline->op2.zv).value.str.len, opline->op2.literal + 1, 0 );
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); } while (0);
   }
  } else {
   ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).class_entry;
  }
  retval = zend_std_get_static_property(ce, (*varname).value.str.val, (*varname).value.str.len, 0, (((1<<2) == (1<<0)) ? opline->op1.literal : ((void *)0)) );
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 } else {
  target_symbol_table = zend_get_target_symbol_table(opline->extended_value & 0x70000000 );






  if ((1<<2) == (1<<0)) {
   hash_value = (((zend_literal*)(varname))->hash_value);
  } else if (((((*varname).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*varname).value.str.val) < (compiler_globals.interned_strings_end)))) {
   hash_value = (((Bucket*)(((char*)((*varname).value.str.val))-sizeof(Bucket)))->h);
  } else {
   hash_value = zend_hash_func((*varname).value.str.val, (*varname).value.str.len+1);
  }

  if (zend_hash_quick_find(target_symbol_table, (*varname).value.str.val, (*varname).value.str.len+1, hash_value, (void **) &retval) == -1) {
   switch (type) {
    case 0:
    case 6:
     zend_error((1<<3L),"Undefined variable: %s", (*varname).value.str.val);

    case 3:
     retval = &(executor_globals.uninitialized_zval_ptr);
     break;
    case 2:
     zend_error((1<<3L),"Undefined variable: %s", (*varname).value.str.val);

    case 1:
     zval_addref_p(&(executor_globals.uninitialized_zval));
     _zend_hash_quick_add_or_update(target_symbol_table, (*varname).value.str.val, (*varname).value.str.len+1, hash_value, &(executor_globals.uninitialized_zval_ptr), sizeof(zval *), (void **) &retval, (1<<0) );
     break;
   
   }
  }
  switch (opline->extended_value & 0x70000000) {
   case 0x00000000:
    if ((1<<2) != (1<<1)) {
     if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
    }
    break;
   case 0x10000000:
    if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
    break;
   case 0x20000000:
    zval_update_constant(retval, (void*) 1 );
    break;
   case 0x40000000:
    if ((1<<2) == (1<<2) && !free_op1.var) {
     zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr));
    }
    break;
  }
 }


 if ((1<<2) != (1<<0) && varname == &tmp_varname) {
  _zval_dtor((&tmp_varname) );
 }
 if (opline->extended_value & 0x04000000) {
  if (!zval_isref_p(*retval)) { do { if (zval_refcount_p(*((retval))) > 1) { zval *new_zv; zval_delref_p(*(retval)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval))->value; (*new_zv).type = (**(retval)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((retval))); };
 }
 zval_addref_p((*retval));
 switch (type) {
  case 0:
  case 3:
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (*retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   break;
  case 6: {
   zend_free_op free_res;

   zend_pzval_unlock_func(*retval, &free_res, 1 );
   if (retval != &(executor_globals.uninitialized_zval_ptr)) {
    if (!zval_isref_p(*retval)) { do { if (zval_refcount_p(*((retval))) > 1) { zval *new_zv; zval_delref_p(*(retval)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval))->value; (*new_zv).type = (**(retval)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
   }
   zval_addref_p((*retval));
   if (free_res.var) { i_zval_ptr_dtor(*(&free_res.var) ); };
  }

  default:
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = retval;
   break;
 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_R_SPEC_VAR_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_VAR_UNUSED(0, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_W_SPEC_VAR_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_VAR_UNUSED(1, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_RW_SPEC_VAR_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_VAR_UNUSED(2, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_FUNC_ARG_SPEC_VAR_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 return zend_fetch_var_address_helper_SPEC_VAR_UNUSED(((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && (opline->extended_value & 0x000fffff) <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[(opline->extended_value & 0x000fffff)-1].pass_by_reference & (1|2)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x1000000|0x2000000))))?1:0, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_UNSET_SPEC_VAR_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_VAR_UNUSED(6, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_IS_SPEC_VAR_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_VAR_UNUSED(3, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_W_SPEC_VAR_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **container;

 ;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<2) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, ((void *)0), (1<<3), 1 );

 if ((1<<2) == (1<<2) && (free_op1.var != ((void *)0)) && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};


 if (__builtin_expect(opline->extended_value != 0, 0)) {
  zval **retval_ptr = (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr;

  if (retval_ptr) {
   zval_delref_p(*(retval_ptr));
   if (!zval_isref_p(*retval_ptr)) { do { if (zval_refcount_p(*((retval_ptr))) > 1) { zval *new_zv; zval_delref_p(*(retval_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval_ptr))->value; (*new_zv).type = (**(retval_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((retval_ptr))); };
   zval_addref_p(*(retval_ptr));
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_RW_SPEC_VAR_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **container;

 ;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<2) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, ((void *)0), (1<<3), 2 );

 if ((1<<2) == (1<<2) && (free_op1.var != ((void *)0)) && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **container;

 ;

 if (((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && (opline->extended_value & 0x000fffff) <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[(opline->extended_value & 0x000fffff)-1].pass_by_reference & (1|2)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x1000000|0x2000000))))) {
  container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
  if ((1<<2) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
  }
  zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, ((void *)0), (1<<3), 1 );
  if ((1<<2) == (1<<2) && (free_op1.var != ((void *)0)) && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
  }
 } else {
  if ((1<<3) == (1<<3)) {
   zend_error_noreturn((1<<0L), "Cannot use [] for reading");
  }
  container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
  zend_fetch_dimension_address_read(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, ((void *)0), (1<<3), 0 );
 }

 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_DIM_SPEC_VAR_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **object_ptr;

 ;
 object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<2) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 if ((**object_ptr).type == 5) {

  zval *property_name = ((void *)0);

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property_name))->value; (*_tmp).type = (*(property_name)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property_name) = _tmp; } while (0);
  }
  zend_assign_to_object((!((opline)->result_type & (1<<5)))?&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr:((void *)0), object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, 147, (((1<<3) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
  if (0) {
   i_zval_ptr_dtor(*(&property_name) );
  } else {

  }
 } else {
  zend_free_op free_op_data1, free_op_data2;
  zval *value;
  zval *dim = ((void *)0);
  zval **variable_ptr_ptr;

  zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)), object_ptr, dim, (1<<3), 1 );

  value = _get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, &free_op_data1, 0 );
  variable_ptr_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data->Ts, &free_op_data2 );
  if (__builtin_expect(variable_ptr_ptr == ((void *)0), 0)) {
   if (zend_assign_to_string_offset(&(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)), value, (opline+1)->op1_type )) {
    if ((!((opline)->result_type & (1<<5)))) {
     zval *retval;

     do { (retval) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(retval))->u.buffered = ((void *)0); } while (0);
     do { const char *__s=((*(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)).str_offset.str).value.str.val+(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)).str_offset.offset); int __l=1; zval *__z = (retval); (*__z).value.str.len = __l; (*__z).value.str.val = (1?_estrndup((__s), (__l) ):(char*)__s); (*__z).type = 6; } while (0);
     (retval)->refcount__gc = 1; (retval)->is_ref__gc = 0;;
     do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
    }
   } else if ((!((opline)->result_type & (1<<5)))) {
    zval_addref_p((&(executor_globals.uninitialized_zval)));
    do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   }
  } else if (__builtin_expect(*variable_ptr_ptr == &(executor_globals.error_zval), 0)) {
   if (((zend_uintptr_t)free_op_data1.var & 1L)) {
    _zval_dtor((value) );
   }
   if ((!((opline)->result_type & (1<<5)))) {
    zval_addref_p((&(executor_globals.uninitialized_zval)));
    do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   }
  } else {
   if ((opline+1)->op1_type == (1<<1)) {
     value = zend_assign_tmp_to_variable(variable_ptr_ptr, value );
   } else if ((opline+1)->op1_type == (1<<0)) {
     value = zend_assign_const_to_variable(variable_ptr_ptr, value );
   } else {
     value = zend_assign_to_variable(variable_ptr_ptr, value );
   }
   if ((!((opline)->result_type & (1<<5)))) {
    zval_addref_p((value));
    do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (value); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   }
  }
  if (free_op_data2.var) { i_zval_ptr_dtor(*(&free_op_data2.var) ); };
   if (free_op_data1.var != ((void *)0) && (((zend_uintptr_t)free_op_data1.var & 1L) == 0)) { i_zval_ptr_dtor(*(&free_op_data1.var) ); };
 }
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *function_name;
 zend_class_entry *ce;

 ;
 zend_ptr_stack_3_push(&(executor_globals.arg_types_stack), execute_data->fbc, execute_data->object, execute_data->called_scope);

 if ((1<<2) == (1<<0)) {

  if ((executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)]) {
   ce = (executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)];
  } else {
   ce = zend_fetch_class_by_name((*opline->op1.zv).value.str.val, (*opline->op1.zv).value.str.len, opline->op1.literal + 1, opline->extended_value );
   if (__builtin_expect(ce == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Class '%s' not found", (*opline->op1.zv).value.str.val);
   }
   do { (executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)] = (ce); } while (0);
  }
  execute_data->called_scope = ce;
 } else {
  ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).class_entry;

  if (opline->extended_value == 2 || opline->extended_value == 1) {
   execute_data->called_scope = (executor_globals.called_scope);
  } else {
   execute_data->called_scope = ce;
  }
 }

 if ((1<<2) == (1<<0) &&
     (1<<3) == (1<<0) &&
     (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
  execute_data->fbc = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
 } else if ((1<<2) != (1<<0) &&
            (1<<3) == (1<<0) &&
            (execute_data->fbc = (((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] == (ce)) ? (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] : ((void *)0)))) {

 } else if ((1<<3) != (1<<3)) {
  char *function_name_strval = ((void *)0);
  int function_name_strlen = 0;


  if ((1<<3) == (1<<0)) {
   function_name_strval = (*opline->op2.zv).value.str.val;
   function_name_strlen = (*opline->op2.zv).value.str.len;
  } else {
   function_name = ((void *)0);

   if (__builtin_expect((*function_name).type != 6, 0)) {
    zend_error_noreturn((1<<0L), "Function name must be a string");
   } else {
    function_name_strval = (*function_name).value.str.val;
    function_name_strlen = (*function_name).value.str.len;
    }
  }

  if (function_name_strval) {
   if (ce->get_static_method) {
    execute_data->fbc = ce->get_static_method(ce, function_name_strval, function_name_strlen );
   } else {
    execute_data->fbc = zend_std_get_static_method(ce, function_name_strval, function_name_strlen, (((1<<3) == (1<<0)) ? (opline->op2.literal + 1) : ((void *)0)) );
   }
   if (__builtin_expect(execute_data->fbc == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Call to undefined method %s::%s()", ce->name, function_name_strval);
   }
   if ((1<<3) == (1<<0) && __builtin_expect((execute_data->fbc->common.fn_flags & 0x200000) == 0, 1)) {
    if ((1<<2) == (1<<0)) {
     do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (execute_data->fbc); } while (0);
    } else {
     do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] = (execute_data->fbc); } while (0);
    }
   }
  }
  if ((1<<3) != (1<<0)) {

  }
 } else {
  if (__builtin_expect(ce->constructor == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot call constructor");
  }
  if ((executor_globals.This) && zend_get_class_entry(&(*(executor_globals.This)) ) != ce->constructor->common.scope && (ce->constructor->common.fn_flags & 0x400)) {
   zend_error_noreturn((1<<0L), "Cannot call private %s::__construct()", ce->name);
  }
  execute_data->fbc = ce->constructor;
 }

 if (execute_data->fbc->common.fn_flags & 0x01) {
  execute_data->object = ((void *)0);
 } else {
  if ((executor_globals.This) &&
      (*(executor_globals.This)).value.obj.handlers->get_class_entry &&
      !instanceof_function(zend_get_class_entry(&(*(executor_globals.This)) ), ce )) {


   if (execute_data->fbc->common.fn_flags & 0x10000) {
    zend_error((1<<11L), "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", execute_data->fbc->common.scope->name, execute_data->fbc->common.function_name);
   } else {

    zend_error_noreturn((1<<0L), "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", execute_data->fbc->common.scope->name, execute_data->fbc->common.function_name);
   }
  }
  if ((execute_data->object = (executor_globals.This))) {
   zval_addref_p(execute_data->object);
   execute_data->called_scope = zend_get_class_entry(&(*execute_data->object) );
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *expr_ptr;

 ;
 if (((1<<2) == (1<<2) || (1<<2) == (1<<4)) && opline->extended_value) {
  zval **expr_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

  if ((1<<2) == (1<<2) && __builtin_expect(expr_ptr_ptr == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot create references to/from string offsets");
  }
  if (!zval_isref_p(*expr_ptr_ptr)) { do { if (zval_refcount_p(*((expr_ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(expr_ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(expr_ptr_ptr))->value; (*new_zv).type = (**(expr_ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(expr_ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((expr_ptr_ptr))); };
  expr_ptr = *expr_ptr_ptr;
  zval_addref_p(expr_ptr);
 } else {
  expr_ptr=_get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
  if (0) {
   zval *new_expr;

   do { (new_expr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_expr))->u.buffered = ((void *)0); } while (0);
   do { do { (new_expr)->value = (expr_ptr)->value; (*new_expr).type = (*expr_ptr).type; } while (0); zval_set_refcount_p(new_expr, 1); zval_unset_isref_p(new_expr); } while (0);
   expr_ptr = new_expr;
  } else if ((1<<2) == (1<<0) || zval_isref_p(expr_ptr)) {
   zval *new_expr;

   do { (new_expr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_expr))->u.buffered = ((void *)0); } while (0);
   do { do { (new_expr)->value = (expr_ptr)->value; (*new_expr).type = (*expr_ptr).type; } while (0); zval_set_refcount_p(new_expr, 1); zval_unset_isref_p(new_expr); } while (0);
   expr_ptr = new_expr;
   _zval_copy_ctor((&(*expr_ptr)) );
  } else {
   zval_addref_p(expr_ptr);
  }
 }

 if ((1<<3) != (1<<3)) {

  zval *offset = ((void *)0);
  ulong hval;

  switch ((*offset).type) {
   case 2:
    hval = zend_dval_to_lval((*offset).value.dval);
    goto num_index;
   case 1:
   case 3:
    hval = (*offset).value.lval;
num_index:
    _zend_hash_index_update_or_next_insert(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, hval, &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   case 6:
    if ((1<<3) == (1<<0)) {
     hval = (((zend_literal*)(offset))->hash_value);
    } else {
     do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index; } } } while (0);
     if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
      hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
     } else {
      hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
     }
    }
    _zend_hash_quick_add_or_update(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   case 0:
    _zend_hash_add_or_update(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, "", sizeof(""), &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   default:
    zend_error((1<<1L), "Illegal offset type");
    i_zval_ptr_dtor(*(&expr_ptr) );

    break;
  }

 } else {
  _zend_hash_index_update_or_next_insert(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, 0, &expr_ptr, sizeof(zval *), ((void *)0), (1<<2) );
 }
 if (((1<<2) == (1<<2) || (1<<2) == (1<<4)) && opline->extended_value) {
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 } else {
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_ARRAY_SPEC_VAR_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 _array_init((&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var), 0 );
 if ((1<<2) == (1<<3)) {
  execute_data->opline++; return 0;

 } else {
  return ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_UNUSED_HANDLER(execute_data );

 }
}

static int __attribute__((fastcall)) ZEND_UNSET_VAR_SPEC_VAR_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval tmp, *varname;
 HashTable *target_symbol_table;
 zend_free_op free_op1;

 ;
 if ((1<<2) == (1<<4) &&
     (1<<3) == (1<<3) &&
     (opline->extended_value & 0x00800000)) {
  if ((executor_globals.active_symbol_table)) {
   zend_compiled_variable *cv = &((executor_globals.active_op_array)->vars[opline->op1.var]);

   zend_delete_variable(execute_data->prev_execute_data, (executor_globals.active_symbol_table), cv->name, cv->name_len+1, cv->hash_value );
   execute_data->CVs[opline->op1.var] = ((void *)0);
  } else if (execute_data->CVs[opline->op1.var]) {
   i_zval_ptr_dtor(*(execute_data->CVs[opline->op1.var]) );
   execute_data->CVs[opline->op1.var] = ((void *)0);
  }
  ;
  execute_data->opline++; return 0;
 }

 varname = _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<2) != (1<<0) && (*varname).type != 6) {
  do { (&tmp)->value = (varname)->value; (*&tmp).type = (*varname).type; } while (0);
  _zval_copy_ctor((&tmp) );
  if ((&tmp)->type != 6) { _convert_to_string((&tmp) ); };
  varname = &tmp;
 } else if ((1<<2) == (1<<2) || (1<<2) == (1<<4)) {
  zval_addref_p(varname);
 }

 if ((1<<3) != (1<<3)) {
  zend_class_entry *ce;

  if ((1<<3) == (1<<0)) {
   if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
    ce = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
   } else {
    ce = zend_fetch_class_by_name((*opline->op2.zv).value.str.val, (*opline->op2.zv).value.str.len, opline->op2.literal + 1, 0 );
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); } while (0);
   }
  } else {
   ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).class_entry;
  }
  zend_std_unset_static_property(ce, (*varname).value.str.val, (*varname).value.str.len, (((1<<2) == (1<<0)) ? opline->op1.literal : ((void *)0)) );
 } else {
  ulong hash_value = zend_inline_hash_func(varname->value.str.val, varname->value.str.len+1);

  target_symbol_table = zend_get_target_symbol_table(opline->extended_value & 0x70000000 );
  zend_delete_variable(execute_data, target_symbol_table, varname->value.str.val, varname->value.str.len+1, hash_value );
 }

 if ((1<<2) != (1<<0) && varname == &tmp) {
  _zval_dtor((&tmp) );
 } else if ((1<<2) == (1<<2) || (1<<2) == (1<<4)) {
  i_zval_ptr_dtor(*(&varname) );
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ISSET_ISEMPTY_VAR_SPEC_VAR_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval **value;
 zend_bool isset = 1;

 ;
 if ((1<<2) == (1<<4) &&
     (1<<3) == (1<<3) &&
     (opline->extended_value & 0x00800000)) {
  if (execute_data->CVs[opline->op1.var]) {
   value = execute_data->CVs[opline->op1.var];
  } else if ((executor_globals.active_symbol_table)) {
   zend_compiled_variable *cv = &((executor_globals.active_op_array)->vars[opline->op1.var]);

   if (zend_hash_quick_find((executor_globals.active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, (void **) &value) == -1) {
    isset = 0;
   }
  } else {
   isset = 0;
  }
 } else {
  HashTable *target_symbol_table;
  zend_free_op free_op1;
  zval tmp, *varname = _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

  if ((1<<2) != (1<<0) && (*varname).type != 6) {
   do { (&tmp)->value = (varname)->value; (*&tmp).type = (*varname).type; } while (0);
   _zval_copy_ctor((&tmp) );
   if ((&tmp)->type != 6) { _convert_to_string((&tmp) ); };
   varname = &tmp;
  }

  if ((1<<3) != (1<<3)) {
   zend_class_entry *ce;

   if ((1<<3) == (1<<0)) {
    if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
     ce = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
    } else {
     ce = zend_fetch_class_by_name((*opline->op2.zv).value.str.val, (*opline->op2.zv).value.str.len, opline->op2.literal + 1, 0 );
     do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); } while (0);
    }
   } else {
    ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).class_entry;
   }
   value = zend_std_get_static_property(ce, (*varname).value.str.val, (*varname).value.str.len, 1, (((1<<2) == (1<<0)) ? opline->op1.literal : ((void *)0)) );
   if (!value) {
    isset = 0;
   }
  } else {
   target_symbol_table = zend_get_target_symbol_table(opline->extended_value & 0x70000000 );
   if (zend_hash_find(target_symbol_table, varname->value.str.val, varname->value.str.len+1, (void **) &value) == -1) {
    isset = 0;
   }
  }

  if ((1<<2) != (1<<0) && varname == &tmp) {
   _zval_dtor((&tmp) );
  }
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 }

 if (opline->extended_value & 0x02000000) {
  if (isset && (**value).type != 0) {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((1) != 0); (*__z).type = 3; } while (0);
  } else {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((0) != 0); (*__z).type = 3; } while (0);
  }
 } else {
  if (!isset || !i_zend_is_true(*value)) {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((1) != 0); (*__z).type = 3; } while (0);
  } else {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((0) != 0); (*__z).type = 3; } while (0);
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SEPARATE_SPEC_VAR_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *var_ptr, *new_zv;

 ;
 var_ptr = (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr;
 if ((*var_ptr).type != 5 &&
     !zval_isref_p(var_ptr) &&
     zval_refcount_p(var_ptr) > 1) {

  zval_delref_p(var_ptr);
  do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0);
  do { do { (new_zv)->value = (var_ptr)->value; (*new_zv).type = (*var_ptr).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0);
  var_ptr = new_zv;
  _zval_copy_ctor((var_ptr) );
  (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr = var_ptr;
 }
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ADD_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 add_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SUB_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 sub_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_MUL_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 mul_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_DIV_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 div_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_MOD_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 mod_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SL_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 shift_left_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SR_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 shift_right_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_CONCAT_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 concat_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_IDENTICAL_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 is_identical_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_NOT_IDENTICAL_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 is_identical_function(result,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 (*result).value.lval = !(*result).value.lval;
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_EQUAL_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval == 0)) != 0); (*__z).type = 3; } while (0);
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_NOT_EQUAL_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval != 0)) != 0); (*__z).type = 3; } while (0);
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_SMALLER_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval < 0)) != 0); (*__z).type = 3; } while (0);
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_SMALLER_OR_EQUAL_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval <= 0)) != 0); (*__z).type = 3; } while (0);
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_OR_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 bitwise_or_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_AND_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 bitwise_and_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_XOR_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 bitwise_xor_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BOOL_XOR_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 boolean_xor_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_binary_assign_op_obj_helper_SPEC_VAR_CV(int (*binary_op)(zval *result, zval *op1, zval *op2 ), zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op_data1;
 zval **object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 zval *object;
 zval *property = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );
 zval *value = _get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, &free_op_data1, 0 );
 int have_get_ptr = 0;

 if ((1<<2) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }

 make_real_object(object_ptr );
 object = *object_ptr;

 if (__builtin_expect((*object).type != 5, 0)) {
  zend_error((1<<1L), "Attempt to assign property of non-object");

  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };

  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = &(executor_globals.uninitialized_zval);
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
  }
 } else {

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
  }


  if (opline->extended_value == 136
   && (*object).value.obj.handlers->get_property_ptr_ptr) {
   zval **zptr = (*object).value.obj.handlers->get_property_ptr_ptr(object, property, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   if (zptr != ((void *)0)) {
    if (!zval_isref_p(*zptr)) { do { if (zval_refcount_p(*((zptr))) > 1) { zval *new_zv; zval_delref_p(*(zptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(zptr))->value; (*new_zv).type = (**(zptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(zptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

    have_get_ptr = 1;
    binary_op(*zptr, *zptr, value );
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((*zptr));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = *zptr;
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
   }
  }

  if (!have_get_ptr) {
   zval *z = ((void *)0);

   if (opline->extended_value == 136) {
    if ((*object).value.obj.handlers->read_property) {
     z = (*object).value.obj.handlers->read_property(object, property, 0, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
    }
   } else {
    if ((*object).value.obj.handlers->read_dimension) {
     z = (*object).value.obj.handlers->read_dimension(object, property, 0 );
    }
   }
   if (z) {
    if ((*z).type == 5 && (*z).value.obj.handlers->get) {
     zval *value = (*z).value.obj.handlers->get(z );

     if (zval_refcount_p(z) == 0) {
      if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); };
      _zval_dtor((z) );
      do { if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); }; _efree((z) ); } while (0);
     }
     z = value;
    }
    zval_addref_p(z);
    if (!zval_isref_p(*&z)) { do { if (zval_refcount_p(*((&z))) > 1) { zval *new_zv; zval_delref_p(*(&z)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(&z))->value; (*new_zv).type = (**(&z)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(&z) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
    binary_op(z, z, value );
    if (opline->extended_value == 136) {
     (*object).value.obj.handlers->write_property(object, property, z, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
    } else {
     (*object).value.obj.handlers->write_dimension(object, property, z );
    }
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((z));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = z;
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
    i_zval_ptr_dtor(*(&z) );
   } else {
    zend_error((1<<1L), "Attempt to assign property of non-object");
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((&(executor_globals.uninitialized_zval)));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = &(executor_globals.uninitialized_zval);
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
   }
  }

  if (0) {
   i_zval_ptr_dtor(*(&property) );
  } else {

  }
  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };
 }

 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_binary_assign_op_helper_SPEC_VAR_CV(int (*binary_op)(zval *result, zval *op1, zval *op2 ), zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op_data2, free_op_data1;
 zval **var_ptr;
 zval *value;

 ;
 switch (opline->extended_value) {
  case 136:
   return zend_binary_assign_op_obj_helper_SPEC_VAR_CV(binary_op, execute_data );
   break;
  case 147: {
    zval **container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

    if ((1<<2) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
     zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
    } else if (__builtin_expect((**container).type == 5, 0)) {
     if ((1<<2) == (1<<2) && !(free_op1.var != ((void *)0))) {
      zval_addref_p(*(container));
     }
     return zend_binary_assign_op_obj_helper_SPEC_VAR_CV(binary_op, execute_data );
    } else {
     zval *dim = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );

     zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)), container, dim, (1<<4), 2 );
     value = _get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, &free_op_data1, 0 );
     var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data->Ts, &free_op_data2 );
    }
   }
   break;
  default:
   value = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );
   var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

   break;
 }

 if (__builtin_expect(var_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use assign-op operators with overloaded objects nor string offsets");
 }

 if (__builtin_expect(*var_ptr == &(executor_globals.error_zval), 0)) {
  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }

  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
  ;
  if (opline->extended_value == 147) {
   execute_data->opline++;
  }
  execute_data->opline++; return 0;
 }

 if (!zval_isref_p(*var_ptr)) { do { if (zval_refcount_p(*((var_ptr))) > 1) { zval *new_zv; zval_delref_p(*(var_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(var_ptr))->value; (*new_zv).type = (**(var_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(var_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

 if (__builtin_expect((**var_ptr).type == 5, 0)
    && ((**var_ptr)).value.obj.handlers->get
    && ((**var_ptr)).value.obj.handlers->set) {

  zval *objval = ((**var_ptr)).value.obj.handlers->get(*var_ptr );
  zval_addref_p(objval);
  binary_op(objval, objval, value );
  ((**var_ptr)).value.obj.handlers->set(var_ptr, objval );
  i_zval_ptr_dtor(*(&objval) );
 } else {
  binary_op(*var_ptr, *var_ptr, value );
 }

 if ((!((opline)->result_type & (1<<5)))) {
  zval_addref_p((*var_ptr));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (*var_ptr); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
 }

 if (opline->extended_value == 147) {
  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };
  if (free_op_data2.var) { i_zval_ptr_dtor(*(&free_op_data2.var) ); };
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
  ;
  execute_data->opline++;
 } else {
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
  ;
 }
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_ADD_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_CV(add_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SUB_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_CV(sub_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_MUL_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_CV(mul_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_DIV_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_CV(div_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_MOD_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_CV(mod_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SL_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_CV(shift_left_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SR_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_CV(shift_right_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_CONCAT_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_CV(concat_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_OR_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_CV(bitwise_or_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_AND_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_CV(bitwise_and_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_XOR_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_VAR_CV(bitwise_xor_function, execute_data );
}

static int __attribute__((fastcall)) zend_pre_incdec_property_helper_SPEC_VAR_CV(incdec_t incdec_op, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **object_ptr;
 zval *object;
 zval *property;
 zval **retval;
 int have_get_ptr = 0;

 ;
 object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 property = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );
 retval = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr;

 if ((1<<2) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot increment/decrement overloaded objects nor string offsets");
 }

 make_real_object(object_ptr );
 object = *object_ptr;

 if (__builtin_expect((*object).type != 5, 0)) {
  zend_error((1<<1L), "Attempt to increment/decrement property of non-object");

  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   *retval = &(executor_globals.uninitialized_zval);
  }
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
  ;
  execute_data->opline++; return 0;
 }



 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }

 if ((*object).value.obj.handlers->get_property_ptr_ptr) {
  zval **zptr = (*object).value.obj.handlers->get_property_ptr_ptr(object, property, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
  if (zptr != ((void *)0)) {
   if (!zval_isref_p(*zptr)) { do { if (zval_refcount_p(*((zptr))) > 1) { zval *new_zv; zval_delref_p(*(zptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(zptr))->value; (*new_zv).type = (**(zptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(zptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

   have_get_ptr = 1;
   incdec_op(*zptr);
   if ((!((opline)->result_type & (1<<5)))) {
    *retval = *zptr;
    zval_addref_p((*retval));
   }
  }
 }

 if (!have_get_ptr) {
  if ((*object).value.obj.handlers->read_property && (*object).value.obj.handlers->write_property) {
   zval *z = (*object).value.obj.handlers->read_property(object, property, 0, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );

   if (__builtin_expect((*z).type == 5, 0) && (*z).value.obj.handlers->get) {
    zval *value = (*z).value.obj.handlers->get(z );

    if (zval_refcount_p(z) == 0) {
     if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); };
     _zval_dtor((z) );
     do { if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); }; _efree((z) ); } while (0);
    }
    z = value;
   }
   zval_addref_p(z);
   if (!zval_isref_p(*&z)) { do { if (zval_refcount_p(*((&z))) > 1) { zval *new_zv; zval_delref_p(*(&z)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(&z))->value; (*new_zv).type = (**(&z)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(&z) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
   incdec_op(z);
   *retval = z;
   (*object).value.obj.handlers->write_property(object, property, z, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   if ((!((opline)->result_type & (1<<5)))) { zval_addref_p((*retval)); };
   i_zval_ptr_dtor(*(&z) );
  } else {
   zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
   if ((!((opline)->result_type & (1<<5)))) {
    zval_addref_p((&(executor_globals.uninitialized_zval)));
    *retval = &(executor_globals.uninitialized_zval);
   }
  }
 }

 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {

 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_PRE_INC_OBJ_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_pre_incdec_property_helper_SPEC_VAR_CV(increment_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_PRE_DEC_OBJ_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_pre_incdec_property_helper_SPEC_VAR_CV(decrement_function, execute_data );
}

static int __attribute__((fastcall)) zend_post_incdec_property_helper_SPEC_VAR_CV(incdec_t incdec_op, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **object_ptr;
 zval *object;
 zval *property;
 zval *retval;
 int have_get_ptr = 0;

 ;
 object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 property = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );
 retval = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 if ((1<<2) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot increment/decrement overloaded objects nor string offsets");
 }

 make_real_object(object_ptr );
 object = *object_ptr;

 if (__builtin_expect((*object).type != 5, 0)) {
  zend_error((1<<1L), "Attempt to increment/decrement property of non-object");

  { (*retval).type = 0; };
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
  ;
  execute_data->opline++; return 0;
 }



 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }

 if ((*object).value.obj.handlers->get_property_ptr_ptr) {
  zval **zptr = (*object).value.obj.handlers->get_property_ptr_ptr(object, property, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
  if (zptr != ((void *)0)) {
   have_get_ptr = 1;
   if (!zval_isref_p(*zptr)) { do { if (zval_refcount_p(*((zptr))) > 1) { zval *new_zv; zval_delref_p(*(zptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(zptr))->value; (*new_zv).type = (**(zptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(zptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

   do { (retval)->value = (*zptr)->value; (*retval).type = (**zptr).type; } while (0);
   _zval_copy_ctor((&(*retval)) );

   incdec_op(*zptr);

  }
 }

 if (!have_get_ptr) {
  if ((*object).value.obj.handlers->read_property && (*object).value.obj.handlers->write_property) {
   zval *z = (*object).value.obj.handlers->read_property(object, property, 0, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   zval *z_copy;

   if (__builtin_expect((*z).type == 5, 0) && (*z).value.obj.handlers->get) {
    zval *value = (*z).value.obj.handlers->get(z );

    if (zval_refcount_p(z) == 0) {
     if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); };
     _zval_dtor((z) );
     do { if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); }; _efree((z) ); } while (0);
    }
    z = value;
   }
   do { (retval)->value = (z)->value; (*retval).type = (*z).type; } while (0);
   _zval_copy_ctor((&(*retval)) );
   do { (z_copy) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(z_copy))->u.buffered = ((void *)0); } while (0);
   do { do { (z_copy)->value = (z)->value; (*z_copy).type = (*z).type; } while (0); zval_set_refcount_p(z_copy, 1); zval_unset_isref_p(z_copy); } while (0);
   _zval_copy_ctor((&(*z_copy)) );
   incdec_op(z_copy);
   zval_addref_p(z);
   (*object).value.obj.handlers->write_property(object, property, z_copy, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   i_zval_ptr_dtor(*(&z_copy) );
   i_zval_ptr_dtor(*(&z) );
  } else {
   zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
   { (*retval).type = 0; };
  }
 }

 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {

 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_POST_INC_OBJ_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_post_incdec_property_helper_SPEC_VAR_CV(increment_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_POST_DEC_OBJ_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_post_incdec_property_helper_SPEC_VAR_CV(decrement_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_R_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **container;

 ;

 if ((opline->extended_value & 0x08000000) &&
     (1<<2) != (1<<4) &&
     (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr) {
  zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr));
 }
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 zend_fetch_dimension_address_read(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ), (1<<4), 0 );

 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_W_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **container;

 ;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<2) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ), (1<<4), 1 );

 if ((1<<2) == (1<<2) && (free_op1.var != ((void *)0)) && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};


 if (__builtin_expect(opline->extended_value != 0, 0)) {
  zval **retval_ptr = (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr;

  if (retval_ptr) {
   zval_delref_p(*(retval_ptr));
   if (!zval_isref_p(*retval_ptr)) { do { if (zval_refcount_p(*((retval_ptr))) > 1) { zval *new_zv; zval_delref_p(*(retval_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval_ptr))->value; (*new_zv).type = (**(retval_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((retval_ptr))); };
   zval_addref_p(*(retval_ptr));
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_RW_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **container;

 ;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<2) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ), (1<<4), 2 );

 if ((1<<2) == (1<<2) && (free_op1.var != ((void *)0)) && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_IS_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **container;

 ;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 zend_fetch_dimension_address_read(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ), (1<<4), 3 );

 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **container;

 ;

 if (((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && (opline->extended_value & 0x000fffff) <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[(opline->extended_value & 0x000fffff)-1].pass_by_reference & (1|2)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x1000000|0x2000000))))) {
  container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
  if ((1<<2) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
  }
  zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ), (1<<4), 1 );
  if ((1<<2) == (1<<2) && (free_op1.var != ((void *)0)) && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
  }
 } else {
  if ((1<<4) == (1<<3)) {
   zend_error_noreturn((1<<0L), "Cannot use [] for reading");
  }
  container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
  zend_fetch_dimension_address_read(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ), (1<<4), 0 );
 }

 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_UNSET_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **container;

 ;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<2) == (1<<4)) {
  if (container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
 }
 if ((1<<2) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ), (1<<4), 6 );

 if ((1<<2) == (1<<2) && (free_op1.var != ((void *)0)) && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 if (__builtin_expect((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot unset string offsets");
 } else {
  zend_free_op free_res;
  zval **retval_ptr = (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr;

  zend_pzval_unlock_func(*retval_ptr, &free_res, 1 );
  if (retval_ptr != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*retval_ptr)) { do { if (zval_refcount_p(*((retval_ptr))) > 1) { zval *new_zv; zval_delref_p(*(retval_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval_ptr))->value; (*new_zv).type = (**(retval_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
  zval_addref_p((*retval_ptr));
  if (free_res.var) { i_zval_ptr_dtor(*(&free_res.var) ); };
  ;
  execute_data->opline++; return 0;
 }
}

static int __attribute__((fastcall)) zend_fetch_property_address_read_helper_SPEC_VAR_CV(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *container;

 zval *offset;

 ;
 container = _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 offset = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );

 if (__builtin_expect((*container).type != 5, 0) ||
     __builtin_expect((*container).value.obj.handlers->read_property == ((void *)0), 0)) {
  zend_error((1<<3L), "Trying to get property of non-object");
  zval_addref_p((&(executor_globals.uninitialized_zval)));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);

 } else {
  zval *retval;

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
  }


  retval = (*container).value.obj.handlers->read_property(container, offset, 0, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );

  zval_addref_p((retval));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);

  if (0) {
   i_zval_ptr_dtor(*(&offset) );
  } else {

  }
 }

 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_R_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_property_address_read_helper_SPEC_VAR_CV(execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_W_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *property;
 zval **container;

 ;
 property = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );

 if ((1<<2) == (1<<2) && (opline->extended_value & 0x08000000)) {
  zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr));
  (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr = *(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr;
 }

 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 if ((1<<2) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }

 zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)), 1 );
 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {

 }
 if ((1<<2) == (1<<2) && (free_op1.var != ((void *)0)) && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};


 if (opline->extended_value & 0x04000000) {
  zval **retval_ptr = (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr;

  zval_delref_p(*(retval_ptr));
  if (!zval_isref_p(*retval_ptr)) { do { if (zval_refcount_p(*((retval_ptr))) > 1) { zval *new_zv; zval_delref_p(*(retval_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval_ptr))->value; (*new_zv).type = (**(retval_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((retval_ptr))); };
  zval_addref_p(*(retval_ptr));
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_RW_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *property;
 zval **container;

 ;
 property = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }
 if ((1<<2) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }
 zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)), 2 );
 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {

 }
 if ((1<<2) == (1<<2) && (free_op1.var != ((void *)0)) && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_IS_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *container;

 zval *offset;

 ;
 container = _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 offset = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );

 if (__builtin_expect((*container).type != 5, 0) ||
     __builtin_expect((*container).value.obj.handlers->read_property == ((void *)0), 0)) {
  zval_addref_p((&(executor_globals.uninitialized_zval)));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);

 } else {
  zval *retval;

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
  }


  retval = (*container).value.obj.handlers->read_property(container, offset, 3, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );

  zval_addref_p((retval));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);

  if (0) {
   i_zval_ptr_dtor(*(&offset) );
  } else {

  }
 }

 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 if (((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && (opline->extended_value & 0x000fffff) <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[(opline->extended_value & 0x000fffff)-1].pass_by_reference & (1|2)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x1000000|0x2000000))))) {

  zend_free_op free_op1;
  zval *property;
  zval **container;

  ;
  property = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );
  container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
  }
  if ((1<<2) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
  }
  zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)), 1 );
  if (0) {
   i_zval_ptr_dtor(*(&property) );
  } else {

  }
  if ((1<<2) == (1<<2) && (free_op1.var != ((void *)0)) && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
  }
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
  ;
  execute_data->opline++; return 0;
 } else {
  return zend_fetch_property_address_read_helper_SPEC_VAR_CV(execute_data );
 }
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_UNSET_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_res;
 zval **container;
 zval *property;

 ;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 property = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );

 if ((1<<2) == (1<<4)) {
  if (container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
 }
 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }
 if ((1<<2) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }
 zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)), 6 );
 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {

 }
 if ((1<<2) == (1<<2) && (free_op1.var != ((void *)0)) && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 zend_pzval_unlock_func(*(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr, &free_res, 1 );
 if ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr != &(executor_globals.uninitialized_zval_ptr)) {
  if (!zval_isref_p(*(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr)) { do { if (zval_refcount_p(*(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr))->value; (*new_zv).type = (**((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
 }
 zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr));
 if (free_res.var) { i_zval_ptr_dtor(*(&free_res.var) ); };
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_OBJ_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **object_ptr;
 zval *property_name;

 ;
 object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 property_name = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );

 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property_name))->value; (*_tmp).type = (*(property_name)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property_name) = _tmp; } while (0);
 }
 if ((1<<2) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 zend_assign_to_object((!((opline)->result_type & (1<<5)))?&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr:((void *)0), object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, 136, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
 if (0) {
  i_zval_ptr_dtor(*(&property_name) );
 } else {

 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_DIM_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **object_ptr;

 ;
 object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<2) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 if ((**object_ptr).type == 5) {

  zval *property_name = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property_name))->value; (*_tmp).type = (*(property_name)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property_name) = _tmp; } while (0);
  }
  zend_assign_to_object((!((opline)->result_type & (1<<5)))?&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr:((void *)0), object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, 147, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
  if (0) {
   i_zval_ptr_dtor(*(&property_name) );
  } else {

  }
 } else {
  zend_free_op free_op_data1, free_op_data2;
  zval *value;
  zval *dim = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );
  zval **variable_ptr_ptr;

  zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)), object_ptr, dim, (1<<4), 1 );

  value = _get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, &free_op_data1, 0 );
  variable_ptr_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data->Ts, &free_op_data2 );
  if (__builtin_expect(variable_ptr_ptr == ((void *)0), 0)) {
   if (zend_assign_to_string_offset(&(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)), value, (opline+1)->op1_type )) {
    if ((!((opline)->result_type & (1<<5)))) {
     zval *retval;

     do { (retval) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(retval))->u.buffered = ((void *)0); } while (0);
     do { const char *__s=((*(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)).str_offset.str).value.str.val+(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)).str_offset.offset); int __l=1; zval *__z = (retval); (*__z).value.str.len = __l; (*__z).value.str.val = (1?_estrndup((__s), (__l) ):(char*)__s); (*__z).type = 6; } while (0);
     (retval)->refcount__gc = 1; (retval)->is_ref__gc = 0;;
     do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
    }
   } else if ((!((opline)->result_type & (1<<5)))) {
    zval_addref_p((&(executor_globals.uninitialized_zval)));
    do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   }
  } else if (__builtin_expect(*variable_ptr_ptr == &(executor_globals.error_zval), 0)) {
   if (((zend_uintptr_t)free_op_data1.var & 1L)) {
    _zval_dtor((value) );
   }
   if ((!((opline)->result_type & (1<<5)))) {
    zval_addref_p((&(executor_globals.uninitialized_zval)));
    do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   }
  } else {
   if ((opline+1)->op1_type == (1<<1)) {
     value = zend_assign_tmp_to_variable(variable_ptr_ptr, value );
   } else if ((opline+1)->op1_type == (1<<0)) {
     value = zend_assign_const_to_variable(variable_ptr_ptr, value );
   } else {
     value = zend_assign_to_variable(variable_ptr_ptr, value );
   }
   if ((!((opline)->result_type & (1<<5)))) {
    zval_addref_p((value));
    do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (value); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   }
  }
  if (free_op_data2.var) { i_zval_ptr_dtor(*(&free_op_data2.var) ); };
   if (free_op_data1.var != ((void *)0) && (((zend_uintptr_t)free_op_data1.var & 1L) == 0)) { i_zval_ptr_dtor(*(&free_op_data1.var) ); };
 }
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *value;
 zval **variable_ptr_ptr;

 ;
 value = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );
 variable_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if ((1<<2) == (1<<2) && __builtin_expect(variable_ptr_ptr == ((void *)0), 0)) {
  if (zend_assign_to_string_offset(&(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)), value, (1<<4) )) {
   if ((!((opline)->result_type & (1<<5)))) {
    zval *retval;

    do { (retval) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(retval))->u.buffered = ((void *)0); } while (0);
    do { const char *__s=((*(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).str_offset.str).value.str.val+(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).str_offset.offset); int __l=1; zval *__z = (retval); (*__z).value.str.len = __l; (*__z).value.str.val = (1?_estrndup((__s), (__l) ):(char*)__s); (*__z).type = 6; } while (0);
    (retval)->refcount__gc = 1; (retval)->is_ref__gc = 0;;
    do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   }
  } else if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }
 } else if ((1<<2) == (1<<2) && __builtin_expect(*variable_ptr_ptr == &(executor_globals.error_zval), 0)) {
  if (0) {
   _zval_dtor((value) );
  }
  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }
 } else {
  if ((1<<4) == (1<<1)) {
    value = zend_assign_tmp_to_variable(variable_ptr_ptr, value );
  } else if ((1<<4) == (1<<0)) {
    value = zend_assign_const_to_variable(variable_ptr_ptr, value );
  } else {
    value = zend_assign_to_variable(variable_ptr_ptr, value );
  }
  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((value));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (value); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }
 }

 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};



 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_REF_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval **variable_ptr_ptr;
 zval **value_ptr_ptr;

 ;
 value_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op2.var );

 if ((1<<4) == (1<<2) &&
     value_ptr_ptr &&
     !zval_isref_p(*(value_ptr_ptr)) &&
     opline->extended_value == 1<<0 &&
     !(*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).var.fcall_returned_reference) {
  if (free_op2.var == ((void *)0)) {
   zval_addref_p((*value_ptr_ptr));
  }
  zend_error((1<<11L), "Only variables should be assigned by reference");
  if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {

   ; return 0;
  }
  return ZEND_ASSIGN_SPEC_VAR_CV_HANDLER(execute_data );
 } else if ((1<<4) == (1<<2) && opline->extended_value == 1<<1) {
  zval_addref_p((*value_ptr_ptr));
 }
 if ((1<<2) == (1<<2) && __builtin_expect((*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr == &(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr, 0)) {
  zend_error_noreturn((1<<0L), "Cannot assign by reference to overloaded object");
 }

 variable_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 if (((1<<4) == (1<<2) && __builtin_expect(value_ptr_ptr == ((void *)0), 0)) ||
     ((1<<2) == (1<<2) && __builtin_expect(variable_ptr_ptr == ((void *)0), 0))) {
  zend_error_noreturn((1<<0L), "Cannot create references to/from string offsets nor overloaded objects");
 }
 zend_assign_to_variable_reference(variable_ptr_ptr, value_ptr_ptr );

 if ((1<<4) == (1<<2) && opline->extended_value == 1<<1) {
  zval_delref_p(*(variable_ptr_ptr));
 }

 if ((!((opline)->result_type & (1<<5)))) {
  zval_addref_p((*variable_ptr_ptr));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (*variable_ptr_ptr); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
 }

 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_METHOD_CALL_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *function_name;
 char *function_name_strval;
 int function_name_strlen;
 zend_free_op free_op1;

 ;
 zend_ptr_stack_3_push(&(executor_globals.arg_types_stack), execute_data->fbc, execute_data->object, execute_data->called_scope);

 function_name = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );

 if ((1<<4) != (1<<0) &&
     __builtin_expect((*function_name).type != 6, 0)) {
  zend_error_noreturn((1<<0L), "Method name must be a string");
 }

 function_name_strval = (*function_name).value.str.val;
 function_name_strlen = (*function_name).value.str.len;

 execute_data->object = _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 if (__builtin_expect(execute_data->object != ((void *)0), 1) &&
     __builtin_expect((*execute_data->object).type == 5, 1)) {
  execute_data->called_scope = zend_get_class_entry(&(*execute_data->object) );

  if ((1<<4) != (1<<0) ||
      (execute_data->fbc = (((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] == (execute_data->called_scope)) ? (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] : ((void *)0))) == ((void *)0)) {
      zval *object = execute_data->object;

   if (__builtin_expect((*execute_data->object).value.obj.handlers->get_method == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Object does not support method calls");
   }


   execute_data->fbc = (*execute_data->object).value.obj.handlers->get_method(&execute_data->object, function_name_strval, function_name_strlen, (((1<<4) == (1<<0)) ? (opline->op2.literal + 1) : ((void *)0)) );
   if (__builtin_expect(execute_data->fbc == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Call to undefined method %s::%s()", ((execute_data->object) && (*execute_data->object).type == 5 && (*execute_data->object).value.obj.handlers->get_class_entry != ((void *)0) && (*execute_data->object).value.obj.handlers->get_class_entry(execute_data->object ) ? (*execute_data->object).value.obj.handlers->get_class_entry(execute_data->object )->name : ""), function_name_strval);
   }
   if ((1<<4) == (1<<0) &&
       __builtin_expect((execute_data->fbc->common.fn_flags & 0x200000) == 0, 1) &&
       __builtin_expect(execute_data->object == object, 1)) {
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (execute_data->called_scope); (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] = (execute_data->fbc); } while (0);
   }
  }
 } else {
  zend_error_noreturn((1<<0L), "Call to a member function %s() on a non-object", function_name_strval);
 }

 if ((execute_data->fbc->common.fn_flags & 0x01) != 0) {
  execute_data->object = ((void *)0);
 } else {
  if (!zval_isref_p(execute_data->object)) {
   zval_addref_p(execute_data->object);
  } else {
   zval *this_ptr;
   do { (this_ptr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(this_ptr))->u.buffered = ((void *)0); } while (0);
   do { do { (this_ptr)->value = (execute_data->object)->value; (*this_ptr).type = (*execute_data->object).type; } while (0); zval_set_refcount_p(this_ptr, 1); zval_unset_isref_p(this_ptr); } while (0);
   _zval_copy_ctor((this_ptr) );
   execute_data->object = this_ptr;
  }
 }

 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *function_name;
 zend_class_entry *ce;

 ;
 zend_ptr_stack_3_push(&(executor_globals.arg_types_stack), execute_data->fbc, execute_data->object, execute_data->called_scope);

 if ((1<<2) == (1<<0)) {

  if ((executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)]) {
   ce = (executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)];
  } else {
   ce = zend_fetch_class_by_name((*opline->op1.zv).value.str.val, (*opline->op1.zv).value.str.len, opline->op1.literal + 1, opline->extended_value );
   if (__builtin_expect(ce == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Class '%s' not found", (*opline->op1.zv).value.str.val);
   }
   do { (executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)] = (ce); } while (0);
  }
  execute_data->called_scope = ce;
 } else {
  ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).class_entry;

  if (opline->extended_value == 2 || opline->extended_value == 1) {
   execute_data->called_scope = (executor_globals.called_scope);
  } else {
   execute_data->called_scope = ce;
  }
 }

 if ((1<<2) == (1<<0) &&
     (1<<4) == (1<<0) &&
     (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
  execute_data->fbc = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
 } else if ((1<<2) != (1<<0) &&
            (1<<4) == (1<<0) &&
            (execute_data->fbc = (((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] == (ce)) ? (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] : ((void *)0)))) {

 } else if ((1<<4) != (1<<3)) {
  char *function_name_strval = ((void *)0);
  int function_name_strlen = 0;


  if ((1<<4) == (1<<0)) {
   function_name_strval = (*opline->op2.zv).value.str.val;
   function_name_strlen = (*opline->op2.zv).value.str.len;
  } else {
   function_name = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );

   if (__builtin_expect((*function_name).type != 6, 0)) {
    zend_error_noreturn((1<<0L), "Function name must be a string");
   } else {
    function_name_strval = (*function_name).value.str.val;
    function_name_strlen = (*function_name).value.str.len;
    }
  }

  if (function_name_strval) {
   if (ce->get_static_method) {
    execute_data->fbc = ce->get_static_method(ce, function_name_strval, function_name_strlen );
   } else {
    execute_data->fbc = zend_std_get_static_method(ce, function_name_strval, function_name_strlen, (((1<<4) == (1<<0)) ? (opline->op2.literal + 1) : ((void *)0)) );
   }
   if (__builtin_expect(execute_data->fbc == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Call to undefined method %s::%s()", ce->name, function_name_strval);
   }
   if ((1<<4) == (1<<0) && __builtin_expect((execute_data->fbc->common.fn_flags & 0x200000) == 0, 1)) {
    if ((1<<2) == (1<<0)) {
     do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (execute_data->fbc); } while (0);
    } else {
     do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] = (execute_data->fbc); } while (0);
    }
   }
  }
  if ((1<<4) != (1<<0)) {

  }
 } else {
  if (__builtin_expect(ce->constructor == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot call constructor");
  }
  if ((executor_globals.This) && zend_get_class_entry(&(*(executor_globals.This)) ) != ce->constructor->common.scope && (ce->constructor->common.fn_flags & 0x400)) {
   zend_error_noreturn((1<<0L), "Cannot call private %s::__construct()", ce->name);
  }
  execute_data->fbc = ce->constructor;
 }

 if (execute_data->fbc->common.fn_flags & 0x01) {
  execute_data->object = ((void *)0);
 } else {
  if ((executor_globals.This) &&
      (*(executor_globals.This)).value.obj.handlers->get_class_entry &&
      !instanceof_function(zend_get_class_entry(&(*(executor_globals.This)) ), ce )) {


   if (execute_data->fbc->common.fn_flags & 0x10000) {
    zend_error((1<<11L), "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", execute_data->fbc->common.scope->name, execute_data->fbc->common.function_name);
   } else {

    zend_error_noreturn((1<<0L), "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", execute_data->fbc->common.scope->name, execute_data->fbc->common.function_name);
   }
  }
  if ((execute_data->object = (executor_globals.This))) {
   zval_addref_p(execute_data->object);
   execute_data->called_scope = zend_get_class_entry(&(*execute_data->object) );
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_CASE_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;

 ;
 if ((1<<2)==(1<<2)) {
  zval_addref_p(((*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr));
 }
 is_equal_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
     _get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 ),
     _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *expr_ptr;

 ;
 if (((1<<2) == (1<<2) || (1<<2) == (1<<4)) && opline->extended_value) {
  zval **expr_ptr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

  if ((1<<2) == (1<<2) && __builtin_expect(expr_ptr_ptr == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot create references to/from string offsets");
  }
  if (!zval_isref_p(*expr_ptr_ptr)) { do { if (zval_refcount_p(*((expr_ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(expr_ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(expr_ptr_ptr))->value; (*new_zv).type = (**(expr_ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(expr_ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((expr_ptr_ptr))); };
  expr_ptr = *expr_ptr_ptr;
  zval_addref_p(expr_ptr);
 } else {
  expr_ptr=_get_zval_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
  if (0) {
   zval *new_expr;

   do { (new_expr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_expr))->u.buffered = ((void *)0); } while (0);
   do { do { (new_expr)->value = (expr_ptr)->value; (*new_expr).type = (*expr_ptr).type; } while (0); zval_set_refcount_p(new_expr, 1); zval_unset_isref_p(new_expr); } while (0);
   expr_ptr = new_expr;
  } else if ((1<<2) == (1<<0) || zval_isref_p(expr_ptr)) {
   zval *new_expr;

   do { (new_expr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_expr))->u.buffered = ((void *)0); } while (0);
   do { do { (new_expr)->value = (expr_ptr)->value; (*new_expr).type = (*expr_ptr).type; } while (0); zval_set_refcount_p(new_expr, 1); zval_unset_isref_p(new_expr); } while (0);
   expr_ptr = new_expr;
   _zval_copy_ctor((&(*expr_ptr)) );
  } else {
   zval_addref_p(expr_ptr);
  }
 }

 if ((1<<4) != (1<<3)) {

  zval *offset = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );
  ulong hval;

  switch ((*offset).type) {
   case 2:
    hval = zend_dval_to_lval((*offset).value.dval);
    goto num_index;
   case 1:
   case 3:
    hval = (*offset).value.lval;
num_index:
    _zend_hash_index_update_or_next_insert(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, hval, &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   case 6:
    if ((1<<4) == (1<<0)) {
     hval = (((zend_literal*)(offset))->hash_value);
    } else {
     do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index; } } } while (0);
     if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
      hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
     } else {
      hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
     }
    }
    _zend_hash_quick_add_or_update(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   case 0:
    _zend_hash_add_or_update(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, "", sizeof(""), &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   default:
    zend_error((1<<1L), "Illegal offset type");
    i_zval_ptr_dtor(*(&expr_ptr) );

    break;
  }

 } else {
  _zend_hash_index_update_or_next_insert(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, 0, &expr_ptr, sizeof(zval *), ((void *)0), (1<<2) );
 }
 if (((1<<2) == (1<<2) || (1<<2) == (1<<4)) && opline->extended_value) {
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 } else {
  if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};
 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_ARRAY_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 _array_init((&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var), 0 );
 if ((1<<2) == (1<<3)) {
  execute_data->opline++; return 0;

 } else {
  return ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CV_HANDLER(execute_data );

 }
}

static int __attribute__((fastcall)) ZEND_UNSET_DIM_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **container;
 zval *offset;
 ulong hval;

 ;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 offset = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );

 if ((1<<2) != (1<<2) || container) {
  if ((1<<2) == (1<<4) && container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
  switch ((**container).type) {
   case 4: {
    HashTable *ht = (**container).value.ht;

    switch ((*offset).type) {
     case 2:
      hval = zend_dval_to_lval((*offset).value.dval);
      goto num_index_dim;
     case 7:
     case 3:
     case 1:
num_index_dim:
      hval = (*offset).value.lval;
      zend_hash_del_key_or_index(ht, ((void *)0), 0, hval, 1);
      break;
     case 6:
      if ((1<<4) == (1<<4) || (1<<4) == (1<<2)) {
       zval_addref_p(offset);
      }
      if ((1<<4) == (1<<0)) {
       hval = (((zend_literal*)(offset))->hash_value);
      } else {
       do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index_dim; } } } while (0);
       if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
        hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
       } else {
        hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
       }
      }
      if (ht == &(executor_globals.symbol_table)) {
       zend_delete_global_variable_ex(offset->value.str.val, offset->value.str.len, hval );
      } else {
       zend_hash_del_key_or_index(ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, 2);
      }
      if ((1<<4) == (1<<4) || (1<<4) == (1<<2)) {
       i_zval_ptr_dtor(*(&offset) );
      }
      break;
     case 0:
      zend_hash_del_key_or_index(ht, "", sizeof(""), 0, 0);
      break;
     default:
      zend_error((1<<1L), "Illegal offset type in unset");
      break;
    }

    break;
   }
   case 5:
    if (__builtin_expect((**container).value.obj.handlers->unset_dimension == ((void *)0), 0)) {
     zend_error_noreturn((1<<0L), "Cannot use object as array");
    }
    if (0) {
     do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
    }
    (**container).value.obj.handlers->unset_dimension(*container, offset );
    if (0) {
     i_zval_ptr_dtor(*(&offset) );
    } else {

    }
    break;
   case 6:
    zend_error_noreturn((1<<0L), "Cannot unset string offsets");
    return 0;
   default:

    break;
  }
 } else {

 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_UNSET_OBJ_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **container;
 zval *offset;

 ;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );
 offset = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );

 if ((1<<2) != (1<<2) || container) {
  if ((1<<2) == (1<<4) && container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
  if ((**container).type == 5) {
   if (0) {
    do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
   }
   if ((**container).value.obj.handlers->unset_property) {
    (**container).value.obj.handlers->unset_property(*container, offset, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   } else {
    zend_error((1<<3L), "Trying to unset property of non-object");
   }
   if (0) {
    i_zval_ptr_dtor(*(&offset) );
   } else {

   }
  } else {

  }
 } else {

 }
 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_CV(int prop_dim, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **container;
 zval **value = ((void *)0);
 int result = 0;
 ulong hval;
 zval *offset;

 ;
 container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data->Ts, &free_op1 );

 offset = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );

 if ((**container).type == 4 && !prop_dim) {
  HashTable *ht;
  int isset = 0;

  ht = (**container).value.ht;

  switch ((*offset).type) {
   case 2:
    hval = zend_dval_to_lval((*offset).value.dval);
    goto num_index_prop;
   case 7:
   case 3:
   case 1:
    hval = (*offset).value.lval;
num_index_prop:
    if (zend_hash_index_find(ht, hval, (void **) &value) == 0) {
     isset = 1;
    }
    break;
   case 6:
    if ((1<<4) == (1<<0)) {
     hval = (((zend_literal*)(offset))->hash_value);
    } else {
     if (!prop_dim) {
      do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index_prop; } } } while (0);
     }
     if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
      hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
     } else {
      hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
     }
    }
    if (zend_hash_quick_find(ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, (void **) &value) == 0) {
     isset = 1;
    }
    break;
   case 0:
    if (zend_hash_find(ht, "", sizeof(""), (void **) &value) == 0) {
     isset = 1;
    }
    break;
   default:
    zend_error((1<<1L), "Illegal offset type in isset or empty");
    break;
  }

  if (opline->extended_value & 0x02000000) {
   if (isset && (**value).type == 0) {
    result = 0;
   } else {
    result = isset;
   }
  } else {
   if (!isset || !i_zend_is_true(*value)) {
    result = 0;
   } else {
    result = 1;
   }
  }

 } else if ((**container).type == 5) {
  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
  }
  if (prop_dim) {
   if ((**container).value.obj.handlers->has_property) {
    result = (**container).value.obj.handlers->has_property(*container, offset, (opline->extended_value & 0x01000000) != 0, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   } else {
    zend_error((1<<3L), "Trying to check property of non-object");
    result = 0;
   }
  } else {
   if ((**container).value.obj.handlers->has_dimension) {
    result = (**container).value.obj.handlers->has_dimension(*container, offset, (opline->extended_value & 0x01000000) != 0 );
   } else {
    zend_error((1<<3L), "Trying to check element of non-array");
    result = 0;
   }
  }
  if (0) {
   i_zval_ptr_dtor(*(&offset) );
  } else {

  }
 } else if ((*container)->type == 6 && !prop_dim) {
  zval tmp;

  if ((*offset).type != 1) {
   do { (&tmp)->value = (offset)->value; (*&tmp).type = (*offset).type; } while (0);
   _zval_copy_ctor((&tmp) );
   convert_to_long(&tmp);
   offset = &tmp;
  }
  if ((*offset).type == 1) {
   if (opline->extended_value & 0x02000000) {
    if (offset->value.lval >= 0 && offset->value.lval < (**container).value.str.len) {
     result = 1;
    }
   } else {
    if (offset->value.lval >= 0 && offset->value.lval < (**container).value.str.len && (**container).value.str.val[offset->value.lval] != '0') {
     result = 1;
    }
   }
  }

 } else {

 }

 ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).type = 3;
 if (opline->extended_value & 0x02000000) {
  ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.lval = result;
 } else {
  ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.lval = !result;
 }

 if (free_op1.var) {i_zval_ptr_dtor(*(&free_op1.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_CV(0, execute_data );
}

static int __attribute__((fastcall)) ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_VAR_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_CV(1, execute_data );
}

static int __attribute__((fastcall)) ZEND_CLONE_SPEC_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *obj;
 zend_class_entry *ce;
 zend_function *clone;
 zend_object_clone_obj_t clone_call;

 ;
 obj = _get_obj_zval_ptr_unused();

 if ((1<<3) == (1<<0) ||
     __builtin_expect((*obj).type != 5, 0)) {
  zend_error_noreturn((1<<0L), "__clone method called on non-object");
 }

 ce = zend_get_class_entry(&(*obj) );
 clone = ce ? ce->clone : ((void *)0);
 clone_call = (*obj).value.obj.handlers->clone_obj;
 if (__builtin_expect(clone_call == ((void *)0), 0)) {
  if (ce) {
   zend_error_noreturn((1<<0L), "Trying to clone an uncloneable object of class %s", ce->name);
  } else {
   zend_error_noreturn((1<<0L), "Trying to clone an uncloneable object");
  }
 }

 if (ce && clone) {
  if (clone->op_array.fn_flags & 0x400) {


   if (__builtin_expect(ce != (executor_globals.scope), 0)) {
    zend_error_noreturn((1<<0L), "Call to private %s::__clone() from context '%s'", ce->name, (executor_globals.scope) ? (executor_globals.scope)->name : "");
   }
  } else if ((clone->common.fn_flags & 0x200)) {


   if (__builtin_expect(!zend_check_protected(clone->common.scope, (executor_globals.scope)), 0)) {
    zend_error_noreturn((1<<0L), "Call to protected %s::__clone() from context '%s'", ce->name, (executor_globals.scope) ? (executor_globals.scope)->name : "");
   }
  }
 }

 if (__builtin_expect((executor_globals.exception) == ((void *)0), 1)) {
  zval *retval;

  do { (retval) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(retval))->u.buffered = ((void *)0); } while (0);
  (*retval).value.obj = clone_call(obj );
  (*retval).type = 5;
  zval_set_refcount_p(retval, 1);
  zval_set_isref_p(retval);
  if (!(!((opline)->result_type & (1<<5))) || __builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
   i_zval_ptr_dtor(*(&retval) );
  } else {
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_EXIT_SPEC_UNUSED_HANDLER(zend_execute_data *execute_data )
{
# 20741 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_vm_execute.h"
 _zend_bailout("/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_vm_execute.h", 20741);
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_binary_assign_op_obj_helper_SPEC_UNUSED_CONST(int (*binary_op)(zval *result, zval *op1, zval *op2 ), zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op_data1;
 zval **object_ptr = _get_obj_zval_ptr_ptr_unused();
 zval *object;
 zval *property = opline->op2.zv;
 zval *value = _get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, &free_op_data1, 0 );
 int have_get_ptr = 0;

 if ((1<<3) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }

 make_real_object(object_ptr );
 object = *object_ptr;

 if (__builtin_expect((*object).type != 5, 0)) {
  zend_error((1<<1L), "Attempt to assign property of non-object");

  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };

  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = &(executor_globals.uninitialized_zval);
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
  }
 } else {

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
  }


  if (opline->extended_value == 136
   && (*object).value.obj.handlers->get_property_ptr_ptr) {
   zval **zptr = (*object).value.obj.handlers->get_property_ptr_ptr(object, property, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   if (zptr != ((void *)0)) {
    if (!zval_isref_p(*zptr)) { do { if (zval_refcount_p(*((zptr))) > 1) { zval *new_zv; zval_delref_p(*(zptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(zptr))->value; (*new_zv).type = (**(zptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(zptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

    have_get_ptr = 1;
    binary_op(*zptr, *zptr, value );
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((*zptr));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = *zptr;
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
   }
  }

  if (!have_get_ptr) {
   zval *z = ((void *)0);

   if (opline->extended_value == 136) {
    if ((*object).value.obj.handlers->read_property) {
     z = (*object).value.obj.handlers->read_property(object, property, 0, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
    }
   } else {
    if ((*object).value.obj.handlers->read_dimension) {
     z = (*object).value.obj.handlers->read_dimension(object, property, 0 );
    }
   }
   if (z) {
    if ((*z).type == 5 && (*z).value.obj.handlers->get) {
     zval *value = (*z).value.obj.handlers->get(z );

     if (zval_refcount_p(z) == 0) {
      if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); };
      _zval_dtor((z) );
      do { if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); }; _efree((z) ); } while (0);
     }
     z = value;
    }
    zval_addref_p(z);
    if (!zval_isref_p(*&z)) { do { if (zval_refcount_p(*((&z))) > 1) { zval *new_zv; zval_delref_p(*(&z)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(&z))->value; (*new_zv).type = (**(&z)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(&z) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
    binary_op(z, z, value );
    if (opline->extended_value == 136) {
     (*object).value.obj.handlers->write_property(object, property, z, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
    } else {
     (*object).value.obj.handlers->write_dimension(object, property, z );
    }
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((z));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = z;
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
    i_zval_ptr_dtor(*(&z) );
   } else {
    zend_error((1<<1L), "Attempt to assign property of non-object");
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((&(executor_globals.uninitialized_zval)));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = &(executor_globals.uninitialized_zval);
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
   }
  }

  if (0) {
   i_zval_ptr_dtor(*(&property) );
  } else {

  }
  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };
 }


 ;
 execute_data->opline++;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_binary_assign_op_helper_SPEC_UNUSED_CONST(int (*binary_op)(zval *result, zval *op1, zval *op2 ), zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op_data2, free_op_data1;
 zval **var_ptr;
 zval *value;

 ;
 switch (opline->extended_value) {
  case 136:
   return zend_binary_assign_op_obj_helper_SPEC_UNUSED_CONST(binary_op, execute_data );
   break;
  case 147: {
    zval **container = _get_obj_zval_ptr_ptr_unused();

    if ((1<<3) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
     zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
    } else if (__builtin_expect((**container).type == 5, 0)) {
     if ((1<<3) == (1<<2) && !0) {
      zval_addref_p(*(container));
     }
     return zend_binary_assign_op_obj_helper_SPEC_UNUSED_CONST(binary_op, execute_data );
    } else {
     zval *dim = opline->op2.zv;

     zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)), container, dim, (1<<0), 2 );
     value = _get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, &free_op_data1, 0 );
     var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data->Ts, &free_op_data2 );
    }
   }
   break;
  default:
   value = opline->op2.zv;
   var_ptr = ((void *)0);

   break;
 }

 if (__builtin_expect(var_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use assign-op operators with overloaded objects nor string offsets");
 }

 if (__builtin_expect(*var_ptr == &(executor_globals.error_zval), 0)) {
  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }


  ;
  if (opline->extended_value == 147) {
   execute_data->opline++;
  }
  execute_data->opline++; return 0;
 }

 if (!zval_isref_p(*var_ptr)) { do { if (zval_refcount_p(*((var_ptr))) > 1) { zval *new_zv; zval_delref_p(*(var_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(var_ptr))->value; (*new_zv).type = (**(var_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(var_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

 if (__builtin_expect((**var_ptr).type == 5, 0)
    && ((**var_ptr)).value.obj.handlers->get
    && ((**var_ptr)).value.obj.handlers->set) {

  zval *objval = ((**var_ptr)).value.obj.handlers->get(*var_ptr );
  zval_addref_p(objval);
  binary_op(objval, objval, value );
  ((**var_ptr)).value.obj.handlers->set(var_ptr, objval );
  i_zval_ptr_dtor(*(&objval) );
 } else {
  binary_op(*var_ptr, *var_ptr, value );
 }

 if ((!((opline)->result_type & (1<<5)))) {
  zval_addref_p((*var_ptr));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (*var_ptr); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
 }

 if (opline->extended_value == 147) {
  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };
  if (free_op_data2.var) { i_zval_ptr_dtor(*(&free_op_data2.var) ); };

  ;
  execute_data->opline++;
 } else {

  ;
 }
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_ADD_SPEC_UNUSED_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_CONST(add_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SUB_SPEC_UNUSED_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_CONST(sub_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_MUL_SPEC_UNUSED_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_CONST(mul_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_DIV_SPEC_UNUSED_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_CONST(div_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_MOD_SPEC_UNUSED_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_CONST(mod_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SL_SPEC_UNUSED_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_CONST(shift_left_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SR_SPEC_UNUSED_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_CONST(shift_right_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_CONCAT_SPEC_UNUSED_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_CONST(concat_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_OR_SPEC_UNUSED_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_CONST(bitwise_or_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_AND_SPEC_UNUSED_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_CONST(bitwise_and_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_CONST(bitwise_xor_function, execute_data );
}

static int __attribute__((fastcall)) zend_pre_incdec_property_helper_SPEC_UNUSED_CONST(incdec_t incdec_op, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval **object_ptr;
 zval *object;
 zval *property;
 zval **retval;
 int have_get_ptr = 0;

 ;
 object_ptr = _get_obj_zval_ptr_ptr_unused();
 property = opline->op2.zv;
 retval = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr;

 if ((1<<3) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot increment/decrement overloaded objects nor string offsets");
 }

 make_real_object(object_ptr );
 object = *object_ptr;

 if (__builtin_expect((*object).type != 5, 0)) {
  zend_error((1<<1L), "Attempt to increment/decrement property of non-object");

  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   *retval = &(executor_globals.uninitialized_zval);
  }

  ;
  execute_data->opline++; return 0;
 }



 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }

 if ((*object).value.obj.handlers->get_property_ptr_ptr) {
  zval **zptr = (*object).value.obj.handlers->get_property_ptr_ptr(object, property, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
  if (zptr != ((void *)0)) {
   if (!zval_isref_p(*zptr)) { do { if (zval_refcount_p(*((zptr))) > 1) { zval *new_zv; zval_delref_p(*(zptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(zptr))->value; (*new_zv).type = (**(zptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(zptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

   have_get_ptr = 1;
   incdec_op(*zptr);
   if ((!((opline)->result_type & (1<<5)))) {
    *retval = *zptr;
    zval_addref_p((*retval));
   }
  }
 }

 if (!have_get_ptr) {
  if ((*object).value.obj.handlers->read_property && (*object).value.obj.handlers->write_property) {
   zval *z = (*object).value.obj.handlers->read_property(object, property, 0, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );

   if (__builtin_expect((*z).type == 5, 0) && (*z).value.obj.handlers->get) {
    zval *value = (*z).value.obj.handlers->get(z );

    if (zval_refcount_p(z) == 0) {
     if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); };
     _zval_dtor((z) );
     do { if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); }; _efree((z) ); } while (0);
    }
    z = value;
   }
   zval_addref_p(z);
   if (!zval_isref_p(*&z)) { do { if (zval_refcount_p(*((&z))) > 1) { zval *new_zv; zval_delref_p(*(&z)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(&z))->value; (*new_zv).type = (**(&z)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(&z) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
   incdec_op(z);
   *retval = z;
   (*object).value.obj.handlers->write_property(object, property, z, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   if ((!((opline)->result_type & (1<<5)))) { zval_addref_p((*retval)); };
   i_zval_ptr_dtor(*(&z) );
  } else {
   zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
   if ((!((opline)->result_type & (1<<5)))) {
    zval_addref_p((&(executor_globals.uninitialized_zval)));
    *retval = &(executor_globals.uninitialized_zval);
   }
  }
 }

 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {

 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_PRE_INC_OBJ_SPEC_UNUSED_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_pre_incdec_property_helper_SPEC_UNUSED_CONST(increment_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_PRE_DEC_OBJ_SPEC_UNUSED_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_pre_incdec_property_helper_SPEC_UNUSED_CONST(decrement_function, execute_data );
}

static int __attribute__((fastcall)) zend_post_incdec_property_helper_SPEC_UNUSED_CONST(incdec_t incdec_op, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval **object_ptr;
 zval *object;
 zval *property;
 zval *retval;
 int have_get_ptr = 0;

 ;
 object_ptr = _get_obj_zval_ptr_ptr_unused();
 property = opline->op2.zv;
 retval = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 if ((1<<3) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot increment/decrement overloaded objects nor string offsets");
 }

 make_real_object(object_ptr );
 object = *object_ptr;

 if (__builtin_expect((*object).type != 5, 0)) {
  zend_error((1<<1L), "Attempt to increment/decrement property of non-object");

  { (*retval).type = 0; };

  ;
  execute_data->opline++; return 0;
 }



 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }

 if ((*object).value.obj.handlers->get_property_ptr_ptr) {
  zval **zptr = (*object).value.obj.handlers->get_property_ptr_ptr(object, property, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
  if (zptr != ((void *)0)) {
   have_get_ptr = 1;
   if (!zval_isref_p(*zptr)) { do { if (zval_refcount_p(*((zptr))) > 1) { zval *new_zv; zval_delref_p(*(zptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(zptr))->value; (*new_zv).type = (**(zptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(zptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

   do { (retval)->value = (*zptr)->value; (*retval).type = (**zptr).type; } while (0);
   _zval_copy_ctor((&(*retval)) );

   incdec_op(*zptr);

  }
 }

 if (!have_get_ptr) {
  if ((*object).value.obj.handlers->read_property && (*object).value.obj.handlers->write_property) {
   zval *z = (*object).value.obj.handlers->read_property(object, property, 0, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   zval *z_copy;

   if (__builtin_expect((*z).type == 5, 0) && (*z).value.obj.handlers->get) {
    zval *value = (*z).value.obj.handlers->get(z );

    if (zval_refcount_p(z) == 0) {
     if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); };
     _zval_dtor((z) );
     do { if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); }; _efree((z) ); } while (0);
    }
    z = value;
   }
   do { (retval)->value = (z)->value; (*retval).type = (*z).type; } while (0);
   _zval_copy_ctor((&(*retval)) );
   do { (z_copy) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(z_copy))->u.buffered = ((void *)0); } while (0);
   do { do { (z_copy)->value = (z)->value; (*z_copy).type = (*z).type; } while (0); zval_set_refcount_p(z_copy, 1); zval_unset_isref_p(z_copy); } while (0);
   _zval_copy_ctor((&(*z_copy)) );
   incdec_op(z_copy);
   zval_addref_p(z);
   (*object).value.obj.handlers->write_property(object, property, z_copy, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   i_zval_ptr_dtor(*(&z_copy) );
   i_zval_ptr_dtor(*(&z) );
  } else {
   zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
   { (*retval).type = 0; };
  }
 }

 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {

 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_POST_INC_OBJ_SPEC_UNUSED_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_post_incdec_property_helper_SPEC_UNUSED_CONST(increment_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_POST_DEC_OBJ_SPEC_UNUSED_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_post_incdec_property_helper_SPEC_UNUSED_CONST(decrement_function, execute_data );
}

static int __attribute__((fastcall)) zend_fetch_property_address_read_helper_SPEC_UNUSED_CONST(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *container;

 zval *offset;

 ;
 container = _get_obj_zval_ptr_unused();
 offset = opline->op2.zv;

 if (__builtin_expect((*container).type != 5, 0) ||
     __builtin_expect((*container).value.obj.handlers->read_property == ((void *)0), 0)) {
  zend_error((1<<3L), "Trying to get property of non-object");
  zval_addref_p((&(executor_globals.uninitialized_zval)));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);

 } else {
  zval *retval;

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
  }


  retval = (*container).value.obj.handlers->read_property(container, offset, 0, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );

  zval_addref_p((retval));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);

  if (0) {
   i_zval_ptr_dtor(*(&offset) );
  } else {

  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_R_SPEC_UNUSED_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_property_address_read_helper_SPEC_UNUSED_CONST(execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_W_SPEC_UNUSED_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *property;
 zval **container;

 ;
 property = opline->op2.zv;

 if ((1<<3) == (1<<2) && (opline->extended_value & 0x08000000)) {
  zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr));
  (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr = *(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr;
 }

 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }
 container = _get_obj_zval_ptr_ptr_unused();
 if ((1<<3) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }

 zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)), 1 );
 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {

 }
 if ((1<<3) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }


 if (opline->extended_value & 0x04000000) {
  zval **retval_ptr = (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr;

  zval_delref_p(*(retval_ptr));
  if (!zval_isref_p(*retval_ptr)) { do { if (zval_refcount_p(*((retval_ptr))) > 1) { zval *new_zv; zval_delref_p(*(retval_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval_ptr))->value; (*new_zv).type = (**(retval_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((retval_ptr))); };
  zval_addref_p(*(retval_ptr));
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_RW_SPEC_UNUSED_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *property;
 zval **container;

 ;
 property = opline->op2.zv;
 container = _get_obj_zval_ptr_ptr_unused();

 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }
 if ((1<<3) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }
 zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)), 2 );
 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {

 }
 if ((1<<3) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_IS_SPEC_UNUSED_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *container;

 zval *offset;

 ;
 container = _get_obj_zval_ptr_unused();
 offset = opline->op2.zv;

 if (__builtin_expect((*container).type != 5, 0) ||
     __builtin_expect((*container).value.obj.handlers->read_property == ((void *)0), 0)) {
  zval_addref_p((&(executor_globals.uninitialized_zval)));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);

 } else {
  zval *retval;

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
  }


  retval = (*container).value.obj.handlers->read_property(container, offset, 3, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );

  zval_addref_p((retval));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);

  if (0) {
   i_zval_ptr_dtor(*(&offset) );
  } else {

  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 if (((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && (opline->extended_value & 0x000fffff) <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[(opline->extended_value & 0x000fffff)-1].pass_by_reference & (1|2)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x1000000|0x2000000))))) {

  zend_free_op free_op1;
  zval *property;
  zval **container;

  ;
  property = opline->op2.zv;
  container = _get_obj_zval_ptr_ptr_unused();

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
  }
  if ((1<<3) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
  }
  zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)), 1 );
  if (0) {
   i_zval_ptr_dtor(*(&property) );
  } else {

  }
  if ((1<<3) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
  }

  ;
  execute_data->opline++; return 0;
 } else {
  return zend_fetch_property_address_read_helper_SPEC_UNUSED_CONST(execute_data );
 }
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_res;
 zval **container;
 zval *property;

 ;
 container = _get_obj_zval_ptr_ptr_unused();
 property = opline->op2.zv;

 if ((1<<3) == (1<<4)) {
  if (container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
 }
 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }
 if ((1<<3) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }
 zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)), 6 );
 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {

 }
 if ((1<<3) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }

 zend_pzval_unlock_func(*(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr, &free_res, 1 );
 if ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr != &(executor_globals.uninitialized_zval_ptr)) {
  if (!zval_isref_p(*(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr)) { do { if (zval_refcount_p(*(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr))->value; (*new_zv).type = (**((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
 }
 zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr));
 if (free_res.var) { i_zval_ptr_dtor(*(&free_res.var) ); };
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_OBJ_SPEC_UNUSED_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval **object_ptr;
 zval *property_name;

 ;
 object_ptr = _get_obj_zval_ptr_ptr_unused();
 property_name = opline->op2.zv;

 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property_name))->value; (*_tmp).type = (*(property_name)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property_name) = _tmp; } while (0);
 }
 if ((1<<3) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 zend_assign_to_object((!((opline)->result_type & (1<<5)))?&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr:((void *)0), object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, 136, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
 if (0) {
  i_zval_ptr_dtor(*(&property_name) );
 } else {

 }


 ;
 execute_data->opline++;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ADD_CHAR_SPEC_UNUSED_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *str = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;

 if ((1<<3) == (1<<3)) {

  (*str).value.str.val = ((void *)0);
  (*str).value.str.len = 0;
  (*str).type = 6;

  (str)->refcount__gc = 1; (str)->is_ref__gc = 0;;
 }

 add_char_to_string(str, str, opline->op2.zv);



 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ADD_STRING_SPEC_UNUSED_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *str = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;

 if ((1<<3) == (1<<3)) {

  (*str).value.str.val = ((void *)0);
  (*str).value.str.len = 0;
  (*str).type = 6;

  (str)->refcount__gc = 1; (str)->is_ref__gc = 0;;
 }

 add_string_to_string(str, str, opline->op2.zv);



 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_METHOD_CALL_SPEC_UNUSED_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *function_name;
 char *function_name_strval;
 int function_name_strlen;


 ;
 zend_ptr_stack_3_push(&(executor_globals.arg_types_stack), execute_data->fbc, execute_data->object, execute_data->called_scope);

 function_name = opline->op2.zv;

 if ((1<<0) != (1<<0) &&
     __builtin_expect((*function_name).type != 6, 0)) {
  zend_error_noreturn((1<<0L), "Method name must be a string");
 }

 function_name_strval = (*function_name).value.str.val;
 function_name_strlen = (*function_name).value.str.len;

 execute_data->object = _get_obj_zval_ptr_unused();

 if (__builtin_expect(execute_data->object != ((void *)0), 1) &&
     __builtin_expect((*execute_data->object).type == 5, 1)) {
  execute_data->called_scope = zend_get_class_entry(&(*execute_data->object) );

  if ((1<<0) != (1<<0) ||
      (execute_data->fbc = (((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] == (execute_data->called_scope)) ? (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] : ((void *)0))) == ((void *)0)) {
      zval *object = execute_data->object;

   if (__builtin_expect((*execute_data->object).value.obj.handlers->get_method == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Object does not support method calls");
   }


   execute_data->fbc = (*execute_data->object).value.obj.handlers->get_method(&execute_data->object, function_name_strval, function_name_strlen, (((1<<0) == (1<<0)) ? (opline->op2.literal + 1) : ((void *)0)) );
   if (__builtin_expect(execute_data->fbc == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Call to undefined method %s::%s()", ((execute_data->object) && (*execute_data->object).type == 5 && (*execute_data->object).value.obj.handlers->get_class_entry != ((void *)0) && (*execute_data->object).value.obj.handlers->get_class_entry(execute_data->object ) ? (*execute_data->object).value.obj.handlers->get_class_entry(execute_data->object )->name : ""), function_name_strval);
   }
   if ((1<<0) == (1<<0) &&
       __builtin_expect((execute_data->fbc->common.fn_flags & 0x200000) == 0, 1) &&
       __builtin_expect(execute_data->object == object, 1)) {
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (execute_data->called_scope); (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] = (execute_data->fbc); } while (0);
   }
  }
 } else {
  zend_error_noreturn((1<<0L), "Call to a member function %s() on a non-object", function_name_strval);
 }

 if ((execute_data->fbc->common.fn_flags & 0x01) != 0) {
  execute_data->object = ((void *)0);
 } else {
  if (!zval_isref_p(execute_data->object)) {
   zval_addref_p(execute_data->object);
  } else {
   zval *this_ptr;
   do { (this_ptr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(this_ptr))->u.buffered = ((void *)0); } while (0);
   do { do { (this_ptr)->value = (execute_data->object)->value; (*this_ptr).type = (*execute_data->object).type; } while (0); zval_set_refcount_p(this_ptr, 1); zval_unset_isref_p(this_ptr); } while (0);
   _zval_copy_ctor((this_ptr) );
   execute_data->object = this_ptr;
  }
 }


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_CONSTANT_SPEC_UNUSED_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 ;
 if ((1<<3) == (1<<3)) {
  zend_constant *c;
  zval *retval;

  if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
   c = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
  } else if ((c = zend_quick_get_constant(opline->op2.literal + 1, opline->extended_value )) == ((void *)0)) {
   if ((opline->extended_value & 0x010) != 0) {
    char *actual = (char *)zend_memrchr((*opline->op2.zv).value.str.val, '\\', (*opline->op2.zv).value.str.len);
    if(!actual) {
     actual = (*opline->op2.zv).value.str.val;
    } else {
     actual++;
    }

    zend_error((1<<3L), "Use of undefined constant %s - assumed '%s'", actual, actual);
    do { const char *__s=(actual); int __l=(*opline->op2.zv).value.str.len-(actual - (*opline->op2.zv).value.str.val); zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.str.len = __l; (*__z).value.str.val = (1?_estrndup((__s), (__l) ):(char*)__s); (*__z).type = 6; } while (0);
    ;
    execute_data->opline++; return 0;
   } else {
    zend_error_noreturn((1<<0L), "Undefined constant '%s'", (*opline->op2.zv).value.str.val);
   }
  } else {
   do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (c); } while (0);
  }
  retval = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;
  do { (retval)->value = (&c->value)->value; (*retval).type = (*&c->value).type; } while (0);
  _zval_copy_ctor((retval) );
  ;
  execute_data->opline++; return 0;
 } else {

  zend_class_entry *ce;
  zval **value;

  if ((1<<3) == (1<<0)) {
   if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
    value = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
    do { (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var)->value = (*value)->value; (*&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).type = (**value).type; } while (0);
    _zval_copy_ctor((&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var) );
    ;
    execute_data->opline++; return 0;
   } else if ((executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)]) {
    ce = (executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)];
   } else {
    ce = zend_fetch_class_by_name((*opline->op1.zv).value.str.val, (*opline->op1.zv).value.str.len, opline->op1.literal + 1, opline->extended_value );
    if (__builtin_expect(ce == ((void *)0), 0)) {
     zend_error_noreturn((1<<0L), "Undefined class constant '%s'", (*opline->op2.zv).value.str.val);
    }
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op1.literal->cache_slot)] = (ce); } while (0);
   }
  } else {
   ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).class_entry;
   if ((value = (((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] == (ce)) ? (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] : ((void *)0))) != ((void *)0)) {
    do { (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var)->value = (*value)->value; (*&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).type = (**value).type; } while (0);
    _zval_copy_ctor((&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var) );
    ;
    execute_data->opline++; return 0;
   }
  }

  if (__builtin_expect(zend_hash_quick_find(&ce->constants_table, (*opline->op2.zv).value.str.val, (*opline->op2.zv).value.str.len+1, (((zend_literal*)(opline->op2.zv))->hash_value), (void **) &value) == 0, 1)) {
   if ((**value).type == 9 ||
       ((**value).type & 0x00f) == 8) {
    zend_class_entry *old_scope = (executor_globals.scope);

    (executor_globals.scope) = ce;
    zval_update_constant(value, (void *) 1 );
    (executor_globals.scope) = old_scope;
   }
   if ((1<<3) == (1<<0)) {
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (value); } while (0);
   } else {
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] = (value); } while (0);
   }
   do { (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var)->value = (*value)->value; (*&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).type = (**value).type; } while (0);
   _zval_copy_ctor((&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var) );
  } else {
   zend_error_noreturn((1<<0L), "Undefined class constant '%s'", (*opline->op2.zv).value.str.val);
  }

  ;
  execute_data->opline++; return 0;
 }
}

static int __attribute__((fastcall)) ZEND_INIT_ARRAY_SPEC_UNUSED_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 _array_init((&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var), 0 );
 if ((1<<3) == (1<<3)) {
  execute_data->opline++; return 0;




 }
}

static int __attribute__((fastcall)) ZEND_UNSET_DIM_SPEC_UNUSED_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval **container;
 zval *offset;
 ulong hval;

 ;
 container = _get_obj_zval_ptr_ptr_unused();
 offset = opline->op2.zv;

 if ((1<<3) != (1<<2) || container) {
  if ((1<<3) == (1<<4) && container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
  switch ((**container).type) {
   case 4: {
    HashTable *ht = (**container).value.ht;

    switch ((*offset).type) {
     case 2:
      hval = zend_dval_to_lval((*offset).value.dval);
      goto num_index_dim;
     case 7:
     case 3:
     case 1:
num_index_dim:
      hval = (*offset).value.lval;
      zend_hash_del_key_or_index(ht, ((void *)0), 0, hval, 1);
      break;
     case 6:
      if ((1<<0) == (1<<4) || (1<<0) == (1<<2)) {
       zval_addref_p(offset);
      }
      if ((1<<0) == (1<<0)) {
       hval = (((zend_literal*)(offset))->hash_value);
      } else {
       do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index_dim; } } } while (0);
       if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
        hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
       } else {
        hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
       }
      }
      if (ht == &(executor_globals.symbol_table)) {
       zend_delete_global_variable_ex(offset->value.str.val, offset->value.str.len, hval );
      } else {
       zend_hash_del_key_or_index(ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, 2);
      }
      if ((1<<0) == (1<<4) || (1<<0) == (1<<2)) {
       i_zval_ptr_dtor(*(&offset) );
      }
      break;
     case 0:
      zend_hash_del_key_or_index(ht, "", sizeof(""), 0, 0);
      break;
     default:
      zend_error((1<<1L), "Illegal offset type in unset");
      break;
    }

    break;
   }
   case 5:
    if (__builtin_expect((**container).value.obj.handlers->unset_dimension == ((void *)0), 0)) {
     zend_error_noreturn((1<<0L), "Cannot use object as array");
    }
    if (0) {
     do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
    }
    (**container).value.obj.handlers->unset_dimension(*container, offset );
    if (0) {
     i_zval_ptr_dtor(*(&offset) );
    } else {

    }
    break;
   case 6:
    zend_error_noreturn((1<<0L), "Cannot unset string offsets");
    return 0;
   default:

    break;
  }
 } else {

 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_UNSET_OBJ_SPEC_UNUSED_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval **container;
 zval *offset;

 ;
 container = _get_obj_zval_ptr_ptr_unused();
 offset = opline->op2.zv;

 if ((1<<3) != (1<<2) || container) {
  if ((1<<3) == (1<<4) && container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
  if ((**container).type == 5) {
   if (0) {
    do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
   }
   if ((**container).value.obj.handlers->unset_property) {
    (**container).value.obj.handlers->unset_property(*container, offset, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   } else {
    zend_error((1<<3L), "Trying to unset property of non-object");
   }
   if (0) {
    i_zval_ptr_dtor(*(&offset) );
   } else {

   }
  } else {

  }
 } else {

 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_CONST(int prop_dim, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval **container;
 zval **value = ((void *)0);
 int result = 0;
 ulong hval;
 zval *offset;

 ;
 container = _get_obj_zval_ptr_ptr_unused();

 offset = opline->op2.zv;

 if ((**container).type == 4 && !prop_dim) {
  HashTable *ht;
  int isset = 0;

  ht = (**container).value.ht;

  switch ((*offset).type) {
   case 2:
    hval = zend_dval_to_lval((*offset).value.dval);
    goto num_index_prop;
   case 7:
   case 3:
   case 1:
    hval = (*offset).value.lval;
num_index_prop:
    if (zend_hash_index_find(ht, hval, (void **) &value) == 0) {
     isset = 1;
    }
    break;
   case 6:
    if ((1<<0) == (1<<0)) {
     hval = (((zend_literal*)(offset))->hash_value);
    } else {
     if (!prop_dim) {
      do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index_prop; } } } while (0);
     }
     if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
      hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
     } else {
      hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
     }
    }
    if (zend_hash_quick_find(ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, (void **) &value) == 0) {
     isset = 1;
    }
    break;
   case 0:
    if (zend_hash_find(ht, "", sizeof(""), (void **) &value) == 0) {
     isset = 1;
    }
    break;
   default:
    zend_error((1<<1L), "Illegal offset type in isset or empty");
    break;
  }

  if (opline->extended_value & 0x02000000) {
   if (isset && (**value).type == 0) {
    result = 0;
   } else {
    result = isset;
   }
  } else {
   if (!isset || !i_zend_is_true(*value)) {
    result = 0;
   } else {
    result = 1;
   }
  }

 } else if ((**container).type == 5) {
  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
  }
  if (prop_dim) {
   if ((**container).value.obj.handlers->has_property) {
    result = (**container).value.obj.handlers->has_property(*container, offset, (opline->extended_value & 0x01000000) != 0, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   } else {
    zend_error((1<<3L), "Trying to check property of non-object");
    result = 0;
   }
  } else {
   if ((**container).value.obj.handlers->has_dimension) {
    result = (**container).value.obj.handlers->has_dimension(*container, offset, (opline->extended_value & 0x01000000) != 0 );
   } else {
    zend_error((1<<3L), "Trying to check element of non-array");
    result = 0;
   }
  }
  if (0) {
   i_zval_ptr_dtor(*(&offset) );
  } else {

  }
 } else if ((*container)->type == 6 && !prop_dim) {
  zval tmp;

  if ((*offset).type != 1) {
   do { (&tmp)->value = (offset)->value; (*&tmp).type = (*offset).type; } while (0);
   _zval_copy_ctor((&tmp) );
   convert_to_long(&tmp);
   offset = &tmp;
  }
  if ((*offset).type == 1) {
   if (opline->extended_value & 0x02000000) {
    if (offset->value.lval >= 0 && offset->value.lval < (**container).value.str.len) {
     result = 1;
    }
   } else {
    if (offset->value.lval >= 0 && offset->value.lval < (**container).value.str.len && (**container).value.str.val[offset->value.lval] != '0') {
     result = 1;
    }
   }
  }

 } else {

 }

 ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).type = 3;
 if (opline->extended_value & 0x02000000) {
  ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.lval = result;
 } else {
  ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.lval = !result;
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_CONST(0, execute_data );
}

static int __attribute__((fastcall)) ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_CONST(1, execute_data );
}

static int __attribute__((fastcall)) zend_binary_assign_op_obj_helper_SPEC_UNUSED_TMP(int (*binary_op)(zval *result, zval *op1, zval *op2 ), zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2, free_op_data1;
 zval **object_ptr = _get_obj_zval_ptr_ptr_unused();
 zval *object;
 zval *property = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );
 zval *value = _get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, &free_op_data1, 0 );
 int have_get_ptr = 0;

 if ((1<<3) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }

 make_real_object(object_ptr );
 object = *object_ptr;

 if (__builtin_expect((*object).type != 5, 0)) {
  zend_error((1<<1L), "Attempt to assign property of non-object");
  _zval_dtor((free_op2.var) );
  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };

  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = &(executor_globals.uninitialized_zval);
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
  }
 } else {

  if (1) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
  }


  if (opline->extended_value == 136
   && (*object).value.obj.handlers->get_property_ptr_ptr) {
   zval **zptr = (*object).value.obj.handlers->get_property_ptr_ptr(object, property, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   if (zptr != ((void *)0)) {
    if (!zval_isref_p(*zptr)) { do { if (zval_refcount_p(*((zptr))) > 1) { zval *new_zv; zval_delref_p(*(zptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(zptr))->value; (*new_zv).type = (**(zptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(zptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

    have_get_ptr = 1;
    binary_op(*zptr, *zptr, value );
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((*zptr));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = *zptr;
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
   }
  }

  if (!have_get_ptr) {
   zval *z = ((void *)0);

   if (opline->extended_value == 136) {
    if ((*object).value.obj.handlers->read_property) {
     z = (*object).value.obj.handlers->read_property(object, property, 0, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
    }
   } else {
    if ((*object).value.obj.handlers->read_dimension) {
     z = (*object).value.obj.handlers->read_dimension(object, property, 0 );
    }
   }
   if (z) {
    if ((*z).type == 5 && (*z).value.obj.handlers->get) {
     zval *value = (*z).value.obj.handlers->get(z );

     if (zval_refcount_p(z) == 0) {
      if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); };
      _zval_dtor((z) );
      do { if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); }; _efree((z) ); } while (0);
     }
     z = value;
    }
    zval_addref_p(z);
    if (!zval_isref_p(*&z)) { do { if (zval_refcount_p(*((&z))) > 1) { zval *new_zv; zval_delref_p(*(&z)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(&z))->value; (*new_zv).type = (**(&z)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(&z) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
    binary_op(z, z, value );
    if (opline->extended_value == 136) {
     (*object).value.obj.handlers->write_property(object, property, z, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
    } else {
     (*object).value.obj.handlers->write_dimension(object, property, z );
    }
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((z));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = z;
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
    i_zval_ptr_dtor(*(&z) );
   } else {
    zend_error((1<<1L), "Attempt to assign property of non-object");
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((&(executor_globals.uninitialized_zval)));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = &(executor_globals.uninitialized_zval);
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
   }
  }

  if (1) {
   i_zval_ptr_dtor(*(&property) );
  } else {
   _zval_dtor((free_op2.var) );
  }
  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };
 }


 ;
 execute_data->opline++;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_binary_assign_op_helper_SPEC_UNUSED_TMP(int (*binary_op)(zval *result, zval *op1, zval *op2 ), zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2, free_op_data2, free_op_data1;
 zval **var_ptr;
 zval *value;

 ;
 switch (opline->extended_value) {
  case 136:
   return zend_binary_assign_op_obj_helper_SPEC_UNUSED_TMP(binary_op, execute_data );
   break;
  case 147: {
    zval **container = _get_obj_zval_ptr_ptr_unused();

    if ((1<<3) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
     zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
    } else if (__builtin_expect((**container).type == 5, 0)) {
     if ((1<<3) == (1<<2) && !0) {
      zval_addref_p(*(container));
     }
     return zend_binary_assign_op_obj_helper_SPEC_UNUSED_TMP(binary_op, execute_data );
    } else {
     zval *dim = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );

     zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)), container, dim, (1<<1), 2 );
     value = _get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, &free_op_data1, 0 );
     var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data->Ts, &free_op_data2 );
    }
   }
   break;
  default:
   value = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );
   var_ptr = ((void *)0);

   break;
 }

 if (__builtin_expect(var_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use assign-op operators with overloaded objects nor string offsets");
 }

 if (__builtin_expect(*var_ptr == &(executor_globals.error_zval), 0)) {
  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }
  _zval_dtor((free_op2.var) );

  ;
  if (opline->extended_value == 147) {
   execute_data->opline++;
  }
  execute_data->opline++; return 0;
 }

 if (!zval_isref_p(*var_ptr)) { do { if (zval_refcount_p(*((var_ptr))) > 1) { zval *new_zv; zval_delref_p(*(var_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(var_ptr))->value; (*new_zv).type = (**(var_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(var_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

 if (__builtin_expect((**var_ptr).type == 5, 0)
    && ((**var_ptr)).value.obj.handlers->get
    && ((**var_ptr)).value.obj.handlers->set) {

  zval *objval = ((**var_ptr)).value.obj.handlers->get(*var_ptr );
  zval_addref_p(objval);
  binary_op(objval, objval, value );
  ((**var_ptr)).value.obj.handlers->set(var_ptr, objval );
  i_zval_ptr_dtor(*(&objval) );
 } else {
  binary_op(*var_ptr, *var_ptr, value );
 }

 if ((!((opline)->result_type & (1<<5)))) {
  zval_addref_p((*var_ptr));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (*var_ptr); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
 }
 _zval_dtor((free_op2.var) );

 if (opline->extended_value == 147) {
  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };
  if (free_op_data2.var) { i_zval_ptr_dtor(*(&free_op_data2.var) ); };

  ;
  execute_data->opline++;
 } else {

  ;
 }
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_ADD_SPEC_UNUSED_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_TMP(add_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SUB_SPEC_UNUSED_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_TMP(sub_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_MUL_SPEC_UNUSED_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_TMP(mul_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_DIV_SPEC_UNUSED_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_TMP(div_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_MOD_SPEC_UNUSED_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_TMP(mod_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SL_SPEC_UNUSED_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_TMP(shift_left_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SR_SPEC_UNUSED_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_TMP(shift_right_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_CONCAT_SPEC_UNUSED_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_TMP(concat_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_OR_SPEC_UNUSED_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_TMP(bitwise_or_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_AND_SPEC_UNUSED_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_TMP(bitwise_and_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_TMP(bitwise_xor_function, execute_data );
}

static int __attribute__((fastcall)) zend_pre_incdec_property_helper_SPEC_UNUSED_TMP(incdec_t incdec_op, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval **object_ptr;
 zval *object;
 zval *property;
 zval **retval;
 int have_get_ptr = 0;

 ;
 object_ptr = _get_obj_zval_ptr_ptr_unused();
 property = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );
 retval = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr;

 if ((1<<3) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot increment/decrement overloaded objects nor string offsets");
 }

 make_real_object(object_ptr );
 object = *object_ptr;

 if (__builtin_expect((*object).type != 5, 0)) {
  zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
  _zval_dtor((free_op2.var) );
  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   *retval = &(executor_globals.uninitialized_zval);
  }

  ;
  execute_data->opline++; return 0;
 }



 if (1) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }

 if ((*object).value.obj.handlers->get_property_ptr_ptr) {
  zval **zptr = (*object).value.obj.handlers->get_property_ptr_ptr(object, property, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
  if (zptr != ((void *)0)) {
   if (!zval_isref_p(*zptr)) { do { if (zval_refcount_p(*((zptr))) > 1) { zval *new_zv; zval_delref_p(*(zptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(zptr))->value; (*new_zv).type = (**(zptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(zptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

   have_get_ptr = 1;
   incdec_op(*zptr);
   if ((!((opline)->result_type & (1<<5)))) {
    *retval = *zptr;
    zval_addref_p((*retval));
   }
  }
 }

 if (!have_get_ptr) {
  if ((*object).value.obj.handlers->read_property && (*object).value.obj.handlers->write_property) {
   zval *z = (*object).value.obj.handlers->read_property(object, property, 0, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );

   if (__builtin_expect((*z).type == 5, 0) && (*z).value.obj.handlers->get) {
    zval *value = (*z).value.obj.handlers->get(z );

    if (zval_refcount_p(z) == 0) {
     if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); };
     _zval_dtor((z) );
     do { if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); }; _efree((z) ); } while (0);
    }
    z = value;
   }
   zval_addref_p(z);
   if (!zval_isref_p(*&z)) { do { if (zval_refcount_p(*((&z))) > 1) { zval *new_zv; zval_delref_p(*(&z)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(&z))->value; (*new_zv).type = (**(&z)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(&z) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
   incdec_op(z);
   *retval = z;
   (*object).value.obj.handlers->write_property(object, property, z, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   if ((!((opline)->result_type & (1<<5)))) { zval_addref_p((*retval)); };
   i_zval_ptr_dtor(*(&z) );
  } else {
   zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
   if ((!((opline)->result_type & (1<<5)))) {
    zval_addref_p((&(executor_globals.uninitialized_zval)));
    *retval = &(executor_globals.uninitialized_zval);
   }
  }
 }

 if (1) {
  i_zval_ptr_dtor(*(&property) );
 } else {
  _zval_dtor((free_op2.var) );
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_PRE_INC_OBJ_SPEC_UNUSED_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_pre_incdec_property_helper_SPEC_UNUSED_TMP(increment_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_PRE_DEC_OBJ_SPEC_UNUSED_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_pre_incdec_property_helper_SPEC_UNUSED_TMP(decrement_function, execute_data );
}

static int __attribute__((fastcall)) zend_post_incdec_property_helper_SPEC_UNUSED_TMP(incdec_t incdec_op, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval **object_ptr;
 zval *object;
 zval *property;
 zval *retval;
 int have_get_ptr = 0;

 ;
 object_ptr = _get_obj_zval_ptr_ptr_unused();
 property = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );
 retval = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 if ((1<<3) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot increment/decrement overloaded objects nor string offsets");
 }

 make_real_object(object_ptr );
 object = *object_ptr;

 if (__builtin_expect((*object).type != 5, 0)) {
  zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
  _zval_dtor((free_op2.var) );
  { (*retval).type = 0; };

  ;
  execute_data->opline++; return 0;
 }



 if (1) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }

 if ((*object).value.obj.handlers->get_property_ptr_ptr) {
  zval **zptr = (*object).value.obj.handlers->get_property_ptr_ptr(object, property, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
  if (zptr != ((void *)0)) {
   have_get_ptr = 1;
   if (!zval_isref_p(*zptr)) { do { if (zval_refcount_p(*((zptr))) > 1) { zval *new_zv; zval_delref_p(*(zptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(zptr))->value; (*new_zv).type = (**(zptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(zptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

   do { (retval)->value = (*zptr)->value; (*retval).type = (**zptr).type; } while (0);
   _zval_copy_ctor((&(*retval)) );

   incdec_op(*zptr);

  }
 }

 if (!have_get_ptr) {
  if ((*object).value.obj.handlers->read_property && (*object).value.obj.handlers->write_property) {
   zval *z = (*object).value.obj.handlers->read_property(object, property, 0, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   zval *z_copy;

   if (__builtin_expect((*z).type == 5, 0) && (*z).value.obj.handlers->get) {
    zval *value = (*z).value.obj.handlers->get(z );

    if (zval_refcount_p(z) == 0) {
     if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); };
     _zval_dtor((z) );
     do { if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); }; _efree((z) ); } while (0);
    }
    z = value;
   }
   do { (retval)->value = (z)->value; (*retval).type = (*z).type; } while (0);
   _zval_copy_ctor((&(*retval)) );
   do { (z_copy) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(z_copy))->u.buffered = ((void *)0); } while (0);
   do { do { (z_copy)->value = (z)->value; (*z_copy).type = (*z).type; } while (0); zval_set_refcount_p(z_copy, 1); zval_unset_isref_p(z_copy); } while (0);
   _zval_copy_ctor((&(*z_copy)) );
   incdec_op(z_copy);
   zval_addref_p(z);
   (*object).value.obj.handlers->write_property(object, property, z_copy, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   i_zval_ptr_dtor(*(&z_copy) );
   i_zval_ptr_dtor(*(&z) );
  } else {
   zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
   { (*retval).type = 0; };
  }
 }

 if (1) {
  i_zval_ptr_dtor(*(&property) );
 } else {
  _zval_dtor((free_op2.var) );
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_POST_INC_OBJ_SPEC_UNUSED_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_post_incdec_property_helper_SPEC_UNUSED_TMP(increment_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_POST_DEC_OBJ_SPEC_UNUSED_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_post_incdec_property_helper_SPEC_UNUSED_TMP(decrement_function, execute_data );
}

static int __attribute__((fastcall)) zend_fetch_property_address_read_helper_SPEC_UNUSED_TMP(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *container;
 zend_free_op free_op2;
 zval *offset;

 ;
 container = _get_obj_zval_ptr_unused();
 offset = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );

 if (__builtin_expect((*container).type != 5, 0) ||
     __builtin_expect((*container).value.obj.handlers->read_property == ((void *)0), 0)) {
  zend_error((1<<3L), "Trying to get property of non-object");
  zval_addref_p((&(executor_globals.uninitialized_zval)));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  _zval_dtor((free_op2.var) );
 } else {
  zval *retval;

  if (1) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
  }


  retval = (*container).value.obj.handlers->read_property(container, offset, 0, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );

  zval_addref_p((retval));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);

  if (1) {
   i_zval_ptr_dtor(*(&offset) );
  } else {
   _zval_dtor((free_op2.var) );
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_R_SPEC_UNUSED_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_property_address_read_helper_SPEC_UNUSED_TMP(execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_W_SPEC_UNUSED_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval *property;
 zval **container;

 ;
 property = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((1<<3) == (1<<2) && (opline->extended_value & 0x08000000)) {
  zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr));
  (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr = *(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr;
 }

 if (1) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }
 container = _get_obj_zval_ptr_ptr_unused();
 if ((1<<3) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }

 zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)), 1 );
 if (1) {
  i_zval_ptr_dtor(*(&property) );
 } else {
  _zval_dtor((free_op2.var) );
 }
 if ((1<<3) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }


 if (opline->extended_value & 0x04000000) {
  zval **retval_ptr = (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr;

  zval_delref_p(*(retval_ptr));
  if (!zval_isref_p(*retval_ptr)) { do { if (zval_refcount_p(*((retval_ptr))) > 1) { zval *new_zv; zval_delref_p(*(retval_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval_ptr))->value; (*new_zv).type = (**(retval_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((retval_ptr))); };
  zval_addref_p(*(retval_ptr));
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_RW_SPEC_UNUSED_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval *property;
 zval **container;

 ;
 property = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );
 container = _get_obj_zval_ptr_ptr_unused();

 if (1) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }
 if ((1<<3) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }
 zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)), 2 );
 if (1) {
  i_zval_ptr_dtor(*(&property) );
 } else {
  _zval_dtor((free_op2.var) );
 }
 if ((1<<3) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_IS_SPEC_UNUSED_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *container;
 zend_free_op free_op2;
 zval *offset;

 ;
 container = _get_obj_zval_ptr_unused();
 offset = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );

 if (__builtin_expect((*container).type != 5, 0) ||
     __builtin_expect((*container).value.obj.handlers->read_property == ((void *)0), 0)) {
  zval_addref_p((&(executor_globals.uninitialized_zval)));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  _zval_dtor((free_op2.var) );
 } else {
  zval *retval;

  if (1) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
  }


  retval = (*container).value.obj.handlers->read_property(container, offset, 3, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );

  zval_addref_p((retval));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);

  if (1) {
   i_zval_ptr_dtor(*(&offset) );
  } else {
   _zval_dtor((free_op2.var) );
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 if (((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && (opline->extended_value & 0x000fffff) <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[(opline->extended_value & 0x000fffff)-1].pass_by_reference & (1|2)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x1000000|0x2000000))))) {

  zend_free_op free_op1, free_op2;
  zval *property;
  zval **container;

  ;
  property = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );
  container = _get_obj_zval_ptr_ptr_unused();

  if (1) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
  }
  if ((1<<3) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
  }
  zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)), 1 );
  if (1) {
   i_zval_ptr_dtor(*(&property) );
  } else {
   _zval_dtor((free_op2.var) );
  }
  if ((1<<3) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
  }

  ;
  execute_data->opline++; return 0;
 } else {
  return zend_fetch_property_address_read_helper_SPEC_UNUSED_TMP(execute_data );
 }
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2, free_res;
 zval **container;
 zval *property;

 ;
 container = _get_obj_zval_ptr_ptr_unused();
 property = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((1<<3) == (1<<4)) {
  if (container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
 }
 if (1) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }
 if ((1<<3) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }
 zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)), 6 );
 if (1) {
  i_zval_ptr_dtor(*(&property) );
 } else {
  _zval_dtor((free_op2.var) );
 }
 if ((1<<3) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }

 zend_pzval_unlock_func(*(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr, &free_res, 1 );
 if ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr != &(executor_globals.uninitialized_zval_ptr)) {
  if (!zval_isref_p(*(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr)) { do { if (zval_refcount_p(*(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr))->value; (*new_zv).type = (**((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
 }
 zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr));
 if (free_res.var) { i_zval_ptr_dtor(*(&free_res.var) ); };
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval **object_ptr;
 zval *property_name;

 ;
 object_ptr = _get_obj_zval_ptr_ptr_unused();
 property_name = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );

 if (1) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property_name))->value; (*_tmp).type = (*(property_name)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property_name) = _tmp; } while (0);
 }
 if ((1<<3) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 zend_assign_to_object((!((opline)->result_type & (1<<5)))?&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr:((void *)0), object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, 136, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
 if (1) {
  i_zval_ptr_dtor(*(&property_name) );
 } else {
  _zval_dtor((free_op2.var) );
 }


 ;
 execute_data->opline++;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ADD_VAR_SPEC_UNUSED_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval *str = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;
 zval *var;
 zval var_copy;
 int use_copy = 0;

 ;
 var = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((1<<3) == (1<<3)) {

  (*str).value.str.val = ((void *)0);
  (*str).value.str.len = 0;
  (*str).type = 6;

  (str)->refcount__gc = 1; (str)->is_ref__gc = 0;;
 }

 if ((*var).type != 6) {
  zend_make_printable_zval(var, &var_copy, &use_copy);

  if (use_copy) {
   var = &var_copy;
  }
 }
 add_string_to_string(str, str, var);

 if (use_copy) {
  _zval_dtor((var) );
 }






 _zval_dtor((free_op2.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_METHOD_CALL_SPEC_UNUSED_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *function_name;
 char *function_name_strval;
 int function_name_strlen;
 zend_free_op free_op2;

 ;
 zend_ptr_stack_3_push(&(executor_globals.arg_types_stack), execute_data->fbc, execute_data->object, execute_data->called_scope);

 function_name = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((1<<1) != (1<<0) &&
     __builtin_expect((*function_name).type != 6, 0)) {
  zend_error_noreturn((1<<0L), "Method name must be a string");
 }

 function_name_strval = (*function_name).value.str.val;
 function_name_strlen = (*function_name).value.str.len;

 execute_data->object = _get_obj_zval_ptr_unused();

 if (__builtin_expect(execute_data->object != ((void *)0), 1) &&
     __builtin_expect((*execute_data->object).type == 5, 1)) {
  execute_data->called_scope = zend_get_class_entry(&(*execute_data->object) );

  if ((1<<1) != (1<<0) ||
      (execute_data->fbc = (((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] == (execute_data->called_scope)) ? (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] : ((void *)0))) == ((void *)0)) {
      zval *object = execute_data->object;

   if (__builtin_expect((*execute_data->object).value.obj.handlers->get_method == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Object does not support method calls");
   }


   execute_data->fbc = (*execute_data->object).value.obj.handlers->get_method(&execute_data->object, function_name_strval, function_name_strlen, (((1<<1) == (1<<0)) ? (opline->op2.literal + 1) : ((void *)0)) );
   if (__builtin_expect(execute_data->fbc == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Call to undefined method %s::%s()", ((execute_data->object) && (*execute_data->object).type == 5 && (*execute_data->object).value.obj.handlers->get_class_entry != ((void *)0) && (*execute_data->object).value.obj.handlers->get_class_entry(execute_data->object ) ? (*execute_data->object).value.obj.handlers->get_class_entry(execute_data->object )->name : ""), function_name_strval);
   }
   if ((1<<1) == (1<<0) &&
       __builtin_expect((execute_data->fbc->common.fn_flags & 0x200000) == 0, 1) &&
       __builtin_expect(execute_data->object == object, 1)) {
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (execute_data->called_scope); (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] = (execute_data->fbc); } while (0);
   }
  }
 } else {
  zend_error_noreturn((1<<0L), "Call to a member function %s() on a non-object", function_name_strval);
 }

 if ((execute_data->fbc->common.fn_flags & 0x01) != 0) {
  execute_data->object = ((void *)0);
 } else {
  if (!zval_isref_p(execute_data->object)) {
   zval_addref_p(execute_data->object);
  } else {
   zval *this_ptr;
   do { (this_ptr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(this_ptr))->u.buffered = ((void *)0); } while (0);
   do { do { (this_ptr)->value = (execute_data->object)->value; (*this_ptr).type = (*execute_data->object).type; } while (0); zval_set_refcount_p(this_ptr, 1); zval_unset_isref_p(this_ptr); } while (0);
   _zval_copy_ctor((this_ptr) );
   execute_data->object = this_ptr;
  }
 }

 _zval_dtor((free_op2.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_ARRAY_SPEC_UNUSED_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 _array_init((&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var), 0 );
 if ((1<<3) == (1<<3)) {
  execute_data->opline++; return 0;




 }
}

static int __attribute__((fastcall)) ZEND_UNSET_DIM_SPEC_UNUSED_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval **container;
 zval *offset;
 ulong hval;

 ;
 container = _get_obj_zval_ptr_ptr_unused();
 offset = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((1<<3) != (1<<2) || container) {
  if ((1<<3) == (1<<4) && container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
  switch ((**container).type) {
   case 4: {
    HashTable *ht = (**container).value.ht;

    switch ((*offset).type) {
     case 2:
      hval = zend_dval_to_lval((*offset).value.dval);
      goto num_index_dim;
     case 7:
     case 3:
     case 1:
num_index_dim:
      hval = (*offset).value.lval;
      zend_hash_del_key_or_index(ht, ((void *)0), 0, hval, 1);
      break;
     case 6:
      if ((1<<1) == (1<<4) || (1<<1) == (1<<2)) {
       zval_addref_p(offset);
      }
      if ((1<<1) == (1<<0)) {
       hval = (((zend_literal*)(offset))->hash_value);
      } else {
       do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index_dim; } } } while (0);
       if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
        hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
       } else {
        hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
       }
      }
      if (ht == &(executor_globals.symbol_table)) {
       zend_delete_global_variable_ex(offset->value.str.val, offset->value.str.len, hval );
      } else {
       zend_hash_del_key_or_index(ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, 2);
      }
      if ((1<<1) == (1<<4) || (1<<1) == (1<<2)) {
       i_zval_ptr_dtor(*(&offset) );
      }
      break;
     case 0:
      zend_hash_del_key_or_index(ht, "", sizeof(""), 0, 0);
      break;
     default:
      zend_error((1<<1L), "Illegal offset type in unset");
      break;
    }
    _zval_dtor((free_op2.var) );
    break;
   }
   case 5:
    if (__builtin_expect((**container).value.obj.handlers->unset_dimension == ((void *)0), 0)) {
     zend_error_noreturn((1<<0L), "Cannot use object as array");
    }
    if (1) {
     do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
    }
    (**container).value.obj.handlers->unset_dimension(*container, offset );
    if (1) {
     i_zval_ptr_dtor(*(&offset) );
    } else {
     _zval_dtor((free_op2.var) );
    }
    break;
   case 6:
    zend_error_noreturn((1<<0L), "Cannot unset string offsets");
    return 0;
   default:
    _zval_dtor((free_op2.var) );
    break;
  }
 } else {
  _zval_dtor((free_op2.var) );
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_UNSET_OBJ_SPEC_UNUSED_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval **container;
 zval *offset;

 ;
 container = _get_obj_zval_ptr_ptr_unused();
 offset = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((1<<3) != (1<<2) || container) {
  if ((1<<3) == (1<<4) && container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
  if ((**container).type == 5) {
   if (1) {
    do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
   }
   if ((**container).value.obj.handlers->unset_property) {
    (**container).value.obj.handlers->unset_property(*container, offset, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   } else {
    zend_error((1<<3L), "Trying to unset property of non-object");
   }
   if (1) {
    i_zval_ptr_dtor(*(&offset) );
   } else {
    _zval_dtor((free_op2.var) );
   }
  } else {
   _zval_dtor((free_op2.var) );
  }
 } else {
  _zval_dtor((free_op2.var) );
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_TMP(int prop_dim, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval **container;
 zval **value = ((void *)0);
 int result = 0;
 ulong hval;
 zval *offset;

 ;
 container = _get_obj_zval_ptr_ptr_unused();

 offset = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((**container).type == 4 && !prop_dim) {
  HashTable *ht;
  int isset = 0;

  ht = (**container).value.ht;

  switch ((*offset).type) {
   case 2:
    hval = zend_dval_to_lval((*offset).value.dval);
    goto num_index_prop;
   case 7:
   case 3:
   case 1:
    hval = (*offset).value.lval;
num_index_prop:
    if (zend_hash_index_find(ht, hval, (void **) &value) == 0) {
     isset = 1;
    }
    break;
   case 6:
    if ((1<<1) == (1<<0)) {
     hval = (((zend_literal*)(offset))->hash_value);
    } else {
     if (!prop_dim) {
      do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index_prop; } } } while (0);
     }
     if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
      hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
     } else {
      hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
     }
    }
    if (zend_hash_quick_find(ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, (void **) &value) == 0) {
     isset = 1;
    }
    break;
   case 0:
    if (zend_hash_find(ht, "", sizeof(""), (void **) &value) == 0) {
     isset = 1;
    }
    break;
   default:
    zend_error((1<<1L), "Illegal offset type in isset or empty");
    break;
  }

  if (opline->extended_value & 0x02000000) {
   if (isset && (**value).type == 0) {
    result = 0;
   } else {
    result = isset;
   }
  } else {
   if (!isset || !i_zend_is_true(*value)) {
    result = 0;
   } else {
    result = 1;
   }
  }
  _zval_dtor((free_op2.var) );
 } else if ((**container).type == 5) {
  if (1) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
  }
  if (prop_dim) {
   if ((**container).value.obj.handlers->has_property) {
    result = (**container).value.obj.handlers->has_property(*container, offset, (opline->extended_value & 0x01000000) != 0, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   } else {
    zend_error((1<<3L), "Trying to check property of non-object");
    result = 0;
   }
  } else {
   if ((**container).value.obj.handlers->has_dimension) {
    result = (**container).value.obj.handlers->has_dimension(*container, offset, (opline->extended_value & 0x01000000) != 0 );
   } else {
    zend_error((1<<3L), "Trying to check element of non-array");
    result = 0;
   }
  }
  if (1) {
   i_zval_ptr_dtor(*(&offset) );
  } else {
   _zval_dtor((free_op2.var) );
  }
 } else if ((*container)->type == 6 && !prop_dim) {
  zval tmp;

  if ((*offset).type != 1) {
   do { (&tmp)->value = (offset)->value; (*&tmp).type = (*offset).type; } while (0);
   _zval_copy_ctor((&tmp) );
   convert_to_long(&tmp);
   offset = &tmp;
  }
  if ((*offset).type == 1) {
   if (opline->extended_value & 0x02000000) {
    if (offset->value.lval >= 0 && offset->value.lval < (**container).value.str.len) {
     result = 1;
    }
   } else {
    if (offset->value.lval >= 0 && offset->value.lval < (**container).value.str.len && (**container).value.str.val[offset->value.lval] != '0') {
     result = 1;
    }
   }
  }
  _zval_dtor((free_op2.var) );
 } else {
  _zval_dtor((free_op2.var) );
 }

 ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).type = 3;
 if (opline->extended_value & 0x02000000) {
  ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.lval = result;
 } else {
  ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.lval = !result;
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_TMP(0, execute_data );
}

static int __attribute__((fastcall)) ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_TMP(1, execute_data );
}

static int __attribute__((fastcall)) zend_binary_assign_op_obj_helper_SPEC_UNUSED_VAR(int (*binary_op)(zval *result, zval *op1, zval *op2 ), zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2, free_op_data1;
 zval **object_ptr = _get_obj_zval_ptr_ptr_unused();
 zval *object;
 zval *property = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );
 zval *value = _get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, &free_op_data1, 0 );
 int have_get_ptr = 0;

 if ((1<<3) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }

 make_real_object(object_ptr );
 object = *object_ptr;

 if (__builtin_expect((*object).type != 5, 0)) {
  zend_error((1<<1L), "Attempt to assign property of non-object");
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };

  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = &(executor_globals.uninitialized_zval);
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
  }
 } else {

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
  }


  if (opline->extended_value == 136
   && (*object).value.obj.handlers->get_property_ptr_ptr) {
   zval **zptr = (*object).value.obj.handlers->get_property_ptr_ptr(object, property, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   if (zptr != ((void *)0)) {
    if (!zval_isref_p(*zptr)) { do { if (zval_refcount_p(*((zptr))) > 1) { zval *new_zv; zval_delref_p(*(zptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(zptr))->value; (*new_zv).type = (**(zptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(zptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

    have_get_ptr = 1;
    binary_op(*zptr, *zptr, value );
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((*zptr));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = *zptr;
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
   }
  }

  if (!have_get_ptr) {
   zval *z = ((void *)0);

   if (opline->extended_value == 136) {
    if ((*object).value.obj.handlers->read_property) {
     z = (*object).value.obj.handlers->read_property(object, property, 0, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
    }
   } else {
    if ((*object).value.obj.handlers->read_dimension) {
     z = (*object).value.obj.handlers->read_dimension(object, property, 0 );
    }
   }
   if (z) {
    if ((*z).type == 5 && (*z).value.obj.handlers->get) {
     zval *value = (*z).value.obj.handlers->get(z );

     if (zval_refcount_p(z) == 0) {
      if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); };
      _zval_dtor((z) );
      do { if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); }; _efree((z) ); } while (0);
     }
     z = value;
    }
    zval_addref_p(z);
    if (!zval_isref_p(*&z)) { do { if (zval_refcount_p(*((&z))) > 1) { zval *new_zv; zval_delref_p(*(&z)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(&z))->value; (*new_zv).type = (**(&z)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(&z) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
    binary_op(z, z, value );
    if (opline->extended_value == 136) {
     (*object).value.obj.handlers->write_property(object, property, z, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
    } else {
     (*object).value.obj.handlers->write_dimension(object, property, z );
    }
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((z));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = z;
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
    i_zval_ptr_dtor(*(&z) );
   } else {
    zend_error((1<<1L), "Attempt to assign property of non-object");
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((&(executor_globals.uninitialized_zval)));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = &(executor_globals.uninitialized_zval);
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
   }
  }

  if (0) {
   i_zval_ptr_dtor(*(&property) );
  } else {
   if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
  }
  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };
 }


 ;
 execute_data->opline++;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_binary_assign_op_helper_SPEC_UNUSED_VAR(int (*binary_op)(zval *result, zval *op1, zval *op2 ), zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2, free_op_data2, free_op_data1;
 zval **var_ptr;
 zval *value;

 ;
 switch (opline->extended_value) {
  case 136:
   return zend_binary_assign_op_obj_helper_SPEC_UNUSED_VAR(binary_op, execute_data );
   break;
  case 147: {
    zval **container = _get_obj_zval_ptr_ptr_unused();

    if ((1<<3) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
     zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
    } else if (__builtin_expect((**container).type == 5, 0)) {
     if ((1<<3) == (1<<2) && !0) {
      zval_addref_p(*(container));
     }
     return zend_binary_assign_op_obj_helper_SPEC_UNUSED_VAR(binary_op, execute_data );
    } else {
     zval *dim = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );

     zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)), container, dim, (1<<2), 2 );
     value = _get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, &free_op_data1, 0 );
     var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data->Ts, &free_op_data2 );
    }
   }
   break;
  default:
   value = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );
   var_ptr = ((void *)0);

   break;
 }

 if (__builtin_expect(var_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use assign-op operators with overloaded objects nor string offsets");
 }

 if (__builtin_expect(*var_ptr == &(executor_globals.error_zval), 0)) {
  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};

  ;
  if (opline->extended_value == 147) {
   execute_data->opline++;
  }
  execute_data->opline++; return 0;
 }

 if (!zval_isref_p(*var_ptr)) { do { if (zval_refcount_p(*((var_ptr))) > 1) { zval *new_zv; zval_delref_p(*(var_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(var_ptr))->value; (*new_zv).type = (**(var_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(var_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

 if (__builtin_expect((**var_ptr).type == 5, 0)
    && ((**var_ptr)).value.obj.handlers->get
    && ((**var_ptr)).value.obj.handlers->set) {

  zval *objval = ((**var_ptr)).value.obj.handlers->get(*var_ptr );
  zval_addref_p(objval);
  binary_op(objval, objval, value );
  ((**var_ptr)).value.obj.handlers->set(var_ptr, objval );
  i_zval_ptr_dtor(*(&objval) );
 } else {
  binary_op(*var_ptr, *var_ptr, value );
 }

 if ((!((opline)->result_type & (1<<5)))) {
  zval_addref_p((*var_ptr));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (*var_ptr); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
 }
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};

 if (opline->extended_value == 147) {
  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };
  if (free_op_data2.var) { i_zval_ptr_dtor(*(&free_op_data2.var) ); };

  ;
  execute_data->opline++;
 } else {

  ;
 }
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_ADD_SPEC_UNUSED_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_VAR(add_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SUB_SPEC_UNUSED_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_VAR(sub_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_MUL_SPEC_UNUSED_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_VAR(mul_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_DIV_SPEC_UNUSED_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_VAR(div_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_MOD_SPEC_UNUSED_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_VAR(mod_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SL_SPEC_UNUSED_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_VAR(shift_left_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SR_SPEC_UNUSED_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_VAR(shift_right_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_CONCAT_SPEC_UNUSED_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_VAR(concat_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_OR_SPEC_UNUSED_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_VAR(bitwise_or_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_AND_SPEC_UNUSED_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_VAR(bitwise_and_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_VAR(bitwise_xor_function, execute_data );
}

static int __attribute__((fastcall)) zend_pre_incdec_property_helper_SPEC_UNUSED_VAR(incdec_t incdec_op, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval **object_ptr;
 zval *object;
 zval *property;
 zval **retval;
 int have_get_ptr = 0;

 ;
 object_ptr = _get_obj_zval_ptr_ptr_unused();
 property = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );
 retval = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr;

 if ((1<<3) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot increment/decrement overloaded objects nor string offsets");
 }

 make_real_object(object_ptr );
 object = *object_ptr;

 if (__builtin_expect((*object).type != 5, 0)) {
  zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   *retval = &(executor_globals.uninitialized_zval);
  }

  ;
  execute_data->opline++; return 0;
 }



 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }

 if ((*object).value.obj.handlers->get_property_ptr_ptr) {
  zval **zptr = (*object).value.obj.handlers->get_property_ptr_ptr(object, property, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
  if (zptr != ((void *)0)) {
   if (!zval_isref_p(*zptr)) { do { if (zval_refcount_p(*((zptr))) > 1) { zval *new_zv; zval_delref_p(*(zptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(zptr))->value; (*new_zv).type = (**(zptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(zptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

   have_get_ptr = 1;
   incdec_op(*zptr);
   if ((!((opline)->result_type & (1<<5)))) {
    *retval = *zptr;
    zval_addref_p((*retval));
   }
  }
 }

 if (!have_get_ptr) {
  if ((*object).value.obj.handlers->read_property && (*object).value.obj.handlers->write_property) {
   zval *z = (*object).value.obj.handlers->read_property(object, property, 0, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );

   if (__builtin_expect((*z).type == 5, 0) && (*z).value.obj.handlers->get) {
    zval *value = (*z).value.obj.handlers->get(z );

    if (zval_refcount_p(z) == 0) {
     if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); };
     _zval_dtor((z) );
     do { if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); }; _efree((z) ); } while (0);
    }
    z = value;
   }
   zval_addref_p(z);
   if (!zval_isref_p(*&z)) { do { if (zval_refcount_p(*((&z))) > 1) { zval *new_zv; zval_delref_p(*(&z)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(&z))->value; (*new_zv).type = (**(&z)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(&z) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
   incdec_op(z);
   *retval = z;
   (*object).value.obj.handlers->write_property(object, property, z, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   if ((!((opline)->result_type & (1<<5)))) { zval_addref_p((*retval)); };
   i_zval_ptr_dtor(*(&z) );
  } else {
   zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
   if ((!((opline)->result_type & (1<<5)))) {
    zval_addref_p((&(executor_globals.uninitialized_zval)));
    *retval = &(executor_globals.uninitialized_zval);
   }
  }
 }

 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_PRE_INC_OBJ_SPEC_UNUSED_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_pre_incdec_property_helper_SPEC_UNUSED_VAR(increment_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_PRE_DEC_OBJ_SPEC_UNUSED_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_pre_incdec_property_helper_SPEC_UNUSED_VAR(decrement_function, execute_data );
}

static int __attribute__((fastcall)) zend_post_incdec_property_helper_SPEC_UNUSED_VAR(incdec_t incdec_op, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval **object_ptr;
 zval *object;
 zval *property;
 zval *retval;
 int have_get_ptr = 0;

 ;
 object_ptr = _get_obj_zval_ptr_ptr_unused();
 property = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );
 retval = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 if ((1<<3) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot increment/decrement overloaded objects nor string offsets");
 }

 make_real_object(object_ptr );
 object = *object_ptr;

 if (__builtin_expect((*object).type != 5, 0)) {
  zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
  { (*retval).type = 0; };

  ;
  execute_data->opline++; return 0;
 }



 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }

 if ((*object).value.obj.handlers->get_property_ptr_ptr) {
  zval **zptr = (*object).value.obj.handlers->get_property_ptr_ptr(object, property, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
  if (zptr != ((void *)0)) {
   have_get_ptr = 1;
   if (!zval_isref_p(*zptr)) { do { if (zval_refcount_p(*((zptr))) > 1) { zval *new_zv; zval_delref_p(*(zptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(zptr))->value; (*new_zv).type = (**(zptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(zptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

   do { (retval)->value = (*zptr)->value; (*retval).type = (**zptr).type; } while (0);
   _zval_copy_ctor((&(*retval)) );

   incdec_op(*zptr);

  }
 }

 if (!have_get_ptr) {
  if ((*object).value.obj.handlers->read_property && (*object).value.obj.handlers->write_property) {
   zval *z = (*object).value.obj.handlers->read_property(object, property, 0, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   zval *z_copy;

   if (__builtin_expect((*z).type == 5, 0) && (*z).value.obj.handlers->get) {
    zval *value = (*z).value.obj.handlers->get(z );

    if (zval_refcount_p(z) == 0) {
     if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); };
     _zval_dtor((z) );
     do { if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); }; _efree((z) ); } while (0);
    }
    z = value;
   }
   do { (retval)->value = (z)->value; (*retval).type = (*z).type; } while (0);
   _zval_copy_ctor((&(*retval)) );
   do { (z_copy) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(z_copy))->u.buffered = ((void *)0); } while (0);
   do { do { (z_copy)->value = (z)->value; (*z_copy).type = (*z).type; } while (0); zval_set_refcount_p(z_copy, 1); zval_unset_isref_p(z_copy); } while (0);
   _zval_copy_ctor((&(*z_copy)) );
   incdec_op(z_copy);
   zval_addref_p(z);
   (*object).value.obj.handlers->write_property(object, property, z_copy, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   i_zval_ptr_dtor(*(&z_copy) );
   i_zval_ptr_dtor(*(&z) );
  } else {
   zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
   { (*retval).type = 0; };
  }
 }

 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_POST_INC_OBJ_SPEC_UNUSED_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_post_incdec_property_helper_SPEC_UNUSED_VAR(increment_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_POST_DEC_OBJ_SPEC_UNUSED_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_post_incdec_property_helper_SPEC_UNUSED_VAR(decrement_function, execute_data );
}

static int __attribute__((fastcall)) zend_fetch_property_address_read_helper_SPEC_UNUSED_VAR(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *container;
 zend_free_op free_op2;
 zval *offset;

 ;
 container = _get_obj_zval_ptr_unused();
 offset = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );

 if (__builtin_expect((*container).type != 5, 0) ||
     __builtin_expect((*container).value.obj.handlers->read_property == ((void *)0), 0)) {
  zend_error((1<<3L), "Trying to get property of non-object");
  zval_addref_p((&(executor_globals.uninitialized_zval)));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 } else {
  zval *retval;

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
  }


  retval = (*container).value.obj.handlers->read_property(container, offset, 0, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );

  zval_addref_p((retval));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);

  if (0) {
   i_zval_ptr_dtor(*(&offset) );
  } else {
   if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_R_SPEC_UNUSED_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_property_address_read_helper_SPEC_UNUSED_VAR(execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_W_SPEC_UNUSED_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval *property;
 zval **container;

 ;
 property = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((1<<3) == (1<<2) && (opline->extended_value & 0x08000000)) {
  zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr));
  (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr = *(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr;
 }

 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }
 container = _get_obj_zval_ptr_ptr_unused();
 if ((1<<3) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }

 zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)), 1 );
 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 }
 if ((1<<3) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }


 if (opline->extended_value & 0x04000000) {
  zval **retval_ptr = (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr;

  zval_delref_p(*(retval_ptr));
  if (!zval_isref_p(*retval_ptr)) { do { if (zval_refcount_p(*((retval_ptr))) > 1) { zval *new_zv; zval_delref_p(*(retval_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval_ptr))->value; (*new_zv).type = (**(retval_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((retval_ptr))); };
  zval_addref_p(*(retval_ptr));
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_RW_SPEC_UNUSED_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval *property;
 zval **container;

 ;
 property = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );
 container = _get_obj_zval_ptr_ptr_unused();

 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }
 if ((1<<3) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }
 zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)), 2 );
 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 }
 if ((1<<3) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_IS_SPEC_UNUSED_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *container;
 zend_free_op free_op2;
 zval *offset;

 ;
 container = _get_obj_zval_ptr_unused();
 offset = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );

 if (__builtin_expect((*container).type != 5, 0) ||
     __builtin_expect((*container).value.obj.handlers->read_property == ((void *)0), 0)) {
  zval_addref_p((&(executor_globals.uninitialized_zval)));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 } else {
  zval *retval;

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
  }


  retval = (*container).value.obj.handlers->read_property(container, offset, 3, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );

  zval_addref_p((retval));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);

  if (0) {
   i_zval_ptr_dtor(*(&offset) );
  } else {
   if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 if (((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && (opline->extended_value & 0x000fffff) <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[(opline->extended_value & 0x000fffff)-1].pass_by_reference & (1|2)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x1000000|0x2000000))))) {

  zend_free_op free_op1, free_op2;
  zval *property;
  zval **container;

  ;
  property = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );
  container = _get_obj_zval_ptr_ptr_unused();

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
  }
  if ((1<<3) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
  }
  zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)), 1 );
  if (0) {
   i_zval_ptr_dtor(*(&property) );
  } else {
   if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
  }
  if ((1<<3) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
  }

  ;
  execute_data->opline++; return 0;
 } else {
  return zend_fetch_property_address_read_helper_SPEC_UNUSED_VAR(execute_data );
 }
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2, free_res;
 zval **container;
 zval *property;

 ;
 container = _get_obj_zval_ptr_ptr_unused();
 property = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((1<<3) == (1<<4)) {
  if (container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
 }
 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }
 if ((1<<3) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }
 zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)), 6 );
 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 }
 if ((1<<3) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }

 zend_pzval_unlock_func(*(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr, &free_res, 1 );
 if ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr != &(executor_globals.uninitialized_zval_ptr)) {
  if (!zval_isref_p(*(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr)) { do { if (zval_refcount_p(*(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr))->value; (*new_zv).type = (**((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
 }
 zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr));
 if (free_res.var) { i_zval_ptr_dtor(*(&free_res.var) ); };
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_OBJ_SPEC_UNUSED_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval **object_ptr;
 zval *property_name;

 ;
 object_ptr = _get_obj_zval_ptr_ptr_unused();
 property_name = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );

 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property_name))->value; (*_tmp).type = (*(property_name)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property_name) = _tmp; } while (0);
 }
 if ((1<<3) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 zend_assign_to_object((!((opline)->result_type & (1<<5)))?&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr:((void *)0), object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, 136, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
 if (0) {
  i_zval_ptr_dtor(*(&property_name) );
 } else {
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 }


 ;
 execute_data->opline++;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ADD_VAR_SPEC_UNUSED_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval *str = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;
 zval *var;
 zval var_copy;
 int use_copy = 0;

 ;
 var = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((1<<3) == (1<<3)) {

  (*str).value.str.val = ((void *)0);
  (*str).value.str.len = 0;
  (*str).type = 6;

  (str)->refcount__gc = 1; (str)->is_ref__gc = 0;;
 }

 if ((*var).type != 6) {
  zend_make_printable_zval(var, &var_copy, &use_copy);

  if (use_copy) {
   var = &var_copy;
  }
 }
 add_string_to_string(str, str, var);

 if (use_copy) {
  _zval_dtor((var) );
 }






 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_METHOD_CALL_SPEC_UNUSED_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *function_name;
 char *function_name_strval;
 int function_name_strlen;
 zend_free_op free_op2;

 ;
 zend_ptr_stack_3_push(&(executor_globals.arg_types_stack), execute_data->fbc, execute_data->object, execute_data->called_scope);

 function_name = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((1<<2) != (1<<0) &&
     __builtin_expect((*function_name).type != 6, 0)) {
  zend_error_noreturn((1<<0L), "Method name must be a string");
 }

 function_name_strval = (*function_name).value.str.val;
 function_name_strlen = (*function_name).value.str.len;

 execute_data->object = _get_obj_zval_ptr_unused();

 if (__builtin_expect(execute_data->object != ((void *)0), 1) &&
     __builtin_expect((*execute_data->object).type == 5, 1)) {
  execute_data->called_scope = zend_get_class_entry(&(*execute_data->object) );

  if ((1<<2) != (1<<0) ||
      (execute_data->fbc = (((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] == (execute_data->called_scope)) ? (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] : ((void *)0))) == ((void *)0)) {
      zval *object = execute_data->object;

   if (__builtin_expect((*execute_data->object).value.obj.handlers->get_method == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Object does not support method calls");
   }


   execute_data->fbc = (*execute_data->object).value.obj.handlers->get_method(&execute_data->object, function_name_strval, function_name_strlen, (((1<<2) == (1<<0)) ? (opline->op2.literal + 1) : ((void *)0)) );
   if (__builtin_expect(execute_data->fbc == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Call to undefined method %s::%s()", ((execute_data->object) && (*execute_data->object).type == 5 && (*execute_data->object).value.obj.handlers->get_class_entry != ((void *)0) && (*execute_data->object).value.obj.handlers->get_class_entry(execute_data->object ) ? (*execute_data->object).value.obj.handlers->get_class_entry(execute_data->object )->name : ""), function_name_strval);
   }
   if ((1<<2) == (1<<0) &&
       __builtin_expect((execute_data->fbc->common.fn_flags & 0x200000) == 0, 1) &&
       __builtin_expect(execute_data->object == object, 1)) {
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (execute_data->called_scope); (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] = (execute_data->fbc); } while (0);
   }
  }
 } else {
  zend_error_noreturn((1<<0L), "Call to a member function %s() on a non-object", function_name_strval);
 }

 if ((execute_data->fbc->common.fn_flags & 0x01) != 0) {
  execute_data->object = ((void *)0);
 } else {
  if (!zval_isref_p(execute_data->object)) {
   zval_addref_p(execute_data->object);
  } else {
   zval *this_ptr;
   do { (this_ptr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(this_ptr))->u.buffered = ((void *)0); } while (0);
   do { do { (this_ptr)->value = (execute_data->object)->value; (*this_ptr).type = (*execute_data->object).type; } while (0); zval_set_refcount_p(this_ptr, 1); zval_unset_isref_p(this_ptr); } while (0);
   _zval_copy_ctor((this_ptr) );
   execute_data->object = this_ptr;
  }
 }

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_ARRAY_SPEC_UNUSED_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 _array_init((&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var), 0 );
 if ((1<<3) == (1<<3)) {
  execute_data->opline++; return 0;




 }
}

static int __attribute__((fastcall)) ZEND_UNSET_DIM_SPEC_UNUSED_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval **container;
 zval *offset;
 ulong hval;

 ;
 container = _get_obj_zval_ptr_ptr_unused();
 offset = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((1<<3) != (1<<2) || container) {
  if ((1<<3) == (1<<4) && container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
  switch ((**container).type) {
   case 4: {
    HashTable *ht = (**container).value.ht;

    switch ((*offset).type) {
     case 2:
      hval = zend_dval_to_lval((*offset).value.dval);
      goto num_index_dim;
     case 7:
     case 3:
     case 1:
num_index_dim:
      hval = (*offset).value.lval;
      zend_hash_del_key_or_index(ht, ((void *)0), 0, hval, 1);
      break;
     case 6:
      if ((1<<2) == (1<<4) || (1<<2) == (1<<2)) {
       zval_addref_p(offset);
      }
      if ((1<<2) == (1<<0)) {
       hval = (((zend_literal*)(offset))->hash_value);
      } else {
       do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index_dim; } } } while (0);
       if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
        hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
       } else {
        hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
       }
      }
      if (ht == &(executor_globals.symbol_table)) {
       zend_delete_global_variable_ex(offset->value.str.val, offset->value.str.len, hval );
      } else {
       zend_hash_del_key_or_index(ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, 2);
      }
      if ((1<<2) == (1<<4) || (1<<2) == (1<<2)) {
       i_zval_ptr_dtor(*(&offset) );
      }
      break;
     case 0:
      zend_hash_del_key_or_index(ht, "", sizeof(""), 0, 0);
      break;
     default:
      zend_error((1<<1L), "Illegal offset type in unset");
      break;
    }
    if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
    break;
   }
   case 5:
    if (__builtin_expect((**container).value.obj.handlers->unset_dimension == ((void *)0), 0)) {
     zend_error_noreturn((1<<0L), "Cannot use object as array");
    }
    if (0) {
     do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
    }
    (**container).value.obj.handlers->unset_dimension(*container, offset );
    if (0) {
     i_zval_ptr_dtor(*(&offset) );
    } else {
     if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
    }
    break;
   case 6:
    zend_error_noreturn((1<<0L), "Cannot unset string offsets");
    return 0;
   default:
    if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
    break;
  }
 } else {
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_UNSET_OBJ_SPEC_UNUSED_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval **container;
 zval *offset;

 ;
 container = _get_obj_zval_ptr_ptr_unused();
 offset = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((1<<3) != (1<<2) || container) {
  if ((1<<3) == (1<<4) && container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
  if ((**container).type == 5) {
   if (0) {
    do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
   }
   if ((**container).value.obj.handlers->unset_property) {
    (**container).value.obj.handlers->unset_property(*container, offset, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   } else {
    zend_error((1<<3L), "Trying to unset property of non-object");
   }
   if (0) {
    i_zval_ptr_dtor(*(&offset) );
   } else {
    if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
   }
  } else {
   if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
  }
 } else {
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_VAR(int prop_dim, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval **container;
 zval **value = ((void *)0);
 int result = 0;
 ulong hval;
 zval *offset;

 ;
 container = _get_obj_zval_ptr_ptr_unused();

 offset = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((**container).type == 4 && !prop_dim) {
  HashTable *ht;
  int isset = 0;

  ht = (**container).value.ht;

  switch ((*offset).type) {
   case 2:
    hval = zend_dval_to_lval((*offset).value.dval);
    goto num_index_prop;
   case 7:
   case 3:
   case 1:
    hval = (*offset).value.lval;
num_index_prop:
    if (zend_hash_index_find(ht, hval, (void **) &value) == 0) {
     isset = 1;
    }
    break;
   case 6:
    if ((1<<2) == (1<<0)) {
     hval = (((zend_literal*)(offset))->hash_value);
    } else {
     if (!prop_dim) {
      do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index_prop; } } } while (0);
     }
     if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
      hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
     } else {
      hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
     }
    }
    if (zend_hash_quick_find(ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, (void **) &value) == 0) {
     isset = 1;
    }
    break;
   case 0:
    if (zend_hash_find(ht, "", sizeof(""), (void **) &value) == 0) {
     isset = 1;
    }
    break;
   default:
    zend_error((1<<1L), "Illegal offset type in isset or empty");
    break;
  }

  if (opline->extended_value & 0x02000000) {
   if (isset && (**value).type == 0) {
    result = 0;
   } else {
    result = isset;
   }
  } else {
   if (!isset || !i_zend_is_true(*value)) {
    result = 0;
   } else {
    result = 1;
   }
  }
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 } else if ((**container).type == 5) {
  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
  }
  if (prop_dim) {
   if ((**container).value.obj.handlers->has_property) {
    result = (**container).value.obj.handlers->has_property(*container, offset, (opline->extended_value & 0x01000000) != 0, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   } else {
    zend_error((1<<3L), "Trying to check property of non-object");
    result = 0;
   }
  } else {
   if ((**container).value.obj.handlers->has_dimension) {
    result = (**container).value.obj.handlers->has_dimension(*container, offset, (opline->extended_value & 0x01000000) != 0 );
   } else {
    zend_error((1<<3L), "Trying to check element of non-array");
    result = 0;
   }
  }
  if (0) {
   i_zval_ptr_dtor(*(&offset) );
  } else {
   if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
  }
 } else if ((*container)->type == 6 && !prop_dim) {
  zval tmp;

  if ((*offset).type != 1) {
   do { (&tmp)->value = (offset)->value; (*&tmp).type = (*offset).type; } while (0);
   _zval_copy_ctor((&tmp) );
   convert_to_long(&tmp);
   offset = &tmp;
  }
  if ((*offset).type == 1) {
   if (opline->extended_value & 0x02000000) {
    if (offset->value.lval >= 0 && offset->value.lval < (**container).value.str.len) {
     result = 1;
    }
   } else {
    if (offset->value.lval >= 0 && offset->value.lval < (**container).value.str.len && (**container).value.str.val[offset->value.lval] != '0') {
     result = 1;
    }
   }
  }
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 } else {
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 }

 ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).type = 3;
 if (opline->extended_value & 0x02000000) {
  ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.lval = result;
 } else {
  ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.lval = !result;
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_VAR(0, execute_data );
}

static int __attribute__((fastcall)) ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_VAR(1, execute_data );
}

static int __attribute__((fastcall)) zend_binary_assign_op_obj_helper_SPEC_UNUSED_UNUSED(int (*binary_op)(zval *result, zval *op1, zval *op2 ), zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op_data1;
 zval **object_ptr = _get_obj_zval_ptr_ptr_unused();
 zval *object;
 zval *property = ((void *)0);
 zval *value = _get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, &free_op_data1, 0 );
 int have_get_ptr = 0;

 if ((1<<3) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }

 make_real_object(object_ptr );
 object = *object_ptr;

 if (__builtin_expect((*object).type != 5, 0)) {
  zend_error((1<<1L), "Attempt to assign property of non-object");

  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };

  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = &(executor_globals.uninitialized_zval);
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
  }
 } else {

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
  }


  if (opline->extended_value == 136
   && (*object).value.obj.handlers->get_property_ptr_ptr) {
   zval **zptr = (*object).value.obj.handlers->get_property_ptr_ptr(object, property, (((1<<3) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   if (zptr != ((void *)0)) {
    if (!zval_isref_p(*zptr)) { do { if (zval_refcount_p(*((zptr))) > 1) { zval *new_zv; zval_delref_p(*(zptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(zptr))->value; (*new_zv).type = (**(zptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(zptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

    have_get_ptr = 1;
    binary_op(*zptr, *zptr, value );
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((*zptr));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = *zptr;
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
   }
  }

  if (!have_get_ptr) {
   zval *z = ((void *)0);

   if (opline->extended_value == 136) {
    if ((*object).value.obj.handlers->read_property) {
     z = (*object).value.obj.handlers->read_property(object, property, 0, (((1<<3) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
    }
   } else {
    if ((*object).value.obj.handlers->read_dimension) {
     z = (*object).value.obj.handlers->read_dimension(object, property, 0 );
    }
   }
   if (z) {
    if ((*z).type == 5 && (*z).value.obj.handlers->get) {
     zval *value = (*z).value.obj.handlers->get(z );

     if (zval_refcount_p(z) == 0) {
      if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); };
      _zval_dtor((z) );
      do { if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); }; _efree((z) ); } while (0);
     }
     z = value;
    }
    zval_addref_p(z);
    if (!zval_isref_p(*&z)) { do { if (zval_refcount_p(*((&z))) > 1) { zval *new_zv; zval_delref_p(*(&z)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(&z))->value; (*new_zv).type = (**(&z)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(&z) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
    binary_op(z, z, value );
    if (opline->extended_value == 136) {
     (*object).value.obj.handlers->write_property(object, property, z, (((1<<3) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
    } else {
     (*object).value.obj.handlers->write_dimension(object, property, z );
    }
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((z));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = z;
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
    i_zval_ptr_dtor(*(&z) );
   } else {
    zend_error((1<<1L), "Attempt to assign property of non-object");
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((&(executor_globals.uninitialized_zval)));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = &(executor_globals.uninitialized_zval);
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
   }
  }

  if (0) {
   i_zval_ptr_dtor(*(&property) );
  } else {

  }
  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };
 }


 ;
 execute_data->opline++;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED(int (*binary_op)(zval *result, zval *op1, zval *op2 ), zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op_data2, free_op_data1;
 zval **var_ptr;
 zval *value;

 ;
 switch (opline->extended_value) {
  case 136:
   return zend_binary_assign_op_obj_helper_SPEC_UNUSED_UNUSED(binary_op, execute_data );
   break;
  case 147: {
    zval **container = _get_obj_zval_ptr_ptr_unused();

    if ((1<<3) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
     zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
    } else if (__builtin_expect((**container).type == 5, 0)) {
     if ((1<<3) == (1<<2) && !0) {
      zval_addref_p(*(container));
     }
     return zend_binary_assign_op_obj_helper_SPEC_UNUSED_UNUSED(binary_op, execute_data );
    } else {
     zval *dim = ((void *)0);

     zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)), container, dim, (1<<3), 2 );
     value = _get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, &free_op_data1, 0 );
     var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data->Ts, &free_op_data2 );
    }
   }
   break;
  default:
   value = ((void *)0);
   var_ptr = ((void *)0);

   break;
 }

 if (__builtin_expect(var_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use assign-op operators with overloaded objects nor string offsets");
 }

 if (__builtin_expect(*var_ptr == &(executor_globals.error_zval), 0)) {
  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }


  ;
  if (opline->extended_value == 147) {
   execute_data->opline++;
  }
  execute_data->opline++; return 0;
 }

 if (!zval_isref_p(*var_ptr)) { do { if (zval_refcount_p(*((var_ptr))) > 1) { zval *new_zv; zval_delref_p(*(var_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(var_ptr))->value; (*new_zv).type = (**(var_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(var_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

 if (__builtin_expect((**var_ptr).type == 5, 0)
    && ((**var_ptr)).value.obj.handlers->get
    && ((**var_ptr)).value.obj.handlers->set) {

  zval *objval = ((**var_ptr)).value.obj.handlers->get(*var_ptr );
  zval_addref_p(objval);
  binary_op(objval, objval, value );
  ((**var_ptr)).value.obj.handlers->set(var_ptr, objval );
  i_zval_ptr_dtor(*(&objval) );
 } else {
  binary_op(*var_ptr, *var_ptr, value );
 }

 if ((!((opline)->result_type & (1<<5)))) {
  zval_addref_p((*var_ptr));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (*var_ptr); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
 }

 if (opline->extended_value == 147) {
  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };
  if (free_op_data2.var) { i_zval_ptr_dtor(*(&free_op_data2.var) ); };

  ;
  execute_data->opline++;
 } else {

  ;
 }
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_ADD_SPEC_UNUSED_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED(add_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SUB_SPEC_UNUSED_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED(sub_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_MUL_SPEC_UNUSED_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED(mul_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_DIV_SPEC_UNUSED_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED(div_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_MOD_SPEC_UNUSED_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED(mod_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SL_SPEC_UNUSED_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED(shift_left_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SR_SPEC_UNUSED_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED(shift_right_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_CONCAT_SPEC_UNUSED_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED(concat_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_OR_SPEC_UNUSED_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED(bitwise_or_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_AND_SPEC_UNUSED_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED(bitwise_and_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED(bitwise_xor_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_INIT_ARRAY_SPEC_UNUSED_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 _array_init((&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var), 0 );
 if ((1<<3) == (1<<3)) {
  execute_data->opline++; return 0;




 }
}

static int __attribute__((fastcall)) zend_binary_assign_op_obj_helper_SPEC_UNUSED_CV(int (*binary_op)(zval *result, zval *op1, zval *op2 ), zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op_data1;
 zval **object_ptr = _get_obj_zval_ptr_ptr_unused();
 zval *object;
 zval *property = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );
 zval *value = _get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, &free_op_data1, 0 );
 int have_get_ptr = 0;

 if ((1<<3) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }

 make_real_object(object_ptr );
 object = *object_ptr;

 if (__builtin_expect((*object).type != 5, 0)) {
  zend_error((1<<1L), "Attempt to assign property of non-object");

  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };

  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = &(executor_globals.uninitialized_zval);
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
  }
 } else {

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
  }


  if (opline->extended_value == 136
   && (*object).value.obj.handlers->get_property_ptr_ptr) {
   zval **zptr = (*object).value.obj.handlers->get_property_ptr_ptr(object, property, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   if (zptr != ((void *)0)) {
    if (!zval_isref_p(*zptr)) { do { if (zval_refcount_p(*((zptr))) > 1) { zval *new_zv; zval_delref_p(*(zptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(zptr))->value; (*new_zv).type = (**(zptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(zptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

    have_get_ptr = 1;
    binary_op(*zptr, *zptr, value );
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((*zptr));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = *zptr;
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
   }
  }

  if (!have_get_ptr) {
   zval *z = ((void *)0);

   if (opline->extended_value == 136) {
    if ((*object).value.obj.handlers->read_property) {
     z = (*object).value.obj.handlers->read_property(object, property, 0, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
    }
   } else {
    if ((*object).value.obj.handlers->read_dimension) {
     z = (*object).value.obj.handlers->read_dimension(object, property, 0 );
    }
   }
   if (z) {
    if ((*z).type == 5 && (*z).value.obj.handlers->get) {
     zval *value = (*z).value.obj.handlers->get(z );

     if (zval_refcount_p(z) == 0) {
      if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); };
      _zval_dtor((z) );
      do { if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); }; _efree((z) ); } while (0);
     }
     z = value;
    }
    zval_addref_p(z);
    if (!zval_isref_p(*&z)) { do { if (zval_refcount_p(*((&z))) > 1) { zval *new_zv; zval_delref_p(*(&z)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(&z))->value; (*new_zv).type = (**(&z)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(&z) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
    binary_op(z, z, value );
    if (opline->extended_value == 136) {
     (*object).value.obj.handlers->write_property(object, property, z, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
    } else {
     (*object).value.obj.handlers->write_dimension(object, property, z );
    }
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((z));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = z;
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
    i_zval_ptr_dtor(*(&z) );
   } else {
    zend_error((1<<1L), "Attempt to assign property of non-object");
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((&(executor_globals.uninitialized_zval)));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = &(executor_globals.uninitialized_zval);
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
   }
  }

  if (0) {
   i_zval_ptr_dtor(*(&property) );
  } else {

  }
  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };
 }


 ;
 execute_data->opline++;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_binary_assign_op_helper_SPEC_UNUSED_CV(int (*binary_op)(zval *result, zval *op1, zval *op2 ), zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op_data2, free_op_data1;
 zval **var_ptr;
 zval *value;

 ;
 switch (opline->extended_value) {
  case 136:
   return zend_binary_assign_op_obj_helper_SPEC_UNUSED_CV(binary_op, execute_data );
   break;
  case 147: {
    zval **container = _get_obj_zval_ptr_ptr_unused();

    if ((1<<3) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
     zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
    } else if (__builtin_expect((**container).type == 5, 0)) {
     if ((1<<3) == (1<<2) && !0) {
      zval_addref_p(*(container));
     }
     return zend_binary_assign_op_obj_helper_SPEC_UNUSED_CV(binary_op, execute_data );
    } else {
     zval *dim = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );

     zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)), container, dim, (1<<4), 2 );
     value = _get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, &free_op_data1, 0 );
     var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data->Ts, &free_op_data2 );
    }
   }
   break;
  default:
   value = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );
   var_ptr = ((void *)0);

   break;
 }

 if (__builtin_expect(var_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use assign-op operators with overloaded objects nor string offsets");
 }

 if (__builtin_expect(*var_ptr == &(executor_globals.error_zval), 0)) {
  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }


  ;
  if (opline->extended_value == 147) {
   execute_data->opline++;
  }
  execute_data->opline++; return 0;
 }

 if (!zval_isref_p(*var_ptr)) { do { if (zval_refcount_p(*((var_ptr))) > 1) { zval *new_zv; zval_delref_p(*(var_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(var_ptr))->value; (*new_zv).type = (**(var_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(var_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

 if (__builtin_expect((**var_ptr).type == 5, 0)
    && ((**var_ptr)).value.obj.handlers->get
    && ((**var_ptr)).value.obj.handlers->set) {

  zval *objval = ((**var_ptr)).value.obj.handlers->get(*var_ptr );
  zval_addref_p(objval);
  binary_op(objval, objval, value );
  ((**var_ptr)).value.obj.handlers->set(var_ptr, objval );
  i_zval_ptr_dtor(*(&objval) );
 } else {
  binary_op(*var_ptr, *var_ptr, value );
 }

 if ((!((opline)->result_type & (1<<5)))) {
  zval_addref_p((*var_ptr));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (*var_ptr); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
 }

 if (opline->extended_value == 147) {
  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };
  if (free_op_data2.var) { i_zval_ptr_dtor(*(&free_op_data2.var) ); };

  ;
  execute_data->opline++;
 } else {

  ;
 }
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_ADD_SPEC_UNUSED_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_CV(add_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SUB_SPEC_UNUSED_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_CV(sub_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_MUL_SPEC_UNUSED_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_CV(mul_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_DIV_SPEC_UNUSED_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_CV(div_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_MOD_SPEC_UNUSED_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_CV(mod_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SL_SPEC_UNUSED_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_CV(shift_left_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SR_SPEC_UNUSED_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_CV(shift_right_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_CONCAT_SPEC_UNUSED_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_CV(concat_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_OR_SPEC_UNUSED_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_CV(bitwise_or_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_AND_SPEC_UNUSED_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_CV(bitwise_and_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_UNUSED_CV(bitwise_xor_function, execute_data );
}

static int __attribute__((fastcall)) zend_pre_incdec_property_helper_SPEC_UNUSED_CV(incdec_t incdec_op, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval **object_ptr;
 zval *object;
 zval *property;
 zval **retval;
 int have_get_ptr = 0;

 ;
 object_ptr = _get_obj_zval_ptr_ptr_unused();
 property = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );
 retval = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr;

 if ((1<<3) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot increment/decrement overloaded objects nor string offsets");
 }

 make_real_object(object_ptr );
 object = *object_ptr;

 if (__builtin_expect((*object).type != 5, 0)) {
  zend_error((1<<1L), "Attempt to increment/decrement property of non-object");

  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   *retval = &(executor_globals.uninitialized_zval);
  }

  ;
  execute_data->opline++; return 0;
 }



 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }

 if ((*object).value.obj.handlers->get_property_ptr_ptr) {
  zval **zptr = (*object).value.obj.handlers->get_property_ptr_ptr(object, property, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
  if (zptr != ((void *)0)) {
   if (!zval_isref_p(*zptr)) { do { if (zval_refcount_p(*((zptr))) > 1) { zval *new_zv; zval_delref_p(*(zptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(zptr))->value; (*new_zv).type = (**(zptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(zptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

   have_get_ptr = 1;
   incdec_op(*zptr);
   if ((!((opline)->result_type & (1<<5)))) {
    *retval = *zptr;
    zval_addref_p((*retval));
   }
  }
 }

 if (!have_get_ptr) {
  if ((*object).value.obj.handlers->read_property && (*object).value.obj.handlers->write_property) {
   zval *z = (*object).value.obj.handlers->read_property(object, property, 0, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );

   if (__builtin_expect((*z).type == 5, 0) && (*z).value.obj.handlers->get) {
    zval *value = (*z).value.obj.handlers->get(z );

    if (zval_refcount_p(z) == 0) {
     if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); };
     _zval_dtor((z) );
     do { if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); }; _efree((z) ); } while (0);
    }
    z = value;
   }
   zval_addref_p(z);
   if (!zval_isref_p(*&z)) { do { if (zval_refcount_p(*((&z))) > 1) { zval *new_zv; zval_delref_p(*(&z)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(&z))->value; (*new_zv).type = (**(&z)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(&z) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
   incdec_op(z);
   *retval = z;
   (*object).value.obj.handlers->write_property(object, property, z, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   if ((!((opline)->result_type & (1<<5)))) { zval_addref_p((*retval)); };
   i_zval_ptr_dtor(*(&z) );
  } else {
   zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
   if ((!((opline)->result_type & (1<<5)))) {
    zval_addref_p((&(executor_globals.uninitialized_zval)));
    *retval = &(executor_globals.uninitialized_zval);
   }
  }
 }

 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {

 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_PRE_INC_OBJ_SPEC_UNUSED_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_pre_incdec_property_helper_SPEC_UNUSED_CV(increment_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_PRE_DEC_OBJ_SPEC_UNUSED_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_pre_incdec_property_helper_SPEC_UNUSED_CV(decrement_function, execute_data );
}

static int __attribute__((fastcall)) zend_post_incdec_property_helper_SPEC_UNUSED_CV(incdec_t incdec_op, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval **object_ptr;
 zval *object;
 zval *property;
 zval *retval;
 int have_get_ptr = 0;

 ;
 object_ptr = _get_obj_zval_ptr_ptr_unused();
 property = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );
 retval = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 if ((1<<3) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot increment/decrement overloaded objects nor string offsets");
 }

 make_real_object(object_ptr );
 object = *object_ptr;

 if (__builtin_expect((*object).type != 5, 0)) {
  zend_error((1<<1L), "Attempt to increment/decrement property of non-object");

  { (*retval).type = 0; };

  ;
  execute_data->opline++; return 0;
 }



 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }

 if ((*object).value.obj.handlers->get_property_ptr_ptr) {
  zval **zptr = (*object).value.obj.handlers->get_property_ptr_ptr(object, property, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
  if (zptr != ((void *)0)) {
   have_get_ptr = 1;
   if (!zval_isref_p(*zptr)) { do { if (zval_refcount_p(*((zptr))) > 1) { zval *new_zv; zval_delref_p(*(zptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(zptr))->value; (*new_zv).type = (**(zptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(zptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

   do { (retval)->value = (*zptr)->value; (*retval).type = (**zptr).type; } while (0);
   _zval_copy_ctor((&(*retval)) );

   incdec_op(*zptr);

  }
 }

 if (!have_get_ptr) {
  if ((*object).value.obj.handlers->read_property && (*object).value.obj.handlers->write_property) {
   zval *z = (*object).value.obj.handlers->read_property(object, property, 0, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   zval *z_copy;

   if (__builtin_expect((*z).type == 5, 0) && (*z).value.obj.handlers->get) {
    zval *value = (*z).value.obj.handlers->get(z );

    if (zval_refcount_p(z) == 0) {
     if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); };
     _zval_dtor((z) );
     do { if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); }; _efree((z) ); } while (0);
    }
    z = value;
   }
   do { (retval)->value = (z)->value; (*retval).type = (*z).type; } while (0);
   _zval_copy_ctor((&(*retval)) );
   do { (z_copy) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(z_copy))->u.buffered = ((void *)0); } while (0);
   do { do { (z_copy)->value = (z)->value; (*z_copy).type = (*z).type; } while (0); zval_set_refcount_p(z_copy, 1); zval_unset_isref_p(z_copy); } while (0);
   _zval_copy_ctor((&(*z_copy)) );
   incdec_op(z_copy);
   zval_addref_p(z);
   (*object).value.obj.handlers->write_property(object, property, z_copy, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   i_zval_ptr_dtor(*(&z_copy) );
   i_zval_ptr_dtor(*(&z) );
  } else {
   zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
   { (*retval).type = 0; };
  }
 }

 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {

 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_POST_INC_OBJ_SPEC_UNUSED_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_post_incdec_property_helper_SPEC_UNUSED_CV(increment_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_POST_DEC_OBJ_SPEC_UNUSED_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_post_incdec_property_helper_SPEC_UNUSED_CV(decrement_function, execute_data );
}

static int __attribute__((fastcall)) zend_fetch_property_address_read_helper_SPEC_UNUSED_CV(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *container;

 zval *offset;

 ;
 container = _get_obj_zval_ptr_unused();
 offset = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );

 if (__builtin_expect((*container).type != 5, 0) ||
     __builtin_expect((*container).value.obj.handlers->read_property == ((void *)0), 0)) {
  zend_error((1<<3L), "Trying to get property of non-object");
  zval_addref_p((&(executor_globals.uninitialized_zval)));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);

 } else {
  zval *retval;

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
  }


  retval = (*container).value.obj.handlers->read_property(container, offset, 0, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );

  zval_addref_p((retval));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);

  if (0) {
   i_zval_ptr_dtor(*(&offset) );
  } else {

  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_R_SPEC_UNUSED_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_property_address_read_helper_SPEC_UNUSED_CV(execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_W_SPEC_UNUSED_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *property;
 zval **container;

 ;
 property = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );

 if ((1<<3) == (1<<2) && (opline->extended_value & 0x08000000)) {
  zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr));
  (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr = *(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr;
 }

 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }
 container = _get_obj_zval_ptr_ptr_unused();
 if ((1<<3) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }

 zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)), 1 );
 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {

 }
 if ((1<<3) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }


 if (opline->extended_value & 0x04000000) {
  zval **retval_ptr = (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr;

  zval_delref_p(*(retval_ptr));
  if (!zval_isref_p(*retval_ptr)) { do { if (zval_refcount_p(*((retval_ptr))) > 1) { zval *new_zv; zval_delref_p(*(retval_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval_ptr))->value; (*new_zv).type = (**(retval_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((retval_ptr))); };
  zval_addref_p(*(retval_ptr));
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_RW_SPEC_UNUSED_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *property;
 zval **container;

 ;
 property = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );
 container = _get_obj_zval_ptr_ptr_unused();

 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }
 if ((1<<3) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }
 zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)), 2 );
 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {

 }
 if ((1<<3) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_IS_SPEC_UNUSED_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *container;

 zval *offset;

 ;
 container = _get_obj_zval_ptr_unused();
 offset = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );

 if (__builtin_expect((*container).type != 5, 0) ||
     __builtin_expect((*container).value.obj.handlers->read_property == ((void *)0), 0)) {
  zval_addref_p((&(executor_globals.uninitialized_zval)));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);

 } else {
  zval *retval;

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
  }


  retval = (*container).value.obj.handlers->read_property(container, offset, 3, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );

  zval_addref_p((retval));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);

  if (0) {
   i_zval_ptr_dtor(*(&offset) );
  } else {

  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 if (((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && (opline->extended_value & 0x000fffff) <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[(opline->extended_value & 0x000fffff)-1].pass_by_reference & (1|2)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x1000000|0x2000000))))) {

  zend_free_op free_op1;
  zval *property;
  zval **container;

  ;
  property = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );
  container = _get_obj_zval_ptr_ptr_unused();

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
  }
  if ((1<<3) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
  }
  zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)), 1 );
  if (0) {
   i_zval_ptr_dtor(*(&property) );
  } else {

  }
  if ((1<<3) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
  }

  ;
  execute_data->opline++; return 0;
 } else {
  return zend_fetch_property_address_read_helper_SPEC_UNUSED_CV(execute_data );
 }
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_res;
 zval **container;
 zval *property;

 ;
 container = _get_obj_zval_ptr_ptr_unused();
 property = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );

 if ((1<<3) == (1<<4)) {
  if (container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
 }
 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }
 if ((1<<3) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }
 zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)), 6 );
 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {

 }
 if ((1<<3) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }

 zend_pzval_unlock_func(*(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr, &free_res, 1 );
 if ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr != &(executor_globals.uninitialized_zval_ptr)) {
  if (!zval_isref_p(*(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr)) { do { if (zval_refcount_p(*(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr))->value; (*new_zv).type = (**((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
 }
 zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr));
 if (free_res.var) { i_zval_ptr_dtor(*(&free_res.var) ); };
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_OBJ_SPEC_UNUSED_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval **object_ptr;
 zval *property_name;

 ;
 object_ptr = _get_obj_zval_ptr_ptr_unused();
 property_name = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );

 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property_name))->value; (*_tmp).type = (*(property_name)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property_name) = _tmp; } while (0);
 }
 if ((1<<3) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 zend_assign_to_object((!((opline)->result_type & (1<<5)))?&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr:((void *)0), object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, 136, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
 if (0) {
  i_zval_ptr_dtor(*(&property_name) );
 } else {

 }


 ;
 execute_data->opline++;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ADD_VAR_SPEC_UNUSED_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *str = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;
 zval *var;
 zval var_copy;
 int use_copy = 0;

 ;
 var = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );

 if ((1<<3) == (1<<3)) {

  (*str).value.str.val = ((void *)0);
  (*str).value.str.len = 0;
  (*str).type = 6;

  (str)->refcount__gc = 1; (str)->is_ref__gc = 0;;
 }

 if ((*var).type != 6) {
  zend_make_printable_zval(var, &var_copy, &use_copy);

  if (use_copy) {
   var = &var_copy;
  }
 }
 add_string_to_string(str, str, var);

 if (use_copy) {
  _zval_dtor((var) );
 }







 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_METHOD_CALL_SPEC_UNUSED_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *function_name;
 char *function_name_strval;
 int function_name_strlen;


 ;
 zend_ptr_stack_3_push(&(executor_globals.arg_types_stack), execute_data->fbc, execute_data->object, execute_data->called_scope);

 function_name = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );

 if ((1<<4) != (1<<0) &&
     __builtin_expect((*function_name).type != 6, 0)) {
  zend_error_noreturn((1<<0L), "Method name must be a string");
 }

 function_name_strval = (*function_name).value.str.val;
 function_name_strlen = (*function_name).value.str.len;

 execute_data->object = _get_obj_zval_ptr_unused();

 if (__builtin_expect(execute_data->object != ((void *)0), 1) &&
     __builtin_expect((*execute_data->object).type == 5, 1)) {
  execute_data->called_scope = zend_get_class_entry(&(*execute_data->object) );

  if ((1<<4) != (1<<0) ||
      (execute_data->fbc = (((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] == (execute_data->called_scope)) ? (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] : ((void *)0))) == ((void *)0)) {
      zval *object = execute_data->object;

   if (__builtin_expect((*execute_data->object).value.obj.handlers->get_method == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Object does not support method calls");
   }


   execute_data->fbc = (*execute_data->object).value.obj.handlers->get_method(&execute_data->object, function_name_strval, function_name_strlen, (((1<<4) == (1<<0)) ? (opline->op2.literal + 1) : ((void *)0)) );
   if (__builtin_expect(execute_data->fbc == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Call to undefined method %s::%s()", ((execute_data->object) && (*execute_data->object).type == 5 && (*execute_data->object).value.obj.handlers->get_class_entry != ((void *)0) && (*execute_data->object).value.obj.handlers->get_class_entry(execute_data->object ) ? (*execute_data->object).value.obj.handlers->get_class_entry(execute_data->object )->name : ""), function_name_strval);
   }
   if ((1<<4) == (1<<0) &&
       __builtin_expect((execute_data->fbc->common.fn_flags & 0x200000) == 0, 1) &&
       __builtin_expect(execute_data->object == object, 1)) {
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (execute_data->called_scope); (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] = (execute_data->fbc); } while (0);
   }
  }
 } else {
  zend_error_noreturn((1<<0L), "Call to a member function %s() on a non-object", function_name_strval);
 }

 if ((execute_data->fbc->common.fn_flags & 0x01) != 0) {
  execute_data->object = ((void *)0);
 } else {
  if (!zval_isref_p(execute_data->object)) {
   zval_addref_p(execute_data->object);
  } else {
   zval *this_ptr;
   do { (this_ptr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(this_ptr))->u.buffered = ((void *)0); } while (0);
   do { do { (this_ptr)->value = (execute_data->object)->value; (*this_ptr).type = (*execute_data->object).type; } while (0); zval_set_refcount_p(this_ptr, 1); zval_unset_isref_p(this_ptr); } while (0);
   _zval_copy_ctor((this_ptr) );
   execute_data->object = this_ptr;
  }
 }


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_ARRAY_SPEC_UNUSED_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 _array_init((&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var), 0 );
 if ((1<<3) == (1<<3)) {
  execute_data->opline++; return 0;




 }
}

static int __attribute__((fastcall)) ZEND_UNSET_DIM_SPEC_UNUSED_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval **container;
 zval *offset;
 ulong hval;

 ;
 container = _get_obj_zval_ptr_ptr_unused();
 offset = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );

 if ((1<<3) != (1<<2) || container) {
  if ((1<<3) == (1<<4) && container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
  switch ((**container).type) {
   case 4: {
    HashTable *ht = (**container).value.ht;

    switch ((*offset).type) {
     case 2:
      hval = zend_dval_to_lval((*offset).value.dval);
      goto num_index_dim;
     case 7:
     case 3:
     case 1:
num_index_dim:
      hval = (*offset).value.lval;
      zend_hash_del_key_or_index(ht, ((void *)0), 0, hval, 1);
      break;
     case 6:
      if ((1<<4) == (1<<4) || (1<<4) == (1<<2)) {
       zval_addref_p(offset);
      }
      if ((1<<4) == (1<<0)) {
       hval = (((zend_literal*)(offset))->hash_value);
      } else {
       do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index_dim; } } } while (0);
       if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
        hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
       } else {
        hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
       }
      }
      if (ht == &(executor_globals.symbol_table)) {
       zend_delete_global_variable_ex(offset->value.str.val, offset->value.str.len, hval );
      } else {
       zend_hash_del_key_or_index(ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, 2);
      }
      if ((1<<4) == (1<<4) || (1<<4) == (1<<2)) {
       i_zval_ptr_dtor(*(&offset) );
      }
      break;
     case 0:
      zend_hash_del_key_or_index(ht, "", sizeof(""), 0, 0);
      break;
     default:
      zend_error((1<<1L), "Illegal offset type in unset");
      break;
    }

    break;
   }
   case 5:
    if (__builtin_expect((**container).value.obj.handlers->unset_dimension == ((void *)0), 0)) {
     zend_error_noreturn((1<<0L), "Cannot use object as array");
    }
    if (0) {
     do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
    }
    (**container).value.obj.handlers->unset_dimension(*container, offset );
    if (0) {
     i_zval_ptr_dtor(*(&offset) );
    } else {

    }
    break;
   case 6:
    zend_error_noreturn((1<<0L), "Cannot unset string offsets");
    return 0;
   default:

    break;
  }
 } else {

 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_UNSET_OBJ_SPEC_UNUSED_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval **container;
 zval *offset;

 ;
 container = _get_obj_zval_ptr_ptr_unused();
 offset = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );

 if ((1<<3) != (1<<2) || container) {
  if ((1<<3) == (1<<4) && container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
  if ((**container).type == 5) {
   if (0) {
    do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
   }
   if ((**container).value.obj.handlers->unset_property) {
    (**container).value.obj.handlers->unset_property(*container, offset, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   } else {
    zend_error((1<<3L), "Trying to unset property of non-object");
   }
   if (0) {
    i_zval_ptr_dtor(*(&offset) );
   } else {

   }
  } else {

  }
 } else {

 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_CV(int prop_dim, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval **container;
 zval **value = ((void *)0);
 int result = 0;
 ulong hval;
 zval *offset;

 ;
 container = _get_obj_zval_ptr_ptr_unused();

 offset = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );

 if ((**container).type == 4 && !prop_dim) {
  HashTable *ht;
  int isset = 0;

  ht = (**container).value.ht;

  switch ((*offset).type) {
   case 2:
    hval = zend_dval_to_lval((*offset).value.dval);
    goto num_index_prop;
   case 7:
   case 3:
   case 1:
    hval = (*offset).value.lval;
num_index_prop:
    if (zend_hash_index_find(ht, hval, (void **) &value) == 0) {
     isset = 1;
    }
    break;
   case 6:
    if ((1<<4) == (1<<0)) {
     hval = (((zend_literal*)(offset))->hash_value);
    } else {
     if (!prop_dim) {
      do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index_prop; } } } while (0);
     }
     if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
      hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
     } else {
      hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
     }
    }
    if (zend_hash_quick_find(ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, (void **) &value) == 0) {
     isset = 1;
    }
    break;
   case 0:
    if (zend_hash_find(ht, "", sizeof(""), (void **) &value) == 0) {
     isset = 1;
    }
    break;
   default:
    zend_error((1<<1L), "Illegal offset type in isset or empty");
    break;
  }

  if (opline->extended_value & 0x02000000) {
   if (isset && (**value).type == 0) {
    result = 0;
   } else {
    result = isset;
   }
  } else {
   if (!isset || !i_zend_is_true(*value)) {
    result = 0;
   } else {
    result = 1;
   }
  }

 } else if ((**container).type == 5) {
  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
  }
  if (prop_dim) {
   if ((**container).value.obj.handlers->has_property) {
    result = (**container).value.obj.handlers->has_property(*container, offset, (opline->extended_value & 0x01000000) != 0, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   } else {
    zend_error((1<<3L), "Trying to check property of non-object");
    result = 0;
   }
  } else {
   if ((**container).value.obj.handlers->has_dimension) {
    result = (**container).value.obj.handlers->has_dimension(*container, offset, (opline->extended_value & 0x01000000) != 0 );
   } else {
    zend_error((1<<3L), "Trying to check element of non-array");
    result = 0;
   }
  }
  if (0) {
   i_zval_ptr_dtor(*(&offset) );
  } else {

  }
 } else if ((*container)->type == 6 && !prop_dim) {
  zval tmp;

  if ((*offset).type != 1) {
   do { (&tmp)->value = (offset)->value; (*&tmp).type = (*offset).type; } while (0);
   _zval_copy_ctor((&tmp) );
   convert_to_long(&tmp);
   offset = &tmp;
  }
  if ((*offset).type == 1) {
   if (opline->extended_value & 0x02000000) {
    if (offset->value.lval >= 0 && offset->value.lval < (**container).value.str.len) {
     result = 1;
    }
   } else {
    if (offset->value.lval >= 0 && offset->value.lval < (**container).value.str.len && (**container).value.str.val[offset->value.lval] != '0') {
     result = 1;
    }
   }
  }

 } else {

 }

 ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).type = 3;
 if (opline->extended_value & 0x02000000) {
  ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.lval = result;
 } else {
  ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.lval = !result;
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_CV(0, execute_data );
}

static int __attribute__((fastcall)) ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_CV(1, execute_data );
}

static int __attribute__((fastcall)) ZEND_BW_NOT_SPEC_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 bitwise_not_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BOOL_NOT_SPEC_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 boolean_not_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_PRE_INC_SPEC_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval **var_ptr;

 ;
 var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var );

 if ((1<<4) == (1<<2) && __builtin_expect(var_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot increment/decrement overloaded objects nor string offsets");
 }
 if ((1<<4) == (1<<2) && __builtin_expect(*var_ptr == &(executor_globals.error_zval), 0)) {
  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }

  ;
  execute_data->opline++; return 0;
 }

 if (!zval_isref_p(*var_ptr)) { do { if (zval_refcount_p(*((var_ptr))) > 1) { zval *new_zv; zval_delref_p(*(var_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(var_ptr))->value; (*new_zv).type = (**(var_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(var_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

 if (__builtin_expect((**var_ptr).type == 5, 0)
    && ((**var_ptr)).value.obj.handlers->get
    && ((**var_ptr)).value.obj.handlers->set) {

  zval *val = ((**var_ptr)).value.obj.handlers->get(*var_ptr );
  zval_addref_p(val);
  increment_function(val);
  ((**var_ptr)).value.obj.handlers->set(var_ptr, val );
  i_zval_ptr_dtor(*(&val) );
 } else {
  increment_function(*var_ptr);
 }

 if ((!((opline)->result_type & (1<<5)))) {
  zval_addref_p((*var_ptr));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (*var_ptr); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_PRE_DEC_SPEC_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval **var_ptr;

 ;
 var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var );

 if ((1<<4) == (1<<2) && __builtin_expect(var_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot increment/decrement overloaded objects nor string offsets");
 }
 if ((1<<4) == (1<<2) && __builtin_expect(*var_ptr == &(executor_globals.error_zval), 0)) {
  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }

  ;
  execute_data->opline++; return 0;
 }

 if (!zval_isref_p(*var_ptr)) { do { if (zval_refcount_p(*((var_ptr))) > 1) { zval *new_zv; zval_delref_p(*(var_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(var_ptr))->value; (*new_zv).type = (**(var_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(var_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

 if (__builtin_expect((**var_ptr).type == 5, 0)
    && ((**var_ptr)).value.obj.handlers->get
    && ((**var_ptr)).value.obj.handlers->set) {

  zval *val = ((**var_ptr)).value.obj.handlers->get(*var_ptr );
  zval_addref_p(val);
  decrement_function(val);
  ((**var_ptr)).value.obj.handlers->set(var_ptr, val );
  i_zval_ptr_dtor(*(&val) );
 } else {
  decrement_function(*var_ptr);
 }

 if ((!((opline)->result_type & (1<<5)))) {
  zval_addref_p((*var_ptr));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (*var_ptr); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_POST_INC_SPEC_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval **var_ptr, *retval;

 ;
 var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var );

 if ((1<<4) == (1<<2) && __builtin_expect(var_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot increment/decrement overloaded objects nor string offsets");
 }
 if ((1<<4) == (1<<2) && __builtin_expect(*var_ptr == &(executor_globals.error_zval), 0)) {
  { (*&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).type = 0; };

  ;
  execute_data->opline++; return 0;
 }

 retval = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;
 do { (retval)->value = (*var_ptr)->value; (*retval).type = (**var_ptr).type; } while (0);
 _zval_copy_ctor((&(*retval)) );

 if (!zval_isref_p(*var_ptr)) { do { if (zval_refcount_p(*((var_ptr))) > 1) { zval *new_zv; zval_delref_p(*(var_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(var_ptr))->value; (*new_zv).type = (**(var_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(var_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

 if (__builtin_expect((**var_ptr).type == 5, 0)
    && ((**var_ptr)).value.obj.handlers->get
    && ((**var_ptr)).value.obj.handlers->set) {

  zval *val = ((**var_ptr)).value.obj.handlers->get(*var_ptr );
  zval_addref_p(val);
  increment_function(val);
  ((**var_ptr)).value.obj.handlers->set(var_ptr, val );
  i_zval_ptr_dtor(*(&val) );
 } else {
  increment_function(*var_ptr);
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_POST_DEC_SPEC_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval **var_ptr, *retval;

 ;
 var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var );

 if ((1<<4) == (1<<2) && __builtin_expect(var_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot increment/decrement overloaded objects nor string offsets");
 }
 if ((1<<4) == (1<<2) && __builtin_expect(*var_ptr == &(executor_globals.error_zval), 0)) {
  { (*&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).type = 0; };

  ;
  execute_data->opline++; return 0;
 }

 retval = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;
 do { (retval)->value = (*var_ptr)->value; (*retval).type = (**var_ptr).type; } while (0);
 _zval_copy_ctor((&(*retval)) );

 if (!zval_isref_p(*var_ptr)) { do { if (zval_refcount_p(*((var_ptr))) > 1) { zval *new_zv; zval_delref_p(*(var_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(var_ptr))->value; (*new_zv).type = (**(var_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(var_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

 if (__builtin_expect((**var_ptr).type == 5, 0)
    && ((**var_ptr)).value.obj.handlers->get
    && ((**var_ptr)).value.obj.handlers->set) {

  zval *val = ((**var_ptr)).value.obj.handlers->get(*var_ptr );
  zval_addref_p(val);
  decrement_function(val);
  ((**var_ptr)).value.obj.handlers->set(var_ptr, val );
  i_zval_ptr_dtor(*(&val) );
 } else {
  decrement_function(*var_ptr);
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ECHO_SPEC_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval z_copy;
 zval *z;

 ;
 z = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );

 if ((1<<4) != (1<<0) &&
     __builtin_expect((*z).type == 5, 0) &&
     (*z).value.obj.handlers->get_method != ((void *)0) &&
  zend_std_cast_object_tostring(z, &z_copy, 6 ) == 0) {
  zend_print_variable(&z_copy);
  _zval_dtor((&z_copy) );
 } else {
  zend_print_variable(z);
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_PRINT_SPEC_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = 1; (*__z).type = 1; };
 return ZEND_ECHO_SPEC_CV_HANDLER(execute_data );
}

static int __attribute__((fastcall)) ZEND_JMPZ_SPEC_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *val;
 int ret;

 ;
 val = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );

 if ((1<<4) == (1<<1) && __builtin_expect((*val).type == 3, 1)) {
  ret = (*val).value.lval;
 } else {
  ret = i_zend_is_true(val);

  if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
   ; return 0;
  }
 }
 if (!ret) {



  execute_data->opline = opline->op2.jmp_addr;
  return 0;
 }

 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_JMPNZ_SPEC_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *val;
 int ret;

 ;
 val = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );

 if ((1<<4) == (1<<1) && __builtin_expect((*val).type == 3, 1)) {
  ret = (*val).value.lval;
 } else {
  ret = i_zend_is_true(val);

  if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
   ; return 0;
  }
 }
 if (ret) {



  execute_data->opline = opline->op2.jmp_addr;
  return 0;
 }

 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_JMPZNZ_SPEC_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *val;
 int retval;

 ;
 val = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );

 if ((1<<4) == (1<<1) && __builtin_expect((*val).type == 3, 1)) {
  retval = (*val).value.lval;
 } else {
  retval = i_zend_is_true(val);

  if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
   ; return 0;
  }
 }
 if (__builtin_expect(retval != 0, 1)) {



  execute_data->opline = &execute_data->op_array->opcodes[opline->extended_value];
  return 0;
 } else {



  execute_data->opline = &execute_data->op_array->opcodes[opline->op2.opline_num];
  return 0;
 }
}

static int __attribute__((fastcall)) ZEND_JMPZ_EX_SPEC_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *val;
 int retval;

 ;
 val = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );

 if ((1<<4) == (1<<1) && __builtin_expect((*val).type == 3, 1)) {
  retval = (*val).value.lval;
 } else {
  retval = i_zend_is_true(val);

  if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
   ; return 0;
  }
 }
 ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.lval = retval;
 ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).type = 3;
 if (!retval) {



  execute_data->opline = opline->op2.jmp_addr;
  return 0;
 }
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_JMPNZ_EX_SPEC_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *val;
 int retval;

 ;
 val = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );

 if ((1<<4) == (1<<1) && __builtin_expect((*val).type == 3, 1)) {
  retval = (*val).value.lval;
 } else {
  retval = i_zend_is_true(val);

  if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
   ; return 0;
  }
 }
 ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.lval = retval;
 ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).type = 3;
 if (retval) {



  execute_data->opline = opline->op2.jmp_addr;
  return 0;
 }
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_RETURN_SPEC_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *retval_ptr;


 ;
 retval_ptr = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );

 if (!(executor_globals.return_value_ptr_ptr)) {
  if ((1<<4) == (1<<1)) {

  }
 } else if (!0) {
  if ((1<<4) == (1<<0) ||
      (zval_isref_p(retval_ptr) && zval_refcount_p(retval_ptr) > 0)) {
   zval *ret;

   do { (ret) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(ret))->u.buffered = ((void *)0); } while (0);
   do { do { (ret)->value = (retval_ptr)->value; (*ret).type = (*retval_ptr).type; } while (0); zval_set_refcount_p(ret, 1); zval_unset_isref_p(ret); } while (0);
   _zval_copy_ctor((ret) );
   *(executor_globals.return_value_ptr_ptr) = ret;
  } else if (((1<<4) == (1<<4) || (1<<4) == (1<<2)) &&
             retval_ptr == &(executor_globals.uninitialized_zval)) {
   zval *ret;

   do { (ret) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(ret))->u.buffered = ((void *)0); } while (0); *ret = zval_used_for_init;;;
   *(executor_globals.return_value_ptr_ptr) = ret;
  } else {
   *(executor_globals.return_value_ptr_ptr) = retval_ptr;
   zval_addref_p(retval_ptr);
  }
 } else {
  zval *ret;

  do { (ret) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(ret))->u.buffered = ((void *)0); } while (0);
  do { do { (ret)->value = (retval_ptr)->value; (*ret).type = (*retval_ptr).type; } while (0); zval_set_refcount_p(ret, 1); zval_unset_isref_p(ret); } while (0);
  *(executor_globals.return_value_ptr_ptr) = ret;
 }

 return zend_leave_helper_SPEC(execute_data );
}

static int __attribute__((fastcall)) ZEND_RETURN_BY_REF_SPEC_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *retval_ptr;
 zval **retval_ptr_ptr;


 ;

 do {
  if ((1<<4) == (1<<0) || (1<<4) == (1<<1)) {

   zend_error((1<<3L), "Only variable references should be returned by reference");

   retval_ptr = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );
   if (!(executor_globals.return_value_ptr_ptr)) {
    if ((1<<4) == (1<<1)) {

    }
   } else if (!0) {
    zval *ret;

    do { (ret) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(ret))->u.buffered = ((void *)0); } while (0);
    do { do { (ret)->value = (retval_ptr)->value; (*ret).type = (*retval_ptr).type; } while (0); zval_set_refcount_p(ret, 1); zval_unset_isref_p(ret); } while (0);
    _zval_copy_ctor((ret) );
    *(executor_globals.return_value_ptr_ptr) = ret;
   } else {
    zval *ret;

    do { (ret) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(ret))->u.buffered = ((void *)0); } while (0);
    do { do { (ret)->value = (retval_ptr)->value; (*ret).type = (*retval_ptr).type; } while (0); zval_set_refcount_p(ret, 1); zval_unset_isref_p(ret); } while (0);
    *(executor_globals.return_value_ptr_ptr) = ret;
   }
   break;
  }

  retval_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var );

  if ((1<<4) == (1<<2) && __builtin_expect(retval_ptr_ptr == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot return string offsets by reference");
  }

  if ((1<<4) == (1<<2) && !zval_isref_p(*(retval_ptr_ptr))) {
   if (opline->extended_value == 1<<0 &&
       (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.fcall_returned_reference) {
   } else if ((*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr == &(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr) {
    zend_error((1<<3L), "Only variable references should be returned by reference");
    if ((executor_globals.return_value_ptr_ptr)) {
     retval_ptr = *retval_ptr_ptr;
     *(executor_globals.return_value_ptr_ptr) = retval_ptr;
     zval_addref_p(retval_ptr);
    }
    break;
   }
  }

  if ((executor_globals.return_value_ptr_ptr)) {
   if (!zval_isref_p(*retval_ptr_ptr)) { do { if (zval_refcount_p(*((retval_ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(retval_ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval_ptr_ptr))->value; (*new_zv).type = (**(retval_ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval_ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((retval_ptr_ptr))); };
   zval_addref_p(*(retval_ptr_ptr));

   *(executor_globals.return_value_ptr_ptr) = *retval_ptr_ptr;
  }
 } while (0);

 return zend_leave_helper_SPEC(execute_data );
}

static int __attribute__((fastcall)) ZEND_THROW_SPEC_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *value;
 zval *exception;


 ;
 value = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );

 if ((1<<4) == (1<<0) || __builtin_expect((*value).type != 5, 0)) {
  zend_error_noreturn((1<<0L), "Can only throw objects");
 }
 zend_exception_save();

 do { (exception) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(exception))->u.buffered = ((void *)0); } while (0);
 do { do { (exception)->value = (value)->value; (*exception).type = (*value).type; } while (0); zval_set_refcount_p(exception, 1); zval_unset_isref_p(exception); } while (0);
 if (!0) {
  _zval_copy_ctor((exception) );
 }

 zend_throw_exception_object(exception );
 zend_exception_restore();

 ; return 0;
}

static int __attribute__((fastcall)) zend_send_by_var_helper_SPEC_CV(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *varptr;

 varptr = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );

 if (varptr == &(executor_globals.uninitialized_zval)) {
  do { (varptr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(varptr))->u.buffered = ((void *)0); } while (0);
  *varptr = zval_used_for_init;;
  zval_set_refcount_p(varptr, 0);
 } else if (zval_isref_p(varptr)) {
  zval *original_var = varptr;

  do { (varptr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(varptr))->u.buffered = ((void *)0); } while (0);
  do { (varptr)->value = (original_var)->value; (*varptr).type = (*original_var).type; } while (0);
  zval_unset_isref_p(varptr);
  zval_set_refcount_p(varptr, 0);
  _zval_copy_ctor((varptr) );
 }
 zval_addref_p(varptr);
 zend_vm_stack_push(varptr );
 ;

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SEND_VAR_NO_REF_SPEC_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *varptr;

 ;
 if (opline->extended_value & (1<<1)) {
  if (!(opline->extended_value & (1<<0))) {
   return zend_send_by_var_helper_SPEC_CV(execute_data );
  }
 } else if (!((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && opline->op2.opline_num <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[opline->op2.opline_num-1].pass_by_reference & (1|2)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x1000000|0x2000000))))) {
  return zend_send_by_var_helper_SPEC_CV(execute_data );
 }

 if ((1<<4) == (1<<2) &&
  (opline->extended_value & (1<<2)) &&
  (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.fcall_returned_reference &&
  (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr) {
  varptr = (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr;
  zend_pzval_unlock_func(varptr, &free_op1, 0 );
 } else {
  varptr = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );
 }
 if ((!(opline->extended_value & (1<<2)) ||
      (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.fcall_returned_reference) &&
     varptr != &(executor_globals.uninitialized_zval) &&
     (zval_isref_p(varptr) ||
      (zval_refcount_p(varptr) == 1 && ((1<<4) == (1<<4) || free_op1.var)))) {
  zval_set_isref_p(varptr);
  zval_addref_p(varptr);
  zend_vm_stack_push(varptr );
 } else {
  zval *valptr;

  if ((opline->extended_value & (1<<1)) ?
   !(opline->extended_value & (1<<3)) :
   !((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && opline->op2.opline_num <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[opline->op2.opline_num-1].pass_by_reference & (2)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x2000000))))) {
   zend_error((1<<11L), "Only variables should be passed by reference");
  }
  do { (valptr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(valptr))->u.buffered = ((void *)0); } while (0);
  do { do { (valptr)->value = (varptr)->value; (*valptr).type = (*varptr).type; } while (0); zval_set_refcount_p(valptr, 1); zval_unset_isref_p(valptr); } while (0);
  if (!0) {
   _zval_copy_ctor((valptr) );
  }
  zend_vm_stack_push(valptr );
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SEND_REF_SPEC_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval **varptr_ptr;
 zval *varptr;

 ;
 varptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var );

 if ((1<<4) == (1<<2) && __builtin_expect(varptr_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Only variables can be passed by reference");
 }

 if ((1<<4) == (1<<2) && __builtin_expect(*varptr_ptr == &(executor_globals.error_zval), 0)) {
  zval_delref_p(*(varptr_ptr));
  do { (*varptr_ptr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(*varptr_ptr))->u.buffered = ((void *)0); } while (0);
  **varptr_ptr = zval_used_for_init;;
  zval_set_refcount_p(*(varptr_ptr), 0);
 }

 if (execute_data->function_state.function->type == 1 && !((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && opline->op2.opline_num <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[opline->op2.opline_num-1].pass_by_reference & (1|2)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x1000000|0x2000000))))) {
  return zend_send_by_var_helper_SPEC_CV(execute_data );
 }

 if (!zval_isref_p(*varptr_ptr)) { do { if (zval_refcount_p(*((varptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(varptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(varptr_ptr))->value; (*new_zv).type = (**(varptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(varptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((varptr_ptr))); };
 varptr = *varptr_ptr;
 zval_addref_p(varptr);
 zend_vm_stack_push(varptr );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SEND_VAR_SPEC_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 if ((opline->extended_value == 61)
  && ((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && opline->op2.opline_num <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[opline->op2.opline_num-1].pass_by_reference & (1|2)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x1000000|0x2000000))))) {
  return ZEND_SEND_REF_SPEC_CV_HANDLER(execute_data );
 }
 ;
 return zend_send_by_var_helper_SPEC_CV(execute_data );
}

static int __attribute__((fastcall)) ZEND_BOOL_SPEC_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *retval = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;

 do { zval *__z = (retval); (*__z).value.lval = ((i_zend_is_true(_get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ))) != 0); (*__z).type = 3; } while (0);

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_CLONE_SPEC_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *obj;
 zend_class_entry *ce;
 zend_function *clone;
 zend_object_clone_obj_t clone_call;

 ;
 obj = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );

 if ((1<<4) == (1<<0) ||
     __builtin_expect((*obj).type != 5, 0)) {
  zend_error_noreturn((1<<0L), "__clone method called on non-object");
 }

 ce = zend_get_class_entry(&(*obj) );
 clone = ce ? ce->clone : ((void *)0);
 clone_call = (*obj).value.obj.handlers->clone_obj;
 if (__builtin_expect(clone_call == ((void *)0), 0)) {
  if (ce) {
   zend_error_noreturn((1<<0L), "Trying to clone an uncloneable object of class %s", ce->name);
  } else {
   zend_error_noreturn((1<<0L), "Trying to clone an uncloneable object");
  }
 }

 if (ce && clone) {
  if (clone->op_array.fn_flags & 0x400) {


   if (__builtin_expect(ce != (executor_globals.scope), 0)) {
    zend_error_noreturn((1<<0L), "Call to private %s::__clone() from context '%s'", ce->name, (executor_globals.scope) ? (executor_globals.scope)->name : "");
   }
  } else if ((clone->common.fn_flags & 0x200)) {


   if (__builtin_expect(!zend_check_protected(clone->common.scope, (executor_globals.scope)), 0)) {
    zend_error_noreturn((1<<0L), "Call to protected %s::__clone() from context '%s'", ce->name, (executor_globals.scope) ? (executor_globals.scope)->name : "");
   }
  }
 }

 if (__builtin_expect((executor_globals.exception) == ((void *)0), 1)) {
  zval *retval;

  do { (retval) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(retval))->u.buffered = ((void *)0); } while (0);
  (*retval).value.obj = clone_call(obj );
  (*retval).type = 5;
  zval_set_refcount_p(retval, 1);
  zval_set_isref_p(retval);
  if (!(!((opline)->result_type & (1<<5))) || __builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
   i_zval_ptr_dtor(*(&retval) );
  } else {
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_CAST_SPEC_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *expr;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 expr = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );

 if (opline->extended_value != 6) {
  do { (result)->value = (expr)->value; (*result).type = (*expr).type; } while (0);
  if (!0) {
   _zval_copy_ctor((&(*result)) );
  }
 }
 switch (opline->extended_value) {
  case 0:
   convert_to_null(result);
   break;
  case 3:
   convert_to_boolean(result);
   break;
  case 1:
   convert_to_long(result);
   break;
  case 2:
   convert_to_double(result);
   break;
  case 6: {
   zval var_copy;
   int use_copy;

   zend_make_printable_zval(expr, &var_copy, &use_copy);
   if (use_copy) {
    do { (result)->value = (&var_copy)->value; (*result).type = (*&var_copy).type; } while (0);
    if (0) {

    }
   } else {
    do { (result)->value = (expr)->value; (*result).type = (*expr).type; } while (0);
    if (!0) {
     _zval_copy_ctor((&(*result)) );
    }
   }
   break;
  }
  case 4:
   convert_to_array(result);
   break;
  case 5:
   convert_to_object(result);
   break;
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INCLUDE_OR_EVAL_SPEC_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_op_array *new_op_array=((void *)0);

 zval *inc_filename;
 zval tmp_inc_filename;
 zend_bool failure_retval=0;

 ;
 inc_filename = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );

 if (inc_filename->type!=6) {
  do { (&tmp_inc_filename)->value = (inc_filename)->value; (*&tmp_inc_filename).type = (*inc_filename).type; } while (0);
  _zval_copy_ctor((&tmp_inc_filename) );
  if ((&tmp_inc_filename)->type != 6) { _convert_to_string((&tmp_inc_filename) ); };
  inc_filename = &tmp_inc_filename;
 }

 switch (opline->extended_value) {
  case (1<<2):
  case (1<<4): {
    zend_file_handle file_handle;
    char *resolved_path;

    resolved_path = zend_resolve_path((*inc_filename).value.str.val, (*inc_filename).value.str.len );
    if (resolved_path) {
     failure_retval = zend_hash_exists(&(executor_globals.included_files), resolved_path, strlen(resolved_path)+1);
    } else {
     resolved_path = (*inc_filename).value.str.val;
    }

    if (failure_retval) {

    } else if (0 == zend_stream_open(resolved_path, &file_handle )) {

     if (!file_handle.opened_path) {
      file_handle.opened_path = _estrdup((resolved_path) );
     }

     if (zend_hash_add_empty_element(&(executor_globals.included_files), file_handle.opened_path, strlen(file_handle.opened_path)+1)==0) {
      new_op_array = zend_compile_file(&file_handle, (opline->extended_value==(1<<2)?(1<<1):(1<<3)) );
      zend_destroy_file_handle(&file_handle );
     } else {
      zend_file_handle_dtor(&file_handle );
      failure_retval=1;
     }
    } else {
     if (opline->extended_value == (1<<2)) {
      zend_message_dispatcher(1L, (*inc_filename).value.str.val );
     } else {
      zend_message_dispatcher(2L, (*inc_filename).value.str.val );
     }
    }
    if (resolved_path != (*inc_filename).value.str.val) {
     _efree((resolved_path) );
    }
   }
   break;
  case (1<<1):
  case (1<<3):
   new_op_array = compile_filename(opline->extended_value, inc_filename );
   break;
  case (1<<0): {
    char *eval_desc = zend_make_compiled_string_description("eval()'d code" );

    new_op_array = zend_compile_string(inc_filename, eval_desc );
    _efree((eval_desc) );
   }
   break;
 
 }
 if (inc_filename==&tmp_inc_filename) {
  _zval_dtor((&tmp_inc_filename) );
 }

 if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
  ; return 0;
 } else if (__builtin_expect(new_op_array != ((void *)0), 1)) {
  execute_data->original_return_value = (executor_globals.return_value_ptr_ptr);
  (executor_globals.active_op_array) = new_op_array;
  if ((!((opline)->result_type & (1<<5)))) {
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = ((void *)0);
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr;
   (executor_globals.return_value_ptr_ptr) = (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr;
  } else {
   (executor_globals.return_value_ptr_ptr) = ((void *)0);
  }

  execute_data->current_object = execute_data->object;

  execute_data->function_state.function = (zend_function *) new_op_array;
  execute_data->object = ((void *)0);

  if (!(executor_globals.active_symbol_table)) {
   zend_rebuild_symbol_table();
  }

  if (__builtin_expect(zend_execute == execute, 1)) {
   return 2;
  } else {
   zend_execute(new_op_array );
  }

  execute_data->function_state.function = (zend_function *) execute_data->op_array;
  execute_data->object = execute_data->current_object;

  (executor_globals.opline_ptr) = &execute_data->opline;
  (executor_globals.active_op_array) = execute_data->op_array;
  (executor_globals.return_value_ptr_ptr) = execute_data->original_return_value;
  destroy_op_array(new_op_array );
  _efree((new_op_array) );
  if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
   zend_throw_exception_internal(((void *)0) );
   ; return 0;
  } else if ((!((opline)->result_type & (1<<5)))) {
   if (!(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr) {
    zval *retval;

    do { (retval) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(retval))->u.buffered = ((void *)0); } while (0);
    do { zval *__z = (retval); (*__z).value.lval = ((1) != 0); (*__z).type = 3; } while (0);
    (retval)->refcount__gc = 1; (retval)->is_ref__gc = 0;;
    (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = retval;
   }
  }

 } else if ((!((opline)->result_type & (1<<5)))) {
  zval *retval;

  do { (retval) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(retval))->u.buffered = ((void *)0); } while (0);
  do { zval *__z = (retval); (*__z).value.lval = ((failure_retval) != 0); (*__z).type = 3; } while (0);
  (retval)->refcount__gc = 1; (retval)->is_ref__gc = 0;;
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
 }
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FE_RESET_SPEC_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *array_ptr, **array_ptr_ptr;
 HashTable *fe_ht;
 zend_object_iterator *iter = ((void *)0);
 zend_class_entry *ce = ((void *)0);
 zend_bool is_empty = 0;

 ;

 if (((1<<4) == (1<<4) || (1<<4) == (1<<2)) &&
     (opline->extended_value & (1<<0))) {
  array_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );
  if (array_ptr_ptr == ((void *)0) || array_ptr_ptr == &(executor_globals.uninitialized_zval_ptr)) {
   do { (array_ptr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(array_ptr))->u.buffered = ((void *)0); } while (0); (array_ptr)->refcount__gc = 1; (array_ptr)->is_ref__gc = 0;;;
   { (*array_ptr).type = 0; };
  } else if ((**array_ptr_ptr).type == 5) {
   if((**array_ptr_ptr).value.obj.handlers->get_class_entry == ((void *)0)) {
    zend_error((1<<1L), "foreach() cannot iterate over objects without PHP class");
    if (__builtin_expect(!(executor_globals.exception), 1)) { execute_data->opline = execute_data->op_array->opcodes+opline->op2.opline_num; } else { ; } return 0;
   }

   ce = zend_get_class_entry(&(**array_ptr_ptr) );
   if (!ce || ce->get_iterator == ((void *)0)) {
    if (!zval_isref_p(*array_ptr_ptr)) { do { if (zval_refcount_p(*((array_ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(array_ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(array_ptr_ptr))->value; (*new_zv).type = (**(array_ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(array_ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
    zval_addref_p(*(array_ptr_ptr));
   }
   array_ptr = *array_ptr_ptr;
  } else {
   if ((**array_ptr_ptr).type == 4) {
    if (!zval_isref_p(*array_ptr_ptr)) { do { if (zval_refcount_p(*((array_ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(array_ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(array_ptr_ptr))->value; (*new_zv).type = (**(array_ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(array_ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
    if (opline->extended_value & 1) {
     zval_set_isref_p(*(array_ptr_ptr));
    }
   }
   array_ptr = *array_ptr_ptr;
   zval_addref_p(array_ptr);
  }
 } else {
  array_ptr = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );
  if (0) {
   zval *tmp;

   do { (tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(tmp))->u.buffered = ((void *)0); } while (0);
   do { do { (tmp)->value = (array_ptr)->value; (*tmp).type = (*array_ptr).type; } while (0); zval_set_refcount_p(tmp, 1); zval_unset_isref_p(tmp); } while (0);
   array_ptr = tmp;
   if ((*array_ptr).type == 5) {
    ce = zend_get_class_entry(&(*array_ptr) );
    if (ce && ce->get_iterator) {
     zval_delref_p(array_ptr);
    }
   }
  } else if ((*array_ptr).type == 5) {
   ce = zend_get_class_entry(&(*array_ptr) );
   if (!ce || !ce->get_iterator) {
    zval_addref_p(array_ptr);
   }
  } else if ((1<<4) == (1<<0) ||
             (((1<<4) == (1<<4) || (1<<4) == (1<<2)) &&
              !zval_isref_p(array_ptr) &&
              zval_refcount_p(array_ptr) > 1)) {
   zval *tmp;

   do { (tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(tmp))->u.buffered = ((void *)0); } while (0);
   do { do { (tmp)->value = (array_ptr)->value; (*tmp).type = (*array_ptr).type; } while (0); zval_set_refcount_p(tmp, 1); zval_unset_isref_p(tmp); } while (0);
   _zval_copy_ctor((tmp) );
   array_ptr = tmp;
  } else {
   zval_addref_p(array_ptr);
  }
 }

 if (ce && ce->get_iterator) {
  iter = ce->get_iterator(ce, array_ptr, opline->extended_value & (1<<1) );

  if (iter && __builtin_expect((executor_globals.exception) == ((void *)0), 1)) {
   array_ptr = zend_iterator_wrap(iter );
  } else {

   if (!(executor_globals.exception)) {
    zend_throw_exception_ex(((void *)0), 0 , "Object of type %s did not create an Iterator", ce->name);
   }
   zend_throw_exception_internal(((void *)0) );
   ; return 0;
  }
 }

 (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).fe.ptr = array_ptr;

 if (iter) {
  iter->index = 0;
  if (iter->funcs->rewind) {
   iter->funcs->rewind(iter );
   if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
    i_zval_ptr_dtor(*(&array_ptr) );

    ; return 0;
   }
  }
  is_empty = iter->funcs->valid(iter ) != 0;
  if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
   i_zval_ptr_dtor(*(&array_ptr) );

   ; return 0;
  }
  iter->index = -1;
 } else if ((fe_ht = ((*array_ptr).type==4 ? (*array_ptr).value.ht : (((*array_ptr).type==5 ? (*array_ptr).value.obj.handlers->get_properties((array_ptr) ) : ((void *)0))))) != ((void *)0)) {
  zend_hash_internal_pointer_reset_ex(fe_ht, ((void *)0));
  if (ce) {
   zend_object *zobj = zend_objects_get_address(array_ptr );
   while ((zend_hash_get_current_key_type_ex(fe_ht, ((void *)0)) == 3 ? -1 : 0) == 0) {
    char *str_key;
    uint str_key_len;
    ulong int_key;
    zend_uchar key_type;

    key_type = zend_hash_get_current_key_ex(fe_ht, &str_key, &str_key_len, &int_key, 0, ((void *)0));
    if (key_type != 3 &&
     (key_type == 2 ||
         zend_check_property_access(zobj, str_key, str_key_len-1 ) == 0)) {
     break;
    }
    zend_hash_move_forward_ex(fe_ht, ((void *)0));
   }
  }
  is_empty = (zend_hash_get_current_key_type_ex(fe_ht, ((void *)0)) == 3 ? -1 : 0) != 0;
  zend_hash_get_pointer(fe_ht, &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).fe.fe_pos);
 } else {
  zend_error((1<<1L), "Invalid argument supplied for foreach()");
  is_empty = 1;
 }

 if (is_empty) {
  if (__builtin_expect(!(executor_globals.exception), 1)) { execute_data->opline = execute_data->op_array->opcodes+opline->op2.opline_num; } else { ; } return 0;
 } else {
  ;
  execute_data->opline++; return 0;
 }
}

static int __attribute__((fastcall)) ZEND_EXIT_SPEC_CV_HANDLER(zend_execute_data *execute_data )
{

 zend_op *opline = execute_data->opline;

 ;
 if ((1<<4) != (1<<3)) {

  zval *ptr = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );

  if ((*ptr).type == 1) {
   (executor_globals.exit_status) = (*ptr).value.lval;
  } else {
   zend_print_variable(ptr);
  }

 }

 _zend_bailout("/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_vm_execute.h", 26759);
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_JMP_SET_SPEC_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *value;

 ;
 value = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );

 if (i_zend_is_true(value)) {
  do { (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var)->value = (value)->value; (*&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).type = (*value).type; } while (0);
  _zval_copy_ctor((&((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var)) );




  if (__builtin_expect(!(executor_globals.exception), 1)) { execute_data->opline = opline->op2.jmp_addr; } else { ; } return 0;
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_QM_ASSIGN_SPEC_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *value;

 ;
 value = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );

 do { (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var)->value = (value)->value; (*&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).type = (*value).type; } while (0);
 if (!0) {
  _zval_copy_ctor((&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var) );
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INSTANCEOF_SPEC_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *expr;
 zend_bool result;

 ;
 expr = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );

 if ((*expr).type == 5 && (*expr).value.obj.handlers->get_class_entry) {
  result = instanceof_function(zend_get_class_entry(&(*expr) ), (*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).class_entry );
 } else {
  result = 0;
 }
 do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((result) != 0); (*__z).type = 3; } while (0);

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ADD_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 add_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  opline->op2.zv );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SUB_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 sub_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  opline->op2.zv );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_MUL_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 mul_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  opline->op2.zv );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_DIV_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 div_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  opline->op2.zv );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_MOD_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 mod_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  opline->op2.zv );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SL_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 shift_left_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  opline->op2.zv );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SR_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 shift_right_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  opline->op2.zv );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_CONCAT_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 concat_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  opline->op2.zv );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_IDENTICAL_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 is_identical_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  opline->op2.zv );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_NOT_IDENTICAL_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 is_identical_function(result,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  opline->op2.zv );
 (*result).value.lval = !(*result).value.lval;


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_EQUAL_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  opline->op2.zv );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval == 0)) != 0); (*__z).type = 3; } while (0);


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_NOT_EQUAL_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  opline->op2.zv );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval != 0)) != 0); (*__z).type = 3; } while (0);


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_SMALLER_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  opline->op2.zv );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval < 0)) != 0); (*__z).type = 3; } while (0);


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  opline->op2.zv );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval <= 0)) != 0); (*__z).type = 3; } while (0);


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_OR_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 bitwise_or_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  opline->op2.zv );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_AND_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 bitwise_and_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  opline->op2.zv );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_XOR_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 bitwise_xor_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  opline->op2.zv );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BOOL_XOR_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 boolean_xor_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  opline->op2.zv );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_binary_assign_op_obj_helper_SPEC_CV_CONST(int (*binary_op)(zval *result, zval *op1, zval *op2 ), zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op_data1;
 zval **object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var );
 zval *object;
 zval *property = opline->op2.zv;
 zval *value = _get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, &free_op_data1, 0 );
 int have_get_ptr = 0;

 if ((1<<4) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }

 make_real_object(object_ptr );
 object = *object_ptr;

 if (__builtin_expect((*object).type != 5, 0)) {
  zend_error((1<<1L), "Attempt to assign property of non-object");

  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };

  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = &(executor_globals.uninitialized_zval);
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
  }
 } else {

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
  }


  if (opline->extended_value == 136
   && (*object).value.obj.handlers->get_property_ptr_ptr) {
   zval **zptr = (*object).value.obj.handlers->get_property_ptr_ptr(object, property, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   if (zptr != ((void *)0)) {
    if (!zval_isref_p(*zptr)) { do { if (zval_refcount_p(*((zptr))) > 1) { zval *new_zv; zval_delref_p(*(zptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(zptr))->value; (*new_zv).type = (**(zptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(zptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

    have_get_ptr = 1;
    binary_op(*zptr, *zptr, value );
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((*zptr));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = *zptr;
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
   }
  }

  if (!have_get_ptr) {
   zval *z = ((void *)0);

   if (opline->extended_value == 136) {
    if ((*object).value.obj.handlers->read_property) {
     z = (*object).value.obj.handlers->read_property(object, property, 0, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
    }
   } else {
    if ((*object).value.obj.handlers->read_dimension) {
     z = (*object).value.obj.handlers->read_dimension(object, property, 0 );
    }
   }
   if (z) {
    if ((*z).type == 5 && (*z).value.obj.handlers->get) {
     zval *value = (*z).value.obj.handlers->get(z );

     if (zval_refcount_p(z) == 0) {
      if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); };
      _zval_dtor((z) );
      do { if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); }; _efree((z) ); } while (0);
     }
     z = value;
    }
    zval_addref_p(z);
    if (!zval_isref_p(*&z)) { do { if (zval_refcount_p(*((&z))) > 1) { zval *new_zv; zval_delref_p(*(&z)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(&z))->value; (*new_zv).type = (**(&z)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(&z) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
    binary_op(z, z, value );
    if (opline->extended_value == 136) {
     (*object).value.obj.handlers->write_property(object, property, z, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
    } else {
     (*object).value.obj.handlers->write_dimension(object, property, z );
    }
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((z));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = z;
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
    i_zval_ptr_dtor(*(&z) );
   } else {
    zend_error((1<<1L), "Attempt to assign property of non-object");
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((&(executor_globals.uninitialized_zval)));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = &(executor_globals.uninitialized_zval);
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
   }
  }

  if (0) {
   i_zval_ptr_dtor(*(&property) );
  } else {

  }
  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };
 }


 ;
 execute_data->opline++;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_binary_assign_op_helper_SPEC_CV_CONST(int (*binary_op)(zval *result, zval *op1, zval *op2 ), zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op_data2, free_op_data1;
 zval **var_ptr;
 zval *value;

 ;
 switch (opline->extended_value) {
  case 136:
   return zend_binary_assign_op_obj_helper_SPEC_CV_CONST(binary_op, execute_data );
   break;
  case 147: {
    zval **container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var );

    if ((1<<4) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
     zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
    } else if (__builtin_expect((**container).type == 5, 0)) {
     if ((1<<4) == (1<<2) && !0) {
      zval_addref_p(*(container));
     }
     return zend_binary_assign_op_obj_helper_SPEC_CV_CONST(binary_op, execute_data );
    } else {
     zval *dim = opline->op2.zv;

     zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)), container, dim, (1<<0), 2 );
     value = _get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, &free_op_data1, 0 );
     var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data->Ts, &free_op_data2 );
    }
   }
   break;
  default:
   value = opline->op2.zv;
   var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var );

   break;
 }

 if (__builtin_expect(var_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use assign-op operators with overloaded objects nor string offsets");
 }

 if (__builtin_expect(*var_ptr == &(executor_globals.error_zval), 0)) {
  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }


  ;
  if (opline->extended_value == 147) {
   execute_data->opline++;
  }
  execute_data->opline++; return 0;
 }

 if (!zval_isref_p(*var_ptr)) { do { if (zval_refcount_p(*((var_ptr))) > 1) { zval *new_zv; zval_delref_p(*(var_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(var_ptr))->value; (*new_zv).type = (**(var_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(var_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

 if (__builtin_expect((**var_ptr).type == 5, 0)
    && ((**var_ptr)).value.obj.handlers->get
    && ((**var_ptr)).value.obj.handlers->set) {

  zval *objval = ((**var_ptr)).value.obj.handlers->get(*var_ptr );
  zval_addref_p(objval);
  binary_op(objval, objval, value );
  ((**var_ptr)).value.obj.handlers->set(var_ptr, objval );
  i_zval_ptr_dtor(*(&objval) );
 } else {
  binary_op(*var_ptr, *var_ptr, value );
 }

 if ((!((opline)->result_type & (1<<5)))) {
  zval_addref_p((*var_ptr));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (*var_ptr); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
 }

 if (opline->extended_value == 147) {
  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };
  if (free_op_data2.var) { i_zval_ptr_dtor(*(&free_op_data2.var) ); };

  ;
  execute_data->opline++;
 } else {

  ;
 }
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_ADD_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_CONST(add_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SUB_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_CONST(sub_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_MUL_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_CONST(mul_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_DIV_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_CONST(div_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_MOD_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_CONST(mod_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SL_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_CONST(shift_left_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SR_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_CONST(shift_right_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_CONCAT_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_CONST(concat_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_OR_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_CONST(bitwise_or_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_AND_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_CONST(bitwise_and_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_XOR_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_CONST(bitwise_xor_function, execute_data );
}

static int __attribute__((fastcall)) zend_pre_incdec_property_helper_SPEC_CV_CONST(incdec_t incdec_op, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval **object_ptr;
 zval *object;
 zval *property;
 zval **retval;
 int have_get_ptr = 0;

 ;
 object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var );
 property = opline->op2.zv;
 retval = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr;

 if ((1<<4) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot increment/decrement overloaded objects nor string offsets");
 }

 make_real_object(object_ptr );
 object = *object_ptr;

 if (__builtin_expect((*object).type != 5, 0)) {
  zend_error((1<<1L), "Attempt to increment/decrement property of non-object");

  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   *retval = &(executor_globals.uninitialized_zval);
  }

  ;
  execute_data->opline++; return 0;
 }



 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }

 if ((*object).value.obj.handlers->get_property_ptr_ptr) {
  zval **zptr = (*object).value.obj.handlers->get_property_ptr_ptr(object, property, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
  if (zptr != ((void *)0)) {
   if (!zval_isref_p(*zptr)) { do { if (zval_refcount_p(*((zptr))) > 1) { zval *new_zv; zval_delref_p(*(zptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(zptr))->value; (*new_zv).type = (**(zptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(zptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

   have_get_ptr = 1;
   incdec_op(*zptr);
   if ((!((opline)->result_type & (1<<5)))) {
    *retval = *zptr;
    zval_addref_p((*retval));
   }
  }
 }

 if (!have_get_ptr) {
  if ((*object).value.obj.handlers->read_property && (*object).value.obj.handlers->write_property) {
   zval *z = (*object).value.obj.handlers->read_property(object, property, 0, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );

   if (__builtin_expect((*z).type == 5, 0) && (*z).value.obj.handlers->get) {
    zval *value = (*z).value.obj.handlers->get(z );

    if (zval_refcount_p(z) == 0) {
     if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); };
     _zval_dtor((z) );
     do { if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); }; _efree((z) ); } while (0);
    }
    z = value;
   }
   zval_addref_p(z);
   if (!zval_isref_p(*&z)) { do { if (zval_refcount_p(*((&z))) > 1) { zval *new_zv; zval_delref_p(*(&z)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(&z))->value; (*new_zv).type = (**(&z)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(&z) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
   incdec_op(z);
   *retval = z;
   (*object).value.obj.handlers->write_property(object, property, z, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   if ((!((opline)->result_type & (1<<5)))) { zval_addref_p((*retval)); };
   i_zval_ptr_dtor(*(&z) );
  } else {
   zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
   if ((!((opline)->result_type & (1<<5)))) {
    zval_addref_p((&(executor_globals.uninitialized_zval)));
    *retval = &(executor_globals.uninitialized_zval);
   }
  }
 }

 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {

 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_PRE_INC_OBJ_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_pre_incdec_property_helper_SPEC_CV_CONST(increment_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_PRE_DEC_OBJ_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_pre_incdec_property_helper_SPEC_CV_CONST(decrement_function, execute_data );
}

static int __attribute__((fastcall)) zend_post_incdec_property_helper_SPEC_CV_CONST(incdec_t incdec_op, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval **object_ptr;
 zval *object;
 zval *property;
 zval *retval;
 int have_get_ptr = 0;

 ;
 object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var );
 property = opline->op2.zv;
 retval = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 if ((1<<4) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot increment/decrement overloaded objects nor string offsets");
 }

 make_real_object(object_ptr );
 object = *object_ptr;

 if (__builtin_expect((*object).type != 5, 0)) {
  zend_error((1<<1L), "Attempt to increment/decrement property of non-object");

  { (*retval).type = 0; };

  ;
  execute_data->opline++; return 0;
 }



 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }

 if ((*object).value.obj.handlers->get_property_ptr_ptr) {
  zval **zptr = (*object).value.obj.handlers->get_property_ptr_ptr(object, property, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
  if (zptr != ((void *)0)) {
   have_get_ptr = 1;
   if (!zval_isref_p(*zptr)) { do { if (zval_refcount_p(*((zptr))) > 1) { zval *new_zv; zval_delref_p(*(zptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(zptr))->value; (*new_zv).type = (**(zptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(zptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

   do { (retval)->value = (*zptr)->value; (*retval).type = (**zptr).type; } while (0);
   _zval_copy_ctor((&(*retval)) );

   incdec_op(*zptr);

  }
 }

 if (!have_get_ptr) {
  if ((*object).value.obj.handlers->read_property && (*object).value.obj.handlers->write_property) {
   zval *z = (*object).value.obj.handlers->read_property(object, property, 0, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   zval *z_copy;

   if (__builtin_expect((*z).type == 5, 0) && (*z).value.obj.handlers->get) {
    zval *value = (*z).value.obj.handlers->get(z );

    if (zval_refcount_p(z) == 0) {
     if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); };
     _zval_dtor((z) );
     do { if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); }; _efree((z) ); } while (0);
    }
    z = value;
   }
   do { (retval)->value = (z)->value; (*retval).type = (*z).type; } while (0);
   _zval_copy_ctor((&(*retval)) );
   do { (z_copy) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(z_copy))->u.buffered = ((void *)0); } while (0);
   do { do { (z_copy)->value = (z)->value; (*z_copy).type = (*z).type; } while (0); zval_set_refcount_p(z_copy, 1); zval_unset_isref_p(z_copy); } while (0);
   _zval_copy_ctor((&(*z_copy)) );
   incdec_op(z_copy);
   zval_addref_p(z);
   (*object).value.obj.handlers->write_property(object, property, z_copy, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   i_zval_ptr_dtor(*(&z_copy) );
   i_zval_ptr_dtor(*(&z) );
  } else {
   zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
   { (*retval).type = 0; };
  }
 }

 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {

 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_POST_INC_OBJ_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_post_incdec_property_helper_SPEC_CV_CONST(increment_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_POST_DEC_OBJ_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_post_incdec_property_helper_SPEC_CV_CONST(decrement_function, execute_data );
}

static int __attribute__((fastcall)) zend_fetch_var_address_helper_SPEC_CV_CONST(int type, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *varname;
 zval **retval;
 zval tmp_varname;
 HashTable *target_symbol_table;
 ulong hash_value;

 ;
 varname = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );

  if ((1<<4) != (1<<0) && __builtin_expect((*varname).type != 6, 0)) {
  do { (&tmp_varname)->value = (varname)->value; (*&tmp_varname).type = (*varname).type; } while (0);
  _zval_copy_ctor((&tmp_varname) );
  if ((&tmp_varname)->type != 6) { _convert_to_string((&tmp_varname) ); };
  varname = &tmp_varname;
 }

 if ((1<<0) != (1<<3)) {
  zend_class_entry *ce;

  if ((1<<0) == (1<<0)) {
   if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
    ce = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
   } else {
    ce = zend_fetch_class_by_name((*opline->op2.zv).value.str.val, (*opline->op2.zv).value.str.len, opline->op2.literal + 1, 0 );
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); } while (0);
   }
  } else {
   ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).class_entry;
  }
  retval = zend_std_get_static_property(ce, (*varname).value.str.val, (*varname).value.str.len, 0, (((1<<4) == (1<<0)) ? opline->op1.literal : ((void *)0)) );

 } else {
  target_symbol_table = zend_get_target_symbol_table(opline->extended_value & 0x70000000 );






  if ((1<<4) == (1<<0)) {
   hash_value = (((zend_literal*)(varname))->hash_value);
  } else if (((((*varname).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*varname).value.str.val) < (compiler_globals.interned_strings_end)))) {
   hash_value = (((Bucket*)(((char*)((*varname).value.str.val))-sizeof(Bucket)))->h);
  } else {
   hash_value = zend_hash_func((*varname).value.str.val, (*varname).value.str.len+1);
  }

  if (zend_hash_quick_find(target_symbol_table, (*varname).value.str.val, (*varname).value.str.len+1, hash_value, (void **) &retval) == -1) {
   switch (type) {
    case 0:
    case 6:
     zend_error((1<<3L),"Undefined variable: %s", (*varname).value.str.val);

    case 3:
     retval = &(executor_globals.uninitialized_zval_ptr);
     break;
    case 2:
     zend_error((1<<3L),"Undefined variable: %s", (*varname).value.str.val);

    case 1:
     zval_addref_p(&(executor_globals.uninitialized_zval));
     _zend_hash_quick_add_or_update(target_symbol_table, (*varname).value.str.val, (*varname).value.str.len+1, hash_value, &(executor_globals.uninitialized_zval_ptr), sizeof(zval *), (void **) &retval, (1<<0) );
     break;
   
   }
  }
  switch (opline->extended_value & 0x70000000) {
   case 0x00000000:
    if ((1<<4) != (1<<1)) {

    }
    break;
   case 0x10000000:

    break;
   case 0x20000000:
    zval_update_constant(retval, (void*) 1 );
    break;
   case 0x40000000:
    if ((1<<4) == (1<<2) && !free_op1.var) {
     zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr));
    }
    break;
  }
 }


 if ((1<<4) != (1<<0) && varname == &tmp_varname) {
  _zval_dtor((&tmp_varname) );
 }
 if (opline->extended_value & 0x04000000) {
  if (!zval_isref_p(*retval)) { do { if (zval_refcount_p(*((retval))) > 1) { zval *new_zv; zval_delref_p(*(retval)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval))->value; (*new_zv).type = (**(retval)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((retval))); };
 }
 zval_addref_p((*retval));
 switch (type) {
  case 0:
  case 3:
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (*retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   break;
  case 6: {
   zend_free_op free_res;

   zend_pzval_unlock_func(*retval, &free_res, 1 );
   if (retval != &(executor_globals.uninitialized_zval_ptr)) {
    if (!zval_isref_p(*retval)) { do { if (zval_refcount_p(*((retval))) > 1) { zval *new_zv; zval_delref_p(*(retval)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval))->value; (*new_zv).type = (**(retval)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
   }
   zval_addref_p((*retval));
   if (free_res.var) { i_zval_ptr_dtor(*(&free_res.var) ); };
  }

  default:
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = retval;
   break;
 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_R_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_CV_CONST(0, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_W_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_CV_CONST(1, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_RW_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_CV_CONST(2, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_FUNC_ARG_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 return zend_fetch_var_address_helper_SPEC_CV_CONST(((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && (opline->extended_value & 0x000fffff) <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[(opline->extended_value & 0x000fffff)-1].pass_by_reference & (1|2)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x1000000|0x2000000))))?1:0, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_UNSET_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_CV_CONST(6, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_IS_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_CV_CONST(3, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_R_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval **container;

 ;

 if ((opline->extended_value & 0x08000000) &&
     (1<<4) != (1<<4) &&
     (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr) {
  zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr));
 }
 container = _get_zval_ptr_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );
 zend_fetch_dimension_address_read(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, opline->op2.zv, (1<<0), 0 );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_W_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **container;

 ;
 container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var );

 if ((1<<4) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, opline->op2.zv, (1<<0), 1 );

 if ((1<<4) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }


 if (__builtin_expect(opline->extended_value != 0, 0)) {
  zval **retval_ptr = (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr;

  if (retval_ptr) {
   zval_delref_p(*(retval_ptr));
   if (!zval_isref_p(*retval_ptr)) { do { if (zval_refcount_p(*((retval_ptr))) > 1) { zval *new_zv; zval_delref_p(*(retval_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval_ptr))->value; (*new_zv).type = (**(retval_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((retval_ptr))); };
   zval_addref_p(*(retval_ptr));
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_RW_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **container;

 ;
 container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var );

 if ((1<<4) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, opline->op2.zv, (1<<0), 2 );

 if ((1<<4) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_IS_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval **container;

 ;
 container = _get_zval_ptr_ptr_cv_BP_VAR_IS(execute_data->CVs, opline->op1.var );
 zend_fetch_dimension_address_read(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, opline->op2.zv, (1<<0), 3 );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **container;

 ;

 if (((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && (opline->extended_value & 0x000fffff) <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[(opline->extended_value & 0x000fffff)-1].pass_by_reference & (1|2)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x1000000|0x2000000))))) {
  container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var );
  if ((1<<4) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
  }
  zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, opline->op2.zv, (1<<0), 1 );
  if ((1<<4) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
  }
 } else {
  if ((1<<0) == (1<<3)) {
   zend_error_noreturn((1<<0L), "Cannot use [] for reading");
  }
  container = _get_zval_ptr_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );
  zend_fetch_dimension_address_read(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, opline->op2.zv, (1<<0), 0 );
 }


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_UNSET_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **container;

 ;
 container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data->CVs, opline->op1.var );

 if ((1<<4) == (1<<4)) {
  if (container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
 }
 if ((1<<4) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, opline->op2.zv, (1<<0), 6 );

 if ((1<<4) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }

 if (__builtin_expect((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot unset string offsets");
 } else {
  zend_free_op free_res;
  zval **retval_ptr = (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr;

  zend_pzval_unlock_func(*retval_ptr, &free_res, 1 );
  if (retval_ptr != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*retval_ptr)) { do { if (zval_refcount_p(*((retval_ptr))) > 1) { zval *new_zv; zval_delref_p(*(retval_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval_ptr))->value; (*new_zv).type = (**(retval_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
  zval_addref_p((*retval_ptr));
  if (free_res.var) { i_zval_ptr_dtor(*(&free_res.var) ); };
  ;
  execute_data->opline++; return 0;
 }
}

static int __attribute__((fastcall)) zend_fetch_property_address_read_helper_SPEC_CV_CONST(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *container;

 zval *offset;

 ;
 container = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );
 offset = opline->op2.zv;

 if (__builtin_expect((*container).type != 5, 0) ||
     __builtin_expect((*container).value.obj.handlers->read_property == ((void *)0), 0)) {
  zend_error((1<<3L), "Trying to get property of non-object");
  zval_addref_p((&(executor_globals.uninitialized_zval)));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);

 } else {
  zval *retval;

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
  }


  retval = (*container).value.obj.handlers->read_property(container, offset, 0, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );

  zval_addref_p((retval));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);

  if (0) {
   i_zval_ptr_dtor(*(&offset) );
  } else {

  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_R_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_property_address_read_helper_SPEC_CV_CONST(execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_W_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *property;
 zval **container;

 ;
 property = opline->op2.zv;

 if ((1<<4) == (1<<2) && (opline->extended_value & 0x08000000)) {
  zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr));
  (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr = *(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr;
 }

 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }
 container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var );
 if ((1<<4) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }

 zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)), 1 );
 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {

 }
 if ((1<<4) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }


 if (opline->extended_value & 0x04000000) {
  zval **retval_ptr = (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr;

  zval_delref_p(*(retval_ptr));
  if (!zval_isref_p(*retval_ptr)) { do { if (zval_refcount_p(*((retval_ptr))) > 1) { zval *new_zv; zval_delref_p(*(retval_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval_ptr))->value; (*new_zv).type = (**(retval_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((retval_ptr))); };
  zval_addref_p(*(retval_ptr));
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_RW_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *property;
 zval **container;

 ;
 property = opline->op2.zv;
 container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var );

 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }
 if ((1<<4) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }
 zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)), 2 );
 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {

 }
 if ((1<<4) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_IS_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *container;

 zval *offset;

 ;
 container = _get_zval_ptr_cv_BP_VAR_IS(execute_data->CVs, opline->op1.var );
 offset = opline->op2.zv;

 if (__builtin_expect((*container).type != 5, 0) ||
     __builtin_expect((*container).value.obj.handlers->read_property == ((void *)0), 0)) {
  zval_addref_p((&(executor_globals.uninitialized_zval)));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);

 } else {
  zval *retval;

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
  }


  retval = (*container).value.obj.handlers->read_property(container, offset, 3, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );

  zval_addref_p((retval));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);

  if (0) {
   i_zval_ptr_dtor(*(&offset) );
  } else {

  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 if (((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && (opline->extended_value & 0x000fffff) <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[(opline->extended_value & 0x000fffff)-1].pass_by_reference & (1|2)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x1000000|0x2000000))))) {

  zend_free_op free_op1;
  zval *property;
  zval **container;

  ;
  property = opline->op2.zv;
  container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var );

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
  }
  if ((1<<4) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
  }
  zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)), 1 );
  if (0) {
   i_zval_ptr_dtor(*(&property) );
  } else {

  }
  if ((1<<4) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
  }

  ;
  execute_data->opline++; return 0;
 } else {
  return zend_fetch_property_address_read_helper_SPEC_CV_CONST(execute_data );
 }
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_UNSET_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_res;
 zval **container;
 zval *property;

 ;
 container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data->CVs, opline->op1.var );
 property = opline->op2.zv;

 if ((1<<4) == (1<<4)) {
  if (container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
 }
 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }
 if ((1<<4) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }
 zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)), 6 );
 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {

 }
 if ((1<<4) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }

 zend_pzval_unlock_func(*(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr, &free_res, 1 );
 if ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr != &(executor_globals.uninitialized_zval_ptr)) {
  if (!zval_isref_p(*(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr)) { do { if (zval_refcount_p(*(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr))->value; (*new_zv).type = (**((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
 }
 zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr));
 if (free_res.var) { i_zval_ptr_dtor(*(&free_res.var) ); };
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_OBJ_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval **object_ptr;
 zval *property_name;

 ;
 object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var );
 property_name = opline->op2.zv;

 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property_name))->value; (*_tmp).type = (*(property_name)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property_name) = _tmp; } while (0);
 }
 if ((1<<4) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 zend_assign_to_object((!((opline)->result_type & (1<<5)))?&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr:((void *)0), object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, 136, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
 if (0) {
  i_zval_ptr_dtor(*(&property_name) );
 } else {

 }


 ;
 execute_data->opline++;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_DIM_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval **object_ptr;

 ;
 object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var );

 if ((1<<4) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 if ((**object_ptr).type == 5) {

  zval *property_name = opline->op2.zv;

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property_name))->value; (*_tmp).type = (*(property_name)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property_name) = _tmp; } while (0);
  }
  zend_assign_to_object((!((opline)->result_type & (1<<5)))?&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr:((void *)0), object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, 147, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
  if (0) {
   i_zval_ptr_dtor(*(&property_name) );
  } else {

  }
 } else {
  zend_free_op free_op_data1, free_op_data2;
  zval *value;
  zval *dim = opline->op2.zv;
  zval **variable_ptr_ptr;

  zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)), object_ptr, dim, (1<<0), 1 );

  value = _get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, &free_op_data1, 0 );
  variable_ptr_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data->Ts, &free_op_data2 );
  if (__builtin_expect(variable_ptr_ptr == ((void *)0), 0)) {
   if (zend_assign_to_string_offset(&(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)), value, (opline+1)->op1_type )) {
    if ((!((opline)->result_type & (1<<5)))) {
     zval *retval;

     do { (retval) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(retval))->u.buffered = ((void *)0); } while (0);
     do { const char *__s=((*(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)).str_offset.str).value.str.val+(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)).str_offset.offset); int __l=1; zval *__z = (retval); (*__z).value.str.len = __l; (*__z).value.str.val = (1?_estrndup((__s), (__l) ):(char*)__s); (*__z).type = 6; } while (0);
     (retval)->refcount__gc = 1; (retval)->is_ref__gc = 0;;
     do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
    }
   } else if ((!((opline)->result_type & (1<<5)))) {
    zval_addref_p((&(executor_globals.uninitialized_zval)));
    do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   }
  } else if (__builtin_expect(*variable_ptr_ptr == &(executor_globals.error_zval), 0)) {
   if (((zend_uintptr_t)free_op_data1.var & 1L)) {
    _zval_dtor((value) );
   }
   if ((!((opline)->result_type & (1<<5)))) {
    zval_addref_p((&(executor_globals.uninitialized_zval)));
    do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   }
  } else {
   if ((opline+1)->op1_type == (1<<1)) {
     value = zend_assign_tmp_to_variable(variable_ptr_ptr, value );
   } else if ((opline+1)->op1_type == (1<<0)) {
     value = zend_assign_const_to_variable(variable_ptr_ptr, value );
   } else {
     value = zend_assign_to_variable(variable_ptr_ptr, value );
   }
   if ((!((opline)->result_type & (1<<5)))) {
    zval_addref_p((value));
    do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (value); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   }
  }
  if (free_op_data2.var) { i_zval_ptr_dtor(*(&free_op_data2.var) ); };
   if (free_op_data1.var != ((void *)0) && (((zend_uintptr_t)free_op_data1.var & 1L) == 0)) { i_zval_ptr_dtor(*(&free_op_data1.var) ); };
 }


 ;
 execute_data->opline++;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *value;
 zval **variable_ptr_ptr;

 ;
 value = opline->op2.zv;
 variable_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var );

 if ((1<<4) == (1<<2) && __builtin_expect(variable_ptr_ptr == ((void *)0), 0)) {
  if (zend_assign_to_string_offset(&(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)), value, (1<<0) )) {
   if ((!((opline)->result_type & (1<<5)))) {
    zval *retval;

    do { (retval) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(retval))->u.buffered = ((void *)0); } while (0);
    do { const char *__s=((*(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).str_offset.str).value.str.val+(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).str_offset.offset); int __l=1; zval *__z = (retval); (*__z).value.str.len = __l; (*__z).value.str.val = (1?_estrndup((__s), (__l) ):(char*)__s); (*__z).type = 6; } while (0);
    (retval)->refcount__gc = 1; (retval)->is_ref__gc = 0;;
    do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   }
  } else if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }
 } else if ((1<<4) == (1<<2) && __builtin_expect(*variable_ptr_ptr == &(executor_globals.error_zval), 0)) {
  if (0) {
   _zval_dtor((value) );
  }
  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }
 } else {
  if ((1<<0) == (1<<1)) {
    value = zend_assign_tmp_to_variable(variable_ptr_ptr, value );
  } else if ((1<<0) == (1<<0)) {
    value = zend_assign_const_to_variable(variable_ptr_ptr, value );
  } else {
    value = zend_assign_to_variable(variable_ptr_ptr, value );
  }
  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((value));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (value); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }
 }



 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_METHOD_CALL_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *function_name;
 char *function_name_strval;
 int function_name_strlen;


 ;
 zend_ptr_stack_3_push(&(executor_globals.arg_types_stack), execute_data->fbc, execute_data->object, execute_data->called_scope);

 function_name = opline->op2.zv;

 if ((1<<0) != (1<<0) &&
     __builtin_expect((*function_name).type != 6, 0)) {
  zend_error_noreturn((1<<0L), "Method name must be a string");
 }

 function_name_strval = (*function_name).value.str.val;
 function_name_strlen = (*function_name).value.str.len;

 execute_data->object = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );

 if (__builtin_expect(execute_data->object != ((void *)0), 1) &&
     __builtin_expect((*execute_data->object).type == 5, 1)) {
  execute_data->called_scope = zend_get_class_entry(&(*execute_data->object) );

  if ((1<<0) != (1<<0) ||
      (execute_data->fbc = (((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] == (execute_data->called_scope)) ? (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] : ((void *)0))) == ((void *)0)) {
      zval *object = execute_data->object;

   if (__builtin_expect((*execute_data->object).value.obj.handlers->get_method == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Object does not support method calls");
   }


   execute_data->fbc = (*execute_data->object).value.obj.handlers->get_method(&execute_data->object, function_name_strval, function_name_strlen, (((1<<0) == (1<<0)) ? (opline->op2.literal + 1) : ((void *)0)) );
   if (__builtin_expect(execute_data->fbc == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Call to undefined method %s::%s()", ((execute_data->object) && (*execute_data->object).type == 5 && (*execute_data->object).value.obj.handlers->get_class_entry != ((void *)0) && (*execute_data->object).value.obj.handlers->get_class_entry(execute_data->object ) ? (*execute_data->object).value.obj.handlers->get_class_entry(execute_data->object )->name : ""), function_name_strval);
   }
   if ((1<<0) == (1<<0) &&
       __builtin_expect((execute_data->fbc->common.fn_flags & 0x200000) == 0, 1) &&
       __builtin_expect(execute_data->object == object, 1)) {
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (execute_data->called_scope); (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] = (execute_data->fbc); } while (0);
   }
  }
 } else {
  zend_error_noreturn((1<<0L), "Call to a member function %s() on a non-object", function_name_strval);
 }

 if ((execute_data->fbc->common.fn_flags & 0x01) != 0) {
  execute_data->object = ((void *)0);
 } else {
  if (!zval_isref_p(execute_data->object)) {
   zval_addref_p(execute_data->object);
  } else {
   zval *this_ptr;
   do { (this_ptr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(this_ptr))->u.buffered = ((void *)0); } while (0);
   do { do { (this_ptr)->value = (execute_data->object)->value; (*this_ptr).type = (*execute_data->object).type; } while (0); zval_set_refcount_p(this_ptr, 1); zval_unset_isref_p(this_ptr); } while (0);
   _zval_copy_ctor((this_ptr) );
   execute_data->object = this_ptr;
  }
 }


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_CASE_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 if ((1<<4)==(1<<2)) {
  zval_addref_p(((*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr));
 }
 is_equal_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
     _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
     opline->op2.zv );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *expr_ptr;

 ;
 if (((1<<4) == (1<<2) || (1<<4) == (1<<4)) && opline->extended_value) {
  zval **expr_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var );

  if ((1<<4) == (1<<2) && __builtin_expect(expr_ptr_ptr == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot create references to/from string offsets");
  }
  if (!zval_isref_p(*expr_ptr_ptr)) { do { if (zval_refcount_p(*((expr_ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(expr_ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(expr_ptr_ptr))->value; (*new_zv).type = (**(expr_ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(expr_ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((expr_ptr_ptr))); };
  expr_ptr = *expr_ptr_ptr;
  zval_addref_p(expr_ptr);
 } else {
  expr_ptr=_get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );
  if (0) {
   zval *new_expr;

   do { (new_expr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_expr))->u.buffered = ((void *)0); } while (0);
   do { do { (new_expr)->value = (expr_ptr)->value; (*new_expr).type = (*expr_ptr).type; } while (0); zval_set_refcount_p(new_expr, 1); zval_unset_isref_p(new_expr); } while (0);
   expr_ptr = new_expr;
  } else if ((1<<4) == (1<<0) || zval_isref_p(expr_ptr)) {
   zval *new_expr;

   do { (new_expr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_expr))->u.buffered = ((void *)0); } while (0);
   do { do { (new_expr)->value = (expr_ptr)->value; (*new_expr).type = (*expr_ptr).type; } while (0); zval_set_refcount_p(new_expr, 1); zval_unset_isref_p(new_expr); } while (0);
   expr_ptr = new_expr;
   _zval_copy_ctor((&(*expr_ptr)) );
  } else {
   zval_addref_p(expr_ptr);
  }
 }

 if ((1<<0) != (1<<3)) {

  zval *offset = opline->op2.zv;
  ulong hval;

  switch ((*offset).type) {
   case 2:
    hval = zend_dval_to_lval((*offset).value.dval);
    goto num_index;
   case 1:
   case 3:
    hval = (*offset).value.lval;
num_index:
    _zend_hash_index_update_or_next_insert(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, hval, &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   case 6:
    if ((1<<0) == (1<<0)) {
     hval = (((zend_literal*)(offset))->hash_value);
    } else {
     do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index; } } } while (0);
     if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
      hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
     } else {
      hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
     }
    }
    _zend_hash_quick_add_or_update(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   case 0:
    _zend_hash_add_or_update(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, "", sizeof(""), &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   default:
    zend_error((1<<1L), "Illegal offset type");
    i_zval_ptr_dtor(*(&expr_ptr) );

    break;
  }

 } else {
  _zend_hash_index_update_or_next_insert(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, 0, &expr_ptr, sizeof(zval *), ((void *)0), (1<<2) );
 }
 if (((1<<4) == (1<<2) || (1<<4) == (1<<4)) && opline->extended_value) {

 } else {

 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_ARRAY_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 _array_init((&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var), 0 );
 if ((1<<4) == (1<<3)) {
  execute_data->opline++; return 0;

 } else {
  return ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CONST_HANDLER(execute_data );

 }
}

static int __attribute__((fastcall)) ZEND_UNSET_VAR_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval tmp, *varname;
 HashTable *target_symbol_table;


 ;
 if ((1<<4) == (1<<4) &&
     (1<<0) == (1<<3) &&
     (opline->extended_value & 0x00800000)) {
  if ((executor_globals.active_symbol_table)) {
   zend_compiled_variable *cv = &((executor_globals.active_op_array)->vars[opline->op1.var]);

   zend_delete_variable(execute_data->prev_execute_data, (executor_globals.active_symbol_table), cv->name, cv->name_len+1, cv->hash_value );
   execute_data->CVs[opline->op1.var] = ((void *)0);
  } else if (execute_data->CVs[opline->op1.var]) {
   i_zval_ptr_dtor(*(execute_data->CVs[opline->op1.var]) );
   execute_data->CVs[opline->op1.var] = ((void *)0);
  }
  ;
  execute_data->opline++; return 0;
 }

 varname = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );

 if ((1<<4) != (1<<0) && (*varname).type != 6) {
  do { (&tmp)->value = (varname)->value; (*&tmp).type = (*varname).type; } while (0);
  _zval_copy_ctor((&tmp) );
  if ((&tmp)->type != 6) { _convert_to_string((&tmp) ); };
  varname = &tmp;
 } else if ((1<<4) == (1<<2) || (1<<4) == (1<<4)) {
  zval_addref_p(varname);
 }

 if ((1<<0) != (1<<3)) {
  zend_class_entry *ce;

  if ((1<<0) == (1<<0)) {
   if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
    ce = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
   } else {
    ce = zend_fetch_class_by_name((*opline->op2.zv).value.str.val, (*opline->op2.zv).value.str.len, opline->op2.literal + 1, 0 );
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); } while (0);
   }
  } else {
   ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).class_entry;
  }
  zend_std_unset_static_property(ce, (*varname).value.str.val, (*varname).value.str.len, (((1<<4) == (1<<0)) ? opline->op1.literal : ((void *)0)) );
 } else {
  ulong hash_value = zend_inline_hash_func(varname->value.str.val, varname->value.str.len+1);

  target_symbol_table = zend_get_target_symbol_table(opline->extended_value & 0x70000000 );
  zend_delete_variable(execute_data, target_symbol_table, varname->value.str.val, varname->value.str.len+1, hash_value );
 }

 if ((1<<4) != (1<<0) && varname == &tmp) {
  _zval_dtor((&tmp) );
 } else if ((1<<4) == (1<<2) || (1<<4) == (1<<4)) {
  i_zval_ptr_dtor(*(&varname) );
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_UNSET_DIM_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval **container;
 zval *offset;
 ulong hval;

 ;
 container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data->CVs, opline->op1.var );
 offset = opline->op2.zv;

 if ((1<<4) != (1<<2) || container) {
  if ((1<<4) == (1<<4) && container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
  switch ((**container).type) {
   case 4: {
    HashTable *ht = (**container).value.ht;

    switch ((*offset).type) {
     case 2:
      hval = zend_dval_to_lval((*offset).value.dval);
      goto num_index_dim;
     case 7:
     case 3:
     case 1:
num_index_dim:
      hval = (*offset).value.lval;
      zend_hash_del_key_or_index(ht, ((void *)0), 0, hval, 1);
      break;
     case 6:
      if ((1<<0) == (1<<4) || (1<<0) == (1<<2)) {
       zval_addref_p(offset);
      }
      if ((1<<0) == (1<<0)) {
       hval = (((zend_literal*)(offset))->hash_value);
      } else {
       do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index_dim; } } } while (0);
       if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
        hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
       } else {
        hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
       }
      }
      if (ht == &(executor_globals.symbol_table)) {
       zend_delete_global_variable_ex(offset->value.str.val, offset->value.str.len, hval );
      } else {
       zend_hash_del_key_or_index(ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, 2);
      }
      if ((1<<0) == (1<<4) || (1<<0) == (1<<2)) {
       i_zval_ptr_dtor(*(&offset) );
      }
      break;
     case 0:
      zend_hash_del_key_or_index(ht, "", sizeof(""), 0, 0);
      break;
     default:
      zend_error((1<<1L), "Illegal offset type in unset");
      break;
    }

    break;
   }
   case 5:
    if (__builtin_expect((**container).value.obj.handlers->unset_dimension == ((void *)0), 0)) {
     zend_error_noreturn((1<<0L), "Cannot use object as array");
    }
    if (0) {
     do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
    }
    (**container).value.obj.handlers->unset_dimension(*container, offset );
    if (0) {
     i_zval_ptr_dtor(*(&offset) );
    } else {

    }
    break;
   case 6:
    zend_error_noreturn((1<<0L), "Cannot unset string offsets");
    return 0;
   default:

    break;
  }
 } else {

 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_UNSET_OBJ_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval **container;
 zval *offset;

 ;
 container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data->CVs, opline->op1.var );
 offset = opline->op2.zv;

 if ((1<<4) != (1<<2) || container) {
  if ((1<<4) == (1<<4) && container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
  if ((**container).type == 5) {
   if (0) {
    do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
   }
   if ((**container).value.obj.handlers->unset_property) {
    (**container).value.obj.handlers->unset_property(*container, offset, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   } else {
    zend_error((1<<3L), "Trying to unset property of non-object");
   }
   if (0) {
    i_zval_ptr_dtor(*(&offset) );
   } else {

   }
  } else {

  }
 } else {

 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ISSET_ISEMPTY_VAR_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval **value;
 zend_bool isset = 1;

 ;
 if ((1<<4) == (1<<4) &&
     (1<<0) == (1<<3) &&
     (opline->extended_value & 0x00800000)) {
  if (execute_data->CVs[opline->op1.var]) {
   value = execute_data->CVs[opline->op1.var];
  } else if ((executor_globals.active_symbol_table)) {
   zend_compiled_variable *cv = &((executor_globals.active_op_array)->vars[opline->op1.var]);

   if (zend_hash_quick_find((executor_globals.active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, (void **) &value) == -1) {
    isset = 0;
   }
  } else {
   isset = 0;
  }
 } else {
  HashTable *target_symbol_table;

  zval tmp, *varname = _get_zval_ptr_cv_BP_VAR_IS(execute_data->CVs, opline->op1.var );

  if ((1<<4) != (1<<0) && (*varname).type != 6) {
   do { (&tmp)->value = (varname)->value; (*&tmp).type = (*varname).type; } while (0);
   _zval_copy_ctor((&tmp) );
   if ((&tmp)->type != 6) { _convert_to_string((&tmp) ); };
   varname = &tmp;
  }

  if ((1<<0) != (1<<3)) {
   zend_class_entry *ce;

   if ((1<<0) == (1<<0)) {
    if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
     ce = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
    } else {
     ce = zend_fetch_class_by_name((*opline->op2.zv).value.str.val, (*opline->op2.zv).value.str.len, opline->op2.literal + 1, 0 );
     do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); } while (0);
    }
   } else {
    ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).class_entry;
   }
   value = zend_std_get_static_property(ce, (*varname).value.str.val, (*varname).value.str.len, 1, (((1<<4) == (1<<0)) ? opline->op1.literal : ((void *)0)) );
   if (!value) {
    isset = 0;
   }
  } else {
   target_symbol_table = zend_get_target_symbol_table(opline->extended_value & 0x70000000 );
   if (zend_hash_find(target_symbol_table, varname->value.str.val, varname->value.str.len+1, (void **) &value) == -1) {
    isset = 0;
   }
  }

  if ((1<<4) != (1<<0) && varname == &tmp) {
   _zval_dtor((&tmp) );
  }

 }

 if (opline->extended_value & 0x02000000) {
  if (isset && (**value).type != 0) {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((1) != 0); (*__z).type = 3; } while (0);
  } else {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((0) != 0); (*__z).type = 3; } while (0);
  }
 } else {
  if (!isset || !i_zend_is_true(*value)) {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((1) != 0); (*__z).type = 3; } while (0);
  } else {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((0) != 0); (*__z).type = 3; } while (0);
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_CONST(int prop_dim, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval **container;
 zval **value = ((void *)0);
 int result = 0;
 ulong hval;
 zval *offset;

 ;
 container = _get_zval_ptr_ptr_cv_BP_VAR_IS(execute_data->CVs, opline->op1.var );

 offset = opline->op2.zv;

 if ((**container).type == 4 && !prop_dim) {
  HashTable *ht;
  int isset = 0;

  ht = (**container).value.ht;

  switch ((*offset).type) {
   case 2:
    hval = zend_dval_to_lval((*offset).value.dval);
    goto num_index_prop;
   case 7:
   case 3:
   case 1:
    hval = (*offset).value.lval;
num_index_prop:
    if (zend_hash_index_find(ht, hval, (void **) &value) == 0) {
     isset = 1;
    }
    break;
   case 6:
    if ((1<<0) == (1<<0)) {
     hval = (((zend_literal*)(offset))->hash_value);
    } else {
     if (!prop_dim) {
      do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index_prop; } } } while (0);
     }
     if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
      hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
     } else {
      hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
     }
    }
    if (zend_hash_quick_find(ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, (void **) &value) == 0) {
     isset = 1;
    }
    break;
   case 0:
    if (zend_hash_find(ht, "", sizeof(""), (void **) &value) == 0) {
     isset = 1;
    }
    break;
   default:
    zend_error((1<<1L), "Illegal offset type in isset or empty");
    break;
  }

  if (opline->extended_value & 0x02000000) {
   if (isset && (**value).type == 0) {
    result = 0;
   } else {
    result = isset;
   }
  } else {
   if (!isset || !i_zend_is_true(*value)) {
    result = 0;
   } else {
    result = 1;
   }
  }

 } else if ((**container).type == 5) {
  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
  }
  if (prop_dim) {
   if ((**container).value.obj.handlers->has_property) {
    result = (**container).value.obj.handlers->has_property(*container, offset, (opline->extended_value & 0x01000000) != 0, (((1<<0) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   } else {
    zend_error((1<<3L), "Trying to check property of non-object");
    result = 0;
   }
  } else {
   if ((**container).value.obj.handlers->has_dimension) {
    result = (**container).value.obj.handlers->has_dimension(*container, offset, (opline->extended_value & 0x01000000) != 0 );
   } else {
    zend_error((1<<3L), "Trying to check element of non-array");
    result = 0;
   }
  }
  if (0) {
   i_zval_ptr_dtor(*(&offset) );
  } else {

  }
 } else if ((*container)->type == 6 && !prop_dim) {
  zval tmp;

  if ((*offset).type != 1) {
   do { (&tmp)->value = (offset)->value; (*&tmp).type = (*offset).type; } while (0);
   _zval_copy_ctor((&tmp) );
   convert_to_long(&tmp);
   offset = &tmp;
  }
  if ((*offset).type == 1) {
   if (opline->extended_value & 0x02000000) {
    if (offset->value.lval >= 0 && offset->value.lval < (**container).value.str.len) {
     result = 1;
    }
   } else {
    if (offset->value.lval >= 0 && offset->value.lval < (**container).value.str.len && (**container).value.str.val[offset->value.lval] != '0') {
     result = 1;
    }
   }
  }

 } else {

 }

 ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).type = 3;
 if (opline->extended_value & 0x02000000) {
  ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.lval = result;
 } else {
  ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.lval = !result;
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_CONST(0, execute_data );
}

static int __attribute__((fastcall)) ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CONST_HANDLER(zend_execute_data *execute_data )
{
 return zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_CONST(1, execute_data );
}

static int __attribute__((fastcall)) ZEND_ADD_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 add_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );

 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SUB_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 sub_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );

 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_MUL_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 mul_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );

 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_DIV_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 div_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );

 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_MOD_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 mod_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );

 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SL_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 shift_left_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );

 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SR_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 shift_right_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );

 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_CONCAT_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 concat_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );

 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_IDENTICAL_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 is_identical_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );

 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_NOT_IDENTICAL_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 is_identical_function(result,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 (*result).value.lval = !(*result).value.lval;

 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_EQUAL_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval == 0)) != 0); (*__z).type = 3; } while (0);

 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_NOT_EQUAL_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval != 0)) != 0); (*__z).type = 3; } while (0);

 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_SMALLER_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval < 0)) != 0); (*__z).type = 3; } while (0);

 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval <= 0)) != 0); (*__z).type = 3; } while (0);

 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_OR_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 bitwise_or_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );

 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_AND_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 bitwise_and_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );

 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_XOR_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 bitwise_xor_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );

 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BOOL_XOR_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 boolean_xor_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );

 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_binary_assign_op_obj_helper_SPEC_CV_TMP(int (*binary_op)(zval *result, zval *op1, zval *op2 ), zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2, free_op_data1;
 zval **object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var );
 zval *object;
 zval *property = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );
 zval *value = _get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, &free_op_data1, 0 );
 int have_get_ptr = 0;

 if ((1<<4) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }

 make_real_object(object_ptr );
 object = *object_ptr;

 if (__builtin_expect((*object).type != 5, 0)) {
  zend_error((1<<1L), "Attempt to assign property of non-object");
  _zval_dtor((free_op2.var) );
  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };

  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = &(executor_globals.uninitialized_zval);
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
  }
 } else {

  if (1) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
  }


  if (opline->extended_value == 136
   && (*object).value.obj.handlers->get_property_ptr_ptr) {
   zval **zptr = (*object).value.obj.handlers->get_property_ptr_ptr(object, property, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   if (zptr != ((void *)0)) {
    if (!zval_isref_p(*zptr)) { do { if (zval_refcount_p(*((zptr))) > 1) { zval *new_zv; zval_delref_p(*(zptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(zptr))->value; (*new_zv).type = (**(zptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(zptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

    have_get_ptr = 1;
    binary_op(*zptr, *zptr, value );
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((*zptr));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = *zptr;
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
   }
  }

  if (!have_get_ptr) {
   zval *z = ((void *)0);

   if (opline->extended_value == 136) {
    if ((*object).value.obj.handlers->read_property) {
     z = (*object).value.obj.handlers->read_property(object, property, 0, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
    }
   } else {
    if ((*object).value.obj.handlers->read_dimension) {
     z = (*object).value.obj.handlers->read_dimension(object, property, 0 );
    }
   }
   if (z) {
    if ((*z).type == 5 && (*z).value.obj.handlers->get) {
     zval *value = (*z).value.obj.handlers->get(z );

     if (zval_refcount_p(z) == 0) {
      if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); };
      _zval_dtor((z) );
      do { if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); }; _efree((z) ); } while (0);
     }
     z = value;
    }
    zval_addref_p(z);
    if (!zval_isref_p(*&z)) { do { if (zval_refcount_p(*((&z))) > 1) { zval *new_zv; zval_delref_p(*(&z)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(&z))->value; (*new_zv).type = (**(&z)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(&z) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
    binary_op(z, z, value );
    if (opline->extended_value == 136) {
     (*object).value.obj.handlers->write_property(object, property, z, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
    } else {
     (*object).value.obj.handlers->write_dimension(object, property, z );
    }
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((z));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = z;
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
    i_zval_ptr_dtor(*(&z) );
   } else {
    zend_error((1<<1L), "Attempt to assign property of non-object");
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((&(executor_globals.uninitialized_zval)));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = &(executor_globals.uninitialized_zval);
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
   }
  }

  if (1) {
   i_zval_ptr_dtor(*(&property) );
  } else {
   _zval_dtor((free_op2.var) );
  }
  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };
 }


 ;
 execute_data->opline++;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_binary_assign_op_helper_SPEC_CV_TMP(int (*binary_op)(zval *result, zval *op1, zval *op2 ), zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2, free_op_data2, free_op_data1;
 zval **var_ptr;
 zval *value;

 ;
 switch (opline->extended_value) {
  case 136:
   return zend_binary_assign_op_obj_helper_SPEC_CV_TMP(binary_op, execute_data );
   break;
  case 147: {
    zval **container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var );

    if ((1<<4) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
     zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
    } else if (__builtin_expect((**container).type == 5, 0)) {
     if ((1<<4) == (1<<2) && !0) {
      zval_addref_p(*(container));
     }
     return zend_binary_assign_op_obj_helper_SPEC_CV_TMP(binary_op, execute_data );
    } else {
     zval *dim = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );

     zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)), container, dim, (1<<1), 2 );
     value = _get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, &free_op_data1, 0 );
     var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data->Ts, &free_op_data2 );
    }
   }
   break;
  default:
   value = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );
   var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var );

   break;
 }

 if (__builtin_expect(var_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use assign-op operators with overloaded objects nor string offsets");
 }

 if (__builtin_expect(*var_ptr == &(executor_globals.error_zval), 0)) {
  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }
  _zval_dtor((free_op2.var) );

  ;
  if (opline->extended_value == 147) {
   execute_data->opline++;
  }
  execute_data->opline++; return 0;
 }

 if (!zval_isref_p(*var_ptr)) { do { if (zval_refcount_p(*((var_ptr))) > 1) { zval *new_zv; zval_delref_p(*(var_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(var_ptr))->value; (*new_zv).type = (**(var_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(var_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

 if (__builtin_expect((**var_ptr).type == 5, 0)
    && ((**var_ptr)).value.obj.handlers->get
    && ((**var_ptr)).value.obj.handlers->set) {

  zval *objval = ((**var_ptr)).value.obj.handlers->get(*var_ptr );
  zval_addref_p(objval);
  binary_op(objval, objval, value );
  ((**var_ptr)).value.obj.handlers->set(var_ptr, objval );
  i_zval_ptr_dtor(*(&objval) );
 } else {
  binary_op(*var_ptr, *var_ptr, value );
 }

 if ((!((opline)->result_type & (1<<5)))) {
  zval_addref_p((*var_ptr));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (*var_ptr); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
 }
 _zval_dtor((free_op2.var) );

 if (opline->extended_value == 147) {
  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };
  if (free_op_data2.var) { i_zval_ptr_dtor(*(&free_op_data2.var) ); };

  ;
  execute_data->opline++;
 } else {

  ;
 }
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_ADD_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_TMP(add_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SUB_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_TMP(sub_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_MUL_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_TMP(mul_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_DIV_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_TMP(div_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_MOD_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_TMP(mod_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SL_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_TMP(shift_left_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SR_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_TMP(shift_right_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_CONCAT_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_TMP(concat_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_OR_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_TMP(bitwise_or_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_AND_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_TMP(bitwise_and_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_XOR_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_TMP(bitwise_xor_function, execute_data );
}

static int __attribute__((fastcall)) zend_pre_incdec_property_helper_SPEC_CV_TMP(incdec_t incdec_op, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval **object_ptr;
 zval *object;
 zval *property;
 zval **retval;
 int have_get_ptr = 0;

 ;
 object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var );
 property = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );
 retval = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr;

 if ((1<<4) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot increment/decrement overloaded objects nor string offsets");
 }

 make_real_object(object_ptr );
 object = *object_ptr;

 if (__builtin_expect((*object).type != 5, 0)) {
  zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
  _zval_dtor((free_op2.var) );
  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   *retval = &(executor_globals.uninitialized_zval);
  }

  ;
  execute_data->opline++; return 0;
 }



 if (1) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }

 if ((*object).value.obj.handlers->get_property_ptr_ptr) {
  zval **zptr = (*object).value.obj.handlers->get_property_ptr_ptr(object, property, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
  if (zptr != ((void *)0)) {
   if (!zval_isref_p(*zptr)) { do { if (zval_refcount_p(*((zptr))) > 1) { zval *new_zv; zval_delref_p(*(zptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(zptr))->value; (*new_zv).type = (**(zptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(zptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

   have_get_ptr = 1;
   incdec_op(*zptr);
   if ((!((opline)->result_type & (1<<5)))) {
    *retval = *zptr;
    zval_addref_p((*retval));
   }
  }
 }

 if (!have_get_ptr) {
  if ((*object).value.obj.handlers->read_property && (*object).value.obj.handlers->write_property) {
   zval *z = (*object).value.obj.handlers->read_property(object, property, 0, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );

   if (__builtin_expect((*z).type == 5, 0) && (*z).value.obj.handlers->get) {
    zval *value = (*z).value.obj.handlers->get(z );

    if (zval_refcount_p(z) == 0) {
     if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); };
     _zval_dtor((z) );
     do { if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); }; _efree((z) ); } while (0);
    }
    z = value;
   }
   zval_addref_p(z);
   if (!zval_isref_p(*&z)) { do { if (zval_refcount_p(*((&z))) > 1) { zval *new_zv; zval_delref_p(*(&z)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(&z))->value; (*new_zv).type = (**(&z)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(&z) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
   incdec_op(z);
   *retval = z;
   (*object).value.obj.handlers->write_property(object, property, z, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   if ((!((opline)->result_type & (1<<5)))) { zval_addref_p((*retval)); };
   i_zval_ptr_dtor(*(&z) );
  } else {
   zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
   if ((!((opline)->result_type & (1<<5)))) {
    zval_addref_p((&(executor_globals.uninitialized_zval)));
    *retval = &(executor_globals.uninitialized_zval);
   }
  }
 }

 if (1) {
  i_zval_ptr_dtor(*(&property) );
 } else {
  _zval_dtor((free_op2.var) );
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_PRE_INC_OBJ_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_pre_incdec_property_helper_SPEC_CV_TMP(increment_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_PRE_DEC_OBJ_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_pre_incdec_property_helper_SPEC_CV_TMP(decrement_function, execute_data );
}

static int __attribute__((fastcall)) zend_post_incdec_property_helper_SPEC_CV_TMP(incdec_t incdec_op, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval **object_ptr;
 zval *object;
 zval *property;
 zval *retval;
 int have_get_ptr = 0;

 ;
 object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var );
 property = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );
 retval = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 if ((1<<4) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot increment/decrement overloaded objects nor string offsets");
 }

 make_real_object(object_ptr );
 object = *object_ptr;

 if (__builtin_expect((*object).type != 5, 0)) {
  zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
  _zval_dtor((free_op2.var) );
  { (*retval).type = 0; };

  ;
  execute_data->opline++; return 0;
 }



 if (1) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }

 if ((*object).value.obj.handlers->get_property_ptr_ptr) {
  zval **zptr = (*object).value.obj.handlers->get_property_ptr_ptr(object, property, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
  if (zptr != ((void *)0)) {
   have_get_ptr = 1;
   if (!zval_isref_p(*zptr)) { do { if (zval_refcount_p(*((zptr))) > 1) { zval *new_zv; zval_delref_p(*(zptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(zptr))->value; (*new_zv).type = (**(zptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(zptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

   do { (retval)->value = (*zptr)->value; (*retval).type = (**zptr).type; } while (0);
   _zval_copy_ctor((&(*retval)) );

   incdec_op(*zptr);

  }
 }

 if (!have_get_ptr) {
  if ((*object).value.obj.handlers->read_property && (*object).value.obj.handlers->write_property) {
   zval *z = (*object).value.obj.handlers->read_property(object, property, 0, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   zval *z_copy;

   if (__builtin_expect((*z).type == 5, 0) && (*z).value.obj.handlers->get) {
    zval *value = (*z).value.obj.handlers->get(z );

    if (zval_refcount_p(z) == 0) {
     if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); };
     _zval_dtor((z) );
     do { if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); }; _efree((z) ); } while (0);
    }
    z = value;
   }
   do { (retval)->value = (z)->value; (*retval).type = (*z).type; } while (0);
   _zval_copy_ctor((&(*retval)) );
   do { (z_copy) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(z_copy))->u.buffered = ((void *)0); } while (0);
   do { do { (z_copy)->value = (z)->value; (*z_copy).type = (*z).type; } while (0); zval_set_refcount_p(z_copy, 1); zval_unset_isref_p(z_copy); } while (0);
   _zval_copy_ctor((&(*z_copy)) );
   incdec_op(z_copy);
   zval_addref_p(z);
   (*object).value.obj.handlers->write_property(object, property, z_copy, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   i_zval_ptr_dtor(*(&z_copy) );
   i_zval_ptr_dtor(*(&z) );
  } else {
   zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
   { (*retval).type = 0; };
  }
 }

 if (1) {
  i_zval_ptr_dtor(*(&property) );
 } else {
  _zval_dtor((free_op2.var) );
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_POST_INC_OBJ_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_post_incdec_property_helper_SPEC_CV_TMP(increment_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_POST_DEC_OBJ_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_post_incdec_property_helper_SPEC_CV_TMP(decrement_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_R_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval **container;

 ;

 if ((opline->extended_value & 0x08000000) &&
     (1<<4) != (1<<4) &&
     (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr) {
  zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr));
 }
 container = _get_zval_ptr_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );
 zend_fetch_dimension_address_read(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ), (1<<1), 0 );
 _zval_dtor((free_op2.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_W_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval **container;

 ;
 container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var );

 if ((1<<4) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ), (1<<1), 1 );
 _zval_dtor((free_op2.var) );
 if ((1<<4) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }


 if (__builtin_expect(opline->extended_value != 0, 0)) {
  zval **retval_ptr = (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr;

  if (retval_ptr) {
   zval_delref_p(*(retval_ptr));
   if (!zval_isref_p(*retval_ptr)) { do { if (zval_refcount_p(*((retval_ptr))) > 1) { zval *new_zv; zval_delref_p(*(retval_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval_ptr))->value; (*new_zv).type = (**(retval_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((retval_ptr))); };
   zval_addref_p(*(retval_ptr));
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_RW_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval **container;

 ;
 container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var );

 if ((1<<4) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ), (1<<1), 2 );
 _zval_dtor((free_op2.var) );
 if ((1<<4) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_IS_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval **container;

 ;
 container = _get_zval_ptr_ptr_cv_BP_VAR_IS(execute_data->CVs, opline->op1.var );
 zend_fetch_dimension_address_read(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ), (1<<1), 3 );
 _zval_dtor((free_op2.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval **container;

 ;

 if (((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && (opline->extended_value & 0x000fffff) <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[(opline->extended_value & 0x000fffff)-1].pass_by_reference & (1|2)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x1000000|0x2000000))))) {
  container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var );
  if ((1<<4) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
  }
  zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ), (1<<1), 1 );
  if ((1<<4) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
  }
 } else {
  if ((1<<1) == (1<<3)) {
   zend_error_noreturn((1<<0L), "Cannot use [] for reading");
  }
  container = _get_zval_ptr_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );
  zend_fetch_dimension_address_read(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ), (1<<1), 0 );
 }
 _zval_dtor((free_op2.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_UNSET_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval **container;

 ;
 container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data->CVs, opline->op1.var );

 if ((1<<4) == (1<<4)) {
  if (container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
 }
 if ((1<<4) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ), (1<<1), 6 );
 _zval_dtor((free_op2.var) );
 if ((1<<4) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }

 if (__builtin_expect((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot unset string offsets");
 } else {
  zend_free_op free_res;
  zval **retval_ptr = (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr;

  zend_pzval_unlock_func(*retval_ptr, &free_res, 1 );
  if (retval_ptr != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*retval_ptr)) { do { if (zval_refcount_p(*((retval_ptr))) > 1) { zval *new_zv; zval_delref_p(*(retval_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval_ptr))->value; (*new_zv).type = (**(retval_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
  zval_addref_p((*retval_ptr));
  if (free_res.var) { i_zval_ptr_dtor(*(&free_res.var) ); };
  ;
  execute_data->opline++; return 0;
 }
}

static int __attribute__((fastcall)) zend_fetch_property_address_read_helper_SPEC_CV_TMP(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *container;
 zend_free_op free_op2;
 zval *offset;

 ;
 container = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );
 offset = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );

 if (__builtin_expect((*container).type != 5, 0) ||
     __builtin_expect((*container).value.obj.handlers->read_property == ((void *)0), 0)) {
  zend_error((1<<3L), "Trying to get property of non-object");
  zval_addref_p((&(executor_globals.uninitialized_zval)));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  _zval_dtor((free_op2.var) );
 } else {
  zval *retval;

  if (1) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
  }


  retval = (*container).value.obj.handlers->read_property(container, offset, 0, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );

  zval_addref_p((retval));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);

  if (1) {
   i_zval_ptr_dtor(*(&offset) );
  } else {
   _zval_dtor((free_op2.var) );
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_R_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_property_address_read_helper_SPEC_CV_TMP(execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_W_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval *property;
 zval **container;

 ;
 property = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((1<<4) == (1<<2) && (opline->extended_value & 0x08000000)) {
  zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr));
  (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr = *(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr;
 }

 if (1) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }
 container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var );
 if ((1<<4) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }

 zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)), 1 );
 if (1) {
  i_zval_ptr_dtor(*(&property) );
 } else {
  _zval_dtor((free_op2.var) );
 }
 if ((1<<4) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }


 if (opline->extended_value & 0x04000000) {
  zval **retval_ptr = (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr;

  zval_delref_p(*(retval_ptr));
  if (!zval_isref_p(*retval_ptr)) { do { if (zval_refcount_p(*((retval_ptr))) > 1) { zval *new_zv; zval_delref_p(*(retval_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval_ptr))->value; (*new_zv).type = (**(retval_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((retval_ptr))); };
  zval_addref_p(*(retval_ptr));
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_RW_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval *property;
 zval **container;

 ;
 property = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );
 container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var );

 if (1) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }
 if ((1<<4) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }
 zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)), 2 );
 if (1) {
  i_zval_ptr_dtor(*(&property) );
 } else {
  _zval_dtor((free_op2.var) );
 }
 if ((1<<4) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_IS_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *container;
 zend_free_op free_op2;
 zval *offset;

 ;
 container = _get_zval_ptr_cv_BP_VAR_IS(execute_data->CVs, opline->op1.var );
 offset = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );

 if (__builtin_expect((*container).type != 5, 0) ||
     __builtin_expect((*container).value.obj.handlers->read_property == ((void *)0), 0)) {
  zval_addref_p((&(executor_globals.uninitialized_zval)));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  _zval_dtor((free_op2.var) );
 } else {
  zval *retval;

  if (1) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
  }


  retval = (*container).value.obj.handlers->read_property(container, offset, 3, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );

  zval_addref_p((retval));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);

  if (1) {
   i_zval_ptr_dtor(*(&offset) );
  } else {
   _zval_dtor((free_op2.var) );
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 if (((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && (opline->extended_value & 0x000fffff) <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[(opline->extended_value & 0x000fffff)-1].pass_by_reference & (1|2)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x1000000|0x2000000))))) {

  zend_free_op free_op1, free_op2;
  zval *property;
  zval **container;

  ;
  property = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );
  container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var );

  if (1) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
  }
  if ((1<<4) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
  }
  zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)), 1 );
  if (1) {
   i_zval_ptr_dtor(*(&property) );
  } else {
   _zval_dtor((free_op2.var) );
  }
  if ((1<<4) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
  }

  ;
  execute_data->opline++; return 0;
 } else {
  return zend_fetch_property_address_read_helper_SPEC_CV_TMP(execute_data );
 }
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_UNSET_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2, free_res;
 zval **container;
 zval *property;

 ;
 container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data->CVs, opline->op1.var );
 property = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((1<<4) == (1<<4)) {
  if (container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
 }
 if (1) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }
 if ((1<<4) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }
 zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)), 6 );
 if (1) {
  i_zval_ptr_dtor(*(&property) );
 } else {
  _zval_dtor((free_op2.var) );
 }
 if ((1<<4) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }

 zend_pzval_unlock_func(*(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr, &free_res, 1 );
 if ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr != &(executor_globals.uninitialized_zval_ptr)) {
  if (!zval_isref_p(*(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr)) { do { if (zval_refcount_p(*(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr))->value; (*new_zv).type = (**((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
 }
 zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr));
 if (free_res.var) { i_zval_ptr_dtor(*(&free_res.var) ); };
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_OBJ_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval **object_ptr;
 zval *property_name;

 ;
 object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var );
 property_name = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );

 if (1) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property_name))->value; (*_tmp).type = (*(property_name)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property_name) = _tmp; } while (0);
 }
 if ((1<<4) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 zend_assign_to_object((!((opline)->result_type & (1<<5)))?&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr:((void *)0), object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, 136, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
 if (1) {
  i_zval_ptr_dtor(*(&property_name) );
 } else {
  _zval_dtor((free_op2.var) );
 }


 ;
 execute_data->opline++;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_DIM_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval **object_ptr;

 ;
 object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var );

 if ((1<<4) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 if ((**object_ptr).type == 5) {
  zend_free_op free_op2;
  zval *property_name = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );

  if (1) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property_name))->value; (*_tmp).type = (*(property_name)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property_name) = _tmp; } while (0);
  }
  zend_assign_to_object((!((opline)->result_type & (1<<5)))?&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr:((void *)0), object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, 147, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
  if (1) {
   i_zval_ptr_dtor(*(&property_name) );
  } else {
   _zval_dtor((free_op2.var) );
  }
 } else {
  zend_free_op free_op2, free_op_data1, free_op_data2;
  zval *value;
  zval *dim = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );
  zval **variable_ptr_ptr;

  zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)), object_ptr, dim, (1<<1), 1 );
  _zval_dtor((free_op2.var) );

  value = _get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, &free_op_data1, 0 );
  variable_ptr_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data->Ts, &free_op_data2 );
  if (__builtin_expect(variable_ptr_ptr == ((void *)0), 0)) {
   if (zend_assign_to_string_offset(&(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)), value, (opline+1)->op1_type )) {
    if ((!((opline)->result_type & (1<<5)))) {
     zval *retval;

     do { (retval) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(retval))->u.buffered = ((void *)0); } while (0);
     do { const char *__s=((*(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)).str_offset.str).value.str.val+(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)).str_offset.offset); int __l=1; zval *__z = (retval); (*__z).value.str.len = __l; (*__z).value.str.val = (1?_estrndup((__s), (__l) ):(char*)__s); (*__z).type = 6; } while (0);
     (retval)->refcount__gc = 1; (retval)->is_ref__gc = 0;;
     do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
    }
   } else if ((!((opline)->result_type & (1<<5)))) {
    zval_addref_p((&(executor_globals.uninitialized_zval)));
    do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   }
  } else if (__builtin_expect(*variable_ptr_ptr == &(executor_globals.error_zval), 0)) {
   if (((zend_uintptr_t)free_op_data1.var & 1L)) {
    _zval_dtor((value) );
   }
   if ((!((opline)->result_type & (1<<5)))) {
    zval_addref_p((&(executor_globals.uninitialized_zval)));
    do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   }
  } else {
   if ((opline+1)->op1_type == (1<<1)) {
     value = zend_assign_tmp_to_variable(variable_ptr_ptr, value );
   } else if ((opline+1)->op1_type == (1<<0)) {
     value = zend_assign_const_to_variable(variable_ptr_ptr, value );
   } else {
     value = zend_assign_to_variable(variable_ptr_ptr, value );
   }
   if ((!((opline)->result_type & (1<<5)))) {
    zval_addref_p((value));
    do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (value); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   }
  }
  if (free_op_data2.var) { i_zval_ptr_dtor(*(&free_op_data2.var) ); };
   if (free_op_data1.var != ((void *)0) && (((zend_uintptr_t)free_op_data1.var & 1L) == 0)) { i_zval_ptr_dtor(*(&free_op_data1.var) ); };
 }


 ;
 execute_data->opline++;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval *value;
 zval **variable_ptr_ptr;

 ;
 value = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );
 variable_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var );

 if ((1<<4) == (1<<2) && __builtin_expect(variable_ptr_ptr == ((void *)0), 0)) {
  if (zend_assign_to_string_offset(&(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)), value, (1<<1) )) {
   if ((!((opline)->result_type & (1<<5)))) {
    zval *retval;

    do { (retval) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(retval))->u.buffered = ((void *)0); } while (0);
    do { const char *__s=((*(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).str_offset.str).value.str.val+(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).str_offset.offset); int __l=1; zval *__z = (retval); (*__z).value.str.len = __l; (*__z).value.str.val = (1?_estrndup((__s), (__l) ):(char*)__s); (*__z).type = 6; } while (0);
    (retval)->refcount__gc = 1; (retval)->is_ref__gc = 0;;
    do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   }
  } else if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }
 } else if ((1<<4) == (1<<2) && __builtin_expect(*variable_ptr_ptr == &(executor_globals.error_zval), 0)) {
  if (1) {
   _zval_dtor((value) );
  }
  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }
 } else {
  if ((1<<1) == (1<<1)) {
    value = zend_assign_tmp_to_variable(variable_ptr_ptr, value );
  } else if ((1<<1) == (1<<0)) {
    value = zend_assign_const_to_variable(variable_ptr_ptr, value );
  } else {
    value = zend_assign_to_variable(variable_ptr_ptr, value );
  }
  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((value));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (value); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }
 }



 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_METHOD_CALL_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *function_name;
 char *function_name_strval;
 int function_name_strlen;
 zend_free_op free_op2;

 ;
 zend_ptr_stack_3_push(&(executor_globals.arg_types_stack), execute_data->fbc, execute_data->object, execute_data->called_scope);

 function_name = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((1<<1) != (1<<0) &&
     __builtin_expect((*function_name).type != 6, 0)) {
  zend_error_noreturn((1<<0L), "Method name must be a string");
 }

 function_name_strval = (*function_name).value.str.val;
 function_name_strlen = (*function_name).value.str.len;

 execute_data->object = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );

 if (__builtin_expect(execute_data->object != ((void *)0), 1) &&
     __builtin_expect((*execute_data->object).type == 5, 1)) {
  execute_data->called_scope = zend_get_class_entry(&(*execute_data->object) );

  if ((1<<1) != (1<<0) ||
      (execute_data->fbc = (((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] == (execute_data->called_scope)) ? (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] : ((void *)0))) == ((void *)0)) {
      zval *object = execute_data->object;

   if (__builtin_expect((*execute_data->object).value.obj.handlers->get_method == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Object does not support method calls");
   }


   execute_data->fbc = (*execute_data->object).value.obj.handlers->get_method(&execute_data->object, function_name_strval, function_name_strlen, (((1<<1) == (1<<0)) ? (opline->op2.literal + 1) : ((void *)0)) );
   if (__builtin_expect(execute_data->fbc == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Call to undefined method %s::%s()", ((execute_data->object) && (*execute_data->object).type == 5 && (*execute_data->object).value.obj.handlers->get_class_entry != ((void *)0) && (*execute_data->object).value.obj.handlers->get_class_entry(execute_data->object ) ? (*execute_data->object).value.obj.handlers->get_class_entry(execute_data->object )->name : ""), function_name_strval);
   }
   if ((1<<1) == (1<<0) &&
       __builtin_expect((execute_data->fbc->common.fn_flags & 0x200000) == 0, 1) &&
       __builtin_expect(execute_data->object == object, 1)) {
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (execute_data->called_scope); (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] = (execute_data->fbc); } while (0);
   }
  }
 } else {
  zend_error_noreturn((1<<0L), "Call to a member function %s() on a non-object", function_name_strval);
 }

 if ((execute_data->fbc->common.fn_flags & 0x01) != 0) {
  execute_data->object = ((void *)0);
 } else {
  if (!zval_isref_p(execute_data->object)) {
   zval_addref_p(execute_data->object);
  } else {
   zval *this_ptr;
   do { (this_ptr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(this_ptr))->u.buffered = ((void *)0); } while (0);
   do { do { (this_ptr)->value = (execute_data->object)->value; (*this_ptr).type = (*execute_data->object).type; } while (0); zval_set_refcount_p(this_ptr, 1); zval_unset_isref_p(this_ptr); } while (0);
   _zval_copy_ctor((this_ptr) );
   execute_data->object = this_ptr;
  }
 }

 _zval_dtor((free_op2.var) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_CASE_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 if ((1<<4)==(1<<2)) {
  zval_addref_p(((*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr));
 }
 is_equal_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
     _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
     _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 ) );

 _zval_dtor((free_op2.var) );
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *expr_ptr;

 ;
 if (((1<<4) == (1<<2) || (1<<4) == (1<<4)) && opline->extended_value) {
  zval **expr_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var );

  if ((1<<4) == (1<<2) && __builtin_expect(expr_ptr_ptr == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot create references to/from string offsets");
  }
  if (!zval_isref_p(*expr_ptr_ptr)) { do { if (zval_refcount_p(*((expr_ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(expr_ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(expr_ptr_ptr))->value; (*new_zv).type = (**(expr_ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(expr_ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((expr_ptr_ptr))); };
  expr_ptr = *expr_ptr_ptr;
  zval_addref_p(expr_ptr);
 } else {
  expr_ptr=_get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );
  if (0) {
   zval *new_expr;

   do { (new_expr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_expr))->u.buffered = ((void *)0); } while (0);
   do { do { (new_expr)->value = (expr_ptr)->value; (*new_expr).type = (*expr_ptr).type; } while (0); zval_set_refcount_p(new_expr, 1); zval_unset_isref_p(new_expr); } while (0);
   expr_ptr = new_expr;
  } else if ((1<<4) == (1<<0) || zval_isref_p(expr_ptr)) {
   zval *new_expr;

   do { (new_expr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_expr))->u.buffered = ((void *)0); } while (0);
   do { do { (new_expr)->value = (expr_ptr)->value; (*new_expr).type = (*expr_ptr).type; } while (0); zval_set_refcount_p(new_expr, 1); zval_unset_isref_p(new_expr); } while (0);
   expr_ptr = new_expr;
   _zval_copy_ctor((&(*expr_ptr)) );
  } else {
   zval_addref_p(expr_ptr);
  }
 }

 if ((1<<1) != (1<<3)) {
  zend_free_op free_op2;
  zval *offset = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );
  ulong hval;

  switch ((*offset).type) {
   case 2:
    hval = zend_dval_to_lval((*offset).value.dval);
    goto num_index;
   case 1:
   case 3:
    hval = (*offset).value.lval;
num_index:
    _zend_hash_index_update_or_next_insert(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, hval, &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   case 6:
    if ((1<<1) == (1<<0)) {
     hval = (((zend_literal*)(offset))->hash_value);
    } else {
     do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index; } } } while (0);
     if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
      hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
     } else {
      hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
     }
    }
    _zend_hash_quick_add_or_update(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   case 0:
    _zend_hash_add_or_update(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, "", sizeof(""), &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   default:
    zend_error((1<<1L), "Illegal offset type");
    i_zval_ptr_dtor(*(&expr_ptr) );

    break;
  }
  _zval_dtor((free_op2.var) );
 } else {
  _zend_hash_index_update_or_next_insert(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, 0, &expr_ptr, sizeof(zval *), ((void *)0), (1<<2) );
 }
 if (((1<<4) == (1<<2) || (1<<4) == (1<<4)) && opline->extended_value) {

 } else {

 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_ARRAY_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 _array_init((&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var), 0 );
 if ((1<<4) == (1<<3)) {
  execute_data->opline++; return 0;

 } else {
  return ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_TMP_HANDLER(execute_data );

 }
}

static int __attribute__((fastcall)) ZEND_UNSET_DIM_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval **container;
 zval *offset;
 ulong hval;

 ;
 container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data->CVs, opline->op1.var );
 offset = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((1<<4) != (1<<2) || container) {
  if ((1<<4) == (1<<4) && container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
  switch ((**container).type) {
   case 4: {
    HashTable *ht = (**container).value.ht;

    switch ((*offset).type) {
     case 2:
      hval = zend_dval_to_lval((*offset).value.dval);
      goto num_index_dim;
     case 7:
     case 3:
     case 1:
num_index_dim:
      hval = (*offset).value.lval;
      zend_hash_del_key_or_index(ht, ((void *)0), 0, hval, 1);
      break;
     case 6:
      if ((1<<1) == (1<<4) || (1<<1) == (1<<2)) {
       zval_addref_p(offset);
      }
      if ((1<<1) == (1<<0)) {
       hval = (((zend_literal*)(offset))->hash_value);
      } else {
       do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index_dim; } } } while (0);
       if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
        hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
       } else {
        hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
       }
      }
      if (ht == &(executor_globals.symbol_table)) {
       zend_delete_global_variable_ex(offset->value.str.val, offset->value.str.len, hval );
      } else {
       zend_hash_del_key_or_index(ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, 2);
      }
      if ((1<<1) == (1<<4) || (1<<1) == (1<<2)) {
       i_zval_ptr_dtor(*(&offset) );
      }
      break;
     case 0:
      zend_hash_del_key_or_index(ht, "", sizeof(""), 0, 0);
      break;
     default:
      zend_error((1<<1L), "Illegal offset type in unset");
      break;
    }
    _zval_dtor((free_op2.var) );
    break;
   }
   case 5:
    if (__builtin_expect((**container).value.obj.handlers->unset_dimension == ((void *)0), 0)) {
     zend_error_noreturn((1<<0L), "Cannot use object as array");
    }
    if (1) {
     do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
    }
    (**container).value.obj.handlers->unset_dimension(*container, offset );
    if (1) {
     i_zval_ptr_dtor(*(&offset) );
    } else {
     _zval_dtor((free_op2.var) );
    }
    break;
   case 6:
    zend_error_noreturn((1<<0L), "Cannot unset string offsets");
    return 0;
   default:
    _zval_dtor((free_op2.var) );
    break;
  }
 } else {
  _zval_dtor((free_op2.var) );
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_UNSET_OBJ_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval **container;
 zval *offset;

 ;
 container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data->CVs, opline->op1.var );
 offset = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((1<<4) != (1<<2) || container) {
  if ((1<<4) == (1<<4) && container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
  if ((**container).type == 5) {
   if (1) {
    do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
   }
   if ((**container).value.obj.handlers->unset_property) {
    (**container).value.obj.handlers->unset_property(*container, offset, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   } else {
    zend_error((1<<3L), "Trying to unset property of non-object");
   }
   if (1) {
    i_zval_ptr_dtor(*(&offset) );
   } else {
    _zval_dtor((free_op2.var) );
   }
  } else {
   _zval_dtor((free_op2.var) );
  }
 } else {
  _zval_dtor((free_op2.var) );
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_TMP(int prop_dim, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval **container;
 zval **value = ((void *)0);
 int result = 0;
 ulong hval;
 zval *offset;

 ;
 container = _get_zval_ptr_ptr_cv_BP_VAR_IS(execute_data->CVs, opline->op1.var );

 offset = _get_zval_ptr_tmp(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((**container).type == 4 && !prop_dim) {
  HashTable *ht;
  int isset = 0;

  ht = (**container).value.ht;

  switch ((*offset).type) {
   case 2:
    hval = zend_dval_to_lval((*offset).value.dval);
    goto num_index_prop;
   case 7:
   case 3:
   case 1:
    hval = (*offset).value.lval;
num_index_prop:
    if (zend_hash_index_find(ht, hval, (void **) &value) == 0) {
     isset = 1;
    }
    break;
   case 6:
    if ((1<<1) == (1<<0)) {
     hval = (((zend_literal*)(offset))->hash_value);
    } else {
     if (!prop_dim) {
      do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index_prop; } } } while (0);
     }
     if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
      hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
     } else {
      hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
     }
    }
    if (zend_hash_quick_find(ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, (void **) &value) == 0) {
     isset = 1;
    }
    break;
   case 0:
    if (zend_hash_find(ht, "", sizeof(""), (void **) &value) == 0) {
     isset = 1;
    }
    break;
   default:
    zend_error((1<<1L), "Illegal offset type in isset or empty");
    break;
  }

  if (opline->extended_value & 0x02000000) {
   if (isset && (**value).type == 0) {
    result = 0;
   } else {
    result = isset;
   }
  } else {
   if (!isset || !i_zend_is_true(*value)) {
    result = 0;
   } else {
    result = 1;
   }
  }
  _zval_dtor((free_op2.var) );
 } else if ((**container).type == 5) {
  if (1) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
  }
  if (prop_dim) {
   if ((**container).value.obj.handlers->has_property) {
    result = (**container).value.obj.handlers->has_property(*container, offset, (opline->extended_value & 0x01000000) != 0, (((1<<1) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   } else {
    zend_error((1<<3L), "Trying to check property of non-object");
    result = 0;
   }
  } else {
   if ((**container).value.obj.handlers->has_dimension) {
    result = (**container).value.obj.handlers->has_dimension(*container, offset, (opline->extended_value & 0x01000000) != 0 );
   } else {
    zend_error((1<<3L), "Trying to check element of non-array");
    result = 0;
   }
  }
  if (1) {
   i_zval_ptr_dtor(*(&offset) );
  } else {
   _zval_dtor((free_op2.var) );
  }
 } else if ((*container)->type == 6 && !prop_dim) {
  zval tmp;

  if ((*offset).type != 1) {
   do { (&tmp)->value = (offset)->value; (*&tmp).type = (*offset).type; } while (0);
   _zval_copy_ctor((&tmp) );
   convert_to_long(&tmp);
   offset = &tmp;
  }
  if ((*offset).type == 1) {
   if (opline->extended_value & 0x02000000) {
    if (offset->value.lval >= 0 && offset->value.lval < (**container).value.str.len) {
     result = 1;
    }
   } else {
    if (offset->value.lval >= 0 && offset->value.lval < (**container).value.str.len && (**container).value.str.val[offset->value.lval] != '0') {
     result = 1;
    }
   }
  }
  _zval_dtor((free_op2.var) );
 } else {
  _zval_dtor((free_op2.var) );
 }

 ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).type = 3;
 if (opline->extended_value & 0x02000000) {
  ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.lval = result;
 } else {
  ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.lval = !result;
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_TMP(0, execute_data );
}

static int __attribute__((fastcall)) ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_TMP_HANDLER(zend_execute_data *execute_data )
{
 return zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_TMP(1, execute_data );
}

static int __attribute__((fastcall)) ZEND_ADD_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 add_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SUB_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 sub_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_MUL_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 mul_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_DIV_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 div_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_MOD_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 mod_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SL_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 shift_left_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SR_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 shift_right_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_CONCAT_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 concat_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_IDENTICAL_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 is_identical_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_NOT_IDENTICAL_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 is_identical_function(result,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 (*result).value.lval = !(*result).value.lval;

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_EQUAL_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval == 0)) != 0); (*__z).type = 3; } while (0);

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_NOT_EQUAL_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval != 0)) != 0); (*__z).type = 3; } while (0);

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_SMALLER_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval < 0)) != 0); (*__z).type = 3; } while (0);

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval <= 0)) != 0); (*__z).type = 3; } while (0);

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_OR_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 bitwise_or_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_AND_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 bitwise_and_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_XOR_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 bitwise_xor_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BOOL_XOR_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 boolean_xor_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_binary_assign_op_obj_helper_SPEC_CV_VAR(int (*binary_op)(zval *result, zval *op1, zval *op2 ), zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2, free_op_data1;
 zval **object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var );
 zval *object;
 zval *property = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );
 zval *value = _get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, &free_op_data1, 0 );
 int have_get_ptr = 0;

 if ((1<<4) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }

 make_real_object(object_ptr );
 object = *object_ptr;

 if (__builtin_expect((*object).type != 5, 0)) {
  zend_error((1<<1L), "Attempt to assign property of non-object");
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };

  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = &(executor_globals.uninitialized_zval);
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
  }
 } else {

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
  }


  if (opline->extended_value == 136
   && (*object).value.obj.handlers->get_property_ptr_ptr) {
   zval **zptr = (*object).value.obj.handlers->get_property_ptr_ptr(object, property, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   if (zptr != ((void *)0)) {
    if (!zval_isref_p(*zptr)) { do { if (zval_refcount_p(*((zptr))) > 1) { zval *new_zv; zval_delref_p(*(zptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(zptr))->value; (*new_zv).type = (**(zptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(zptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

    have_get_ptr = 1;
    binary_op(*zptr, *zptr, value );
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((*zptr));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = *zptr;
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
   }
  }

  if (!have_get_ptr) {
   zval *z = ((void *)0);

   if (opline->extended_value == 136) {
    if ((*object).value.obj.handlers->read_property) {
     z = (*object).value.obj.handlers->read_property(object, property, 0, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
    }
   } else {
    if ((*object).value.obj.handlers->read_dimension) {
     z = (*object).value.obj.handlers->read_dimension(object, property, 0 );
    }
   }
   if (z) {
    if ((*z).type == 5 && (*z).value.obj.handlers->get) {
     zval *value = (*z).value.obj.handlers->get(z );

     if (zval_refcount_p(z) == 0) {
      if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); };
      _zval_dtor((z) );
      do { if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); }; _efree((z) ); } while (0);
     }
     z = value;
    }
    zval_addref_p(z);
    if (!zval_isref_p(*&z)) { do { if (zval_refcount_p(*((&z))) > 1) { zval *new_zv; zval_delref_p(*(&z)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(&z))->value; (*new_zv).type = (**(&z)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(&z) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
    binary_op(z, z, value );
    if (opline->extended_value == 136) {
     (*object).value.obj.handlers->write_property(object, property, z, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
    } else {
     (*object).value.obj.handlers->write_dimension(object, property, z );
    }
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((z));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = z;
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
    i_zval_ptr_dtor(*(&z) );
   } else {
    zend_error((1<<1L), "Attempt to assign property of non-object");
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((&(executor_globals.uninitialized_zval)));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = &(executor_globals.uninitialized_zval);
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
   }
  }

  if (0) {
   i_zval_ptr_dtor(*(&property) );
  } else {
   if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
  }
  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };
 }


 ;
 execute_data->opline++;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_binary_assign_op_helper_SPEC_CV_VAR(int (*binary_op)(zval *result, zval *op1, zval *op2 ), zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2, free_op_data2, free_op_data1;
 zval **var_ptr;
 zval *value;

 ;
 switch (opline->extended_value) {
  case 136:
   return zend_binary_assign_op_obj_helper_SPEC_CV_VAR(binary_op, execute_data );
   break;
  case 147: {
    zval **container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var );

    if ((1<<4) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
     zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
    } else if (__builtin_expect((**container).type == 5, 0)) {
     if ((1<<4) == (1<<2) && !0) {
      zval_addref_p(*(container));
     }
     return zend_binary_assign_op_obj_helper_SPEC_CV_VAR(binary_op, execute_data );
    } else {
     zval *dim = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );

     zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)), container, dim, (1<<2), 2 );
     value = _get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, &free_op_data1, 0 );
     var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data->Ts, &free_op_data2 );
    }
   }
   break;
  default:
   value = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );
   var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var );

   break;
 }

 if (__builtin_expect(var_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use assign-op operators with overloaded objects nor string offsets");
 }

 if (__builtin_expect(*var_ptr == &(executor_globals.error_zval), 0)) {
  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};

  ;
  if (opline->extended_value == 147) {
   execute_data->opline++;
  }
  execute_data->opline++; return 0;
 }

 if (!zval_isref_p(*var_ptr)) { do { if (zval_refcount_p(*((var_ptr))) > 1) { zval *new_zv; zval_delref_p(*(var_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(var_ptr))->value; (*new_zv).type = (**(var_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(var_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

 if (__builtin_expect((**var_ptr).type == 5, 0)
    && ((**var_ptr)).value.obj.handlers->get
    && ((**var_ptr)).value.obj.handlers->set) {

  zval *objval = ((**var_ptr)).value.obj.handlers->get(*var_ptr );
  zval_addref_p(objval);
  binary_op(objval, objval, value );
  ((**var_ptr)).value.obj.handlers->set(var_ptr, objval );
  i_zval_ptr_dtor(*(&objval) );
 } else {
  binary_op(*var_ptr, *var_ptr, value );
 }

 if ((!((opline)->result_type & (1<<5)))) {
  zval_addref_p((*var_ptr));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (*var_ptr); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
 }
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};

 if (opline->extended_value == 147) {
  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };
  if (free_op_data2.var) { i_zval_ptr_dtor(*(&free_op_data2.var) ); };

  ;
  execute_data->opline++;
 } else {

  ;
 }
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_ADD_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_VAR(add_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SUB_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_VAR(sub_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_MUL_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_VAR(mul_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_DIV_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_VAR(div_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_MOD_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_VAR(mod_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SL_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_VAR(shift_left_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SR_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_VAR(shift_right_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_CONCAT_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_VAR(concat_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_OR_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_VAR(bitwise_or_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_AND_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_VAR(bitwise_and_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_XOR_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_VAR(bitwise_xor_function, execute_data );
}

static int __attribute__((fastcall)) zend_pre_incdec_property_helper_SPEC_CV_VAR(incdec_t incdec_op, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval **object_ptr;
 zval *object;
 zval *property;
 zval **retval;
 int have_get_ptr = 0;

 ;
 object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var );
 property = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );
 retval = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr;

 if ((1<<4) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot increment/decrement overloaded objects nor string offsets");
 }

 make_real_object(object_ptr );
 object = *object_ptr;

 if (__builtin_expect((*object).type != 5, 0)) {
  zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   *retval = &(executor_globals.uninitialized_zval);
  }

  ;
  execute_data->opline++; return 0;
 }



 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }

 if ((*object).value.obj.handlers->get_property_ptr_ptr) {
  zval **zptr = (*object).value.obj.handlers->get_property_ptr_ptr(object, property, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
  if (zptr != ((void *)0)) {
   if (!zval_isref_p(*zptr)) { do { if (zval_refcount_p(*((zptr))) > 1) { zval *new_zv; zval_delref_p(*(zptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(zptr))->value; (*new_zv).type = (**(zptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(zptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

   have_get_ptr = 1;
   incdec_op(*zptr);
   if ((!((opline)->result_type & (1<<5)))) {
    *retval = *zptr;
    zval_addref_p((*retval));
   }
  }
 }

 if (!have_get_ptr) {
  if ((*object).value.obj.handlers->read_property && (*object).value.obj.handlers->write_property) {
   zval *z = (*object).value.obj.handlers->read_property(object, property, 0, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );

   if (__builtin_expect((*z).type == 5, 0) && (*z).value.obj.handlers->get) {
    zval *value = (*z).value.obj.handlers->get(z );

    if (zval_refcount_p(z) == 0) {
     if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); };
     _zval_dtor((z) );
     do { if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); }; _efree((z) ); } while (0);
    }
    z = value;
   }
   zval_addref_p(z);
   if (!zval_isref_p(*&z)) { do { if (zval_refcount_p(*((&z))) > 1) { zval *new_zv; zval_delref_p(*(&z)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(&z))->value; (*new_zv).type = (**(&z)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(&z) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
   incdec_op(z);
   *retval = z;
   (*object).value.obj.handlers->write_property(object, property, z, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   if ((!((opline)->result_type & (1<<5)))) { zval_addref_p((*retval)); };
   i_zval_ptr_dtor(*(&z) );
  } else {
   zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
   if ((!((opline)->result_type & (1<<5)))) {
    zval_addref_p((&(executor_globals.uninitialized_zval)));
    *retval = &(executor_globals.uninitialized_zval);
   }
  }
 }

 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_PRE_INC_OBJ_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_pre_incdec_property_helper_SPEC_CV_VAR(increment_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_PRE_DEC_OBJ_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_pre_incdec_property_helper_SPEC_CV_VAR(decrement_function, execute_data );
}

static int __attribute__((fastcall)) zend_post_incdec_property_helper_SPEC_CV_VAR(incdec_t incdec_op, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval **object_ptr;
 zval *object;
 zval *property;
 zval *retval;
 int have_get_ptr = 0;

 ;
 object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var );
 property = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );
 retval = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 if ((1<<4) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot increment/decrement overloaded objects nor string offsets");
 }

 make_real_object(object_ptr );
 object = *object_ptr;

 if (__builtin_expect((*object).type != 5, 0)) {
  zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
  { (*retval).type = 0; };

  ;
  execute_data->opline++; return 0;
 }



 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }

 if ((*object).value.obj.handlers->get_property_ptr_ptr) {
  zval **zptr = (*object).value.obj.handlers->get_property_ptr_ptr(object, property, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
  if (zptr != ((void *)0)) {
   have_get_ptr = 1;
   if (!zval_isref_p(*zptr)) { do { if (zval_refcount_p(*((zptr))) > 1) { zval *new_zv; zval_delref_p(*(zptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(zptr))->value; (*new_zv).type = (**(zptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(zptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

   do { (retval)->value = (*zptr)->value; (*retval).type = (**zptr).type; } while (0);
   _zval_copy_ctor((&(*retval)) );

   incdec_op(*zptr);

  }
 }

 if (!have_get_ptr) {
  if ((*object).value.obj.handlers->read_property && (*object).value.obj.handlers->write_property) {
   zval *z = (*object).value.obj.handlers->read_property(object, property, 0, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   zval *z_copy;

   if (__builtin_expect((*z).type == 5, 0) && (*z).value.obj.handlers->get) {
    zval *value = (*z).value.obj.handlers->get(z );

    if (zval_refcount_p(z) == 0) {
     if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); };
     _zval_dtor((z) );
     do { if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); }; _efree((z) ); } while (0);
    }
    z = value;
   }
   do { (retval)->value = (z)->value; (*retval).type = (*z).type; } while (0);
   _zval_copy_ctor((&(*retval)) );
   do { (z_copy) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(z_copy))->u.buffered = ((void *)0); } while (0);
   do { do { (z_copy)->value = (z)->value; (*z_copy).type = (*z).type; } while (0); zval_set_refcount_p(z_copy, 1); zval_unset_isref_p(z_copy); } while (0);
   _zval_copy_ctor((&(*z_copy)) );
   incdec_op(z_copy);
   zval_addref_p(z);
   (*object).value.obj.handlers->write_property(object, property, z_copy, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   i_zval_ptr_dtor(*(&z_copy) );
   i_zval_ptr_dtor(*(&z) );
  } else {
   zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
   { (*retval).type = 0; };
  }
 }

 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_POST_INC_OBJ_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_post_incdec_property_helper_SPEC_CV_VAR(increment_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_POST_DEC_OBJ_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_post_incdec_property_helper_SPEC_CV_VAR(decrement_function, execute_data );
}

static int __attribute__((fastcall)) zend_fetch_var_address_helper_SPEC_CV_VAR(int type, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *varname;
 zval **retval;
 zval tmp_varname;
 HashTable *target_symbol_table;
 ulong hash_value;

 ;
 varname = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );

  if ((1<<4) != (1<<0) && __builtin_expect((*varname).type != 6, 0)) {
  do { (&tmp_varname)->value = (varname)->value; (*&tmp_varname).type = (*varname).type; } while (0);
  _zval_copy_ctor((&tmp_varname) );
  if ((&tmp_varname)->type != 6) { _convert_to_string((&tmp_varname) ); };
  varname = &tmp_varname;
 }

 if ((1<<2) != (1<<3)) {
  zend_class_entry *ce;

  if ((1<<2) == (1<<0)) {
   if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
    ce = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
   } else {
    ce = zend_fetch_class_by_name((*opline->op2.zv).value.str.val, (*opline->op2.zv).value.str.len, opline->op2.literal + 1, 0 );
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); } while (0);
   }
  } else {
   ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).class_entry;
  }
  retval = zend_std_get_static_property(ce, (*varname).value.str.val, (*varname).value.str.len, 0, (((1<<4) == (1<<0)) ? opline->op1.literal : ((void *)0)) );

 } else {
  target_symbol_table = zend_get_target_symbol_table(opline->extended_value & 0x70000000 );






  if ((1<<4) == (1<<0)) {
   hash_value = (((zend_literal*)(varname))->hash_value);
  } else if (((((*varname).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*varname).value.str.val) < (compiler_globals.interned_strings_end)))) {
   hash_value = (((Bucket*)(((char*)((*varname).value.str.val))-sizeof(Bucket)))->h);
  } else {
   hash_value = zend_hash_func((*varname).value.str.val, (*varname).value.str.len+1);
  }

  if (zend_hash_quick_find(target_symbol_table, (*varname).value.str.val, (*varname).value.str.len+1, hash_value, (void **) &retval) == -1) {
   switch (type) {
    case 0:
    case 6:
     zend_error((1<<3L),"Undefined variable: %s", (*varname).value.str.val);

    case 3:
     retval = &(executor_globals.uninitialized_zval_ptr);
     break;
    case 2:
     zend_error((1<<3L),"Undefined variable: %s", (*varname).value.str.val);

    case 1:
     zval_addref_p(&(executor_globals.uninitialized_zval));
     _zend_hash_quick_add_or_update(target_symbol_table, (*varname).value.str.val, (*varname).value.str.len+1, hash_value, &(executor_globals.uninitialized_zval_ptr), sizeof(zval *), (void **) &retval, (1<<0) );
     break;
   
   }
  }
  switch (opline->extended_value & 0x70000000) {
   case 0x00000000:
    if ((1<<4) != (1<<1)) {

    }
    break;
   case 0x10000000:

    break;
   case 0x20000000:
    zval_update_constant(retval, (void*) 1 );
    break;
   case 0x40000000:
    if ((1<<4) == (1<<2) && !free_op1.var) {
     zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr));
    }
    break;
  }
 }


 if ((1<<4) != (1<<0) && varname == &tmp_varname) {
  _zval_dtor((&tmp_varname) );
 }
 if (opline->extended_value & 0x04000000) {
  if (!zval_isref_p(*retval)) { do { if (zval_refcount_p(*((retval))) > 1) { zval *new_zv; zval_delref_p(*(retval)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval))->value; (*new_zv).type = (**(retval)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((retval))); };
 }
 zval_addref_p((*retval));
 switch (type) {
  case 0:
  case 3:
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (*retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   break;
  case 6: {
   zend_free_op free_res;

   zend_pzval_unlock_func(*retval, &free_res, 1 );
   if (retval != &(executor_globals.uninitialized_zval_ptr)) {
    if (!zval_isref_p(*retval)) { do { if (zval_refcount_p(*((retval))) > 1) { zval *new_zv; zval_delref_p(*(retval)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval))->value; (*new_zv).type = (**(retval)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
   }
   zval_addref_p((*retval));
   if (free_res.var) { i_zval_ptr_dtor(*(&free_res.var) ); };
  }

  default:
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = retval;
   break;
 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_R_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_CV_VAR(0, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_W_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_CV_VAR(1, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_RW_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_CV_VAR(2, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_FUNC_ARG_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 return zend_fetch_var_address_helper_SPEC_CV_VAR(((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && (opline->extended_value & 0x000fffff) <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[(opline->extended_value & 0x000fffff)-1].pass_by_reference & (1|2)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x1000000|0x2000000))))?1:0, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_UNSET_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_CV_VAR(6, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_IS_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_CV_VAR(3, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_R_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval **container;

 ;

 if ((opline->extended_value & 0x08000000) &&
     (1<<4) != (1<<4) &&
     (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr) {
  zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr));
 }
 container = _get_zval_ptr_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );
 zend_fetch_dimension_address_read(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ), (1<<2), 0 );
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_W_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval **container;

 ;
 container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var );

 if ((1<<4) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ), (1<<2), 1 );
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 if ((1<<4) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }


 if (__builtin_expect(opline->extended_value != 0, 0)) {
  zval **retval_ptr = (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr;

  if (retval_ptr) {
   zval_delref_p(*(retval_ptr));
   if (!zval_isref_p(*retval_ptr)) { do { if (zval_refcount_p(*((retval_ptr))) > 1) { zval *new_zv; zval_delref_p(*(retval_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval_ptr))->value; (*new_zv).type = (**(retval_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((retval_ptr))); };
   zval_addref_p(*(retval_ptr));
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_RW_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval **container;

 ;
 container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var );

 if ((1<<4) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ), (1<<2), 2 );
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 if ((1<<4) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_IS_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval **container;

 ;
 container = _get_zval_ptr_ptr_cv_BP_VAR_IS(execute_data->CVs, opline->op1.var );
 zend_fetch_dimension_address_read(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ), (1<<2), 3 );
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval **container;

 ;

 if (((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && (opline->extended_value & 0x000fffff) <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[(opline->extended_value & 0x000fffff)-1].pass_by_reference & (1|2)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x1000000|0x2000000))))) {
  container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var );
  if ((1<<4) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
  }
  zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ), (1<<2), 1 );
  if ((1<<4) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
  }
 } else {
  if ((1<<2) == (1<<3)) {
   zend_error_noreturn((1<<0L), "Cannot use [] for reading");
  }
  container = _get_zval_ptr_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );
  zend_fetch_dimension_address_read(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ), (1<<2), 0 );
 }
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_UNSET_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval **container;

 ;
 container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data->CVs, opline->op1.var );

 if ((1<<4) == (1<<4)) {
  if (container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
 }
 if ((1<<4) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ), (1<<2), 6 );
 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 if ((1<<4) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }

 if (__builtin_expect((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot unset string offsets");
 } else {
  zend_free_op free_res;
  zval **retval_ptr = (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr;

  zend_pzval_unlock_func(*retval_ptr, &free_res, 1 );
  if (retval_ptr != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*retval_ptr)) { do { if (zval_refcount_p(*((retval_ptr))) > 1) { zval *new_zv; zval_delref_p(*(retval_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval_ptr))->value; (*new_zv).type = (**(retval_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
  zval_addref_p((*retval_ptr));
  if (free_res.var) { i_zval_ptr_dtor(*(&free_res.var) ); };
  ;
  execute_data->opline++; return 0;
 }
}

static int __attribute__((fastcall)) zend_fetch_property_address_read_helper_SPEC_CV_VAR(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *container;
 zend_free_op free_op2;
 zval *offset;

 ;
 container = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );
 offset = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );

 if (__builtin_expect((*container).type != 5, 0) ||
     __builtin_expect((*container).value.obj.handlers->read_property == ((void *)0), 0)) {
  zend_error((1<<3L), "Trying to get property of non-object");
  zval_addref_p((&(executor_globals.uninitialized_zval)));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 } else {
  zval *retval;

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
  }


  retval = (*container).value.obj.handlers->read_property(container, offset, 0, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );

  zval_addref_p((retval));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);

  if (0) {
   i_zval_ptr_dtor(*(&offset) );
  } else {
   if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_R_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_property_address_read_helper_SPEC_CV_VAR(execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_W_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval *property;
 zval **container;

 ;
 property = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((1<<4) == (1<<2) && (opline->extended_value & 0x08000000)) {
  zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr));
  (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr = *(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr;
 }

 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }
 container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var );
 if ((1<<4) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }

 zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)), 1 );
 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 }
 if ((1<<4) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }


 if (opline->extended_value & 0x04000000) {
  zval **retval_ptr = (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr;

  zval_delref_p(*(retval_ptr));
  if (!zval_isref_p(*retval_ptr)) { do { if (zval_refcount_p(*((retval_ptr))) > 1) { zval *new_zv; zval_delref_p(*(retval_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval_ptr))->value; (*new_zv).type = (**(retval_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((retval_ptr))); };
  zval_addref_p(*(retval_ptr));
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_RW_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2;
 zval *property;
 zval **container;

 ;
 property = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );
 container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var );

 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }
 if ((1<<4) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }
 zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)), 2 );
 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 }
 if ((1<<4) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_IS_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *container;
 zend_free_op free_op2;
 zval *offset;

 ;
 container = _get_zval_ptr_cv_BP_VAR_IS(execute_data->CVs, opline->op1.var );
 offset = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );

 if (__builtin_expect((*container).type != 5, 0) ||
     __builtin_expect((*container).value.obj.handlers->read_property == ((void *)0), 0)) {
  zval_addref_p((&(executor_globals.uninitialized_zval)));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 } else {
  zval *retval;

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
  }


  retval = (*container).value.obj.handlers->read_property(container, offset, 3, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );

  zval_addref_p((retval));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);

  if (0) {
   i_zval_ptr_dtor(*(&offset) );
  } else {
   if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 if (((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && (opline->extended_value & 0x000fffff) <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[(opline->extended_value & 0x000fffff)-1].pass_by_reference & (1|2)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x1000000|0x2000000))))) {

  zend_free_op free_op1, free_op2;
  zval *property;
  zval **container;

  ;
  property = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );
  container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var );

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
  }
  if ((1<<4) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
  }
  zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)), 1 );
  if (0) {
   i_zval_ptr_dtor(*(&property) );
  } else {
   if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
  }
  if ((1<<4) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
  }

  ;
  execute_data->opline++; return 0;
 } else {
  return zend_fetch_property_address_read_helper_SPEC_CV_VAR(execute_data );
 }
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_UNSET_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_op2, free_res;
 zval **container;
 zval *property;

 ;
 container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data->CVs, opline->op1.var );
 property = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((1<<4) == (1<<4)) {
  if (container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
 }
 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }
 if ((1<<4) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }
 zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)), 6 );
 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 }
 if ((1<<4) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }

 zend_pzval_unlock_func(*(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr, &free_res, 1 );
 if ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr != &(executor_globals.uninitialized_zval_ptr)) {
  if (!zval_isref_p(*(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr)) { do { if (zval_refcount_p(*(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr))->value; (*new_zv).type = (**((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
 }
 zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr));
 if (free_res.var) { i_zval_ptr_dtor(*(&free_res.var) ); };
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_OBJ_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval **object_ptr;
 zval *property_name;

 ;
 object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var );
 property_name = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );

 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property_name))->value; (*_tmp).type = (*(property_name)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property_name) = _tmp; } while (0);
 }
 if ((1<<4) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 zend_assign_to_object((!((opline)->result_type & (1<<5)))?&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr:((void *)0), object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, 136, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
 if (0) {
  i_zval_ptr_dtor(*(&property_name) );
 } else {
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 }


 ;
 execute_data->opline++;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_DIM_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval **object_ptr;

 ;
 object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var );

 if ((1<<4) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 if ((**object_ptr).type == 5) {
  zend_free_op free_op2;
  zval *property_name = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property_name))->value; (*_tmp).type = (*(property_name)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property_name) = _tmp; } while (0);
  }
  zend_assign_to_object((!((opline)->result_type & (1<<5)))?&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr:((void *)0), object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, 147, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
  if (0) {
   i_zval_ptr_dtor(*(&property_name) );
  } else {
   if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
  }
 } else {
  zend_free_op free_op2, free_op_data1, free_op_data2;
  zval *value;
  zval *dim = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );
  zval **variable_ptr_ptr;

  zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)), object_ptr, dim, (1<<2), 1 );
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};

  value = _get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, &free_op_data1, 0 );
  variable_ptr_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data->Ts, &free_op_data2 );
  if (__builtin_expect(variable_ptr_ptr == ((void *)0), 0)) {
   if (zend_assign_to_string_offset(&(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)), value, (opline+1)->op1_type )) {
    if ((!((opline)->result_type & (1<<5)))) {
     zval *retval;

     do { (retval) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(retval))->u.buffered = ((void *)0); } while (0);
     do { const char *__s=((*(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)).str_offset.str).value.str.val+(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)).str_offset.offset); int __l=1; zval *__z = (retval); (*__z).value.str.len = __l; (*__z).value.str.val = (1?_estrndup((__s), (__l) ):(char*)__s); (*__z).type = 6; } while (0);
     (retval)->refcount__gc = 1; (retval)->is_ref__gc = 0;;
     do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
    }
   } else if ((!((opline)->result_type & (1<<5)))) {
    zval_addref_p((&(executor_globals.uninitialized_zval)));
    do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   }
  } else if (__builtin_expect(*variable_ptr_ptr == &(executor_globals.error_zval), 0)) {
   if (((zend_uintptr_t)free_op_data1.var & 1L)) {
    _zval_dtor((value) );
   }
   if ((!((opline)->result_type & (1<<5)))) {
    zval_addref_p((&(executor_globals.uninitialized_zval)));
    do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   }
  } else {
   if ((opline+1)->op1_type == (1<<1)) {
     value = zend_assign_tmp_to_variable(variable_ptr_ptr, value );
   } else if ((opline+1)->op1_type == (1<<0)) {
     value = zend_assign_const_to_variable(variable_ptr_ptr, value );
   } else {
     value = zend_assign_to_variable(variable_ptr_ptr, value );
   }
   if ((!((opline)->result_type & (1<<5)))) {
    zval_addref_p((value));
    do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (value); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   }
  }
  if (free_op_data2.var) { i_zval_ptr_dtor(*(&free_op_data2.var) ); };
   if (free_op_data1.var != ((void *)0) && (((zend_uintptr_t)free_op_data1.var & 1L) == 0)) { i_zval_ptr_dtor(*(&free_op_data1.var) ); };
 }


 ;
 execute_data->opline++;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval *value;
 zval **variable_ptr_ptr;

 ;
 value = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );
 variable_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var );

 if ((1<<4) == (1<<2) && __builtin_expect(variable_ptr_ptr == ((void *)0), 0)) {
  if (zend_assign_to_string_offset(&(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)), value, (1<<2) )) {
   if ((!((opline)->result_type & (1<<5)))) {
    zval *retval;

    do { (retval) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(retval))->u.buffered = ((void *)0); } while (0);
    do { const char *__s=((*(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).str_offset.str).value.str.val+(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).str_offset.offset); int __l=1; zval *__z = (retval); (*__z).value.str.len = __l; (*__z).value.str.val = (1?_estrndup((__s), (__l) ):(char*)__s); (*__z).type = 6; } while (0);
    (retval)->refcount__gc = 1; (retval)->is_ref__gc = 0;;
    do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   }
  } else if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }
 } else if ((1<<4) == (1<<2) && __builtin_expect(*variable_ptr_ptr == &(executor_globals.error_zval), 0)) {
  if (0) {
   _zval_dtor((value) );
  }
  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }
 } else {
  if ((1<<2) == (1<<1)) {
    value = zend_assign_tmp_to_variable(variable_ptr_ptr, value );
  } else if ((1<<2) == (1<<0)) {
    value = zend_assign_const_to_variable(variable_ptr_ptr, value );
  } else {
    value = zend_assign_to_variable(variable_ptr_ptr, value );
  }
  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((value));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (value); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }
 }


  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_REF_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval **variable_ptr_ptr;
 zval **value_ptr_ptr;

 ;
 value_ptr_ptr = _get_zval_ptr_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((1<<2) == (1<<2) &&
     value_ptr_ptr &&
     !zval_isref_p(*(value_ptr_ptr)) &&
     opline->extended_value == 1<<0 &&
     !(*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).var.fcall_returned_reference) {
  if (free_op2.var == ((void *)0)) {
   zval_addref_p((*value_ptr_ptr));
  }
  zend_error((1<<11L), "Only variables should be assigned by reference");
  if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {
   if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
   ; return 0;
  }
  return ZEND_ASSIGN_SPEC_CV_VAR_HANDLER(execute_data );
 } else if ((1<<2) == (1<<2) && opline->extended_value == 1<<1) {
  zval_addref_p((*value_ptr_ptr));
 }
 if ((1<<4) == (1<<2) && __builtin_expect((*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr == &(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr, 0)) {
  zend_error_noreturn((1<<0L), "Cannot assign by reference to overloaded object");
 }

 variable_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var );
 if (((1<<2) == (1<<2) && __builtin_expect(value_ptr_ptr == ((void *)0), 0)) ||
     ((1<<4) == (1<<2) && __builtin_expect(variable_ptr_ptr == ((void *)0), 0))) {
  zend_error_noreturn((1<<0L), "Cannot create references to/from string offsets nor overloaded objects");
 }
 zend_assign_to_variable_reference(variable_ptr_ptr, value_ptr_ptr );

 if ((1<<2) == (1<<2) && opline->extended_value == 1<<1) {
  zval_delref_p(*(variable_ptr_ptr));
 }

 if ((!((opline)->result_type & (1<<5)))) {
  zval_addref_p((*variable_ptr_ptr));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (*variable_ptr_ptr); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
 }

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_METHOD_CALL_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *function_name;
 char *function_name_strval;
 int function_name_strlen;
 zend_free_op free_op2;

 ;
 zend_ptr_stack_3_push(&(executor_globals.arg_types_stack), execute_data->fbc, execute_data->object, execute_data->called_scope);

 function_name = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((1<<2) != (1<<0) &&
     __builtin_expect((*function_name).type != 6, 0)) {
  zend_error_noreturn((1<<0L), "Method name must be a string");
 }

 function_name_strval = (*function_name).value.str.val;
 function_name_strlen = (*function_name).value.str.len;

 execute_data->object = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );

 if (__builtin_expect(execute_data->object != ((void *)0), 1) &&
     __builtin_expect((*execute_data->object).type == 5, 1)) {
  execute_data->called_scope = zend_get_class_entry(&(*execute_data->object) );

  if ((1<<2) != (1<<0) ||
      (execute_data->fbc = (((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] == (execute_data->called_scope)) ? (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] : ((void *)0))) == ((void *)0)) {
      zval *object = execute_data->object;

   if (__builtin_expect((*execute_data->object).value.obj.handlers->get_method == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Object does not support method calls");
   }


   execute_data->fbc = (*execute_data->object).value.obj.handlers->get_method(&execute_data->object, function_name_strval, function_name_strlen, (((1<<2) == (1<<0)) ? (opline->op2.literal + 1) : ((void *)0)) );
   if (__builtin_expect(execute_data->fbc == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Call to undefined method %s::%s()", ((execute_data->object) && (*execute_data->object).type == 5 && (*execute_data->object).value.obj.handlers->get_class_entry != ((void *)0) && (*execute_data->object).value.obj.handlers->get_class_entry(execute_data->object ) ? (*execute_data->object).value.obj.handlers->get_class_entry(execute_data->object )->name : ""), function_name_strval);
   }
   if ((1<<2) == (1<<0) &&
       __builtin_expect((execute_data->fbc->common.fn_flags & 0x200000) == 0, 1) &&
       __builtin_expect(execute_data->object == object, 1)) {
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (execute_data->called_scope); (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] = (execute_data->fbc); } while (0);
   }
  }
 } else {
  zend_error_noreturn((1<<0L), "Call to a member function %s() on a non-object", function_name_strval);
 }

 if ((execute_data->fbc->common.fn_flags & 0x01) != 0) {
  execute_data->object = ((void *)0);
 } else {
  if (!zval_isref_p(execute_data->object)) {
   zval_addref_p(execute_data->object);
  } else {
   zval *this_ptr;
   do { (this_ptr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(this_ptr))->u.buffered = ((void *)0); } while (0);
   do { do { (this_ptr)->value = (execute_data->object)->value; (*this_ptr).type = (*execute_data->object).type; } while (0); zval_set_refcount_p(this_ptr, 1); zval_unset_isref_p(this_ptr); } while (0);
   _zval_copy_ctor((this_ptr) );
   execute_data->object = this_ptr;
  }
 }

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_CASE_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;

 ;
 if ((1<<4)==(1<<2)) {
  zval_addref_p(((*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr));
 }
 is_equal_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
     _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
     _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 ) );

 if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *expr_ptr;

 ;
 if (((1<<4) == (1<<2) || (1<<4) == (1<<4)) && opline->extended_value) {
  zval **expr_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var );

  if ((1<<4) == (1<<2) && __builtin_expect(expr_ptr_ptr == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot create references to/from string offsets");
  }
  if (!zval_isref_p(*expr_ptr_ptr)) { do { if (zval_refcount_p(*((expr_ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(expr_ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(expr_ptr_ptr))->value; (*new_zv).type = (**(expr_ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(expr_ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((expr_ptr_ptr))); };
  expr_ptr = *expr_ptr_ptr;
  zval_addref_p(expr_ptr);
 } else {
  expr_ptr=_get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );
  if (0) {
   zval *new_expr;

   do { (new_expr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_expr))->u.buffered = ((void *)0); } while (0);
   do { do { (new_expr)->value = (expr_ptr)->value; (*new_expr).type = (*expr_ptr).type; } while (0); zval_set_refcount_p(new_expr, 1); zval_unset_isref_p(new_expr); } while (0);
   expr_ptr = new_expr;
  } else if ((1<<4) == (1<<0) || zval_isref_p(expr_ptr)) {
   zval *new_expr;

   do { (new_expr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_expr))->u.buffered = ((void *)0); } while (0);
   do { do { (new_expr)->value = (expr_ptr)->value; (*new_expr).type = (*expr_ptr).type; } while (0); zval_set_refcount_p(new_expr, 1); zval_unset_isref_p(new_expr); } while (0);
   expr_ptr = new_expr;
   _zval_copy_ctor((&(*expr_ptr)) );
  } else {
   zval_addref_p(expr_ptr);
  }
 }

 if ((1<<2) != (1<<3)) {
  zend_free_op free_op2;
  zval *offset = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );
  ulong hval;

  switch ((*offset).type) {
   case 2:
    hval = zend_dval_to_lval((*offset).value.dval);
    goto num_index;
   case 1:
   case 3:
    hval = (*offset).value.lval;
num_index:
    _zend_hash_index_update_or_next_insert(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, hval, &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   case 6:
    if ((1<<2) == (1<<0)) {
     hval = (((zend_literal*)(offset))->hash_value);
    } else {
     do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index; } } } while (0);
     if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
      hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
     } else {
      hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
     }
    }
    _zend_hash_quick_add_or_update(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   case 0:
    _zend_hash_add_or_update(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, "", sizeof(""), &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   default:
    zend_error((1<<1L), "Illegal offset type");
    i_zval_ptr_dtor(*(&expr_ptr) );

    break;
  }
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 } else {
  _zend_hash_index_update_or_next_insert(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, 0, &expr_ptr, sizeof(zval *), ((void *)0), (1<<2) );
 }
 if (((1<<4) == (1<<2) || (1<<4) == (1<<4)) && opline->extended_value) {

 } else {

 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_ARRAY_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 _array_init((&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var), 0 );
 if ((1<<4) == (1<<3)) {
  execute_data->opline++; return 0;

 } else {
  return ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_VAR_HANDLER(execute_data );

 }
}

static int __attribute__((fastcall)) ZEND_UNSET_VAR_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval tmp, *varname;
 HashTable *target_symbol_table;


 ;
 if ((1<<4) == (1<<4) &&
     (1<<2) == (1<<3) &&
     (opline->extended_value & 0x00800000)) {
  if ((executor_globals.active_symbol_table)) {
   zend_compiled_variable *cv = &((executor_globals.active_op_array)->vars[opline->op1.var]);

   zend_delete_variable(execute_data->prev_execute_data, (executor_globals.active_symbol_table), cv->name, cv->name_len+1, cv->hash_value );
   execute_data->CVs[opline->op1.var] = ((void *)0);
  } else if (execute_data->CVs[opline->op1.var]) {
   i_zval_ptr_dtor(*(execute_data->CVs[opline->op1.var]) );
   execute_data->CVs[opline->op1.var] = ((void *)0);
  }
  ;
  execute_data->opline++; return 0;
 }

 varname = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );

 if ((1<<4) != (1<<0) && (*varname).type != 6) {
  do { (&tmp)->value = (varname)->value; (*&tmp).type = (*varname).type; } while (0);
  _zval_copy_ctor((&tmp) );
  if ((&tmp)->type != 6) { _convert_to_string((&tmp) ); };
  varname = &tmp;
 } else if ((1<<4) == (1<<2) || (1<<4) == (1<<4)) {
  zval_addref_p(varname);
 }

 if ((1<<2) != (1<<3)) {
  zend_class_entry *ce;

  if ((1<<2) == (1<<0)) {
   if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
    ce = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
   } else {
    ce = zend_fetch_class_by_name((*opline->op2.zv).value.str.val, (*opline->op2.zv).value.str.len, opline->op2.literal + 1, 0 );
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); } while (0);
   }
  } else {
   ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).class_entry;
  }
  zend_std_unset_static_property(ce, (*varname).value.str.val, (*varname).value.str.len, (((1<<4) == (1<<0)) ? opline->op1.literal : ((void *)0)) );
 } else {
  ulong hash_value = zend_inline_hash_func(varname->value.str.val, varname->value.str.len+1);

  target_symbol_table = zend_get_target_symbol_table(opline->extended_value & 0x70000000 );
  zend_delete_variable(execute_data, target_symbol_table, varname->value.str.val, varname->value.str.len+1, hash_value );
 }

 if ((1<<4) != (1<<0) && varname == &tmp) {
  _zval_dtor((&tmp) );
 } else if ((1<<4) == (1<<2) || (1<<4) == (1<<4)) {
  i_zval_ptr_dtor(*(&varname) );
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_UNSET_DIM_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval **container;
 zval *offset;
 ulong hval;

 ;
 container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data->CVs, opline->op1.var );
 offset = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((1<<4) != (1<<2) || container) {
  if ((1<<4) == (1<<4) && container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
  switch ((**container).type) {
   case 4: {
    HashTable *ht = (**container).value.ht;

    switch ((*offset).type) {
     case 2:
      hval = zend_dval_to_lval((*offset).value.dval);
      goto num_index_dim;
     case 7:
     case 3:
     case 1:
num_index_dim:
      hval = (*offset).value.lval;
      zend_hash_del_key_or_index(ht, ((void *)0), 0, hval, 1);
      break;
     case 6:
      if ((1<<2) == (1<<4) || (1<<2) == (1<<2)) {
       zval_addref_p(offset);
      }
      if ((1<<2) == (1<<0)) {
       hval = (((zend_literal*)(offset))->hash_value);
      } else {
       do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index_dim; } } } while (0);
       if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
        hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
       } else {
        hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
       }
      }
      if (ht == &(executor_globals.symbol_table)) {
       zend_delete_global_variable_ex(offset->value.str.val, offset->value.str.len, hval );
      } else {
       zend_hash_del_key_or_index(ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, 2);
      }
      if ((1<<2) == (1<<4) || (1<<2) == (1<<2)) {
       i_zval_ptr_dtor(*(&offset) );
      }
      break;
     case 0:
      zend_hash_del_key_or_index(ht, "", sizeof(""), 0, 0);
      break;
     default:
      zend_error((1<<1L), "Illegal offset type in unset");
      break;
    }
    if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
    break;
   }
   case 5:
    if (__builtin_expect((**container).value.obj.handlers->unset_dimension == ((void *)0), 0)) {
     zend_error_noreturn((1<<0L), "Cannot use object as array");
    }
    if (0) {
     do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
    }
    (**container).value.obj.handlers->unset_dimension(*container, offset );
    if (0) {
     i_zval_ptr_dtor(*(&offset) );
    } else {
     if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
    }
    break;
   case 6:
    zend_error_noreturn((1<<0L), "Cannot unset string offsets");
    return 0;
   default:
    if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
    break;
  }
 } else {
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_UNSET_OBJ_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval **container;
 zval *offset;

 ;
 container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data->CVs, opline->op1.var );
 offset = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((1<<4) != (1<<2) || container) {
  if ((1<<4) == (1<<4) && container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
  if ((**container).type == 5) {
   if (0) {
    do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
   }
   if ((**container).value.obj.handlers->unset_property) {
    (**container).value.obj.handlers->unset_property(*container, offset, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   } else {
    zend_error((1<<3L), "Trying to unset property of non-object");
   }
   if (0) {
    i_zval_ptr_dtor(*(&offset) );
   } else {
    if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
   }
  } else {
   if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
  }
 } else {
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ISSET_ISEMPTY_VAR_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval **value;
 zend_bool isset = 1;

 ;
 if ((1<<4) == (1<<4) &&
     (1<<2) == (1<<3) &&
     (opline->extended_value & 0x00800000)) {
  if (execute_data->CVs[opline->op1.var]) {
   value = execute_data->CVs[opline->op1.var];
  } else if ((executor_globals.active_symbol_table)) {
   zend_compiled_variable *cv = &((executor_globals.active_op_array)->vars[opline->op1.var]);

   if (zend_hash_quick_find((executor_globals.active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, (void **) &value) == -1) {
    isset = 0;
   }
  } else {
   isset = 0;
  }
 } else {
  HashTable *target_symbol_table;

  zval tmp, *varname = _get_zval_ptr_cv_BP_VAR_IS(execute_data->CVs, opline->op1.var );

  if ((1<<4) != (1<<0) && (*varname).type != 6) {
   do { (&tmp)->value = (varname)->value; (*&tmp).type = (*varname).type; } while (0);
   _zval_copy_ctor((&tmp) );
   if ((&tmp)->type != 6) { _convert_to_string((&tmp) ); };
   varname = &tmp;
  }

  if ((1<<2) != (1<<3)) {
   zend_class_entry *ce;

   if ((1<<2) == (1<<0)) {
    if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
     ce = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
    } else {
     ce = zend_fetch_class_by_name((*opline->op2.zv).value.str.val, (*opline->op2.zv).value.str.len, opline->op2.literal + 1, 0 );
     do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); } while (0);
    }
   } else {
    ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).class_entry;
   }
   value = zend_std_get_static_property(ce, (*varname).value.str.val, (*varname).value.str.len, 1, (((1<<4) == (1<<0)) ? opline->op1.literal : ((void *)0)) );
   if (!value) {
    isset = 0;
   }
  } else {
   target_symbol_table = zend_get_target_symbol_table(opline->extended_value & 0x70000000 );
   if (zend_hash_find(target_symbol_table, varname->value.str.val, varname->value.str.len+1, (void **) &value) == -1) {
    isset = 0;
   }
  }

  if ((1<<4) != (1<<0) && varname == &tmp) {
   _zval_dtor((&tmp) );
  }

 }

 if (opline->extended_value & 0x02000000) {
  if (isset && (**value).type != 0) {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((1) != 0); (*__z).type = 3; } while (0);
  } else {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((0) != 0); (*__z).type = 3; } while (0);
  }
 } else {
  if (!isset || !i_zend_is_true(*value)) {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((1) != 0); (*__z).type = 3; } while (0);
  } else {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((0) != 0); (*__z).type = 3; } while (0);
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_VAR(int prop_dim, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval **container;
 zval **value = ((void *)0);
 int result = 0;
 ulong hval;
 zval *offset;

 ;
 container = _get_zval_ptr_ptr_cv_BP_VAR_IS(execute_data->CVs, opline->op1.var );

 offset = _get_zval_ptr_var(opline->op2.var, execute_data->Ts, &free_op2 );

 if ((**container).type == 4 && !prop_dim) {
  HashTable *ht;
  int isset = 0;

  ht = (**container).value.ht;

  switch ((*offset).type) {
   case 2:
    hval = zend_dval_to_lval((*offset).value.dval);
    goto num_index_prop;
   case 7:
   case 3:
   case 1:
    hval = (*offset).value.lval;
num_index_prop:
    if (zend_hash_index_find(ht, hval, (void **) &value) == 0) {
     isset = 1;
    }
    break;
   case 6:
    if ((1<<2) == (1<<0)) {
     hval = (((zend_literal*)(offset))->hash_value);
    } else {
     if (!prop_dim) {
      do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index_prop; } } } while (0);
     }
     if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
      hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
     } else {
      hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
     }
    }
    if (zend_hash_quick_find(ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, (void **) &value) == 0) {
     isset = 1;
    }
    break;
   case 0:
    if (zend_hash_find(ht, "", sizeof(""), (void **) &value) == 0) {
     isset = 1;
    }
    break;
   default:
    zend_error((1<<1L), "Illegal offset type in isset or empty");
    break;
  }

  if (opline->extended_value & 0x02000000) {
   if (isset && (**value).type == 0) {
    result = 0;
   } else {
    result = isset;
   }
  } else {
   if (!isset || !i_zend_is_true(*value)) {
    result = 0;
   } else {
    result = 1;
   }
  }
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 } else if ((**container).type == 5) {
  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
  }
  if (prop_dim) {
   if ((**container).value.obj.handlers->has_property) {
    result = (**container).value.obj.handlers->has_property(*container, offset, (opline->extended_value & 0x01000000) != 0, (((1<<2) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   } else {
    zend_error((1<<3L), "Trying to check property of non-object");
    result = 0;
   }
  } else {
   if ((**container).value.obj.handlers->has_dimension) {
    result = (**container).value.obj.handlers->has_dimension(*container, offset, (opline->extended_value & 0x01000000) != 0 );
   } else {
    zend_error((1<<3L), "Trying to check element of non-array");
    result = 0;
   }
  }
  if (0) {
   i_zval_ptr_dtor(*(&offset) );
  } else {
   if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
  }
 } else if ((*container)->type == 6 && !prop_dim) {
  zval tmp;

  if ((*offset).type != 1) {
   do { (&tmp)->value = (offset)->value; (*&tmp).type = (*offset).type; } while (0);
   _zval_copy_ctor((&tmp) );
   convert_to_long(&tmp);
   offset = &tmp;
  }
  if ((*offset).type == 1) {
   if (opline->extended_value & 0x02000000) {
    if (offset->value.lval >= 0 && offset->value.lval < (**container).value.str.len) {
     result = 1;
    }
   } else {
    if (offset->value.lval >= 0 && offset->value.lval < (**container).value.str.len && (**container).value.str.val[offset->value.lval] != '0') {
     result = 1;
    }
   }
  }
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 } else {
  if (free_op2.var) {i_zval_ptr_dtor(*(&free_op2.var) );};
 }

 ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).type = 3;
 if (opline->extended_value & 0x02000000) {
  ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.lval = result;
 } else {
  ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.lval = !result;
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_VAR(0, execute_data );
}

static int __attribute__((fastcall)) ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_VAR_HANDLER(zend_execute_data *execute_data )
{
 return zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_VAR(1, execute_data );
}

static int __attribute__((fastcall)) zend_binary_assign_op_obj_helper_SPEC_CV_UNUSED(int (*binary_op)(zval *result, zval *op1, zval *op2 ), zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op_data1;
 zval **object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var );
 zval *object;
 zval *property = ((void *)0);
 zval *value = _get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, &free_op_data1, 0 );
 int have_get_ptr = 0;

 if ((1<<4) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }

 make_real_object(object_ptr );
 object = *object_ptr;

 if (__builtin_expect((*object).type != 5, 0)) {
  zend_error((1<<1L), "Attempt to assign property of non-object");

  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };

  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = &(executor_globals.uninitialized_zval);
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
  }
 } else {

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
  }


  if (opline->extended_value == 136
   && (*object).value.obj.handlers->get_property_ptr_ptr) {
   zval **zptr = (*object).value.obj.handlers->get_property_ptr_ptr(object, property, (((1<<3) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   if (zptr != ((void *)0)) {
    if (!zval_isref_p(*zptr)) { do { if (zval_refcount_p(*((zptr))) > 1) { zval *new_zv; zval_delref_p(*(zptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(zptr))->value; (*new_zv).type = (**(zptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(zptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

    have_get_ptr = 1;
    binary_op(*zptr, *zptr, value );
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((*zptr));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = *zptr;
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
   }
  }

  if (!have_get_ptr) {
   zval *z = ((void *)0);

   if (opline->extended_value == 136) {
    if ((*object).value.obj.handlers->read_property) {
     z = (*object).value.obj.handlers->read_property(object, property, 0, (((1<<3) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
    }
   } else {
    if ((*object).value.obj.handlers->read_dimension) {
     z = (*object).value.obj.handlers->read_dimension(object, property, 0 );
    }
   }
   if (z) {
    if ((*z).type == 5 && (*z).value.obj.handlers->get) {
     zval *value = (*z).value.obj.handlers->get(z );

     if (zval_refcount_p(z) == 0) {
      if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); };
      _zval_dtor((z) );
      do { if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); }; _efree((z) ); } while (0);
     }
     z = value;
    }
    zval_addref_p(z);
    if (!zval_isref_p(*&z)) { do { if (zval_refcount_p(*((&z))) > 1) { zval *new_zv; zval_delref_p(*(&z)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(&z))->value; (*new_zv).type = (**(&z)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(&z) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
    binary_op(z, z, value );
    if (opline->extended_value == 136) {
     (*object).value.obj.handlers->write_property(object, property, z, (((1<<3) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
    } else {
     (*object).value.obj.handlers->write_dimension(object, property, z );
    }
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((z));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = z;
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
    i_zval_ptr_dtor(*(&z) );
   } else {
    zend_error((1<<1L), "Attempt to assign property of non-object");
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((&(executor_globals.uninitialized_zval)));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = &(executor_globals.uninitialized_zval);
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
   }
  }

  if (0) {
   i_zval_ptr_dtor(*(&property) );
  } else {

  }
  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };
 }


 ;
 execute_data->opline++;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_binary_assign_op_helper_SPEC_CV_UNUSED(int (*binary_op)(zval *result, zval *op1, zval *op2 ), zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op_data2, free_op_data1;
 zval **var_ptr;
 zval *value;

 ;
 switch (opline->extended_value) {
  case 136:
   return zend_binary_assign_op_obj_helper_SPEC_CV_UNUSED(binary_op, execute_data );
   break;
  case 147: {
    zval **container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var );

    if ((1<<4) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
     zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
    } else if (__builtin_expect((**container).type == 5, 0)) {
     if ((1<<4) == (1<<2) && !0) {
      zval_addref_p(*(container));
     }
     return zend_binary_assign_op_obj_helper_SPEC_CV_UNUSED(binary_op, execute_data );
    } else {
     zval *dim = ((void *)0);

     zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)), container, dim, (1<<3), 2 );
     value = _get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, &free_op_data1, 0 );
     var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data->Ts, &free_op_data2 );
    }
   }
   break;
  default:
   value = ((void *)0);
   var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var );

   break;
 }

 if (__builtin_expect(var_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use assign-op operators with overloaded objects nor string offsets");
 }

 if (__builtin_expect(*var_ptr == &(executor_globals.error_zval), 0)) {
  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }


  ;
  if (opline->extended_value == 147) {
   execute_data->opline++;
  }
  execute_data->opline++; return 0;
 }

 if (!zval_isref_p(*var_ptr)) { do { if (zval_refcount_p(*((var_ptr))) > 1) { zval *new_zv; zval_delref_p(*(var_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(var_ptr))->value; (*new_zv).type = (**(var_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(var_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

 if (__builtin_expect((**var_ptr).type == 5, 0)
    && ((**var_ptr)).value.obj.handlers->get
    && ((**var_ptr)).value.obj.handlers->set) {

  zval *objval = ((**var_ptr)).value.obj.handlers->get(*var_ptr );
  zval_addref_p(objval);
  binary_op(objval, objval, value );
  ((**var_ptr)).value.obj.handlers->set(var_ptr, objval );
  i_zval_ptr_dtor(*(&objval) );
 } else {
  binary_op(*var_ptr, *var_ptr, value );
 }

 if ((!((opline)->result_type & (1<<5)))) {
  zval_addref_p((*var_ptr));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (*var_ptr); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
 }

 if (opline->extended_value == 147) {
  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };
  if (free_op_data2.var) { i_zval_ptr_dtor(*(&free_op_data2.var) ); };

  ;
  execute_data->opline++;
 } else {

  ;
 }
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_ADD_SPEC_CV_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_UNUSED(add_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SUB_SPEC_CV_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_UNUSED(sub_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_MUL_SPEC_CV_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_UNUSED(mul_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_DIV_SPEC_CV_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_UNUSED(div_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_MOD_SPEC_CV_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_UNUSED(mod_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SL_SPEC_CV_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_UNUSED(shift_left_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SR_SPEC_CV_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_UNUSED(shift_right_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_CONCAT_SPEC_CV_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_UNUSED(concat_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_OR_SPEC_CV_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_UNUSED(bitwise_or_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_AND_SPEC_CV_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_UNUSED(bitwise_and_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_XOR_SPEC_CV_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_UNUSED(bitwise_xor_function, execute_data );
}

static int __attribute__((fastcall)) zend_fetch_var_address_helper_SPEC_CV_UNUSED(int type, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *varname;
 zval **retval;
 zval tmp_varname;
 HashTable *target_symbol_table;
 ulong hash_value;

 ;
 varname = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );

  if ((1<<4) != (1<<0) && __builtin_expect((*varname).type != 6, 0)) {
  do { (&tmp_varname)->value = (varname)->value; (*&tmp_varname).type = (*varname).type; } while (0);
  _zval_copy_ctor((&tmp_varname) );
  if ((&tmp_varname)->type != 6) { _convert_to_string((&tmp_varname) ); };
  varname = &tmp_varname;
 }

 if ((1<<3) != (1<<3)) {
  zend_class_entry *ce;

  if ((1<<3) == (1<<0)) {
   if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
    ce = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
   } else {
    ce = zend_fetch_class_by_name((*opline->op2.zv).value.str.val, (*opline->op2.zv).value.str.len, opline->op2.literal + 1, 0 );
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); } while (0);
   }
  } else {
   ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).class_entry;
  }
  retval = zend_std_get_static_property(ce, (*varname).value.str.val, (*varname).value.str.len, 0, (((1<<4) == (1<<0)) ? opline->op1.literal : ((void *)0)) );

 } else {
  target_symbol_table = zend_get_target_symbol_table(opline->extended_value & 0x70000000 );






  if ((1<<4) == (1<<0)) {
   hash_value = (((zend_literal*)(varname))->hash_value);
  } else if (((((*varname).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*varname).value.str.val) < (compiler_globals.interned_strings_end)))) {
   hash_value = (((Bucket*)(((char*)((*varname).value.str.val))-sizeof(Bucket)))->h);
  } else {
   hash_value = zend_hash_func((*varname).value.str.val, (*varname).value.str.len+1);
  }

  if (zend_hash_quick_find(target_symbol_table, (*varname).value.str.val, (*varname).value.str.len+1, hash_value, (void **) &retval) == -1) {
   switch (type) {
    case 0:
    case 6:
     zend_error((1<<3L),"Undefined variable: %s", (*varname).value.str.val);

    case 3:
     retval = &(executor_globals.uninitialized_zval_ptr);
     break;
    case 2:
     zend_error((1<<3L),"Undefined variable: %s", (*varname).value.str.val);

    case 1:
     zval_addref_p(&(executor_globals.uninitialized_zval));
     _zend_hash_quick_add_or_update(target_symbol_table, (*varname).value.str.val, (*varname).value.str.len+1, hash_value, &(executor_globals.uninitialized_zval_ptr), sizeof(zval *), (void **) &retval, (1<<0) );
     break;
   
   }
  }
  switch (opline->extended_value & 0x70000000) {
   case 0x00000000:
    if ((1<<4) != (1<<1)) {

    }
    break;
   case 0x10000000:

    break;
   case 0x20000000:
    zval_update_constant(retval, (void*) 1 );
    break;
   case 0x40000000:
    if ((1<<4) == (1<<2) && !free_op1.var) {
     zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr));
    }
    break;
  }
 }


 if ((1<<4) != (1<<0) && varname == &tmp_varname) {
  _zval_dtor((&tmp_varname) );
 }
 if (opline->extended_value & 0x04000000) {
  if (!zval_isref_p(*retval)) { do { if (zval_refcount_p(*((retval))) > 1) { zval *new_zv; zval_delref_p(*(retval)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval))->value; (*new_zv).type = (**(retval)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((retval))); };
 }
 zval_addref_p((*retval));
 switch (type) {
  case 0:
  case 3:
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (*retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   break;
  case 6: {
   zend_free_op free_res;

   zend_pzval_unlock_func(*retval, &free_res, 1 );
   if (retval != &(executor_globals.uninitialized_zval_ptr)) {
    if (!zval_isref_p(*retval)) { do { if (zval_refcount_p(*((retval))) > 1) { zval *new_zv; zval_delref_p(*(retval)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval))->value; (*new_zv).type = (**(retval)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
   }
   zval_addref_p((*retval));
   if (free_res.var) { i_zval_ptr_dtor(*(&free_res.var) ); };
  }

  default:
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = retval;
   break;
 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_R_SPEC_CV_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_CV_UNUSED(0, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_W_SPEC_CV_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_CV_UNUSED(1, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_RW_SPEC_CV_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_CV_UNUSED(2, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_FUNC_ARG_SPEC_CV_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 return zend_fetch_var_address_helper_SPEC_CV_UNUSED(((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && (opline->extended_value & 0x000fffff) <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[(opline->extended_value & 0x000fffff)-1].pass_by_reference & (1|2)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x1000000|0x2000000))))?1:0, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_UNSET_SPEC_CV_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_CV_UNUSED(6, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_IS_SPEC_CV_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_var_address_helper_SPEC_CV_UNUSED(3, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_W_SPEC_CV_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **container;

 ;
 container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var );

 if ((1<<4) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, ((void *)0), (1<<3), 1 );

 if ((1<<4) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }


 if (__builtin_expect(opline->extended_value != 0, 0)) {
  zval **retval_ptr = (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr;

  if (retval_ptr) {
   zval_delref_p(*(retval_ptr));
   if (!zval_isref_p(*retval_ptr)) { do { if (zval_refcount_p(*((retval_ptr))) > 1) { zval *new_zv; zval_delref_p(*(retval_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval_ptr))->value; (*new_zv).type = (**(retval_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((retval_ptr))); };
   zval_addref_p(*(retval_ptr));
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_RW_SPEC_CV_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **container;

 ;
 container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var );

 if ((1<<4) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, ((void *)0), (1<<3), 2 );

 if ((1<<4) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **container;

 ;

 if (((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && (opline->extended_value & 0x000fffff) <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[(opline->extended_value & 0x000fffff)-1].pass_by_reference & (1|2)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x1000000|0x2000000))))) {
  container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var );
  if ((1<<4) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
  }
  zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, ((void *)0), (1<<3), 1 );
  if ((1<<4) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
  }
 } else {
  if ((1<<3) == (1<<3)) {
   zend_error_noreturn((1<<0L), "Cannot use [] for reading");
  }
  container = _get_zval_ptr_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );
  zend_fetch_dimension_address_read(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, ((void *)0), (1<<3), 0 );
 }


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_DIM_SPEC_CV_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval **object_ptr;

 ;
 object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var );

 if ((1<<4) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 if ((**object_ptr).type == 5) {

  zval *property_name = ((void *)0);

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property_name))->value; (*_tmp).type = (*(property_name)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property_name) = _tmp; } while (0);
  }
  zend_assign_to_object((!((opline)->result_type & (1<<5)))?&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr:((void *)0), object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, 147, (((1<<3) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
  if (0) {
   i_zval_ptr_dtor(*(&property_name) );
  } else {

  }
 } else {
  zend_free_op free_op_data1, free_op_data2;
  zval *value;
  zval *dim = ((void *)0);
  zval **variable_ptr_ptr;

  zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)), object_ptr, dim, (1<<3), 1 );

  value = _get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, &free_op_data1, 0 );
  variable_ptr_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data->Ts, &free_op_data2 );
  if (__builtin_expect(variable_ptr_ptr == ((void *)0), 0)) {
   if (zend_assign_to_string_offset(&(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)), value, (opline+1)->op1_type )) {
    if ((!((opline)->result_type & (1<<5)))) {
     zval *retval;

     do { (retval) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(retval))->u.buffered = ((void *)0); } while (0);
     do { const char *__s=((*(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)).str_offset.str).value.str.val+(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)).str_offset.offset); int __l=1; zval *__z = (retval); (*__z).value.str.len = __l; (*__z).value.str.val = (1?_estrndup((__s), (__l) ):(char*)__s); (*__z).type = 6; } while (0);
     (retval)->refcount__gc = 1; (retval)->is_ref__gc = 0;;
     do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
    }
   } else if ((!((opline)->result_type & (1<<5)))) {
    zval_addref_p((&(executor_globals.uninitialized_zval)));
    do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   }
  } else if (__builtin_expect(*variable_ptr_ptr == &(executor_globals.error_zval), 0)) {
   if (((zend_uintptr_t)free_op_data1.var & 1L)) {
    _zval_dtor((value) );
   }
   if ((!((opline)->result_type & (1<<5)))) {
    zval_addref_p((&(executor_globals.uninitialized_zval)));
    do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   }
  } else {
   if ((opline+1)->op1_type == (1<<1)) {
     value = zend_assign_tmp_to_variable(variable_ptr_ptr, value );
   } else if ((opline+1)->op1_type == (1<<0)) {
     value = zend_assign_const_to_variable(variable_ptr_ptr, value );
   } else {
     value = zend_assign_to_variable(variable_ptr_ptr, value );
   }
   if ((!((opline)->result_type & (1<<5)))) {
    zval_addref_p((value));
    do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (value); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   }
  }
  if (free_op_data2.var) { i_zval_ptr_dtor(*(&free_op_data2.var) ); };
   if (free_op_data1.var != ((void *)0) && (((zend_uintptr_t)free_op_data1.var & 1L) == 0)) { i_zval_ptr_dtor(*(&free_op_data1.var) ); };
 }


 ;
 execute_data->opline++;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *expr_ptr;

 ;
 if (((1<<4) == (1<<2) || (1<<4) == (1<<4)) && opline->extended_value) {
  zval **expr_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var );

  if ((1<<4) == (1<<2) && __builtin_expect(expr_ptr_ptr == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot create references to/from string offsets");
  }
  if (!zval_isref_p(*expr_ptr_ptr)) { do { if (zval_refcount_p(*((expr_ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(expr_ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(expr_ptr_ptr))->value; (*new_zv).type = (**(expr_ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(expr_ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((expr_ptr_ptr))); };
  expr_ptr = *expr_ptr_ptr;
  zval_addref_p(expr_ptr);
 } else {
  expr_ptr=_get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );
  if (0) {
   zval *new_expr;

   do { (new_expr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_expr))->u.buffered = ((void *)0); } while (0);
   do { do { (new_expr)->value = (expr_ptr)->value; (*new_expr).type = (*expr_ptr).type; } while (0); zval_set_refcount_p(new_expr, 1); zval_unset_isref_p(new_expr); } while (0);
   expr_ptr = new_expr;
  } else if ((1<<4) == (1<<0) || zval_isref_p(expr_ptr)) {
   zval *new_expr;

   do { (new_expr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_expr))->u.buffered = ((void *)0); } while (0);
   do { do { (new_expr)->value = (expr_ptr)->value; (*new_expr).type = (*expr_ptr).type; } while (0); zval_set_refcount_p(new_expr, 1); zval_unset_isref_p(new_expr); } while (0);
   expr_ptr = new_expr;
   _zval_copy_ctor((&(*expr_ptr)) );
  } else {
   zval_addref_p(expr_ptr);
  }
 }

 if ((1<<3) != (1<<3)) {

  zval *offset = ((void *)0);
  ulong hval;

  switch ((*offset).type) {
   case 2:
    hval = zend_dval_to_lval((*offset).value.dval);
    goto num_index;
   case 1:
   case 3:
    hval = (*offset).value.lval;
num_index:
    _zend_hash_index_update_or_next_insert(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, hval, &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   case 6:
    if ((1<<3) == (1<<0)) {
     hval = (((zend_literal*)(offset))->hash_value);
    } else {
     do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index; } } } while (0);
     if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
      hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
     } else {
      hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
     }
    }
    _zend_hash_quick_add_or_update(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   case 0:
    _zend_hash_add_or_update(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, "", sizeof(""), &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   default:
    zend_error((1<<1L), "Illegal offset type");
    i_zval_ptr_dtor(*(&expr_ptr) );

    break;
  }

 } else {
  _zend_hash_index_update_or_next_insert(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, 0, &expr_ptr, sizeof(zval *), ((void *)0), (1<<2) );
 }
 if (((1<<4) == (1<<2) || (1<<4) == (1<<4)) && opline->extended_value) {

 } else {

 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_ARRAY_SPEC_CV_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 _array_init((&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var), 0 );
 if ((1<<4) == (1<<3)) {
  execute_data->opline++; return 0;

 } else {
  return ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_UNUSED_HANDLER(execute_data );

 }
}

static int __attribute__((fastcall)) ZEND_UNSET_VAR_SPEC_CV_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval tmp, *varname;
 HashTable *target_symbol_table;


 ;
 if ((1<<4) == (1<<4) &&
     (1<<3) == (1<<3) &&
     (opline->extended_value & 0x00800000)) {
  if ((executor_globals.active_symbol_table)) {
   zend_compiled_variable *cv = &((executor_globals.active_op_array)->vars[opline->op1.var]);

   zend_delete_variable(execute_data->prev_execute_data, (executor_globals.active_symbol_table), cv->name, cv->name_len+1, cv->hash_value );
   execute_data->CVs[opline->op1.var] = ((void *)0);
  } else if (execute_data->CVs[opline->op1.var]) {
   i_zval_ptr_dtor(*(execute_data->CVs[opline->op1.var]) );
   execute_data->CVs[opline->op1.var] = ((void *)0);
  }
  ;
  execute_data->opline++; return 0;
 }

 varname = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );

 if ((1<<4) != (1<<0) && (*varname).type != 6) {
  do { (&tmp)->value = (varname)->value; (*&tmp).type = (*varname).type; } while (0);
  _zval_copy_ctor((&tmp) );
  if ((&tmp)->type != 6) { _convert_to_string((&tmp) ); };
  varname = &tmp;
 } else if ((1<<4) == (1<<2) || (1<<4) == (1<<4)) {
  zval_addref_p(varname);
 }

 if ((1<<3) != (1<<3)) {
  zend_class_entry *ce;

  if ((1<<3) == (1<<0)) {
   if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
    ce = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
   } else {
    ce = zend_fetch_class_by_name((*opline->op2.zv).value.str.val, (*opline->op2.zv).value.str.len, opline->op2.literal + 1, 0 );
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); } while (0);
   }
  } else {
   ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).class_entry;
  }
  zend_std_unset_static_property(ce, (*varname).value.str.val, (*varname).value.str.len, (((1<<4) == (1<<0)) ? opline->op1.literal : ((void *)0)) );
 } else {
  ulong hash_value = zend_inline_hash_func(varname->value.str.val, varname->value.str.len+1);

  target_symbol_table = zend_get_target_symbol_table(opline->extended_value & 0x70000000 );
  zend_delete_variable(execute_data, target_symbol_table, varname->value.str.val, varname->value.str.len+1, hash_value );
 }

 if ((1<<4) != (1<<0) && varname == &tmp) {
  _zval_dtor((&tmp) );
 } else if ((1<<4) == (1<<2) || (1<<4) == (1<<4)) {
  i_zval_ptr_dtor(*(&varname) );
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ISSET_ISEMPTY_VAR_SPEC_CV_UNUSED_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval **value;
 zend_bool isset = 1;

 ;
 if ((1<<4) == (1<<4) &&
     (1<<3) == (1<<3) &&
     (opline->extended_value & 0x00800000)) {
  if (execute_data->CVs[opline->op1.var]) {
   value = execute_data->CVs[opline->op1.var];
  } else if ((executor_globals.active_symbol_table)) {
   zend_compiled_variable *cv = &((executor_globals.active_op_array)->vars[opline->op1.var]);

   if (zend_hash_quick_find((executor_globals.active_symbol_table), cv->name, cv->name_len+1, cv->hash_value, (void **) &value) == -1) {
    isset = 0;
   }
  } else {
   isset = 0;
  }
 } else {
  HashTable *target_symbol_table;

  zval tmp, *varname = _get_zval_ptr_cv_BP_VAR_IS(execute_data->CVs, opline->op1.var );

  if ((1<<4) != (1<<0) && (*varname).type != 6) {
   do { (&tmp)->value = (varname)->value; (*&tmp).type = (*varname).type; } while (0);
   _zval_copy_ctor((&tmp) );
   if ((&tmp)->type != 6) { _convert_to_string((&tmp) ); };
   varname = &tmp;
  }

  if ((1<<3) != (1<<3)) {
   zend_class_entry *ce;

   if ((1<<3) == (1<<0)) {
    if ((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)]) {
     ce = (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)];
    } else {
     ce = zend_fetch_class_by_name((*opline->op2.zv).value.str.val, (*opline->op2.zv).value.str.len, opline->op2.literal + 1, 0 );
     do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (ce); } while (0);
    }
   } else {
    ce = (*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).class_entry;
   }
   value = zend_std_get_static_property(ce, (*varname).value.str.val, (*varname).value.str.len, 1, (((1<<4) == (1<<0)) ? opline->op1.literal : ((void *)0)) );
   if (!value) {
    isset = 0;
   }
  } else {
   target_symbol_table = zend_get_target_symbol_table(opline->extended_value & 0x70000000 );
   if (zend_hash_find(target_symbol_table, varname->value.str.val, varname->value.str.len+1, (void **) &value) == -1) {
    isset = 0;
   }
  }

  if ((1<<4) != (1<<0) && varname == &tmp) {
   _zval_dtor((&tmp) );
  }

 }

 if (opline->extended_value & 0x02000000) {
  if (isset && (**value).type != 0) {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((1) != 0); (*__z).type = 3; } while (0);
  } else {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((0) != 0); (*__z).type = 3; } while (0);
  }
 } else {
  if (!isset || !i_zend_is_true(*value)) {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((1) != 0); (*__z).type = 3; } while (0);
  } else {
   do { zval *__z = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var); (*__z).value.lval = ((0) != 0); (*__z).type = 3; } while (0);
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ADD_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 add_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SUB_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 sub_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_MUL_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 mul_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_DIV_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 div_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_MOD_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 mod_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SL_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 shift_left_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_SR_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 shift_right_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_CONCAT_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 concat_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_IDENTICAL_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 is_identical_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_NOT_IDENTICAL_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 is_identical_function(result,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 (*result).value.lval = !(*result).value.lval;


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_EQUAL_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval == 0)) != 0); (*__z).type = 3; } while (0);


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_NOT_EQUAL_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval != 0)) != 0); (*__z).type = 3; } while (0);


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_SMALLER_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval < 0)) != 0); (*__z).type = 3; } while (0);


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *result = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 ;
 compare_function(result,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );
 do { zval *__z = (result); (*__z).value.lval = ((((*result).value.lval <= 0)) != 0); (*__z).type = 3; } while (0);


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_OR_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 bitwise_or_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_AND_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 bitwise_and_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BW_XOR_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 bitwise_xor_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_BOOL_XOR_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 boolean_xor_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
  _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_binary_assign_op_obj_helper_SPEC_CV_CV(int (*binary_op)(zval *result, zval *op1, zval *op2 ), zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op_data1;
 zval **object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var );
 zval *object;
 zval *property = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );
 zval *value = _get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, &free_op_data1, 0 );
 int have_get_ptr = 0;

 if ((1<<4) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }

 make_real_object(object_ptr );
 object = *object_ptr;

 if (__builtin_expect((*object).type != 5, 0)) {
  zend_error((1<<1L), "Attempt to assign property of non-object");

  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };

  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = &(executor_globals.uninitialized_zval);
   (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
  }
 } else {

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
  }


  if (opline->extended_value == 136
   && (*object).value.obj.handlers->get_property_ptr_ptr) {
   zval **zptr = (*object).value.obj.handlers->get_property_ptr_ptr(object, property, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   if (zptr != ((void *)0)) {
    if (!zval_isref_p(*zptr)) { do { if (zval_refcount_p(*((zptr))) > 1) { zval *new_zv; zval_delref_p(*(zptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(zptr))->value; (*new_zv).type = (**(zptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(zptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

    have_get_ptr = 1;
    binary_op(*zptr, *zptr, value );
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((*zptr));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = *zptr;
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
   }
  }

  if (!have_get_ptr) {
   zval *z = ((void *)0);

   if (opline->extended_value == 136) {
    if ((*object).value.obj.handlers->read_property) {
     z = (*object).value.obj.handlers->read_property(object, property, 0, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
    }
   } else {
    if ((*object).value.obj.handlers->read_dimension) {
     z = (*object).value.obj.handlers->read_dimension(object, property, 0 );
    }
   }
   if (z) {
    if ((*z).type == 5 && (*z).value.obj.handlers->get) {
     zval *value = (*z).value.obj.handlers->get(z );

     if (zval_refcount_p(z) == 0) {
      if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); };
      _zval_dtor((z) );
      do { if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); }; _efree((z) ); } while (0);
     }
     z = value;
    }
    zval_addref_p(z);
    if (!zval_isref_p(*&z)) { do { if (zval_refcount_p(*((&z))) > 1) { zval *new_zv; zval_delref_p(*(&z)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(&z))->value; (*new_zv).type = (**(&z)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(&z) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
    binary_op(z, z, value );
    if (opline->extended_value == 136) {
     (*object).value.obj.handlers->write_property(object, property, z, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
    } else {
     (*object).value.obj.handlers->write_dimension(object, property, z );
    }
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((z));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = z;
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
    i_zval_ptr_dtor(*(&z) );
   } else {
    zend_error((1<<1L), "Attempt to assign property of non-object");
    if ((!((opline)->result_type & (1<<5)))) {
     zval_addref_p((&(executor_globals.uninitialized_zval)));
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr = &(executor_globals.uninitialized_zval);
     (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr = ((void *)0);
    }
   }
  }

  if (0) {
   i_zval_ptr_dtor(*(&property) );
  } else {

  }
  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };
 }


 ;
 execute_data->opline++;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_binary_assign_op_helper_SPEC_CV_CV(int (*binary_op)(zval *result, zval *op1, zval *op2 ), zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op_data2, free_op_data1;
 zval **var_ptr;
 zval *value;

 ;
 switch (opline->extended_value) {
  case 136:
   return zend_binary_assign_op_obj_helper_SPEC_CV_CV(binary_op, execute_data );
   break;
  case 147: {
    zval **container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var );

    if ((1<<4) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
     zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
    } else if (__builtin_expect((**container).type == 5, 0)) {
     if ((1<<4) == (1<<2) && !0) {
      zval_addref_p(*(container));
     }
     return zend_binary_assign_op_obj_helper_SPEC_CV_CV(binary_op, execute_data );
    } else {
     zval *dim = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );

     zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)), container, dim, (1<<4), 2 );
     value = _get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, &free_op_data1, 0 );
     var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data->Ts, &free_op_data2 );
    }
   }
   break;
  default:
   value = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );
   var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var );

   break;
 }

 if (__builtin_expect(var_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use assign-op operators with overloaded objects nor string offsets");
 }

 if (__builtin_expect(*var_ptr == &(executor_globals.error_zval), 0)) {
  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }


  ;
  if (opline->extended_value == 147) {
   execute_data->opline++;
  }
  execute_data->opline++; return 0;
 }

 if (!zval_isref_p(*var_ptr)) { do { if (zval_refcount_p(*((var_ptr))) > 1) { zval *new_zv; zval_delref_p(*(var_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(var_ptr))->value; (*new_zv).type = (**(var_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(var_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

 if (__builtin_expect((**var_ptr).type == 5, 0)
    && ((**var_ptr)).value.obj.handlers->get
    && ((**var_ptr)).value.obj.handlers->set) {

  zval *objval = ((**var_ptr)).value.obj.handlers->get(*var_ptr );
  zval_addref_p(objval);
  binary_op(objval, objval, value );
  ((**var_ptr)).value.obj.handlers->set(var_ptr, objval );
  i_zval_ptr_dtor(*(&objval) );
 } else {
  binary_op(*var_ptr, *var_ptr, value );
 }

 if ((!((opline)->result_type & (1<<5)))) {
  zval_addref_p((*var_ptr));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (*var_ptr); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
 }

 if (opline->extended_value == 147) {
  if (free_op_data1.var) { if ((zend_uintptr_t)free_op_data1.var & 1L) { _zval_dtor(((zval*)((zend_uintptr_t)free_op_data1.var & ~1L)) ); } else { i_zval_ptr_dtor(*(&free_op_data1.var) ); } };
  if (free_op_data2.var) { i_zval_ptr_dtor(*(&free_op_data2.var) ); };

  ;
  execute_data->opline++;
 } else {

  ;
 }
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_ADD_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_CV(add_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SUB_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_CV(sub_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_MUL_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_CV(mul_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_DIV_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_CV(div_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_MOD_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_CV(mod_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SL_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_CV(shift_left_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SR_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_CV(shift_right_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_CONCAT_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_CV(concat_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_OR_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_CV(bitwise_or_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_AND_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_CV(bitwise_and_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_ASSIGN_BW_XOR_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_binary_assign_op_helper_SPEC_CV_CV(bitwise_xor_function, execute_data );
}

static int __attribute__((fastcall)) zend_pre_incdec_property_helper_SPEC_CV_CV(incdec_t incdec_op, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval **object_ptr;
 zval *object;
 zval *property;
 zval **retval;
 int have_get_ptr = 0;

 ;
 object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var );
 property = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );
 retval = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr;

 if ((1<<4) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot increment/decrement overloaded objects nor string offsets");
 }

 make_real_object(object_ptr );
 object = *object_ptr;

 if (__builtin_expect((*object).type != 5, 0)) {
  zend_error((1<<1L), "Attempt to increment/decrement property of non-object");

  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   *retval = &(executor_globals.uninitialized_zval);
  }

  ;
  execute_data->opline++; return 0;
 }



 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }

 if ((*object).value.obj.handlers->get_property_ptr_ptr) {
  zval **zptr = (*object).value.obj.handlers->get_property_ptr_ptr(object, property, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
  if (zptr != ((void *)0)) {
   if (!zval_isref_p(*zptr)) { do { if (zval_refcount_p(*((zptr))) > 1) { zval *new_zv; zval_delref_p(*(zptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(zptr))->value; (*new_zv).type = (**(zptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(zptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

   have_get_ptr = 1;
   incdec_op(*zptr);
   if ((!((opline)->result_type & (1<<5)))) {
    *retval = *zptr;
    zval_addref_p((*retval));
   }
  }
 }

 if (!have_get_ptr) {
  if ((*object).value.obj.handlers->read_property && (*object).value.obj.handlers->write_property) {
   zval *z = (*object).value.obj.handlers->read_property(object, property, 0, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );

   if (__builtin_expect((*z).type == 5, 0) && (*z).value.obj.handlers->get) {
    zval *value = (*z).value.obj.handlers->get(z );

    if (zval_refcount_p(z) == 0) {
     if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); };
     _zval_dtor((z) );
     do { if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); }; _efree((z) ); } while (0);
    }
    z = value;
   }
   zval_addref_p(z);
   if (!zval_isref_p(*&z)) { do { if (zval_refcount_p(*((&z))) > 1) { zval *new_zv; zval_delref_p(*(&z)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(&z))->value; (*new_zv).type = (**(&z)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(&z) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
   incdec_op(z);
   *retval = z;
   (*object).value.obj.handlers->write_property(object, property, z, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   if ((!((opline)->result_type & (1<<5)))) { zval_addref_p((*retval)); };
   i_zval_ptr_dtor(*(&z) );
  } else {
   zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
   if ((!((opline)->result_type & (1<<5)))) {
    zval_addref_p((&(executor_globals.uninitialized_zval)));
    *retval = &(executor_globals.uninitialized_zval);
   }
  }
 }

 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {

 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_PRE_INC_OBJ_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_pre_incdec_property_helper_SPEC_CV_CV(increment_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_PRE_DEC_OBJ_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_pre_incdec_property_helper_SPEC_CV_CV(decrement_function, execute_data );
}

static int __attribute__((fastcall)) zend_post_incdec_property_helper_SPEC_CV_CV(incdec_t incdec_op, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval **object_ptr;
 zval *object;
 zval *property;
 zval *retval;
 int have_get_ptr = 0;

 ;
 object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var );
 property = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );
 retval = &(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var;

 if ((1<<4) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot increment/decrement overloaded objects nor string offsets");
 }

 make_real_object(object_ptr );
 object = *object_ptr;

 if (__builtin_expect((*object).type != 5, 0)) {
  zend_error((1<<1L), "Attempt to increment/decrement property of non-object");

  { (*retval).type = 0; };

  ;
  execute_data->opline++; return 0;
 }



 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }

 if ((*object).value.obj.handlers->get_property_ptr_ptr) {
  zval **zptr = (*object).value.obj.handlers->get_property_ptr_ptr(object, property, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
  if (zptr != ((void *)0)) {
   have_get_ptr = 1;
   if (!zval_isref_p(*zptr)) { do { if (zval_refcount_p(*((zptr))) > 1) { zval *new_zv; zval_delref_p(*(zptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(zptr))->value; (*new_zv).type = (**(zptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(zptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };

   do { (retval)->value = (*zptr)->value; (*retval).type = (**zptr).type; } while (0);
   _zval_copy_ctor((&(*retval)) );

   incdec_op(*zptr);

  }
 }

 if (!have_get_ptr) {
  if ((*object).value.obj.handlers->read_property && (*object).value.obj.handlers->write_property) {
   zval *z = (*object).value.obj.handlers->read_property(object, property, 0, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   zval *z_copy;

   if (__builtin_expect((*z).type == 5, 0) && (*z).value.obj.handlers->get) {
    zval *value = (*z).value.obj.handlers->get(z );

    if (zval_refcount_p(z) == 0) {
     if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); };
     _zval_dtor((z) );
     do { if (((gc_root_buffer*)(((zend_uintptr_t)(((zval_gc_info*)z)->u.buffered)) & ~0x03))) { gc_remove_zval_from_buffer(z ); }; _efree((z) ); } while (0);
    }
    z = value;
   }
   do { (retval)->value = (z)->value; (*retval).type = (*z).type; } while (0);
   _zval_copy_ctor((&(*retval)) );
   do { (z_copy) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(z_copy))->u.buffered = ((void *)0); } while (0);
   do { do { (z_copy)->value = (z)->value; (*z_copy).type = (*z).type; } while (0); zval_set_refcount_p(z_copy, 1); zval_unset_isref_p(z_copy); } while (0);
   _zval_copy_ctor((&(*z_copy)) );
   incdec_op(z_copy);
   zval_addref_p(z);
   (*object).value.obj.handlers->write_property(object, property, z_copy, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   i_zval_ptr_dtor(*(&z_copy) );
   i_zval_ptr_dtor(*(&z) );
  } else {
   zend_error((1<<1L), "Attempt to increment/decrement property of non-object");
   { (*retval).type = 0; };
  }
 }

 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {

 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_POST_INC_OBJ_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_post_incdec_property_helper_SPEC_CV_CV(increment_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_POST_DEC_OBJ_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_post_incdec_property_helper_SPEC_CV_CV(decrement_function, execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_R_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval **container;

 ;

 if ((opline->extended_value & 0x08000000) &&
     (1<<4) != (1<<4) &&
     (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr) {
  zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr));
 }
 container = _get_zval_ptr_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );
 zend_fetch_dimension_address_read(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ), (1<<4), 0 );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_W_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **container;

 ;
 container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var );

 if ((1<<4) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ), (1<<4), 1 );

 if ((1<<4) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }


 if (__builtin_expect(opline->extended_value != 0, 0)) {
  zval **retval_ptr = (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr;

  if (retval_ptr) {
   zval_delref_p(*(retval_ptr));
   if (!zval_isref_p(*retval_ptr)) { do { if (zval_refcount_p(*((retval_ptr))) > 1) { zval *new_zv; zval_delref_p(*(retval_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval_ptr))->value; (*new_zv).type = (**(retval_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((retval_ptr))); };
   zval_addref_p(*(retval_ptr));
  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_RW_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **container;

 ;
 container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var );

 if ((1<<4) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ), (1<<4), 2 );

 if ((1<<4) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_IS_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval **container;

 ;
 container = _get_zval_ptr_ptr_cv_BP_VAR_IS(execute_data->CVs, opline->op1.var );
 zend_fetch_dimension_address_read(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ), (1<<4), 3 );


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **container;

 ;

 if (((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && (opline->extended_value & 0x000fffff) <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[(opline->extended_value & 0x000fffff)-1].pass_by_reference & (1|2)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x1000000|0x2000000))))) {
  container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var );
  if ((1<<4) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
  }
  zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ), (1<<4), 1 );
  if ((1<<4) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
  }
 } else {
  if ((1<<4) == (1<<3)) {
   zend_error_noreturn((1<<0L), "Cannot use [] for reading");
  }
  container = _get_zval_ptr_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );
  zend_fetch_dimension_address_read(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ), (1<<4), 0 );
 }


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_DIM_UNSET_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval **container;

 ;
 container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data->CVs, opline->op1.var );

 if ((1<<4) == (1<<4)) {
  if (container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
 }
 if ((1<<4) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ), (1<<4), 6 );

 if ((1<<4) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }

 if (__builtin_expect((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot unset string offsets");
 } else {
  zend_free_op free_res;
  zval **retval_ptr = (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr;

  zend_pzval_unlock_func(*retval_ptr, &free_res, 1 );
  if (retval_ptr != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*retval_ptr)) { do { if (zval_refcount_p(*((retval_ptr))) > 1) { zval *new_zv; zval_delref_p(*(retval_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval_ptr))->value; (*new_zv).type = (**(retval_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
  zval_addref_p((*retval_ptr));
  if (free_res.var) { i_zval_ptr_dtor(*(&free_res.var) ); };
  ;
  execute_data->opline++; return 0;
 }
}

static int __attribute__((fastcall)) zend_fetch_property_address_read_helper_SPEC_CV_CV(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *container;

 zval *offset;

 ;
 container = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );
 offset = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );

 if (__builtin_expect((*container).type != 5, 0) ||
     __builtin_expect((*container).value.obj.handlers->read_property == ((void *)0), 0)) {
  zend_error((1<<3L), "Trying to get property of non-object");
  zval_addref_p((&(executor_globals.uninitialized_zval)));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);

 } else {
  zval *retval;

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
  }


  retval = (*container).value.obj.handlers->read_property(container, offset, 0, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );

  zval_addref_p((retval));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);

  if (0) {
   i_zval_ptr_dtor(*(&offset) );
  } else {

  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_R_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_fetch_property_address_read_helper_SPEC_CV_CV(execute_data );
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_W_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *property;
 zval **container;

 ;
 property = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );

 if ((1<<4) == (1<<2) && (opline->extended_value & 0x08000000)) {
  zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr));
  (*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr = *(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr;
 }

 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }
 container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var );
 if ((1<<4) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }

 zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)), 1 );
 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {

 }
 if ((1<<4) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }


 if (opline->extended_value & 0x04000000) {
  zval **retval_ptr = (*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr;

  zval_delref_p(*(retval_ptr));
  if (!zval_isref_p(*retval_ptr)) { do { if (zval_refcount_p(*((retval_ptr))) > 1) { zval *new_zv; zval_delref_p(*(retval_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(retval_ptr))->value; (*new_zv).type = (**(retval_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(retval_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((retval_ptr))); };
  zval_addref_p(*(retval_ptr));
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_RW_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1;
 zval *property;
 zval **container;

 ;
 property = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );
 container = _get_zval_ptr_ptr_cv_BP_VAR_RW(execute_data->CVs, opline->op1.var );

 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }
 if ((1<<4) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }
 zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)), 2 );
 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {

 }
 if ((1<<4) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_IS_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *container;

 zval *offset;

 ;
 container = _get_zval_ptr_cv_BP_VAR_IS(execute_data->CVs, opline->op1.var );
 offset = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );

 if (__builtin_expect((*container).type != 5, 0) ||
     __builtin_expect((*container).value.obj.handlers->read_property == ((void *)0), 0)) {
  zval_addref_p((&(executor_globals.uninitialized_zval)));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);

 } else {
  zval *retval;

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
  }


  retval = (*container).value.obj.handlers->read_property(container, offset, 3, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );

  zval_addref_p((retval));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);

  if (0) {
   i_zval_ptr_dtor(*(&offset) );
  } else {

  }
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 if (((execute_data->fbc) && ((((zend_function*)(execute_data->fbc))->common.arg_info && (opline->extended_value & 0x000fffff) <= ((zend_function*)(execute_data->fbc))->common.num_args) ? (((zend_function *)(execute_data->fbc))->common.arg_info[(opline->extended_value & 0x000fffff)-1].pass_by_reference & (1|2)) : (((zend_function *)(execute_data->fbc))->common.fn_flags & (0x1000000|0x2000000))))) {

  zend_free_op free_op1;
  zval *property;
  zval **container;

  ;
  property = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );
  container = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var );

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
  }
  if ((1<<4) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
  }
  zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)), 1 );
  if (0) {
   i_zval_ptr_dtor(*(&property) );
  } else {

  }
  if ((1<<4) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
  }

  ;
  execute_data->opline++; return 0;
 } else {
  return zend_fetch_property_address_read_helper_SPEC_CV_CV(execute_data );
 }
}

static int __attribute__((fastcall)) ZEND_FETCH_OBJ_UNSET_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op1, free_res;
 zval **container;
 zval *property;

 ;
 container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data->CVs, opline->op1.var );
 property = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );

 if ((1<<4) == (1<<4)) {
  if (container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
 }
 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property))->value; (*_tmp).type = (*(property)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property) = _tmp; } while (0);
 }
 if ((1<<4) == (1<<2) && __builtin_expect(container == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an object");
 }
 zend_fetch_property_address(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)), container, property, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)), 6 );
 if (0) {
  i_zval_ptr_dtor(*(&property) );
 } else {

 }
 if ((1<<4) == (1<<2) && 0 && (zval_refcount_p(free_op1.var) == 1 && ((*free_op1.var).type != 5 || zend_objects_store_get_refcount(free_op1.var ) == 1))) {
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); if (__t->var.ptr_ptr) { __t->var.ptr = *__t->var.ptr_ptr; __t->var.ptr_ptr = &__t->var.ptr; if (!zval_isref_p(__t->var.ptr) && zval_refcount_p(__t->var.ptr) > 2) { do { if (zval_refcount_p(*((__t->var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(__t->var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(__t->var.ptr_ptr))->value; (*new_zv).type = (**(__t->var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(__t->var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); } } } while (0);
 }

 zend_pzval_unlock_func(*(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr, &free_res, 1 );
 if ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr != &(executor_globals.uninitialized_zval_ptr)) {
  if (!zval_isref_p(*(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr)) { do { if (zval_refcount_p(*(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr))->value; (*new_zv).type = (**((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
 }
 zval_addref_p((*(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr_ptr));
 if (free_res.var) { i_zval_ptr_dtor(*(&free_res.var) ); };
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_OBJ_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval **object_ptr;
 zval *property_name;

 ;
 object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var );
 property_name = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );

 if (0) {
  do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property_name))->value; (*_tmp).type = (*(property_name)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property_name) = _tmp; } while (0);
 }
 if ((1<<4) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 zend_assign_to_object((!((opline)->result_type & (1<<5)))?&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr:((void *)0), object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, 136, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
 if (0) {
  i_zval_ptr_dtor(*(&property_name) );
 } else {

 }


 ;
 execute_data->opline++;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_DIM_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval **object_ptr;

 ;
 object_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var );

 if ((1<<4) == (1<<2) && __builtin_expect(object_ptr == ((void *)0), 0)) {
  zend_error_noreturn((1<<0L), "Cannot use string offset as an array");
 }
 if ((**object_ptr).type == 5) {

  zval *property_name = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );

  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((property_name))->value; (*_tmp).type = (*(property_name)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (property_name) = _tmp; } while (0);
  }
  zend_assign_to_object((!((opline)->result_type & (1<<5)))?&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).var.ptr:((void *)0), object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, 147, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
  if (0) {
   i_zval_ptr_dtor(*(&property_name) );
  } else {

  }
 } else {
  zend_free_op free_op_data1, free_op_data2;
  zval *value;
  zval *dim = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );
  zval **variable_ptr_ptr;

  zend_fetch_dimension_address(&(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)), object_ptr, dim, (1<<4), 1 );

  value = _get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data->Ts, &free_op_data1, 0 );
  variable_ptr_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data->Ts, &free_op_data2 );
  if (__builtin_expect(variable_ptr_ptr == ((void *)0), 0)) {
   if (zend_assign_to_string_offset(&(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)), value, (opline+1)->op1_type )) {
    if ((!((opline)->result_type & (1<<5)))) {
     zval *retval;

     do { (retval) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(retval))->u.buffered = ((void *)0); } while (0);
     do { const char *__s=((*(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)).str_offset.str).value.str.val+(*(temp_variable *)((char *) execute_data->Ts + (opline+1)->op2.var)).str_offset.offset); int __l=1; zval *__z = (retval); (*__z).value.str.len = __l; (*__z).value.str.val = (1?_estrndup((__s), (__l) ):(char*)__s); (*__z).type = 6; } while (0);
     (retval)->refcount__gc = 1; (retval)->is_ref__gc = 0;;
     do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
    }
   } else if ((!((opline)->result_type & (1<<5)))) {
    zval_addref_p((&(executor_globals.uninitialized_zval)));
    do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   }
  } else if (__builtin_expect(*variable_ptr_ptr == &(executor_globals.error_zval), 0)) {
   if (((zend_uintptr_t)free_op_data1.var & 1L)) {
    _zval_dtor((value) );
   }
   if ((!((opline)->result_type & (1<<5)))) {
    zval_addref_p((&(executor_globals.uninitialized_zval)));
    do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   }
  } else {
   if ((opline+1)->op1_type == (1<<1)) {
     value = zend_assign_tmp_to_variable(variable_ptr_ptr, value );
   } else if ((opline+1)->op1_type == (1<<0)) {
     value = zend_assign_const_to_variable(variable_ptr_ptr, value );
   } else {
     value = zend_assign_to_variable(variable_ptr_ptr, value );
   }
   if ((!((opline)->result_type & (1<<5)))) {
    zval_addref_p((value));
    do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (value); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   }
  }
  if (free_op_data2.var) { i_zval_ptr_dtor(*(&free_op_data2.var) ); };
   if (free_op_data1.var != ((void *)0) && (((zend_uintptr_t)free_op_data1.var & 1L) == 0)) { i_zval_ptr_dtor(*(&free_op_data1.var) ); };
 }


 ;
 execute_data->opline++;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *value;
 zval **variable_ptr_ptr;

 ;
 value = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );
 variable_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var );

 if ((1<<4) == (1<<2) && __builtin_expect(variable_ptr_ptr == ((void *)0), 0)) {
  if (zend_assign_to_string_offset(&(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)), value, (1<<4) )) {
   if ((!((opline)->result_type & (1<<5)))) {
    zval *retval;

    do { (retval) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(retval))->u.buffered = ((void *)0); } while (0);
    do { const char *__s=((*(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).str_offset.str).value.str.val+(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).str_offset.offset); int __l=1; zval *__z = (retval); (*__z).value.str.len = __l; (*__z).value.str.val = (1?_estrndup((__s), (__l) ):(char*)__s); (*__z).type = 6; } while (0);
    (retval)->refcount__gc = 1; (retval)->is_ref__gc = 0;;
    do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (retval); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
   }
  } else if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }
 } else if ((1<<4) == (1<<2) && __builtin_expect(*variable_ptr_ptr == &(executor_globals.error_zval), 0)) {
  if (0) {
   _zval_dtor((value) );
  }
  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((&(executor_globals.uninitialized_zval)));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (&(executor_globals.uninitialized_zval)); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }
 } else {
  if ((1<<4) == (1<<1)) {
    value = zend_assign_tmp_to_variable(variable_ptr_ptr, value );
  } else if ((1<<4) == (1<<0)) {
    value = zend_assign_const_to_variable(variable_ptr_ptr, value );
  } else {
    value = zend_assign_to_variable(variable_ptr_ptr, value );
  }
  if ((!((opline)->result_type & (1<<5)))) {
   zval_addref_p((value));
   do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (value); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
  }
 }



 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ASSIGN_REF_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zend_free_op free_op2;
 zval **variable_ptr_ptr;
 zval **value_ptr_ptr;

 ;
 value_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op2.var );

 if ((1<<4) == (1<<2) &&
     value_ptr_ptr &&
     !zval_isref_p(*(value_ptr_ptr)) &&
     opline->extended_value == 1<<0 &&
     !(*(temp_variable *)((char *) execute_data->Ts + opline->op2.var)).var.fcall_returned_reference) {
  if (free_op2.var == ((void *)0)) {
   zval_addref_p((*value_ptr_ptr));
  }
  zend_error((1<<11L), "Only variables should be assigned by reference");
  if (__builtin_expect((executor_globals.exception) != ((void *)0), 0)) {

   ; return 0;
  }
  return ZEND_ASSIGN_SPEC_CV_CV_HANDLER(execute_data );
 } else if ((1<<4) == (1<<2) && opline->extended_value == 1<<1) {
  zval_addref_p((*value_ptr_ptr));
 }
 if ((1<<4) == (1<<2) && __builtin_expect((*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr_ptr == &(*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr, 0)) {
  zend_error_noreturn((1<<0L), "Cannot assign by reference to overloaded object");
 }

 variable_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var );
 if (((1<<4) == (1<<2) && __builtin_expect(value_ptr_ptr == ((void *)0), 0)) ||
     ((1<<4) == (1<<2) && __builtin_expect(variable_ptr_ptr == ((void *)0), 0))) {
  zend_error_noreturn((1<<0L), "Cannot create references to/from string offsets nor overloaded objects");
 }
 zend_assign_to_variable_reference(variable_ptr_ptr, value_ptr_ptr );

 if ((1<<4) == (1<<2) && opline->extended_value == 1<<1) {
  zval_delref_p(*(variable_ptr_ptr));
 }

 if ((!((opline)->result_type & (1<<5)))) {
  zval_addref_p((*variable_ptr_ptr));
  do { temp_variable *__t = (&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var))); __t->var.ptr = (*variable_ptr_ptr); __t->var.ptr_ptr = &__t->var.ptr; } while (0);
 }


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_METHOD_CALL_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;
 zval *function_name;
 char *function_name_strval;
 int function_name_strlen;


 ;
 zend_ptr_stack_3_push(&(executor_globals.arg_types_stack), execute_data->fbc, execute_data->object, execute_data->called_scope);

 function_name = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );

 if ((1<<4) != (1<<0) &&
     __builtin_expect((*function_name).type != 6, 0)) {
  zend_error_noreturn((1<<0L), "Method name must be a string");
 }

 function_name_strval = (*function_name).value.str.val;
 function_name_strlen = (*function_name).value.str.len;

 execute_data->object = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );

 if (__builtin_expect(execute_data->object != ((void *)0), 1) &&
     __builtin_expect((*execute_data->object).type == 5, 1)) {
  execute_data->called_scope = zend_get_class_entry(&(*execute_data->object) );

  if ((1<<4) != (1<<0) ||
      (execute_data->fbc = (((executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] == (execute_data->called_scope)) ? (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] : ((void *)0))) == ((void *)0)) {
      zval *object = execute_data->object;

   if (__builtin_expect((*execute_data->object).value.obj.handlers->get_method == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Object does not support method calls");
   }


   execute_data->fbc = (*execute_data->object).value.obj.handlers->get_method(&execute_data->object, function_name_strval, function_name_strlen, (((1<<4) == (1<<0)) ? (opline->op2.literal + 1) : ((void *)0)) );
   if (__builtin_expect(execute_data->fbc == ((void *)0), 0)) {
    zend_error_noreturn((1<<0L), "Call to undefined method %s::%s()", ((execute_data->object) && (*execute_data->object).type == 5 && (*execute_data->object).value.obj.handlers->get_class_entry != ((void *)0) && (*execute_data->object).value.obj.handlers->get_class_entry(execute_data->object ) ? (*execute_data->object).value.obj.handlers->get_class_entry(execute_data->object )->name : ""), function_name_strval);
   }
   if ((1<<4) == (1<<0) &&
       __builtin_expect((execute_data->fbc->common.fn_flags & 0x200000) == 0, 1) &&
       __builtin_expect(execute_data->object == object, 1)) {
    do { (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot)] = (execute_data->called_scope); (executor_globals.active_op_array)->run_time_cache[(opline->op2.literal->cache_slot) + 1] = (execute_data->fbc); } while (0);
   }
  }
 } else {
  zend_error_noreturn((1<<0L), "Call to a member function %s() on a non-object", function_name_strval);
 }

 if ((execute_data->fbc->common.fn_flags & 0x01) != 0) {
  execute_data->object = ((void *)0);
 } else {
  if (!zval_isref_p(execute_data->object)) {
   zval_addref_p(execute_data->object);
  } else {
   zval *this_ptr;
   do { (this_ptr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(this_ptr))->u.buffered = ((void *)0); } while (0);
   do { do { (this_ptr)->value = (execute_data->object)->value; (*this_ptr).type = (*execute_data->object).type; } while (0); zval_set_refcount_p(this_ptr, 1); zval_unset_isref_p(this_ptr); } while (0);
   _zval_copy_ctor((this_ptr) );
   execute_data->object = this_ptr;
  }
 }


 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_CASE_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;


 ;
 if ((1<<4)==(1<<2)) {
  zval_addref_p(((*(temp_variable *)((char *) execute_data->Ts + opline->op1.var)).var.ptr));
 }
 is_equal_function(&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var,
     _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var ),
     _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var ) );

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval *expr_ptr;

 ;
 if (((1<<4) == (1<<2) || (1<<4) == (1<<4)) && opline->extended_value) {
  zval **expr_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data->CVs, opline->op1.var );

  if ((1<<4) == (1<<2) && __builtin_expect(expr_ptr_ptr == ((void *)0), 0)) {
   zend_error_noreturn((1<<0L), "Cannot create references to/from string offsets");
  }
  if (!zval_isref_p(*expr_ptr_ptr)) { do { if (zval_refcount_p(*((expr_ptr_ptr))) > 1) { zval *new_zv; zval_delref_p(*(expr_ptr_ptr)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(expr_ptr_ptr))->value; (*new_zv).type = (**(expr_ptr_ptr)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(expr_ptr_ptr) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); zval_set_isref_p(*((expr_ptr_ptr))); };
  expr_ptr = *expr_ptr_ptr;
  zval_addref_p(expr_ptr);
 } else {
  expr_ptr=_get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op1.var );
  if (0) {
   zval *new_expr;

   do { (new_expr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_expr))->u.buffered = ((void *)0); } while (0);
   do { do { (new_expr)->value = (expr_ptr)->value; (*new_expr).type = (*expr_ptr).type; } while (0); zval_set_refcount_p(new_expr, 1); zval_unset_isref_p(new_expr); } while (0);
   expr_ptr = new_expr;
  } else if ((1<<4) == (1<<0) || zval_isref_p(expr_ptr)) {
   zval *new_expr;

   do { (new_expr) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_expr))->u.buffered = ((void *)0); } while (0);
   do { do { (new_expr)->value = (expr_ptr)->value; (*new_expr).type = (*expr_ptr).type; } while (0); zval_set_refcount_p(new_expr, 1); zval_unset_isref_p(new_expr); } while (0);
   expr_ptr = new_expr;
   _zval_copy_ctor((&(*expr_ptr)) );
  } else {
   zval_addref_p(expr_ptr);
  }
 }

 if ((1<<4) != (1<<3)) {

  zval *offset = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );
  ulong hval;

  switch ((*offset).type) {
   case 2:
    hval = zend_dval_to_lval((*offset).value.dval);
    goto num_index;
   case 1:
   case 3:
    hval = (*offset).value.lval;
num_index:
    _zend_hash_index_update_or_next_insert(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, hval, &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   case 6:
    if ((1<<4) == (1<<0)) {
     hval = (((zend_literal*)(offset))->hash_value);
    } else {
     do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index; } } } while (0);
     if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
      hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
     } else {
      hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
     }
    }
    _zend_hash_quick_add_or_update(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   case 0:
    _zend_hash_add_or_update(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, "", sizeof(""), &expr_ptr, sizeof(zval *), ((void *)0), (1<<0) );
    break;
   default:
    zend_error((1<<1L), "Illegal offset type");
    i_zval_ptr_dtor(*(&expr_ptr) );

    break;
  }

 } else {
  _zend_hash_index_update_or_next_insert(((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.ht, 0, &expr_ptr, sizeof(zval *), ((void *)0), (1<<2) );
 }
 if (((1<<4) == (1<<2) || (1<<4) == (1<<4)) && opline->extended_value) {

 } else {

 }
 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_INIT_ARRAY_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 _array_init((&(*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var), 0 );
 if ((1<<4) == (1<<3)) {
  execute_data->opline++; return 0;

 } else {
  return ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CV_HANDLER(execute_data );

 }
}

static int __attribute__((fastcall)) ZEND_UNSET_DIM_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval **container;
 zval *offset;
 ulong hval;

 ;
 container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data->CVs, opline->op1.var );
 offset = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );

 if ((1<<4) != (1<<2) || container) {
  if ((1<<4) == (1<<4) && container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
  switch ((**container).type) {
   case 4: {
    HashTable *ht = (**container).value.ht;

    switch ((*offset).type) {
     case 2:
      hval = zend_dval_to_lval((*offset).value.dval);
      goto num_index_dim;
     case 7:
     case 3:
     case 1:
num_index_dim:
      hval = (*offset).value.lval;
      zend_hash_del_key_or_index(ht, ((void *)0), 0, hval, 1);
      break;
     case 6:
      if ((1<<4) == (1<<4) || (1<<4) == (1<<2)) {
       zval_addref_p(offset);
      }
      if ((1<<4) == (1<<0)) {
       hval = (((zend_literal*)(offset))->hash_value);
      } else {
       do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index_dim; } } } while (0);
       if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
        hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
       } else {
        hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
       }
      }
      if (ht == &(executor_globals.symbol_table)) {
       zend_delete_global_variable_ex(offset->value.str.val, offset->value.str.len, hval );
      } else {
       zend_hash_del_key_or_index(ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, 2);
      }
      if ((1<<4) == (1<<4) || (1<<4) == (1<<2)) {
       i_zval_ptr_dtor(*(&offset) );
      }
      break;
     case 0:
      zend_hash_del_key_or_index(ht, "", sizeof(""), 0, 0);
      break;
     default:
      zend_error((1<<1L), "Illegal offset type in unset");
      break;
    }

    break;
   }
   case 5:
    if (__builtin_expect((**container).value.obj.handlers->unset_dimension == ((void *)0), 0)) {
     zend_error_noreturn((1<<0L), "Cannot use object as array");
    }
    if (0) {
     do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
    }
    (**container).value.obj.handlers->unset_dimension(*container, offset );
    if (0) {
     i_zval_ptr_dtor(*(&offset) );
    } else {

    }
    break;
   case 6:
    zend_error_noreturn((1<<0L), "Cannot unset string offsets");
    return 0;
   default:

    break;
  }
 } else {

 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_UNSET_OBJ_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval **container;
 zval *offset;

 ;
 container = _get_zval_ptr_ptr_cv_BP_VAR_UNSET(execute_data->CVs, opline->op1.var );
 offset = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );

 if ((1<<4) != (1<<2) || container) {
  if ((1<<4) == (1<<4) && container != &(executor_globals.uninitialized_zval_ptr)) {
   if (!zval_isref_p(*container)) { do { if (zval_refcount_p(*((container))) > 1) { zval *new_zv; zval_delref_p(*(container)); do { (new_zv) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(new_zv))->u.buffered = ((void *)0); } while (0); do { do { (new_zv)->value = (*(container))->value; (*new_zv).type = (**(container)).type; } while (0); zval_set_refcount_p(new_zv, 1); zval_unset_isref_p(new_zv); } while (0); *(container) = new_zv; _zval_copy_ctor((new_zv) ); } } while (0); };
  }
  if ((**container).type == 5) {
   if (0) {
    do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
   }
   if ((**container).value.obj.handlers->unset_property) {
    (**container).value.obj.handlers->unset_property(*container, offset, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   } else {
    zend_error((1<<3L), "Trying to unset property of non-object");
   }
   if (0) {
    i_zval_ptr_dtor(*(&offset) );
   } else {

   }
  } else {

  }
 } else {

 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_CV(int prop_dim, zend_execute_data *execute_data )
{
 zend_op *opline = execute_data->opline;

 zval **container;
 zval **value = ((void *)0);
 int result = 0;
 ulong hval;
 zval *offset;

 ;
 container = _get_zval_ptr_ptr_cv_BP_VAR_IS(execute_data->CVs, opline->op1.var );

 offset = _get_zval_ptr_cv_BP_VAR_R(execute_data->CVs, opline->op2.var );

 if ((**container).type == 4 && !prop_dim) {
  HashTable *ht;
  int isset = 0;

  ht = (**container).value.ht;

  switch ((*offset).type) {
   case 2:
    hval = zend_dval_to_lval((*offset).value.dval);
    goto num_index_prop;
   case 7:
   case 3:
   case 1:
    hval = (*offset).value.lval;
num_index_prop:
    if (zend_hash_index_find(ht, hval, (void **) &value) == 0) {
     isset = 1;
    }
    break;
   case 6:
    if ((1<<4) == (1<<0)) {
     hval = (((zend_literal*)(offset))->hash_value);
    } else {
     if (!prop_dim) {
      do { register const char *tmp = (*offset).value.str.val; if (*tmp == '-') { tmp++; } if (*tmp >= '0' && *tmp <= '9') { const char *end = (*offset).value.str.val + (*offset).value.str.len+1 - 1; if ((*end != '\0') || (*tmp == '0' && (*offset).value.str.len+1 > 2) || (end - tmp > 11 - 1) || (4 == 4 && end - tmp == 11 - 1 && *tmp > '2')) { break; } hval = (*tmp - '0'); while (++tmp != end && *tmp >= '0' && *tmp <= '9') { hval = (hval * 10) + (*tmp - '0'); } if (tmp == end) { if (*(*offset).value.str.val == '-') { if (hval-1 > 2147483647L) { break; } hval = (ulong)(-(long)hval); } else if (hval > 2147483647L) { break; } goto num_index_prop; } } } while (0);
     }
     if (((((*offset).value.str.val) >= (compiler_globals.interned_strings_start)) && (((*offset).value.str.val) < (compiler_globals.interned_strings_end)))) {
      hval = (((Bucket*)(((char*)((*offset).value.str.val))-sizeof(Bucket)))->h);
     } else {
      hval = zend_hash_func((*offset).value.str.val, (*offset).value.str.len+1);
     }
    }
    if (zend_hash_quick_find(ht, (*offset).value.str.val, (*offset).value.str.len+1, hval, (void **) &value) == 0) {
     isset = 1;
    }
    break;
   case 0:
    if (zend_hash_find(ht, "", sizeof(""), (void **) &value) == 0) {
     isset = 1;
    }
    break;
   default:
    zend_error((1<<1L), "Illegal offset type in isset or empty");
    break;
  }

  if (opline->extended_value & 0x02000000) {
   if (isset && (**value).type == 0) {
    result = 0;
   } else {
    result = isset;
   }
  } else {
   if (!isset || !i_zend_is_true(*value)) {
    result = 0;
   } else {
    result = 1;
   }
  }

 } else if ((**container).type == 5) {
  if (0) {
   do { zval *_tmp; do { (_tmp) = (zval*)_emalloc((sizeof(zval_gc_info)) ); ((zval_gc_info*)(_tmp))->u.buffered = ((void *)0); } while (0); do { do { (_tmp)->value = ((offset))->value; (*_tmp).type = (*(offset)).type; } while (0); zval_set_refcount_p(_tmp, 1); zval_unset_isref_p(_tmp); } while (0); (offset) = _tmp; } while (0);
  }
  if (prop_dim) {
   if ((**container).value.obj.handlers->has_property) {
    result = (**container).value.obj.handlers->has_property(*container, offset, (opline->extended_value & 0x01000000) != 0, (((1<<4) == (1<<0)) ? opline->op2.literal : ((void *)0)) );
   } else {
    zend_error((1<<3L), "Trying to check property of non-object");
    result = 0;
   }
  } else {
   if ((**container).value.obj.handlers->has_dimension) {
    result = (**container).value.obj.handlers->has_dimension(*container, offset, (opline->extended_value & 0x01000000) != 0 );
   } else {
    zend_error((1<<3L), "Trying to check element of non-array");
    result = 0;
   }
  }
  if (0) {
   i_zval_ptr_dtor(*(&offset) );
  } else {

  }
 } else if ((*container)->type == 6 && !prop_dim) {
  zval tmp;

  if ((*offset).type != 1) {
   do { (&tmp)->value = (offset)->value; (*&tmp).type = (*offset).type; } while (0);
   _zval_copy_ctor((&tmp) );
   convert_to_long(&tmp);
   offset = &tmp;
  }
  if ((*offset).type == 1) {
   if (opline->extended_value & 0x02000000) {
    if (offset->value.lval >= 0 && offset->value.lval < (**container).value.str.len) {
     result = 1;
    }
   } else {
    if (offset->value.lval >= 0 && offset->value.lval < (**container).value.str.len && (**container).value.str.val[offset->value.lval] != '0') {
     result = 1;
    }
   }
  }

 } else {

 }

 ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).type = 3;
 if (opline->extended_value & 0x02000000) {
  ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.lval = result;
 } else {
  ((*(temp_variable *)((char *) execute_data->Ts + opline->result.var)).tmp_var).value.lval = !result;
 }

 ;
 execute_data->opline++; return 0;
}

static int __attribute__((fastcall)) ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_CV(0, execute_data );
}

static int __attribute__((fastcall)) ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CV_HANDLER(zend_execute_data *execute_data )
{
 return zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_CV(1, execute_data );
}

static int __attribute__((fastcall)) ZEND_NULL_HANDLER(zend_execute_data *execute_data )
{
 zend_error_noreturn((1<<0L), "Invalid opcode %d/%d/%d.", execute_data->opline->opcode, execute_data->opline->op1_type, execute_data->opline->op2_type);
}


void zend_init_opcodes_handlers(void)
{
  static const opcode_handler_t labels[] = {
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_NOP_SPEC_HANDLER,
   ZEND_ADD_SPEC_CONST_CONST_HANDLER,
   ZEND_ADD_SPEC_CONST_TMP_HANDLER,
   ZEND_ADD_SPEC_CONST_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ADD_SPEC_CONST_CV_HANDLER,
   ZEND_ADD_SPEC_TMP_CONST_HANDLER,
   ZEND_ADD_SPEC_TMP_TMP_HANDLER,
   ZEND_ADD_SPEC_TMP_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ADD_SPEC_TMP_CV_HANDLER,
   ZEND_ADD_SPEC_VAR_CONST_HANDLER,
   ZEND_ADD_SPEC_VAR_TMP_HANDLER,
   ZEND_ADD_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ADD_SPEC_VAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ADD_SPEC_CV_CONST_HANDLER,
   ZEND_ADD_SPEC_CV_TMP_HANDLER,
   ZEND_ADD_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ADD_SPEC_CV_CV_HANDLER,
   ZEND_SUB_SPEC_CONST_CONST_HANDLER,
   ZEND_SUB_SPEC_CONST_TMP_HANDLER,
   ZEND_SUB_SPEC_CONST_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SUB_SPEC_CONST_CV_HANDLER,
   ZEND_SUB_SPEC_TMP_CONST_HANDLER,
   ZEND_SUB_SPEC_TMP_TMP_HANDLER,
   ZEND_SUB_SPEC_TMP_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SUB_SPEC_TMP_CV_HANDLER,
   ZEND_SUB_SPEC_VAR_CONST_HANDLER,
   ZEND_SUB_SPEC_VAR_TMP_HANDLER,
   ZEND_SUB_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SUB_SPEC_VAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SUB_SPEC_CV_CONST_HANDLER,
   ZEND_SUB_SPEC_CV_TMP_HANDLER,
   ZEND_SUB_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SUB_SPEC_CV_CV_HANDLER,
   ZEND_MUL_SPEC_CONST_CONST_HANDLER,
   ZEND_MUL_SPEC_CONST_TMP_HANDLER,
   ZEND_MUL_SPEC_CONST_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_MUL_SPEC_CONST_CV_HANDLER,
   ZEND_MUL_SPEC_TMP_CONST_HANDLER,
   ZEND_MUL_SPEC_TMP_TMP_HANDLER,
   ZEND_MUL_SPEC_TMP_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_MUL_SPEC_TMP_CV_HANDLER,
   ZEND_MUL_SPEC_VAR_CONST_HANDLER,
   ZEND_MUL_SPEC_VAR_TMP_HANDLER,
   ZEND_MUL_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_MUL_SPEC_VAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_MUL_SPEC_CV_CONST_HANDLER,
   ZEND_MUL_SPEC_CV_TMP_HANDLER,
   ZEND_MUL_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_MUL_SPEC_CV_CV_HANDLER,
   ZEND_DIV_SPEC_CONST_CONST_HANDLER,
   ZEND_DIV_SPEC_CONST_TMP_HANDLER,
   ZEND_DIV_SPEC_CONST_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_DIV_SPEC_CONST_CV_HANDLER,
   ZEND_DIV_SPEC_TMP_CONST_HANDLER,
   ZEND_DIV_SPEC_TMP_TMP_HANDLER,
   ZEND_DIV_SPEC_TMP_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_DIV_SPEC_TMP_CV_HANDLER,
   ZEND_DIV_SPEC_VAR_CONST_HANDLER,
   ZEND_DIV_SPEC_VAR_TMP_HANDLER,
   ZEND_DIV_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_DIV_SPEC_VAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_DIV_SPEC_CV_CONST_HANDLER,
   ZEND_DIV_SPEC_CV_TMP_HANDLER,
   ZEND_DIV_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_DIV_SPEC_CV_CV_HANDLER,
   ZEND_MOD_SPEC_CONST_CONST_HANDLER,
   ZEND_MOD_SPEC_CONST_TMP_HANDLER,
   ZEND_MOD_SPEC_CONST_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_MOD_SPEC_CONST_CV_HANDLER,
   ZEND_MOD_SPEC_TMP_CONST_HANDLER,
   ZEND_MOD_SPEC_TMP_TMP_HANDLER,
   ZEND_MOD_SPEC_TMP_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_MOD_SPEC_TMP_CV_HANDLER,
   ZEND_MOD_SPEC_VAR_CONST_HANDLER,
   ZEND_MOD_SPEC_VAR_TMP_HANDLER,
   ZEND_MOD_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_MOD_SPEC_VAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_MOD_SPEC_CV_CONST_HANDLER,
   ZEND_MOD_SPEC_CV_TMP_HANDLER,
   ZEND_MOD_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_MOD_SPEC_CV_CV_HANDLER,
   ZEND_SL_SPEC_CONST_CONST_HANDLER,
   ZEND_SL_SPEC_CONST_TMP_HANDLER,
   ZEND_SL_SPEC_CONST_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SL_SPEC_CONST_CV_HANDLER,
   ZEND_SL_SPEC_TMP_CONST_HANDLER,
   ZEND_SL_SPEC_TMP_TMP_HANDLER,
   ZEND_SL_SPEC_TMP_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SL_SPEC_TMP_CV_HANDLER,
   ZEND_SL_SPEC_VAR_CONST_HANDLER,
   ZEND_SL_SPEC_VAR_TMP_HANDLER,
   ZEND_SL_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SL_SPEC_VAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SL_SPEC_CV_CONST_HANDLER,
   ZEND_SL_SPEC_CV_TMP_HANDLER,
   ZEND_SL_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SL_SPEC_CV_CV_HANDLER,
   ZEND_SR_SPEC_CONST_CONST_HANDLER,
   ZEND_SR_SPEC_CONST_TMP_HANDLER,
   ZEND_SR_SPEC_CONST_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SR_SPEC_CONST_CV_HANDLER,
   ZEND_SR_SPEC_TMP_CONST_HANDLER,
   ZEND_SR_SPEC_TMP_TMP_HANDLER,
   ZEND_SR_SPEC_TMP_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SR_SPEC_TMP_CV_HANDLER,
   ZEND_SR_SPEC_VAR_CONST_HANDLER,
   ZEND_SR_SPEC_VAR_TMP_HANDLER,
   ZEND_SR_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SR_SPEC_VAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SR_SPEC_CV_CONST_HANDLER,
   ZEND_SR_SPEC_CV_TMP_HANDLER,
   ZEND_SR_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SR_SPEC_CV_CV_HANDLER,
   ZEND_CONCAT_SPEC_CONST_CONST_HANDLER,
   ZEND_CONCAT_SPEC_CONST_TMP_HANDLER,
   ZEND_CONCAT_SPEC_CONST_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_CONCAT_SPEC_CONST_CV_HANDLER,
   ZEND_CONCAT_SPEC_TMP_CONST_HANDLER,
   ZEND_CONCAT_SPEC_TMP_TMP_HANDLER,
   ZEND_CONCAT_SPEC_TMP_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_CONCAT_SPEC_TMP_CV_HANDLER,
   ZEND_CONCAT_SPEC_VAR_CONST_HANDLER,
   ZEND_CONCAT_SPEC_VAR_TMP_HANDLER,
   ZEND_CONCAT_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_CONCAT_SPEC_VAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_CONCAT_SPEC_CV_CONST_HANDLER,
   ZEND_CONCAT_SPEC_CV_TMP_HANDLER,
   ZEND_CONCAT_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_CONCAT_SPEC_CV_CV_HANDLER,
   ZEND_BW_OR_SPEC_CONST_CONST_HANDLER,
   ZEND_BW_OR_SPEC_CONST_TMP_HANDLER,
   ZEND_BW_OR_SPEC_CONST_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BW_OR_SPEC_CONST_CV_HANDLER,
   ZEND_BW_OR_SPEC_TMP_CONST_HANDLER,
   ZEND_BW_OR_SPEC_TMP_TMP_HANDLER,
   ZEND_BW_OR_SPEC_TMP_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BW_OR_SPEC_TMP_CV_HANDLER,
   ZEND_BW_OR_SPEC_VAR_CONST_HANDLER,
   ZEND_BW_OR_SPEC_VAR_TMP_HANDLER,
   ZEND_BW_OR_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BW_OR_SPEC_VAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BW_OR_SPEC_CV_CONST_HANDLER,
   ZEND_BW_OR_SPEC_CV_TMP_HANDLER,
   ZEND_BW_OR_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BW_OR_SPEC_CV_CV_HANDLER,
   ZEND_BW_AND_SPEC_CONST_CONST_HANDLER,
   ZEND_BW_AND_SPEC_CONST_TMP_HANDLER,
   ZEND_BW_AND_SPEC_CONST_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BW_AND_SPEC_CONST_CV_HANDLER,
   ZEND_BW_AND_SPEC_TMP_CONST_HANDLER,
   ZEND_BW_AND_SPEC_TMP_TMP_HANDLER,
   ZEND_BW_AND_SPEC_TMP_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BW_AND_SPEC_TMP_CV_HANDLER,
   ZEND_BW_AND_SPEC_VAR_CONST_HANDLER,
   ZEND_BW_AND_SPEC_VAR_TMP_HANDLER,
   ZEND_BW_AND_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BW_AND_SPEC_VAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BW_AND_SPEC_CV_CONST_HANDLER,
   ZEND_BW_AND_SPEC_CV_TMP_HANDLER,
   ZEND_BW_AND_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BW_AND_SPEC_CV_CV_HANDLER,
   ZEND_BW_XOR_SPEC_CONST_CONST_HANDLER,
   ZEND_BW_XOR_SPEC_CONST_TMP_HANDLER,
   ZEND_BW_XOR_SPEC_CONST_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BW_XOR_SPEC_CONST_CV_HANDLER,
   ZEND_BW_XOR_SPEC_TMP_CONST_HANDLER,
   ZEND_BW_XOR_SPEC_TMP_TMP_HANDLER,
   ZEND_BW_XOR_SPEC_TMP_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BW_XOR_SPEC_TMP_CV_HANDLER,
   ZEND_BW_XOR_SPEC_VAR_CONST_HANDLER,
   ZEND_BW_XOR_SPEC_VAR_TMP_HANDLER,
   ZEND_BW_XOR_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BW_XOR_SPEC_VAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BW_XOR_SPEC_CV_CONST_HANDLER,
   ZEND_BW_XOR_SPEC_CV_TMP_HANDLER,
   ZEND_BW_XOR_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BW_XOR_SPEC_CV_CV_HANDLER,
   ZEND_BW_NOT_SPEC_CONST_HANDLER,
   ZEND_BW_NOT_SPEC_CONST_HANDLER,
   ZEND_BW_NOT_SPEC_CONST_HANDLER,
   ZEND_BW_NOT_SPEC_CONST_HANDLER,
   ZEND_BW_NOT_SPEC_CONST_HANDLER,
   ZEND_BW_NOT_SPEC_TMP_HANDLER,
   ZEND_BW_NOT_SPEC_TMP_HANDLER,
   ZEND_BW_NOT_SPEC_TMP_HANDLER,
   ZEND_BW_NOT_SPEC_TMP_HANDLER,
   ZEND_BW_NOT_SPEC_TMP_HANDLER,
   ZEND_BW_NOT_SPEC_VAR_HANDLER,
   ZEND_BW_NOT_SPEC_VAR_HANDLER,
   ZEND_BW_NOT_SPEC_VAR_HANDLER,
   ZEND_BW_NOT_SPEC_VAR_HANDLER,
   ZEND_BW_NOT_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BW_NOT_SPEC_CV_HANDLER,
   ZEND_BW_NOT_SPEC_CV_HANDLER,
   ZEND_BW_NOT_SPEC_CV_HANDLER,
   ZEND_BW_NOT_SPEC_CV_HANDLER,
   ZEND_BW_NOT_SPEC_CV_HANDLER,
   ZEND_BOOL_NOT_SPEC_CONST_HANDLER,
   ZEND_BOOL_NOT_SPEC_CONST_HANDLER,
   ZEND_BOOL_NOT_SPEC_CONST_HANDLER,
   ZEND_BOOL_NOT_SPEC_CONST_HANDLER,
   ZEND_BOOL_NOT_SPEC_CONST_HANDLER,
   ZEND_BOOL_NOT_SPEC_TMP_HANDLER,
   ZEND_BOOL_NOT_SPEC_TMP_HANDLER,
   ZEND_BOOL_NOT_SPEC_TMP_HANDLER,
   ZEND_BOOL_NOT_SPEC_TMP_HANDLER,
   ZEND_BOOL_NOT_SPEC_TMP_HANDLER,
   ZEND_BOOL_NOT_SPEC_VAR_HANDLER,
   ZEND_BOOL_NOT_SPEC_VAR_HANDLER,
   ZEND_BOOL_NOT_SPEC_VAR_HANDLER,
   ZEND_BOOL_NOT_SPEC_VAR_HANDLER,
   ZEND_BOOL_NOT_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BOOL_NOT_SPEC_CV_HANDLER,
   ZEND_BOOL_NOT_SPEC_CV_HANDLER,
   ZEND_BOOL_NOT_SPEC_CV_HANDLER,
   ZEND_BOOL_NOT_SPEC_CV_HANDLER,
   ZEND_BOOL_NOT_SPEC_CV_HANDLER,
   ZEND_BOOL_XOR_SPEC_CONST_CONST_HANDLER,
   ZEND_BOOL_XOR_SPEC_CONST_TMP_HANDLER,
   ZEND_BOOL_XOR_SPEC_CONST_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BOOL_XOR_SPEC_CONST_CV_HANDLER,
   ZEND_BOOL_XOR_SPEC_TMP_CONST_HANDLER,
   ZEND_BOOL_XOR_SPEC_TMP_TMP_HANDLER,
   ZEND_BOOL_XOR_SPEC_TMP_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BOOL_XOR_SPEC_TMP_CV_HANDLER,
   ZEND_BOOL_XOR_SPEC_VAR_CONST_HANDLER,
   ZEND_BOOL_XOR_SPEC_VAR_TMP_HANDLER,
   ZEND_BOOL_XOR_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BOOL_XOR_SPEC_VAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BOOL_XOR_SPEC_CV_CONST_HANDLER,
   ZEND_BOOL_XOR_SPEC_CV_TMP_HANDLER,
   ZEND_BOOL_XOR_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BOOL_XOR_SPEC_CV_CV_HANDLER,
   ZEND_IS_IDENTICAL_SPEC_CONST_CONST_HANDLER,
   ZEND_IS_IDENTICAL_SPEC_CONST_TMP_HANDLER,
   ZEND_IS_IDENTICAL_SPEC_CONST_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_IDENTICAL_SPEC_CONST_CV_HANDLER,
   ZEND_IS_IDENTICAL_SPEC_TMP_CONST_HANDLER,
   ZEND_IS_IDENTICAL_SPEC_TMP_TMP_HANDLER,
   ZEND_IS_IDENTICAL_SPEC_TMP_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_IDENTICAL_SPEC_TMP_CV_HANDLER,
   ZEND_IS_IDENTICAL_SPEC_VAR_CONST_HANDLER,
   ZEND_IS_IDENTICAL_SPEC_VAR_TMP_HANDLER,
   ZEND_IS_IDENTICAL_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_IDENTICAL_SPEC_VAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_IDENTICAL_SPEC_CV_CONST_HANDLER,
   ZEND_IS_IDENTICAL_SPEC_CV_TMP_HANDLER,
   ZEND_IS_IDENTICAL_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_IDENTICAL_SPEC_CV_CV_HANDLER,
   ZEND_IS_NOT_IDENTICAL_SPEC_CONST_CONST_HANDLER,
   ZEND_IS_NOT_IDENTICAL_SPEC_CONST_TMP_HANDLER,
   ZEND_IS_NOT_IDENTICAL_SPEC_CONST_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_NOT_IDENTICAL_SPEC_CONST_CV_HANDLER,
   ZEND_IS_NOT_IDENTICAL_SPEC_TMP_CONST_HANDLER,
   ZEND_IS_NOT_IDENTICAL_SPEC_TMP_TMP_HANDLER,
   ZEND_IS_NOT_IDENTICAL_SPEC_TMP_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_NOT_IDENTICAL_SPEC_TMP_CV_HANDLER,
   ZEND_IS_NOT_IDENTICAL_SPEC_VAR_CONST_HANDLER,
   ZEND_IS_NOT_IDENTICAL_SPEC_VAR_TMP_HANDLER,
   ZEND_IS_NOT_IDENTICAL_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_NOT_IDENTICAL_SPEC_VAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_NOT_IDENTICAL_SPEC_CV_CONST_HANDLER,
   ZEND_IS_NOT_IDENTICAL_SPEC_CV_TMP_HANDLER,
   ZEND_IS_NOT_IDENTICAL_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_NOT_IDENTICAL_SPEC_CV_CV_HANDLER,
   ZEND_IS_EQUAL_SPEC_CONST_CONST_HANDLER,
   ZEND_IS_EQUAL_SPEC_CONST_TMP_HANDLER,
   ZEND_IS_EQUAL_SPEC_CONST_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_EQUAL_SPEC_CONST_CV_HANDLER,
   ZEND_IS_EQUAL_SPEC_TMP_CONST_HANDLER,
   ZEND_IS_EQUAL_SPEC_TMP_TMP_HANDLER,
   ZEND_IS_EQUAL_SPEC_TMP_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_EQUAL_SPEC_TMP_CV_HANDLER,
   ZEND_IS_EQUAL_SPEC_VAR_CONST_HANDLER,
   ZEND_IS_EQUAL_SPEC_VAR_TMP_HANDLER,
   ZEND_IS_EQUAL_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_EQUAL_SPEC_VAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_EQUAL_SPEC_CV_CONST_HANDLER,
   ZEND_IS_EQUAL_SPEC_CV_TMP_HANDLER,
   ZEND_IS_EQUAL_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_EQUAL_SPEC_CV_CV_HANDLER,
   ZEND_IS_NOT_EQUAL_SPEC_CONST_CONST_HANDLER,
   ZEND_IS_NOT_EQUAL_SPEC_CONST_TMP_HANDLER,
   ZEND_IS_NOT_EQUAL_SPEC_CONST_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_NOT_EQUAL_SPEC_CONST_CV_HANDLER,
   ZEND_IS_NOT_EQUAL_SPEC_TMP_CONST_HANDLER,
   ZEND_IS_NOT_EQUAL_SPEC_TMP_TMP_HANDLER,
   ZEND_IS_NOT_EQUAL_SPEC_TMP_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_NOT_EQUAL_SPEC_TMP_CV_HANDLER,
   ZEND_IS_NOT_EQUAL_SPEC_VAR_CONST_HANDLER,
   ZEND_IS_NOT_EQUAL_SPEC_VAR_TMP_HANDLER,
   ZEND_IS_NOT_EQUAL_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_NOT_EQUAL_SPEC_VAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_NOT_EQUAL_SPEC_CV_CONST_HANDLER,
   ZEND_IS_NOT_EQUAL_SPEC_CV_TMP_HANDLER,
   ZEND_IS_NOT_EQUAL_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_NOT_EQUAL_SPEC_CV_CV_HANDLER,
   ZEND_IS_SMALLER_SPEC_CONST_CONST_HANDLER,
   ZEND_IS_SMALLER_SPEC_CONST_TMP_HANDLER,
   ZEND_IS_SMALLER_SPEC_CONST_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_SMALLER_SPEC_CONST_CV_HANDLER,
   ZEND_IS_SMALLER_SPEC_TMP_CONST_HANDLER,
   ZEND_IS_SMALLER_SPEC_TMP_TMP_HANDLER,
   ZEND_IS_SMALLER_SPEC_TMP_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_SMALLER_SPEC_TMP_CV_HANDLER,
   ZEND_IS_SMALLER_SPEC_VAR_CONST_HANDLER,
   ZEND_IS_SMALLER_SPEC_VAR_TMP_HANDLER,
   ZEND_IS_SMALLER_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_SMALLER_SPEC_VAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_SMALLER_SPEC_CV_CONST_HANDLER,
   ZEND_IS_SMALLER_SPEC_CV_TMP_HANDLER,
   ZEND_IS_SMALLER_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_SMALLER_SPEC_CV_CV_HANDLER,
   ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_CONST_HANDLER,
   ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMP_HANDLER,
   ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_CV_HANDLER,
   ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMP_CONST_HANDLER,
   ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMP_TMP_HANDLER,
   ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMP_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMP_CV_HANDLER,
   ZEND_IS_SMALLER_OR_EQUAL_SPEC_VAR_CONST_HANDLER,
   ZEND_IS_SMALLER_OR_EQUAL_SPEC_VAR_TMP_HANDLER,
   ZEND_IS_SMALLER_OR_EQUAL_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_SMALLER_OR_EQUAL_SPEC_VAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_CONST_HANDLER,
   ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_TMP_HANDLER,
   ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_CV_HANDLER,
   ZEND_CAST_SPEC_CONST_HANDLER,
   ZEND_CAST_SPEC_CONST_HANDLER,
   ZEND_CAST_SPEC_CONST_HANDLER,
   ZEND_CAST_SPEC_CONST_HANDLER,
   ZEND_CAST_SPEC_CONST_HANDLER,
   ZEND_CAST_SPEC_TMP_HANDLER,
   ZEND_CAST_SPEC_TMP_HANDLER,
   ZEND_CAST_SPEC_TMP_HANDLER,
   ZEND_CAST_SPEC_TMP_HANDLER,
   ZEND_CAST_SPEC_TMP_HANDLER,
   ZEND_CAST_SPEC_VAR_HANDLER,
   ZEND_CAST_SPEC_VAR_HANDLER,
   ZEND_CAST_SPEC_VAR_HANDLER,
   ZEND_CAST_SPEC_VAR_HANDLER,
   ZEND_CAST_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_CAST_SPEC_CV_HANDLER,
   ZEND_CAST_SPEC_CV_HANDLER,
   ZEND_CAST_SPEC_CV_HANDLER,
   ZEND_CAST_SPEC_CV_HANDLER,
   ZEND_CAST_SPEC_CV_HANDLER,
   ZEND_QM_ASSIGN_SPEC_CONST_HANDLER,
   ZEND_QM_ASSIGN_SPEC_CONST_HANDLER,
   ZEND_QM_ASSIGN_SPEC_CONST_HANDLER,
   ZEND_QM_ASSIGN_SPEC_CONST_HANDLER,
   ZEND_QM_ASSIGN_SPEC_CONST_HANDLER,
   ZEND_QM_ASSIGN_SPEC_TMP_HANDLER,
   ZEND_QM_ASSIGN_SPEC_TMP_HANDLER,
   ZEND_QM_ASSIGN_SPEC_TMP_HANDLER,
   ZEND_QM_ASSIGN_SPEC_TMP_HANDLER,
   ZEND_QM_ASSIGN_SPEC_TMP_HANDLER,
   ZEND_QM_ASSIGN_SPEC_VAR_HANDLER,
   ZEND_QM_ASSIGN_SPEC_VAR_HANDLER,
   ZEND_QM_ASSIGN_SPEC_VAR_HANDLER,
   ZEND_QM_ASSIGN_SPEC_VAR_HANDLER,
   ZEND_QM_ASSIGN_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_QM_ASSIGN_SPEC_CV_HANDLER,
   ZEND_QM_ASSIGN_SPEC_CV_HANDLER,
   ZEND_QM_ASSIGN_SPEC_CV_HANDLER,
   ZEND_QM_ASSIGN_SPEC_CV_HANDLER,
   ZEND_QM_ASSIGN_SPEC_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_ADD_SPEC_VAR_CONST_HANDLER,
   ZEND_ASSIGN_ADD_SPEC_VAR_TMP_HANDLER,
   ZEND_ASSIGN_ADD_SPEC_VAR_VAR_HANDLER,
   ZEND_ASSIGN_ADD_SPEC_VAR_UNUSED_HANDLER,
   ZEND_ASSIGN_ADD_SPEC_VAR_CV_HANDLER,
   ZEND_ASSIGN_ADD_SPEC_UNUSED_CONST_HANDLER,
   ZEND_ASSIGN_ADD_SPEC_UNUSED_TMP_HANDLER,
   ZEND_ASSIGN_ADD_SPEC_UNUSED_VAR_HANDLER,
   ZEND_ASSIGN_ADD_SPEC_UNUSED_UNUSED_HANDLER,
   ZEND_ASSIGN_ADD_SPEC_UNUSED_CV_HANDLER,
   ZEND_ASSIGN_ADD_SPEC_CV_CONST_HANDLER,
   ZEND_ASSIGN_ADD_SPEC_CV_TMP_HANDLER,
   ZEND_ASSIGN_ADD_SPEC_CV_VAR_HANDLER,
   ZEND_ASSIGN_ADD_SPEC_CV_UNUSED_HANDLER,
   ZEND_ASSIGN_ADD_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_SUB_SPEC_VAR_CONST_HANDLER,
   ZEND_ASSIGN_SUB_SPEC_VAR_TMP_HANDLER,
   ZEND_ASSIGN_SUB_SPEC_VAR_VAR_HANDLER,
   ZEND_ASSIGN_SUB_SPEC_VAR_UNUSED_HANDLER,
   ZEND_ASSIGN_SUB_SPEC_VAR_CV_HANDLER,
   ZEND_ASSIGN_SUB_SPEC_UNUSED_CONST_HANDLER,
   ZEND_ASSIGN_SUB_SPEC_UNUSED_TMP_HANDLER,
   ZEND_ASSIGN_SUB_SPEC_UNUSED_VAR_HANDLER,
   ZEND_ASSIGN_SUB_SPEC_UNUSED_UNUSED_HANDLER,
   ZEND_ASSIGN_SUB_SPEC_UNUSED_CV_HANDLER,
   ZEND_ASSIGN_SUB_SPEC_CV_CONST_HANDLER,
   ZEND_ASSIGN_SUB_SPEC_CV_TMP_HANDLER,
   ZEND_ASSIGN_SUB_SPEC_CV_VAR_HANDLER,
   ZEND_ASSIGN_SUB_SPEC_CV_UNUSED_HANDLER,
   ZEND_ASSIGN_SUB_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_MUL_SPEC_VAR_CONST_HANDLER,
   ZEND_ASSIGN_MUL_SPEC_VAR_TMP_HANDLER,
   ZEND_ASSIGN_MUL_SPEC_VAR_VAR_HANDLER,
   ZEND_ASSIGN_MUL_SPEC_VAR_UNUSED_HANDLER,
   ZEND_ASSIGN_MUL_SPEC_VAR_CV_HANDLER,
   ZEND_ASSIGN_MUL_SPEC_UNUSED_CONST_HANDLER,
   ZEND_ASSIGN_MUL_SPEC_UNUSED_TMP_HANDLER,
   ZEND_ASSIGN_MUL_SPEC_UNUSED_VAR_HANDLER,
   ZEND_ASSIGN_MUL_SPEC_UNUSED_UNUSED_HANDLER,
   ZEND_ASSIGN_MUL_SPEC_UNUSED_CV_HANDLER,
   ZEND_ASSIGN_MUL_SPEC_CV_CONST_HANDLER,
   ZEND_ASSIGN_MUL_SPEC_CV_TMP_HANDLER,
   ZEND_ASSIGN_MUL_SPEC_CV_VAR_HANDLER,
   ZEND_ASSIGN_MUL_SPEC_CV_UNUSED_HANDLER,
   ZEND_ASSIGN_MUL_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_DIV_SPEC_VAR_CONST_HANDLER,
   ZEND_ASSIGN_DIV_SPEC_VAR_TMP_HANDLER,
   ZEND_ASSIGN_DIV_SPEC_VAR_VAR_HANDLER,
   ZEND_ASSIGN_DIV_SPEC_VAR_UNUSED_HANDLER,
   ZEND_ASSIGN_DIV_SPEC_VAR_CV_HANDLER,
   ZEND_ASSIGN_DIV_SPEC_UNUSED_CONST_HANDLER,
   ZEND_ASSIGN_DIV_SPEC_UNUSED_TMP_HANDLER,
   ZEND_ASSIGN_DIV_SPEC_UNUSED_VAR_HANDLER,
   ZEND_ASSIGN_DIV_SPEC_UNUSED_UNUSED_HANDLER,
   ZEND_ASSIGN_DIV_SPEC_UNUSED_CV_HANDLER,
   ZEND_ASSIGN_DIV_SPEC_CV_CONST_HANDLER,
   ZEND_ASSIGN_DIV_SPEC_CV_TMP_HANDLER,
   ZEND_ASSIGN_DIV_SPEC_CV_VAR_HANDLER,
   ZEND_ASSIGN_DIV_SPEC_CV_UNUSED_HANDLER,
   ZEND_ASSIGN_DIV_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_MOD_SPEC_VAR_CONST_HANDLER,
   ZEND_ASSIGN_MOD_SPEC_VAR_TMP_HANDLER,
   ZEND_ASSIGN_MOD_SPEC_VAR_VAR_HANDLER,
   ZEND_ASSIGN_MOD_SPEC_VAR_UNUSED_HANDLER,
   ZEND_ASSIGN_MOD_SPEC_VAR_CV_HANDLER,
   ZEND_ASSIGN_MOD_SPEC_UNUSED_CONST_HANDLER,
   ZEND_ASSIGN_MOD_SPEC_UNUSED_TMP_HANDLER,
   ZEND_ASSIGN_MOD_SPEC_UNUSED_VAR_HANDLER,
   ZEND_ASSIGN_MOD_SPEC_UNUSED_UNUSED_HANDLER,
   ZEND_ASSIGN_MOD_SPEC_UNUSED_CV_HANDLER,
   ZEND_ASSIGN_MOD_SPEC_CV_CONST_HANDLER,
   ZEND_ASSIGN_MOD_SPEC_CV_TMP_HANDLER,
   ZEND_ASSIGN_MOD_SPEC_CV_VAR_HANDLER,
   ZEND_ASSIGN_MOD_SPEC_CV_UNUSED_HANDLER,
   ZEND_ASSIGN_MOD_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_SL_SPEC_VAR_CONST_HANDLER,
   ZEND_ASSIGN_SL_SPEC_VAR_TMP_HANDLER,
   ZEND_ASSIGN_SL_SPEC_VAR_VAR_HANDLER,
   ZEND_ASSIGN_SL_SPEC_VAR_UNUSED_HANDLER,
   ZEND_ASSIGN_SL_SPEC_VAR_CV_HANDLER,
   ZEND_ASSIGN_SL_SPEC_UNUSED_CONST_HANDLER,
   ZEND_ASSIGN_SL_SPEC_UNUSED_TMP_HANDLER,
   ZEND_ASSIGN_SL_SPEC_UNUSED_VAR_HANDLER,
   ZEND_ASSIGN_SL_SPEC_UNUSED_UNUSED_HANDLER,
   ZEND_ASSIGN_SL_SPEC_UNUSED_CV_HANDLER,
   ZEND_ASSIGN_SL_SPEC_CV_CONST_HANDLER,
   ZEND_ASSIGN_SL_SPEC_CV_TMP_HANDLER,
   ZEND_ASSIGN_SL_SPEC_CV_VAR_HANDLER,
   ZEND_ASSIGN_SL_SPEC_CV_UNUSED_HANDLER,
   ZEND_ASSIGN_SL_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_SR_SPEC_VAR_CONST_HANDLER,
   ZEND_ASSIGN_SR_SPEC_VAR_TMP_HANDLER,
   ZEND_ASSIGN_SR_SPEC_VAR_VAR_HANDLER,
   ZEND_ASSIGN_SR_SPEC_VAR_UNUSED_HANDLER,
   ZEND_ASSIGN_SR_SPEC_VAR_CV_HANDLER,
   ZEND_ASSIGN_SR_SPEC_UNUSED_CONST_HANDLER,
   ZEND_ASSIGN_SR_SPEC_UNUSED_TMP_HANDLER,
   ZEND_ASSIGN_SR_SPEC_UNUSED_VAR_HANDLER,
   ZEND_ASSIGN_SR_SPEC_UNUSED_UNUSED_HANDLER,
   ZEND_ASSIGN_SR_SPEC_UNUSED_CV_HANDLER,
   ZEND_ASSIGN_SR_SPEC_CV_CONST_HANDLER,
   ZEND_ASSIGN_SR_SPEC_CV_TMP_HANDLER,
   ZEND_ASSIGN_SR_SPEC_CV_VAR_HANDLER,
   ZEND_ASSIGN_SR_SPEC_CV_UNUSED_HANDLER,
   ZEND_ASSIGN_SR_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_CONCAT_SPEC_VAR_CONST_HANDLER,
   ZEND_ASSIGN_CONCAT_SPEC_VAR_TMP_HANDLER,
   ZEND_ASSIGN_CONCAT_SPEC_VAR_VAR_HANDLER,
   ZEND_ASSIGN_CONCAT_SPEC_VAR_UNUSED_HANDLER,
   ZEND_ASSIGN_CONCAT_SPEC_VAR_CV_HANDLER,
   ZEND_ASSIGN_CONCAT_SPEC_UNUSED_CONST_HANDLER,
   ZEND_ASSIGN_CONCAT_SPEC_UNUSED_TMP_HANDLER,
   ZEND_ASSIGN_CONCAT_SPEC_UNUSED_VAR_HANDLER,
   ZEND_ASSIGN_CONCAT_SPEC_UNUSED_UNUSED_HANDLER,
   ZEND_ASSIGN_CONCAT_SPEC_UNUSED_CV_HANDLER,
   ZEND_ASSIGN_CONCAT_SPEC_CV_CONST_HANDLER,
   ZEND_ASSIGN_CONCAT_SPEC_CV_TMP_HANDLER,
   ZEND_ASSIGN_CONCAT_SPEC_CV_VAR_HANDLER,
   ZEND_ASSIGN_CONCAT_SPEC_CV_UNUSED_HANDLER,
   ZEND_ASSIGN_CONCAT_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_BW_OR_SPEC_VAR_CONST_HANDLER,
   ZEND_ASSIGN_BW_OR_SPEC_VAR_TMP_HANDLER,
   ZEND_ASSIGN_BW_OR_SPEC_VAR_VAR_HANDLER,
   ZEND_ASSIGN_BW_OR_SPEC_VAR_UNUSED_HANDLER,
   ZEND_ASSIGN_BW_OR_SPEC_VAR_CV_HANDLER,
   ZEND_ASSIGN_BW_OR_SPEC_UNUSED_CONST_HANDLER,
   ZEND_ASSIGN_BW_OR_SPEC_UNUSED_TMP_HANDLER,
   ZEND_ASSIGN_BW_OR_SPEC_UNUSED_VAR_HANDLER,
   ZEND_ASSIGN_BW_OR_SPEC_UNUSED_UNUSED_HANDLER,
   ZEND_ASSIGN_BW_OR_SPEC_UNUSED_CV_HANDLER,
   ZEND_ASSIGN_BW_OR_SPEC_CV_CONST_HANDLER,
   ZEND_ASSIGN_BW_OR_SPEC_CV_TMP_HANDLER,
   ZEND_ASSIGN_BW_OR_SPEC_CV_VAR_HANDLER,
   ZEND_ASSIGN_BW_OR_SPEC_CV_UNUSED_HANDLER,
   ZEND_ASSIGN_BW_OR_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_BW_AND_SPEC_VAR_CONST_HANDLER,
   ZEND_ASSIGN_BW_AND_SPEC_VAR_TMP_HANDLER,
   ZEND_ASSIGN_BW_AND_SPEC_VAR_VAR_HANDLER,
   ZEND_ASSIGN_BW_AND_SPEC_VAR_UNUSED_HANDLER,
   ZEND_ASSIGN_BW_AND_SPEC_VAR_CV_HANDLER,
   ZEND_ASSIGN_BW_AND_SPEC_UNUSED_CONST_HANDLER,
   ZEND_ASSIGN_BW_AND_SPEC_UNUSED_TMP_HANDLER,
   ZEND_ASSIGN_BW_AND_SPEC_UNUSED_VAR_HANDLER,
   ZEND_ASSIGN_BW_AND_SPEC_UNUSED_UNUSED_HANDLER,
   ZEND_ASSIGN_BW_AND_SPEC_UNUSED_CV_HANDLER,
   ZEND_ASSIGN_BW_AND_SPEC_CV_CONST_HANDLER,
   ZEND_ASSIGN_BW_AND_SPEC_CV_TMP_HANDLER,
   ZEND_ASSIGN_BW_AND_SPEC_CV_VAR_HANDLER,
   ZEND_ASSIGN_BW_AND_SPEC_CV_UNUSED_HANDLER,
   ZEND_ASSIGN_BW_AND_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_BW_XOR_SPEC_VAR_CONST_HANDLER,
   ZEND_ASSIGN_BW_XOR_SPEC_VAR_TMP_HANDLER,
   ZEND_ASSIGN_BW_XOR_SPEC_VAR_VAR_HANDLER,
   ZEND_ASSIGN_BW_XOR_SPEC_VAR_UNUSED_HANDLER,
   ZEND_ASSIGN_BW_XOR_SPEC_VAR_CV_HANDLER,
   ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_CONST_HANDLER,
   ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_TMP_HANDLER,
   ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_VAR_HANDLER,
   ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_UNUSED_HANDLER,
   ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_CV_HANDLER,
   ZEND_ASSIGN_BW_XOR_SPEC_CV_CONST_HANDLER,
   ZEND_ASSIGN_BW_XOR_SPEC_CV_TMP_HANDLER,
   ZEND_ASSIGN_BW_XOR_SPEC_CV_VAR_HANDLER,
   ZEND_ASSIGN_BW_XOR_SPEC_CV_UNUSED_HANDLER,
   ZEND_ASSIGN_BW_XOR_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_PRE_INC_SPEC_VAR_HANDLER,
   ZEND_PRE_INC_SPEC_VAR_HANDLER,
   ZEND_PRE_INC_SPEC_VAR_HANDLER,
   ZEND_PRE_INC_SPEC_VAR_HANDLER,
   ZEND_PRE_INC_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_PRE_INC_SPEC_CV_HANDLER,
   ZEND_PRE_INC_SPEC_CV_HANDLER,
   ZEND_PRE_INC_SPEC_CV_HANDLER,
   ZEND_PRE_INC_SPEC_CV_HANDLER,
   ZEND_PRE_INC_SPEC_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_PRE_DEC_SPEC_VAR_HANDLER,
   ZEND_PRE_DEC_SPEC_VAR_HANDLER,
   ZEND_PRE_DEC_SPEC_VAR_HANDLER,
   ZEND_PRE_DEC_SPEC_VAR_HANDLER,
   ZEND_PRE_DEC_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_PRE_DEC_SPEC_CV_HANDLER,
   ZEND_PRE_DEC_SPEC_CV_HANDLER,
   ZEND_PRE_DEC_SPEC_CV_HANDLER,
   ZEND_PRE_DEC_SPEC_CV_HANDLER,
   ZEND_PRE_DEC_SPEC_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_POST_INC_SPEC_VAR_HANDLER,
   ZEND_POST_INC_SPEC_VAR_HANDLER,
   ZEND_POST_INC_SPEC_VAR_HANDLER,
   ZEND_POST_INC_SPEC_VAR_HANDLER,
   ZEND_POST_INC_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_POST_INC_SPEC_CV_HANDLER,
   ZEND_POST_INC_SPEC_CV_HANDLER,
   ZEND_POST_INC_SPEC_CV_HANDLER,
   ZEND_POST_INC_SPEC_CV_HANDLER,
   ZEND_POST_INC_SPEC_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_POST_DEC_SPEC_VAR_HANDLER,
   ZEND_POST_DEC_SPEC_VAR_HANDLER,
   ZEND_POST_DEC_SPEC_VAR_HANDLER,
   ZEND_POST_DEC_SPEC_VAR_HANDLER,
   ZEND_POST_DEC_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_POST_DEC_SPEC_CV_HANDLER,
   ZEND_POST_DEC_SPEC_CV_HANDLER,
   ZEND_POST_DEC_SPEC_CV_HANDLER,
   ZEND_POST_DEC_SPEC_CV_HANDLER,
   ZEND_POST_DEC_SPEC_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_SPEC_VAR_CONST_HANDLER,
   ZEND_ASSIGN_SPEC_VAR_TMP_HANDLER,
   ZEND_ASSIGN_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_SPEC_VAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_SPEC_CV_CONST_HANDLER,
   ZEND_ASSIGN_SPEC_CV_TMP_HANDLER,
   ZEND_ASSIGN_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_REF_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_REF_SPEC_VAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_REF_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_REF_SPEC_CV_CV_HANDLER,
   ZEND_ECHO_SPEC_CONST_HANDLER,
   ZEND_ECHO_SPEC_CONST_HANDLER,
   ZEND_ECHO_SPEC_CONST_HANDLER,
   ZEND_ECHO_SPEC_CONST_HANDLER,
   ZEND_ECHO_SPEC_CONST_HANDLER,
   ZEND_ECHO_SPEC_TMP_HANDLER,
   ZEND_ECHO_SPEC_TMP_HANDLER,
   ZEND_ECHO_SPEC_TMP_HANDLER,
   ZEND_ECHO_SPEC_TMP_HANDLER,
   ZEND_ECHO_SPEC_TMP_HANDLER,
   ZEND_ECHO_SPEC_VAR_HANDLER,
   ZEND_ECHO_SPEC_VAR_HANDLER,
   ZEND_ECHO_SPEC_VAR_HANDLER,
   ZEND_ECHO_SPEC_VAR_HANDLER,
   ZEND_ECHO_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ECHO_SPEC_CV_HANDLER,
   ZEND_ECHO_SPEC_CV_HANDLER,
   ZEND_ECHO_SPEC_CV_HANDLER,
   ZEND_ECHO_SPEC_CV_HANDLER,
   ZEND_ECHO_SPEC_CV_HANDLER,
   ZEND_PRINT_SPEC_CONST_HANDLER,
   ZEND_PRINT_SPEC_CONST_HANDLER,
   ZEND_PRINT_SPEC_CONST_HANDLER,
   ZEND_PRINT_SPEC_CONST_HANDLER,
   ZEND_PRINT_SPEC_CONST_HANDLER,
   ZEND_PRINT_SPEC_TMP_HANDLER,
   ZEND_PRINT_SPEC_TMP_HANDLER,
   ZEND_PRINT_SPEC_TMP_HANDLER,
   ZEND_PRINT_SPEC_TMP_HANDLER,
   ZEND_PRINT_SPEC_TMP_HANDLER,
   ZEND_PRINT_SPEC_VAR_HANDLER,
   ZEND_PRINT_SPEC_VAR_HANDLER,
   ZEND_PRINT_SPEC_VAR_HANDLER,
   ZEND_PRINT_SPEC_VAR_HANDLER,
   ZEND_PRINT_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_PRINT_SPEC_CV_HANDLER,
   ZEND_PRINT_SPEC_CV_HANDLER,
   ZEND_PRINT_SPEC_CV_HANDLER,
   ZEND_PRINT_SPEC_CV_HANDLER,
   ZEND_PRINT_SPEC_CV_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMP_SPEC_HANDLER,
   ZEND_JMPZ_SPEC_CONST_HANDLER,
   ZEND_JMPZ_SPEC_CONST_HANDLER,
   ZEND_JMPZ_SPEC_CONST_HANDLER,
   ZEND_JMPZ_SPEC_CONST_HANDLER,
   ZEND_JMPZ_SPEC_CONST_HANDLER,
   ZEND_JMPZ_SPEC_TMP_HANDLER,
   ZEND_JMPZ_SPEC_TMP_HANDLER,
   ZEND_JMPZ_SPEC_TMP_HANDLER,
   ZEND_JMPZ_SPEC_TMP_HANDLER,
   ZEND_JMPZ_SPEC_TMP_HANDLER,
   ZEND_JMPZ_SPEC_VAR_HANDLER,
   ZEND_JMPZ_SPEC_VAR_HANDLER,
   ZEND_JMPZ_SPEC_VAR_HANDLER,
   ZEND_JMPZ_SPEC_VAR_HANDLER,
   ZEND_JMPZ_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_JMPZ_SPEC_CV_HANDLER,
   ZEND_JMPZ_SPEC_CV_HANDLER,
   ZEND_JMPZ_SPEC_CV_HANDLER,
   ZEND_JMPZ_SPEC_CV_HANDLER,
   ZEND_JMPZ_SPEC_CV_HANDLER,
   ZEND_JMPNZ_SPEC_CONST_HANDLER,
   ZEND_JMPNZ_SPEC_CONST_HANDLER,
   ZEND_JMPNZ_SPEC_CONST_HANDLER,
   ZEND_JMPNZ_SPEC_CONST_HANDLER,
   ZEND_JMPNZ_SPEC_CONST_HANDLER,
   ZEND_JMPNZ_SPEC_TMP_HANDLER,
   ZEND_JMPNZ_SPEC_TMP_HANDLER,
   ZEND_JMPNZ_SPEC_TMP_HANDLER,
   ZEND_JMPNZ_SPEC_TMP_HANDLER,
   ZEND_JMPNZ_SPEC_TMP_HANDLER,
   ZEND_JMPNZ_SPEC_VAR_HANDLER,
   ZEND_JMPNZ_SPEC_VAR_HANDLER,
   ZEND_JMPNZ_SPEC_VAR_HANDLER,
   ZEND_JMPNZ_SPEC_VAR_HANDLER,
   ZEND_JMPNZ_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_JMPNZ_SPEC_CV_HANDLER,
   ZEND_JMPNZ_SPEC_CV_HANDLER,
   ZEND_JMPNZ_SPEC_CV_HANDLER,
   ZEND_JMPNZ_SPEC_CV_HANDLER,
   ZEND_JMPNZ_SPEC_CV_HANDLER,
   ZEND_JMPZNZ_SPEC_CONST_HANDLER,
   ZEND_JMPZNZ_SPEC_CONST_HANDLER,
   ZEND_JMPZNZ_SPEC_CONST_HANDLER,
   ZEND_JMPZNZ_SPEC_CONST_HANDLER,
   ZEND_JMPZNZ_SPEC_CONST_HANDLER,
   ZEND_JMPZNZ_SPEC_TMP_HANDLER,
   ZEND_JMPZNZ_SPEC_TMP_HANDLER,
   ZEND_JMPZNZ_SPEC_TMP_HANDLER,
   ZEND_JMPZNZ_SPEC_TMP_HANDLER,
   ZEND_JMPZNZ_SPEC_TMP_HANDLER,
   ZEND_JMPZNZ_SPEC_VAR_HANDLER,
   ZEND_JMPZNZ_SPEC_VAR_HANDLER,
   ZEND_JMPZNZ_SPEC_VAR_HANDLER,
   ZEND_JMPZNZ_SPEC_VAR_HANDLER,
   ZEND_JMPZNZ_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_JMPZNZ_SPEC_CV_HANDLER,
   ZEND_JMPZNZ_SPEC_CV_HANDLER,
   ZEND_JMPZNZ_SPEC_CV_HANDLER,
   ZEND_JMPZNZ_SPEC_CV_HANDLER,
   ZEND_JMPZNZ_SPEC_CV_HANDLER,
   ZEND_JMPZ_EX_SPEC_CONST_HANDLER,
   ZEND_JMPZ_EX_SPEC_CONST_HANDLER,
   ZEND_JMPZ_EX_SPEC_CONST_HANDLER,
   ZEND_JMPZ_EX_SPEC_CONST_HANDLER,
   ZEND_JMPZ_EX_SPEC_CONST_HANDLER,
   ZEND_JMPZ_EX_SPEC_TMP_HANDLER,
   ZEND_JMPZ_EX_SPEC_TMP_HANDLER,
   ZEND_JMPZ_EX_SPEC_TMP_HANDLER,
   ZEND_JMPZ_EX_SPEC_TMP_HANDLER,
   ZEND_JMPZ_EX_SPEC_TMP_HANDLER,
   ZEND_JMPZ_EX_SPEC_VAR_HANDLER,
   ZEND_JMPZ_EX_SPEC_VAR_HANDLER,
   ZEND_JMPZ_EX_SPEC_VAR_HANDLER,
   ZEND_JMPZ_EX_SPEC_VAR_HANDLER,
   ZEND_JMPZ_EX_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_JMPZ_EX_SPEC_CV_HANDLER,
   ZEND_JMPZ_EX_SPEC_CV_HANDLER,
   ZEND_JMPZ_EX_SPEC_CV_HANDLER,
   ZEND_JMPZ_EX_SPEC_CV_HANDLER,
   ZEND_JMPZ_EX_SPEC_CV_HANDLER,
   ZEND_JMPNZ_EX_SPEC_CONST_HANDLER,
   ZEND_JMPNZ_EX_SPEC_CONST_HANDLER,
   ZEND_JMPNZ_EX_SPEC_CONST_HANDLER,
   ZEND_JMPNZ_EX_SPEC_CONST_HANDLER,
   ZEND_JMPNZ_EX_SPEC_CONST_HANDLER,
   ZEND_JMPNZ_EX_SPEC_TMP_HANDLER,
   ZEND_JMPNZ_EX_SPEC_TMP_HANDLER,
   ZEND_JMPNZ_EX_SPEC_TMP_HANDLER,
   ZEND_JMPNZ_EX_SPEC_TMP_HANDLER,
   ZEND_JMPNZ_EX_SPEC_TMP_HANDLER,
   ZEND_JMPNZ_EX_SPEC_VAR_HANDLER,
   ZEND_JMPNZ_EX_SPEC_VAR_HANDLER,
   ZEND_JMPNZ_EX_SPEC_VAR_HANDLER,
   ZEND_JMPNZ_EX_SPEC_VAR_HANDLER,
   ZEND_JMPNZ_EX_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_JMPNZ_EX_SPEC_CV_HANDLER,
   ZEND_JMPNZ_EX_SPEC_CV_HANDLER,
   ZEND_JMPNZ_EX_SPEC_CV_HANDLER,
   ZEND_JMPNZ_EX_SPEC_CV_HANDLER,
   ZEND_JMPNZ_EX_SPEC_CV_HANDLER,
   ZEND_CASE_SPEC_CONST_CONST_HANDLER,
   ZEND_CASE_SPEC_CONST_TMP_HANDLER,
   ZEND_CASE_SPEC_CONST_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_CASE_SPEC_CONST_CV_HANDLER,
   ZEND_CASE_SPEC_TMP_CONST_HANDLER,
   ZEND_CASE_SPEC_TMP_TMP_HANDLER,
   ZEND_CASE_SPEC_TMP_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_CASE_SPEC_TMP_CV_HANDLER,
   ZEND_CASE_SPEC_VAR_CONST_HANDLER,
   ZEND_CASE_SPEC_VAR_TMP_HANDLER,
   ZEND_CASE_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_CASE_SPEC_VAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_CASE_SPEC_CV_CONST_HANDLER,
   ZEND_CASE_SPEC_CV_TMP_HANDLER,
   ZEND_CASE_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_CASE_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SWITCH_FREE_SPEC_VAR_HANDLER,
   ZEND_SWITCH_FREE_SPEC_VAR_HANDLER,
   ZEND_SWITCH_FREE_SPEC_VAR_HANDLER,
   ZEND_SWITCH_FREE_SPEC_VAR_HANDLER,
   ZEND_SWITCH_FREE_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BRK_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BRK_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BRK_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BRK_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BRK_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_CONT_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_CONT_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_CONT_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_CONT_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_CONT_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BOOL_SPEC_CONST_HANDLER,
   ZEND_BOOL_SPEC_CONST_HANDLER,
   ZEND_BOOL_SPEC_CONST_HANDLER,
   ZEND_BOOL_SPEC_CONST_HANDLER,
   ZEND_BOOL_SPEC_CONST_HANDLER,
   ZEND_BOOL_SPEC_TMP_HANDLER,
   ZEND_BOOL_SPEC_TMP_HANDLER,
   ZEND_BOOL_SPEC_TMP_HANDLER,
   ZEND_BOOL_SPEC_TMP_HANDLER,
   ZEND_BOOL_SPEC_TMP_HANDLER,
   ZEND_BOOL_SPEC_VAR_HANDLER,
   ZEND_BOOL_SPEC_VAR_HANDLER,
   ZEND_BOOL_SPEC_VAR_HANDLER,
   ZEND_BOOL_SPEC_VAR_HANDLER,
   ZEND_BOOL_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BOOL_SPEC_CV_HANDLER,
   ZEND_BOOL_SPEC_CV_HANDLER,
   ZEND_BOOL_SPEC_CV_HANDLER,
   ZEND_BOOL_SPEC_CV_HANDLER,
   ZEND_BOOL_SPEC_CV_HANDLER,
   ZEND_INIT_STRING_SPEC_HANDLER,
   ZEND_INIT_STRING_SPEC_HANDLER,
   ZEND_INIT_STRING_SPEC_HANDLER,
   ZEND_INIT_STRING_SPEC_HANDLER,
   ZEND_INIT_STRING_SPEC_HANDLER,
   ZEND_INIT_STRING_SPEC_HANDLER,
   ZEND_INIT_STRING_SPEC_HANDLER,
   ZEND_INIT_STRING_SPEC_HANDLER,
   ZEND_INIT_STRING_SPEC_HANDLER,
   ZEND_INIT_STRING_SPEC_HANDLER,
   ZEND_INIT_STRING_SPEC_HANDLER,
   ZEND_INIT_STRING_SPEC_HANDLER,
   ZEND_INIT_STRING_SPEC_HANDLER,
   ZEND_INIT_STRING_SPEC_HANDLER,
   ZEND_INIT_STRING_SPEC_HANDLER,
   ZEND_INIT_STRING_SPEC_HANDLER,
   ZEND_INIT_STRING_SPEC_HANDLER,
   ZEND_INIT_STRING_SPEC_HANDLER,
   ZEND_INIT_STRING_SPEC_HANDLER,
   ZEND_INIT_STRING_SPEC_HANDLER,
   ZEND_INIT_STRING_SPEC_HANDLER,
   ZEND_INIT_STRING_SPEC_HANDLER,
   ZEND_INIT_STRING_SPEC_HANDLER,
   ZEND_INIT_STRING_SPEC_HANDLER,
   ZEND_INIT_STRING_SPEC_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ADD_CHAR_SPEC_TMP_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ADD_CHAR_SPEC_UNUSED_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ADD_STRING_SPEC_TMP_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ADD_STRING_SPEC_UNUSED_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ADD_VAR_SPEC_TMP_TMP_HANDLER,
   ZEND_ADD_VAR_SPEC_TMP_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ADD_VAR_SPEC_TMP_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ADD_VAR_SPEC_UNUSED_TMP_HANDLER,
   ZEND_ADD_VAR_SPEC_UNUSED_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ADD_VAR_SPEC_UNUSED_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_BEGIN_SILENCE_SPEC_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_END_SILENCE_SPEC_TMP_HANDLER,
   ZEND_END_SILENCE_SPEC_TMP_HANDLER,
   ZEND_END_SILENCE_SPEC_TMP_HANDLER,
   ZEND_END_SILENCE_SPEC_TMP_HANDLER,
   ZEND_END_SILENCE_SPEC_TMP_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_FCALL_BY_NAME_SPEC_CONST_HANDLER,
   ZEND_INIT_FCALL_BY_NAME_SPEC_TMP_HANDLER,
   ZEND_INIT_FCALL_BY_NAME_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_FCALL_BY_NAME_SPEC_CV_HANDLER,
   ZEND_INIT_FCALL_BY_NAME_SPEC_CONST_HANDLER,
   ZEND_INIT_FCALL_BY_NAME_SPEC_TMP_HANDLER,
   ZEND_INIT_FCALL_BY_NAME_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_FCALL_BY_NAME_SPEC_CV_HANDLER,
   ZEND_INIT_FCALL_BY_NAME_SPEC_CONST_HANDLER,
   ZEND_INIT_FCALL_BY_NAME_SPEC_TMP_HANDLER,
   ZEND_INIT_FCALL_BY_NAME_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_FCALL_BY_NAME_SPEC_CV_HANDLER,
   ZEND_INIT_FCALL_BY_NAME_SPEC_CONST_HANDLER,
   ZEND_INIT_FCALL_BY_NAME_SPEC_TMP_HANDLER,
   ZEND_INIT_FCALL_BY_NAME_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_FCALL_BY_NAME_SPEC_CV_HANDLER,
   ZEND_INIT_FCALL_BY_NAME_SPEC_CONST_HANDLER,
   ZEND_INIT_FCALL_BY_NAME_SPEC_TMP_HANDLER,
   ZEND_INIT_FCALL_BY_NAME_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_FCALL_BY_NAME_SPEC_CV_HANDLER,
   ZEND_DO_FCALL_SPEC_CONST_HANDLER,
   ZEND_DO_FCALL_SPEC_CONST_HANDLER,
   ZEND_DO_FCALL_SPEC_CONST_HANDLER,
   ZEND_DO_FCALL_SPEC_CONST_HANDLER,
   ZEND_DO_FCALL_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
   ZEND_RETURN_SPEC_CONST_HANDLER,
   ZEND_RETURN_SPEC_CONST_HANDLER,
   ZEND_RETURN_SPEC_CONST_HANDLER,
   ZEND_RETURN_SPEC_CONST_HANDLER,
   ZEND_RETURN_SPEC_CONST_HANDLER,
   ZEND_RETURN_SPEC_TMP_HANDLER,
   ZEND_RETURN_SPEC_TMP_HANDLER,
   ZEND_RETURN_SPEC_TMP_HANDLER,
   ZEND_RETURN_SPEC_TMP_HANDLER,
   ZEND_RETURN_SPEC_TMP_HANDLER,
   ZEND_RETURN_SPEC_VAR_HANDLER,
   ZEND_RETURN_SPEC_VAR_HANDLER,
   ZEND_RETURN_SPEC_VAR_HANDLER,
   ZEND_RETURN_SPEC_VAR_HANDLER,
   ZEND_RETURN_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_RETURN_SPEC_CV_HANDLER,
   ZEND_RETURN_SPEC_CV_HANDLER,
   ZEND_RETURN_SPEC_CV_HANDLER,
   ZEND_RETURN_SPEC_CV_HANDLER,
   ZEND_RETURN_SPEC_CV_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_SPEC_HANDLER,
   ZEND_RECV_INIT_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_RECV_INIT_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_RECV_INIT_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_RECV_INIT_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_RECV_INIT_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SEND_VAL_SPEC_CONST_HANDLER,
   ZEND_SEND_VAL_SPEC_CONST_HANDLER,
   ZEND_SEND_VAL_SPEC_CONST_HANDLER,
   ZEND_SEND_VAL_SPEC_CONST_HANDLER,
   ZEND_SEND_VAL_SPEC_CONST_HANDLER,
   ZEND_SEND_VAL_SPEC_TMP_HANDLER,
   ZEND_SEND_VAL_SPEC_TMP_HANDLER,
   ZEND_SEND_VAL_SPEC_TMP_HANDLER,
   ZEND_SEND_VAL_SPEC_TMP_HANDLER,
   ZEND_SEND_VAL_SPEC_TMP_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SEND_VAR_SPEC_VAR_HANDLER,
   ZEND_SEND_VAR_SPEC_VAR_HANDLER,
   ZEND_SEND_VAR_SPEC_VAR_HANDLER,
   ZEND_SEND_VAR_SPEC_VAR_HANDLER,
   ZEND_SEND_VAR_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SEND_VAR_SPEC_CV_HANDLER,
   ZEND_SEND_VAR_SPEC_CV_HANDLER,
   ZEND_SEND_VAR_SPEC_CV_HANDLER,
   ZEND_SEND_VAR_SPEC_CV_HANDLER,
   ZEND_SEND_VAR_SPEC_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SEND_REF_SPEC_VAR_HANDLER,
   ZEND_SEND_REF_SPEC_VAR_HANDLER,
   ZEND_SEND_REF_SPEC_VAR_HANDLER,
   ZEND_SEND_REF_SPEC_VAR_HANDLER,
   ZEND_SEND_REF_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SEND_REF_SPEC_CV_HANDLER,
   ZEND_SEND_REF_SPEC_CV_HANDLER,
   ZEND_SEND_REF_SPEC_CV_HANDLER,
   ZEND_SEND_REF_SPEC_CV_HANDLER,
   ZEND_SEND_REF_SPEC_CV_HANDLER,
   ZEND_NEW_SPEC_HANDLER,
   ZEND_NEW_SPEC_HANDLER,
   ZEND_NEW_SPEC_HANDLER,
   ZEND_NEW_SPEC_HANDLER,
   ZEND_NEW_SPEC_HANDLER,
   ZEND_NEW_SPEC_HANDLER,
   ZEND_NEW_SPEC_HANDLER,
   ZEND_NEW_SPEC_HANDLER,
   ZEND_NEW_SPEC_HANDLER,
   ZEND_NEW_SPEC_HANDLER,
   ZEND_NEW_SPEC_HANDLER,
   ZEND_NEW_SPEC_HANDLER,
   ZEND_NEW_SPEC_HANDLER,
   ZEND_NEW_SPEC_HANDLER,
   ZEND_NEW_SPEC_HANDLER,
   ZEND_NEW_SPEC_HANDLER,
   ZEND_NEW_SPEC_HANDLER,
   ZEND_NEW_SPEC_HANDLER,
   ZEND_NEW_SPEC_HANDLER,
   ZEND_NEW_SPEC_HANDLER,
   ZEND_NEW_SPEC_HANDLER,
   ZEND_NEW_SPEC_HANDLER,
   ZEND_NEW_SPEC_HANDLER,
   ZEND_NEW_SPEC_HANDLER,
   ZEND_NEW_SPEC_HANDLER,
   ZEND_INIT_NS_FCALL_BY_NAME_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_NS_FCALL_BY_NAME_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_NS_FCALL_BY_NAME_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_NS_FCALL_BY_NAME_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_NS_FCALL_BY_NAME_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FREE_SPEC_TMP_HANDLER,
   ZEND_FREE_SPEC_TMP_HANDLER,
   ZEND_FREE_SPEC_TMP_HANDLER,
   ZEND_FREE_SPEC_TMP_HANDLER,
   ZEND_FREE_SPEC_TMP_HANDLER,
   ZEND_FREE_SPEC_VAR_HANDLER,
   ZEND_FREE_SPEC_VAR_HANDLER,
   ZEND_FREE_SPEC_VAR_HANDLER,
   ZEND_FREE_SPEC_VAR_HANDLER,
   ZEND_FREE_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_ARRAY_SPEC_CONST_CONST_HANDLER,
   ZEND_INIT_ARRAY_SPEC_CONST_TMP_HANDLER,
   ZEND_INIT_ARRAY_SPEC_CONST_VAR_HANDLER,
   ZEND_INIT_ARRAY_SPEC_CONST_UNUSED_HANDLER,
   ZEND_INIT_ARRAY_SPEC_CONST_CV_HANDLER,
   ZEND_INIT_ARRAY_SPEC_TMP_CONST_HANDLER,
   ZEND_INIT_ARRAY_SPEC_TMP_TMP_HANDLER,
   ZEND_INIT_ARRAY_SPEC_TMP_VAR_HANDLER,
   ZEND_INIT_ARRAY_SPEC_TMP_UNUSED_HANDLER,
   ZEND_INIT_ARRAY_SPEC_TMP_CV_HANDLER,
   ZEND_INIT_ARRAY_SPEC_VAR_CONST_HANDLER,
   ZEND_INIT_ARRAY_SPEC_VAR_TMP_HANDLER,
   ZEND_INIT_ARRAY_SPEC_VAR_VAR_HANDLER,
   ZEND_INIT_ARRAY_SPEC_VAR_UNUSED_HANDLER,
   ZEND_INIT_ARRAY_SPEC_VAR_CV_HANDLER,
   ZEND_INIT_ARRAY_SPEC_UNUSED_CONST_HANDLER,
   ZEND_INIT_ARRAY_SPEC_UNUSED_TMP_HANDLER,
   ZEND_INIT_ARRAY_SPEC_UNUSED_VAR_HANDLER,
   ZEND_INIT_ARRAY_SPEC_UNUSED_UNUSED_HANDLER,
   ZEND_INIT_ARRAY_SPEC_UNUSED_CV_HANDLER,
   ZEND_INIT_ARRAY_SPEC_CV_CONST_HANDLER,
   ZEND_INIT_ARRAY_SPEC_CV_TMP_HANDLER,
   ZEND_INIT_ARRAY_SPEC_CV_VAR_HANDLER,
   ZEND_INIT_ARRAY_SPEC_CV_UNUSED_HANDLER,
   ZEND_INIT_ARRAY_SPEC_CV_CV_HANDLER,
   ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CONST_HANDLER,
   ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_TMP_HANDLER,
   ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_VAR_HANDLER,
   ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_UNUSED_HANDLER,
   ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CV_HANDLER,
   ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CONST_HANDLER,
   ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_TMP_HANDLER,
   ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_VAR_HANDLER,
   ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_UNUSED_HANDLER,
   ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CV_HANDLER,
   ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CONST_HANDLER,
   ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_TMP_HANDLER,
   ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_VAR_HANDLER,
   ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_UNUSED_HANDLER,
   ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CONST_HANDLER,
   ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_TMP_HANDLER,
   ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_VAR_HANDLER,
   ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_UNUSED_HANDLER,
   ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CV_HANDLER,
   ZEND_INCLUDE_OR_EVAL_SPEC_CONST_HANDLER,
   ZEND_INCLUDE_OR_EVAL_SPEC_CONST_HANDLER,
   ZEND_INCLUDE_OR_EVAL_SPEC_CONST_HANDLER,
   ZEND_INCLUDE_OR_EVAL_SPEC_CONST_HANDLER,
   ZEND_INCLUDE_OR_EVAL_SPEC_CONST_HANDLER,
   ZEND_INCLUDE_OR_EVAL_SPEC_TMP_HANDLER,
   ZEND_INCLUDE_OR_EVAL_SPEC_TMP_HANDLER,
   ZEND_INCLUDE_OR_EVAL_SPEC_TMP_HANDLER,
   ZEND_INCLUDE_OR_EVAL_SPEC_TMP_HANDLER,
   ZEND_INCLUDE_OR_EVAL_SPEC_TMP_HANDLER,
   ZEND_INCLUDE_OR_EVAL_SPEC_VAR_HANDLER,
   ZEND_INCLUDE_OR_EVAL_SPEC_VAR_HANDLER,
   ZEND_INCLUDE_OR_EVAL_SPEC_VAR_HANDLER,
   ZEND_INCLUDE_OR_EVAL_SPEC_VAR_HANDLER,
   ZEND_INCLUDE_OR_EVAL_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INCLUDE_OR_EVAL_SPEC_CV_HANDLER,
   ZEND_INCLUDE_OR_EVAL_SPEC_CV_HANDLER,
   ZEND_INCLUDE_OR_EVAL_SPEC_CV_HANDLER,
   ZEND_INCLUDE_OR_EVAL_SPEC_CV_HANDLER,
   ZEND_INCLUDE_OR_EVAL_SPEC_CV_HANDLER,
   ZEND_UNSET_VAR_SPEC_CONST_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_UNSET_VAR_SPEC_CONST_VAR_HANDLER,
   ZEND_UNSET_VAR_SPEC_CONST_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_UNSET_VAR_SPEC_TMP_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_UNSET_VAR_SPEC_TMP_VAR_HANDLER,
   ZEND_UNSET_VAR_SPEC_TMP_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_UNSET_VAR_SPEC_VAR_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_UNSET_VAR_SPEC_VAR_VAR_HANDLER,
   ZEND_UNSET_VAR_SPEC_VAR_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_UNSET_VAR_SPEC_CV_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_UNSET_VAR_SPEC_CV_VAR_HANDLER,
   ZEND_UNSET_VAR_SPEC_CV_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_UNSET_DIM_SPEC_VAR_CONST_HANDLER,
   ZEND_UNSET_DIM_SPEC_VAR_TMP_HANDLER,
   ZEND_UNSET_DIM_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_UNSET_DIM_SPEC_VAR_CV_HANDLER,
   ZEND_UNSET_DIM_SPEC_UNUSED_CONST_HANDLER,
   ZEND_UNSET_DIM_SPEC_UNUSED_TMP_HANDLER,
   ZEND_UNSET_DIM_SPEC_UNUSED_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_UNSET_DIM_SPEC_UNUSED_CV_HANDLER,
   ZEND_UNSET_DIM_SPEC_CV_CONST_HANDLER,
   ZEND_UNSET_DIM_SPEC_CV_TMP_HANDLER,
   ZEND_UNSET_DIM_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_UNSET_DIM_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_UNSET_OBJ_SPEC_VAR_CONST_HANDLER,
   ZEND_UNSET_OBJ_SPEC_VAR_TMP_HANDLER,
   ZEND_UNSET_OBJ_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_UNSET_OBJ_SPEC_VAR_CV_HANDLER,
   ZEND_UNSET_OBJ_SPEC_UNUSED_CONST_HANDLER,
   ZEND_UNSET_OBJ_SPEC_UNUSED_TMP_HANDLER,
   ZEND_UNSET_OBJ_SPEC_UNUSED_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_UNSET_OBJ_SPEC_UNUSED_CV_HANDLER,
   ZEND_UNSET_OBJ_SPEC_CV_CONST_HANDLER,
   ZEND_UNSET_OBJ_SPEC_CV_TMP_HANDLER,
   ZEND_UNSET_OBJ_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_UNSET_OBJ_SPEC_CV_CV_HANDLER,
   ZEND_FE_RESET_SPEC_CONST_HANDLER,
   ZEND_FE_RESET_SPEC_CONST_HANDLER,
   ZEND_FE_RESET_SPEC_CONST_HANDLER,
   ZEND_FE_RESET_SPEC_CONST_HANDLER,
   ZEND_FE_RESET_SPEC_CONST_HANDLER,
   ZEND_FE_RESET_SPEC_TMP_HANDLER,
   ZEND_FE_RESET_SPEC_TMP_HANDLER,
   ZEND_FE_RESET_SPEC_TMP_HANDLER,
   ZEND_FE_RESET_SPEC_TMP_HANDLER,
   ZEND_FE_RESET_SPEC_TMP_HANDLER,
   ZEND_FE_RESET_SPEC_VAR_HANDLER,
   ZEND_FE_RESET_SPEC_VAR_HANDLER,
   ZEND_FE_RESET_SPEC_VAR_HANDLER,
   ZEND_FE_RESET_SPEC_VAR_HANDLER,
   ZEND_FE_RESET_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FE_RESET_SPEC_CV_HANDLER,
   ZEND_FE_RESET_SPEC_CV_HANDLER,
   ZEND_FE_RESET_SPEC_CV_HANDLER,
   ZEND_FE_RESET_SPEC_CV_HANDLER,
   ZEND_FE_RESET_SPEC_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FE_FETCH_SPEC_VAR_HANDLER,
   ZEND_FE_FETCH_SPEC_VAR_HANDLER,
   ZEND_FE_FETCH_SPEC_VAR_HANDLER,
   ZEND_FE_FETCH_SPEC_VAR_HANDLER,
   ZEND_FE_FETCH_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_EXIT_SPEC_CONST_HANDLER,
   ZEND_EXIT_SPEC_CONST_HANDLER,
   ZEND_EXIT_SPEC_CONST_HANDLER,
   ZEND_EXIT_SPEC_CONST_HANDLER,
   ZEND_EXIT_SPEC_CONST_HANDLER,
   ZEND_EXIT_SPEC_TMP_HANDLER,
   ZEND_EXIT_SPEC_TMP_HANDLER,
   ZEND_EXIT_SPEC_TMP_HANDLER,
   ZEND_EXIT_SPEC_TMP_HANDLER,
   ZEND_EXIT_SPEC_TMP_HANDLER,
   ZEND_EXIT_SPEC_VAR_HANDLER,
   ZEND_EXIT_SPEC_VAR_HANDLER,
   ZEND_EXIT_SPEC_VAR_HANDLER,
   ZEND_EXIT_SPEC_VAR_HANDLER,
   ZEND_EXIT_SPEC_VAR_HANDLER,
   ZEND_EXIT_SPEC_UNUSED_HANDLER,
   ZEND_EXIT_SPEC_UNUSED_HANDLER,
   ZEND_EXIT_SPEC_UNUSED_HANDLER,
   ZEND_EXIT_SPEC_UNUSED_HANDLER,
   ZEND_EXIT_SPEC_UNUSED_HANDLER,
   ZEND_EXIT_SPEC_CV_HANDLER,
   ZEND_EXIT_SPEC_CV_HANDLER,
   ZEND_EXIT_SPEC_CV_HANDLER,
   ZEND_EXIT_SPEC_CV_HANDLER,
   ZEND_EXIT_SPEC_CV_HANDLER,
   ZEND_FETCH_R_SPEC_CONST_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_R_SPEC_CONST_VAR_HANDLER,
   ZEND_FETCH_R_SPEC_CONST_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_R_SPEC_TMP_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_R_SPEC_TMP_VAR_HANDLER,
   ZEND_FETCH_R_SPEC_TMP_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_R_SPEC_VAR_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_R_SPEC_VAR_VAR_HANDLER,
   ZEND_FETCH_R_SPEC_VAR_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_R_SPEC_CV_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_R_SPEC_CV_VAR_HANDLER,
   ZEND_FETCH_R_SPEC_CV_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_DIM_R_SPEC_VAR_CONST_HANDLER,
   ZEND_FETCH_DIM_R_SPEC_VAR_TMP_HANDLER,
   ZEND_FETCH_DIM_R_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_DIM_R_SPEC_VAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_DIM_R_SPEC_CV_CONST_HANDLER,
   ZEND_FETCH_DIM_R_SPEC_CV_TMP_HANDLER,
   ZEND_FETCH_DIM_R_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_DIM_R_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_R_SPEC_VAR_CONST_HANDLER,
   ZEND_FETCH_OBJ_R_SPEC_VAR_TMP_HANDLER,
   ZEND_FETCH_OBJ_R_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_R_SPEC_VAR_CV_HANDLER,
   ZEND_FETCH_OBJ_R_SPEC_UNUSED_CONST_HANDLER,
   ZEND_FETCH_OBJ_R_SPEC_UNUSED_TMP_HANDLER,
   ZEND_FETCH_OBJ_R_SPEC_UNUSED_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_R_SPEC_UNUSED_CV_HANDLER,
   ZEND_FETCH_OBJ_R_SPEC_CV_CONST_HANDLER,
   ZEND_FETCH_OBJ_R_SPEC_CV_TMP_HANDLER,
   ZEND_FETCH_OBJ_R_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_R_SPEC_CV_CV_HANDLER,
   ZEND_FETCH_W_SPEC_CONST_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_W_SPEC_CONST_VAR_HANDLER,
   ZEND_FETCH_W_SPEC_CONST_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_W_SPEC_TMP_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_W_SPEC_TMP_VAR_HANDLER,
   ZEND_FETCH_W_SPEC_TMP_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_W_SPEC_VAR_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_W_SPEC_VAR_VAR_HANDLER,
   ZEND_FETCH_W_SPEC_VAR_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_W_SPEC_CV_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_W_SPEC_CV_VAR_HANDLER,
   ZEND_FETCH_W_SPEC_CV_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_DIM_W_SPEC_VAR_CONST_HANDLER,
   ZEND_FETCH_DIM_W_SPEC_VAR_TMP_HANDLER,
   ZEND_FETCH_DIM_W_SPEC_VAR_VAR_HANDLER,
   ZEND_FETCH_DIM_W_SPEC_VAR_UNUSED_HANDLER,
   ZEND_FETCH_DIM_W_SPEC_VAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_DIM_W_SPEC_CV_CONST_HANDLER,
   ZEND_FETCH_DIM_W_SPEC_CV_TMP_HANDLER,
   ZEND_FETCH_DIM_W_SPEC_CV_VAR_HANDLER,
   ZEND_FETCH_DIM_W_SPEC_CV_UNUSED_HANDLER,
   ZEND_FETCH_DIM_W_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_W_SPEC_VAR_CONST_HANDLER,
   ZEND_FETCH_OBJ_W_SPEC_VAR_TMP_HANDLER,
   ZEND_FETCH_OBJ_W_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_W_SPEC_VAR_CV_HANDLER,
   ZEND_FETCH_OBJ_W_SPEC_UNUSED_CONST_HANDLER,
   ZEND_FETCH_OBJ_W_SPEC_UNUSED_TMP_HANDLER,
   ZEND_FETCH_OBJ_W_SPEC_UNUSED_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_W_SPEC_UNUSED_CV_HANDLER,
   ZEND_FETCH_OBJ_W_SPEC_CV_CONST_HANDLER,
   ZEND_FETCH_OBJ_W_SPEC_CV_TMP_HANDLER,
   ZEND_FETCH_OBJ_W_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_W_SPEC_CV_CV_HANDLER,
   ZEND_FETCH_RW_SPEC_CONST_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_RW_SPEC_CONST_VAR_HANDLER,
   ZEND_FETCH_RW_SPEC_CONST_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_RW_SPEC_TMP_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_RW_SPEC_TMP_VAR_HANDLER,
   ZEND_FETCH_RW_SPEC_TMP_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_RW_SPEC_VAR_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_RW_SPEC_VAR_VAR_HANDLER,
   ZEND_FETCH_RW_SPEC_VAR_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_RW_SPEC_CV_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_RW_SPEC_CV_VAR_HANDLER,
   ZEND_FETCH_RW_SPEC_CV_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_DIM_RW_SPEC_VAR_CONST_HANDLER,
   ZEND_FETCH_DIM_RW_SPEC_VAR_TMP_HANDLER,
   ZEND_FETCH_DIM_RW_SPEC_VAR_VAR_HANDLER,
   ZEND_FETCH_DIM_RW_SPEC_VAR_UNUSED_HANDLER,
   ZEND_FETCH_DIM_RW_SPEC_VAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_DIM_RW_SPEC_CV_CONST_HANDLER,
   ZEND_FETCH_DIM_RW_SPEC_CV_TMP_HANDLER,
   ZEND_FETCH_DIM_RW_SPEC_CV_VAR_HANDLER,
   ZEND_FETCH_DIM_RW_SPEC_CV_UNUSED_HANDLER,
   ZEND_FETCH_DIM_RW_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_RW_SPEC_VAR_CONST_HANDLER,
   ZEND_FETCH_OBJ_RW_SPEC_VAR_TMP_HANDLER,
   ZEND_FETCH_OBJ_RW_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_RW_SPEC_VAR_CV_HANDLER,
   ZEND_FETCH_OBJ_RW_SPEC_UNUSED_CONST_HANDLER,
   ZEND_FETCH_OBJ_RW_SPEC_UNUSED_TMP_HANDLER,
   ZEND_FETCH_OBJ_RW_SPEC_UNUSED_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_RW_SPEC_UNUSED_CV_HANDLER,
   ZEND_FETCH_OBJ_RW_SPEC_CV_CONST_HANDLER,
   ZEND_FETCH_OBJ_RW_SPEC_CV_TMP_HANDLER,
   ZEND_FETCH_OBJ_RW_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_RW_SPEC_CV_CV_HANDLER,
   ZEND_FETCH_IS_SPEC_CONST_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_IS_SPEC_CONST_VAR_HANDLER,
   ZEND_FETCH_IS_SPEC_CONST_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_IS_SPEC_TMP_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_IS_SPEC_TMP_VAR_HANDLER,
   ZEND_FETCH_IS_SPEC_TMP_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_IS_SPEC_VAR_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_IS_SPEC_VAR_VAR_HANDLER,
   ZEND_FETCH_IS_SPEC_VAR_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_IS_SPEC_CV_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_IS_SPEC_CV_VAR_HANDLER,
   ZEND_FETCH_IS_SPEC_CV_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_DIM_IS_SPEC_VAR_CONST_HANDLER,
   ZEND_FETCH_DIM_IS_SPEC_VAR_TMP_HANDLER,
   ZEND_FETCH_DIM_IS_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_DIM_IS_SPEC_VAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_DIM_IS_SPEC_CV_CONST_HANDLER,
   ZEND_FETCH_DIM_IS_SPEC_CV_TMP_HANDLER,
   ZEND_FETCH_DIM_IS_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_DIM_IS_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_IS_SPEC_VAR_CONST_HANDLER,
   ZEND_FETCH_OBJ_IS_SPEC_VAR_TMP_HANDLER,
   ZEND_FETCH_OBJ_IS_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_IS_SPEC_VAR_CV_HANDLER,
   ZEND_FETCH_OBJ_IS_SPEC_UNUSED_CONST_HANDLER,
   ZEND_FETCH_OBJ_IS_SPEC_UNUSED_TMP_HANDLER,
   ZEND_FETCH_OBJ_IS_SPEC_UNUSED_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_IS_SPEC_UNUSED_CV_HANDLER,
   ZEND_FETCH_OBJ_IS_SPEC_CV_CONST_HANDLER,
   ZEND_FETCH_OBJ_IS_SPEC_CV_TMP_HANDLER,
   ZEND_FETCH_OBJ_IS_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_IS_SPEC_CV_CV_HANDLER,
   ZEND_FETCH_FUNC_ARG_SPEC_CONST_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_FUNC_ARG_SPEC_CONST_VAR_HANDLER,
   ZEND_FETCH_FUNC_ARG_SPEC_CONST_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_FUNC_ARG_SPEC_TMP_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_FUNC_ARG_SPEC_TMP_VAR_HANDLER,
   ZEND_FETCH_FUNC_ARG_SPEC_TMP_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_FUNC_ARG_SPEC_VAR_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_FUNC_ARG_SPEC_VAR_VAR_HANDLER,
   ZEND_FETCH_FUNC_ARG_SPEC_VAR_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_FUNC_ARG_SPEC_CV_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_FUNC_ARG_SPEC_CV_VAR_HANDLER,
   ZEND_FETCH_FUNC_ARG_SPEC_CV_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_CONST_HANDLER,
   ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_TMP_HANDLER,
   ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_VAR_HANDLER,
   ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_UNUSED_HANDLER,
   ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_CONST_HANDLER,
   ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_TMP_HANDLER,
   ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_VAR_HANDLER,
   ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_UNUSED_HANDLER,
   ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CONST_HANDLER,
   ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_TMP_HANDLER,
   ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CV_HANDLER,
   ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CONST_HANDLER,
   ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_TMP_HANDLER,
   ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CV_HANDLER,
   ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_CONST_HANDLER,
   ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_TMP_HANDLER,
   ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_CV_HANDLER,
   ZEND_FETCH_UNSET_SPEC_CONST_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_UNSET_SPEC_CONST_VAR_HANDLER,
   ZEND_FETCH_UNSET_SPEC_CONST_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_UNSET_SPEC_TMP_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_UNSET_SPEC_TMP_VAR_HANDLER,
   ZEND_FETCH_UNSET_SPEC_TMP_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_UNSET_SPEC_VAR_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_UNSET_SPEC_VAR_VAR_HANDLER,
   ZEND_FETCH_UNSET_SPEC_VAR_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_UNSET_SPEC_CV_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_UNSET_SPEC_CV_VAR_HANDLER,
   ZEND_FETCH_UNSET_SPEC_CV_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_DIM_UNSET_SPEC_VAR_CONST_HANDLER,
   ZEND_FETCH_DIM_UNSET_SPEC_VAR_TMP_HANDLER,
   ZEND_FETCH_DIM_UNSET_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_DIM_UNSET_SPEC_VAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_DIM_UNSET_SPEC_CV_CONST_HANDLER,
   ZEND_FETCH_DIM_UNSET_SPEC_CV_TMP_HANDLER,
   ZEND_FETCH_DIM_UNSET_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_DIM_UNSET_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_UNSET_SPEC_VAR_CONST_HANDLER,
   ZEND_FETCH_OBJ_UNSET_SPEC_VAR_TMP_HANDLER,
   ZEND_FETCH_OBJ_UNSET_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_UNSET_SPEC_VAR_CV_HANDLER,
   ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_CONST_HANDLER,
   ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_TMP_HANDLER,
   ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_CV_HANDLER,
   ZEND_FETCH_OBJ_UNSET_SPEC_CV_CONST_HANDLER,
   ZEND_FETCH_OBJ_UNSET_SPEC_CV_TMP_HANDLER,
   ZEND_FETCH_OBJ_UNSET_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_OBJ_UNSET_SPEC_CV_CV_HANDLER,
   ZEND_FETCH_DIM_TMP_VAR_SPEC_CONST_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_DIM_TMP_VAR_SPEC_TMP_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_CONSTANT_SPEC_CONST_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_CONSTANT_SPEC_VAR_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_FETCH_CONSTANT_SPEC_UNUSED_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_GOTO_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_GOTO_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_GOTO_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_GOTO_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_GOTO_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_STMT_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_FCALL_END_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_EXT_NOP_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_TICKS_SPEC_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SEND_VAR_NO_REF_SPEC_VAR_HANDLER,
   ZEND_SEND_VAR_NO_REF_SPEC_VAR_HANDLER,
   ZEND_SEND_VAR_NO_REF_SPEC_VAR_HANDLER,
   ZEND_SEND_VAR_NO_REF_SPEC_VAR_HANDLER,
   ZEND_SEND_VAR_NO_REF_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SEND_VAR_NO_REF_SPEC_CV_HANDLER,
   ZEND_SEND_VAR_NO_REF_SPEC_CV_HANDLER,
   ZEND_SEND_VAR_NO_REF_SPEC_CV_HANDLER,
   ZEND_SEND_VAR_NO_REF_SPEC_CV_HANDLER,
   ZEND_SEND_VAR_NO_REF_SPEC_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_CATCH_SPEC_CONST_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_THROW_SPEC_CONST_HANDLER,
   ZEND_THROW_SPEC_CONST_HANDLER,
   ZEND_THROW_SPEC_CONST_HANDLER,
   ZEND_THROW_SPEC_CONST_HANDLER,
   ZEND_THROW_SPEC_CONST_HANDLER,
   ZEND_THROW_SPEC_TMP_HANDLER,
   ZEND_THROW_SPEC_TMP_HANDLER,
   ZEND_THROW_SPEC_TMP_HANDLER,
   ZEND_THROW_SPEC_TMP_HANDLER,
   ZEND_THROW_SPEC_TMP_HANDLER,
   ZEND_THROW_SPEC_VAR_HANDLER,
   ZEND_THROW_SPEC_VAR_HANDLER,
   ZEND_THROW_SPEC_VAR_HANDLER,
   ZEND_THROW_SPEC_VAR_HANDLER,
   ZEND_THROW_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_THROW_SPEC_CV_HANDLER,
   ZEND_THROW_SPEC_CV_HANDLER,
   ZEND_THROW_SPEC_CV_HANDLER,
   ZEND_THROW_SPEC_CV_HANDLER,
   ZEND_THROW_SPEC_CV_HANDLER,
   ZEND_FETCH_CLASS_SPEC_CONST_HANDLER,
   ZEND_FETCH_CLASS_SPEC_TMP_HANDLER,
   ZEND_FETCH_CLASS_SPEC_VAR_HANDLER,
   ZEND_FETCH_CLASS_SPEC_UNUSED_HANDLER,
   ZEND_FETCH_CLASS_SPEC_CV_HANDLER,
   ZEND_FETCH_CLASS_SPEC_CONST_HANDLER,
   ZEND_FETCH_CLASS_SPEC_TMP_HANDLER,
   ZEND_FETCH_CLASS_SPEC_VAR_HANDLER,
   ZEND_FETCH_CLASS_SPEC_UNUSED_HANDLER,
   ZEND_FETCH_CLASS_SPEC_CV_HANDLER,
   ZEND_FETCH_CLASS_SPEC_CONST_HANDLER,
   ZEND_FETCH_CLASS_SPEC_TMP_HANDLER,
   ZEND_FETCH_CLASS_SPEC_VAR_HANDLER,
   ZEND_FETCH_CLASS_SPEC_UNUSED_HANDLER,
   ZEND_FETCH_CLASS_SPEC_CV_HANDLER,
   ZEND_FETCH_CLASS_SPEC_CONST_HANDLER,
   ZEND_FETCH_CLASS_SPEC_TMP_HANDLER,
   ZEND_FETCH_CLASS_SPEC_VAR_HANDLER,
   ZEND_FETCH_CLASS_SPEC_UNUSED_HANDLER,
   ZEND_FETCH_CLASS_SPEC_CV_HANDLER,
   ZEND_FETCH_CLASS_SPEC_CONST_HANDLER,
   ZEND_FETCH_CLASS_SPEC_TMP_HANDLER,
   ZEND_FETCH_CLASS_SPEC_VAR_HANDLER,
   ZEND_FETCH_CLASS_SPEC_UNUSED_HANDLER,
   ZEND_FETCH_CLASS_SPEC_CV_HANDLER,
   ZEND_CLONE_SPEC_CONST_HANDLER,
   ZEND_CLONE_SPEC_CONST_HANDLER,
   ZEND_CLONE_SPEC_CONST_HANDLER,
   ZEND_CLONE_SPEC_CONST_HANDLER,
   ZEND_CLONE_SPEC_CONST_HANDLER,
   ZEND_CLONE_SPEC_TMP_HANDLER,
   ZEND_CLONE_SPEC_TMP_HANDLER,
   ZEND_CLONE_SPEC_TMP_HANDLER,
   ZEND_CLONE_SPEC_TMP_HANDLER,
   ZEND_CLONE_SPEC_TMP_HANDLER,
   ZEND_CLONE_SPEC_VAR_HANDLER,
   ZEND_CLONE_SPEC_VAR_HANDLER,
   ZEND_CLONE_SPEC_VAR_HANDLER,
   ZEND_CLONE_SPEC_VAR_HANDLER,
   ZEND_CLONE_SPEC_VAR_HANDLER,
   ZEND_CLONE_SPEC_UNUSED_HANDLER,
   ZEND_CLONE_SPEC_UNUSED_HANDLER,
   ZEND_CLONE_SPEC_UNUSED_HANDLER,
   ZEND_CLONE_SPEC_UNUSED_HANDLER,
   ZEND_CLONE_SPEC_UNUSED_HANDLER,
   ZEND_CLONE_SPEC_CV_HANDLER,
   ZEND_CLONE_SPEC_CV_HANDLER,
   ZEND_CLONE_SPEC_CV_HANDLER,
   ZEND_CLONE_SPEC_CV_HANDLER,
   ZEND_CLONE_SPEC_CV_HANDLER,
   ZEND_RETURN_BY_REF_SPEC_CONST_HANDLER,
   ZEND_RETURN_BY_REF_SPEC_CONST_HANDLER,
   ZEND_RETURN_BY_REF_SPEC_CONST_HANDLER,
   ZEND_RETURN_BY_REF_SPEC_CONST_HANDLER,
   ZEND_RETURN_BY_REF_SPEC_CONST_HANDLER,
   ZEND_RETURN_BY_REF_SPEC_TMP_HANDLER,
   ZEND_RETURN_BY_REF_SPEC_TMP_HANDLER,
   ZEND_RETURN_BY_REF_SPEC_TMP_HANDLER,
   ZEND_RETURN_BY_REF_SPEC_TMP_HANDLER,
   ZEND_RETURN_BY_REF_SPEC_TMP_HANDLER,
   ZEND_RETURN_BY_REF_SPEC_VAR_HANDLER,
   ZEND_RETURN_BY_REF_SPEC_VAR_HANDLER,
   ZEND_RETURN_BY_REF_SPEC_VAR_HANDLER,
   ZEND_RETURN_BY_REF_SPEC_VAR_HANDLER,
   ZEND_RETURN_BY_REF_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_RETURN_BY_REF_SPEC_CV_HANDLER,
   ZEND_RETURN_BY_REF_SPEC_CV_HANDLER,
   ZEND_RETURN_BY_REF_SPEC_CV_HANDLER,
   ZEND_RETURN_BY_REF_SPEC_CV_HANDLER,
   ZEND_RETURN_BY_REF_SPEC_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_METHOD_CALL_SPEC_TMP_CONST_HANDLER,
   ZEND_INIT_METHOD_CALL_SPEC_TMP_TMP_HANDLER,
   ZEND_INIT_METHOD_CALL_SPEC_TMP_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_METHOD_CALL_SPEC_TMP_CV_HANDLER,
   ZEND_INIT_METHOD_CALL_SPEC_VAR_CONST_HANDLER,
   ZEND_INIT_METHOD_CALL_SPEC_VAR_TMP_HANDLER,
   ZEND_INIT_METHOD_CALL_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_METHOD_CALL_SPEC_VAR_CV_HANDLER,
   ZEND_INIT_METHOD_CALL_SPEC_UNUSED_CONST_HANDLER,
   ZEND_INIT_METHOD_CALL_SPEC_UNUSED_TMP_HANDLER,
   ZEND_INIT_METHOD_CALL_SPEC_UNUSED_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_METHOD_CALL_SPEC_UNUSED_CV_HANDLER,
   ZEND_INIT_METHOD_CALL_SPEC_CV_CONST_HANDLER,
   ZEND_INIT_METHOD_CALL_SPEC_CV_TMP_HANDLER,
   ZEND_INIT_METHOD_CALL_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_METHOD_CALL_SPEC_CV_CV_HANDLER,
   ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_CONST_HANDLER,
   ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_TMP_HANDLER,
   ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_VAR_HANDLER,
   ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_UNUSED_HANDLER,
   ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_CONST_HANDLER,
   ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_TMP_HANDLER,
   ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_VAR_HANDLER,
   ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_UNUSED_HANDLER,
   ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ISSET_ISEMPTY_VAR_SPEC_CONST_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ISSET_ISEMPTY_VAR_SPEC_CONST_VAR_HANDLER,
   ZEND_ISSET_ISEMPTY_VAR_SPEC_CONST_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ISSET_ISEMPTY_VAR_SPEC_TMP_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ISSET_ISEMPTY_VAR_SPEC_TMP_VAR_HANDLER,
   ZEND_ISSET_ISEMPTY_VAR_SPEC_TMP_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ISSET_ISEMPTY_VAR_SPEC_VAR_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ISSET_ISEMPTY_VAR_SPEC_VAR_VAR_HANDLER,
   ZEND_ISSET_ISEMPTY_VAR_SPEC_VAR_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ISSET_ISEMPTY_VAR_SPEC_CV_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ISSET_ISEMPTY_VAR_SPEC_CV_VAR_HANDLER,
   ZEND_ISSET_ISEMPTY_VAR_SPEC_CV_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_VAR_CONST_HANDLER,
   ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_VAR_TMP_HANDLER,
   ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_VAR_CV_HANDLER,
   ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_CONST_HANDLER,
   ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_TMP_HANDLER,
   ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_CV_HANDLER,
   ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CONST_HANDLER,
   ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_TMP_HANDLER,
   ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_PRE_INC_OBJ_SPEC_VAR_CONST_HANDLER,
   ZEND_PRE_INC_OBJ_SPEC_VAR_TMP_HANDLER,
   ZEND_PRE_INC_OBJ_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_PRE_INC_OBJ_SPEC_VAR_CV_HANDLER,
   ZEND_PRE_INC_OBJ_SPEC_UNUSED_CONST_HANDLER,
   ZEND_PRE_INC_OBJ_SPEC_UNUSED_TMP_HANDLER,
   ZEND_PRE_INC_OBJ_SPEC_UNUSED_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_PRE_INC_OBJ_SPEC_UNUSED_CV_HANDLER,
   ZEND_PRE_INC_OBJ_SPEC_CV_CONST_HANDLER,
   ZEND_PRE_INC_OBJ_SPEC_CV_TMP_HANDLER,
   ZEND_PRE_INC_OBJ_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_PRE_INC_OBJ_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_PRE_DEC_OBJ_SPEC_VAR_CONST_HANDLER,
   ZEND_PRE_DEC_OBJ_SPEC_VAR_TMP_HANDLER,
   ZEND_PRE_DEC_OBJ_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_PRE_DEC_OBJ_SPEC_VAR_CV_HANDLER,
   ZEND_PRE_DEC_OBJ_SPEC_UNUSED_CONST_HANDLER,
   ZEND_PRE_DEC_OBJ_SPEC_UNUSED_TMP_HANDLER,
   ZEND_PRE_DEC_OBJ_SPEC_UNUSED_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_PRE_DEC_OBJ_SPEC_UNUSED_CV_HANDLER,
   ZEND_PRE_DEC_OBJ_SPEC_CV_CONST_HANDLER,
   ZEND_PRE_DEC_OBJ_SPEC_CV_TMP_HANDLER,
   ZEND_PRE_DEC_OBJ_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_PRE_DEC_OBJ_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_POST_INC_OBJ_SPEC_VAR_CONST_HANDLER,
   ZEND_POST_INC_OBJ_SPEC_VAR_TMP_HANDLER,
   ZEND_POST_INC_OBJ_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_POST_INC_OBJ_SPEC_VAR_CV_HANDLER,
   ZEND_POST_INC_OBJ_SPEC_UNUSED_CONST_HANDLER,
   ZEND_POST_INC_OBJ_SPEC_UNUSED_TMP_HANDLER,
   ZEND_POST_INC_OBJ_SPEC_UNUSED_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_POST_INC_OBJ_SPEC_UNUSED_CV_HANDLER,
   ZEND_POST_INC_OBJ_SPEC_CV_CONST_HANDLER,
   ZEND_POST_INC_OBJ_SPEC_CV_TMP_HANDLER,
   ZEND_POST_INC_OBJ_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_POST_INC_OBJ_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_POST_DEC_OBJ_SPEC_VAR_CONST_HANDLER,
   ZEND_POST_DEC_OBJ_SPEC_VAR_TMP_HANDLER,
   ZEND_POST_DEC_OBJ_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_POST_DEC_OBJ_SPEC_VAR_CV_HANDLER,
   ZEND_POST_DEC_OBJ_SPEC_UNUSED_CONST_HANDLER,
   ZEND_POST_DEC_OBJ_SPEC_UNUSED_TMP_HANDLER,
   ZEND_POST_DEC_OBJ_SPEC_UNUSED_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_POST_DEC_OBJ_SPEC_UNUSED_CV_HANDLER,
   ZEND_POST_DEC_OBJ_SPEC_CV_CONST_HANDLER,
   ZEND_POST_DEC_OBJ_SPEC_CV_TMP_HANDLER,
   ZEND_POST_DEC_OBJ_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_POST_DEC_OBJ_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_OBJ_SPEC_VAR_CONST_HANDLER,
   ZEND_ASSIGN_OBJ_SPEC_VAR_TMP_HANDLER,
   ZEND_ASSIGN_OBJ_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_OBJ_SPEC_VAR_CV_HANDLER,
   ZEND_ASSIGN_OBJ_SPEC_UNUSED_CONST_HANDLER,
   ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMP_HANDLER,
   ZEND_ASSIGN_OBJ_SPEC_UNUSED_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_OBJ_SPEC_UNUSED_CV_HANDLER,
   ZEND_ASSIGN_OBJ_SPEC_CV_CONST_HANDLER,
   ZEND_ASSIGN_OBJ_SPEC_CV_TMP_HANDLER,
   ZEND_ASSIGN_OBJ_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_OBJ_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INSTANCEOF_SPEC_TMP_HANDLER,
   ZEND_INSTANCEOF_SPEC_TMP_HANDLER,
   ZEND_INSTANCEOF_SPEC_TMP_HANDLER,
   ZEND_INSTANCEOF_SPEC_TMP_HANDLER,
   ZEND_INSTANCEOF_SPEC_TMP_HANDLER,
   ZEND_INSTANCEOF_SPEC_VAR_HANDLER,
   ZEND_INSTANCEOF_SPEC_VAR_HANDLER,
   ZEND_INSTANCEOF_SPEC_VAR_HANDLER,
   ZEND_INSTANCEOF_SPEC_VAR_HANDLER,
   ZEND_INSTANCEOF_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_INSTANCEOF_SPEC_CV_HANDLER,
   ZEND_INSTANCEOF_SPEC_CV_HANDLER,
   ZEND_INSTANCEOF_SPEC_CV_HANDLER,
   ZEND_INSTANCEOF_SPEC_CV_HANDLER,
   ZEND_INSTANCEOF_SPEC_CV_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
   ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
   ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
   ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
   ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
   ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
   ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
   ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
   ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
   ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
   ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
   ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
   ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
   ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
   ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
   ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
   ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
   ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
   ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
   ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
   ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
   ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
   ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
   ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
   ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
   ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
   ZEND_DECLARE_CONST_SPEC_CONST_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ADD_INTERFACE_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ADD_INTERFACE_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ADD_INTERFACE_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ADD_INTERFACE_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ADD_INTERFACE_SPEC_CONST_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_DIM_SPEC_VAR_CONST_HANDLER,
   ZEND_ASSIGN_DIM_SPEC_VAR_TMP_HANDLER,
   ZEND_ASSIGN_DIM_SPEC_VAR_VAR_HANDLER,
   ZEND_ASSIGN_DIM_SPEC_VAR_UNUSED_HANDLER,
   ZEND_ASSIGN_DIM_SPEC_VAR_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ASSIGN_DIM_SPEC_CV_CONST_HANDLER,
   ZEND_ASSIGN_DIM_SPEC_CV_TMP_HANDLER,
   ZEND_ASSIGN_DIM_SPEC_CV_VAR_HANDLER,
   ZEND_ASSIGN_DIM_SPEC_CV_UNUSED_HANDLER,
   ZEND_ASSIGN_DIM_SPEC_CV_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_VAR_CONST_HANDLER,
   ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_VAR_TMP_HANDLER,
   ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_VAR_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_VAR_CV_HANDLER,
   ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CONST_HANDLER,
   ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_TMP_HANDLER,
   ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CV_HANDLER,
   ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CONST_HANDLER,
   ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_TMP_HANDLER,
   ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CV_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_USER_OPCODE_SPEC_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_JMP_SET_SPEC_CONST_HANDLER,
   ZEND_JMP_SET_SPEC_CONST_HANDLER,
   ZEND_JMP_SET_SPEC_CONST_HANDLER,
   ZEND_JMP_SET_SPEC_CONST_HANDLER,
   ZEND_JMP_SET_SPEC_CONST_HANDLER,
   ZEND_JMP_SET_SPEC_TMP_HANDLER,
   ZEND_JMP_SET_SPEC_TMP_HANDLER,
   ZEND_JMP_SET_SPEC_TMP_HANDLER,
   ZEND_JMP_SET_SPEC_TMP_HANDLER,
   ZEND_JMP_SET_SPEC_TMP_HANDLER,
   ZEND_JMP_SET_SPEC_VAR_HANDLER,
   ZEND_JMP_SET_SPEC_VAR_HANDLER,
   ZEND_JMP_SET_SPEC_VAR_HANDLER,
   ZEND_JMP_SET_SPEC_VAR_HANDLER,
   ZEND_JMP_SET_SPEC_VAR_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_JMP_SET_SPEC_CV_HANDLER,
   ZEND_JMP_SET_SPEC_CV_HANDLER,
   ZEND_JMP_SET_SPEC_CV_HANDLER,
   ZEND_JMP_SET_SPEC_CV_HANDLER,
   ZEND_JMP_SET_SPEC_CV_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_DECLARE_LAMBDA_FUNCTION_SPEC_CONST_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_ADD_TRAIT_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_BIND_TRAITS_SPEC_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_SEPARATE_SPEC_VAR_UNUSED_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER,
   ZEND_NULL_HANDLER
  };
  zend_opcode_handlers = (opcode_handler_t*)labels;
}
static opcode_handler_t zend_vm_get_opcode_handler(zend_uchar opcode, zend_op* op)
{
  static const int zend_vm_decode[] = {
   3,
   0,
   1,
   3,
   2,
   3,
   3,
   3,
   3,
   3,
   3,
   3,
   3,
   3,
   3,
   3,
   4
  };
  return zend_opcode_handlers[opcode * 25 + zend_vm_decode[op->op1_type] * 5 + zend_vm_decode[op->op2_type]];
}

__attribute__ ((visibility("default"))) void zend_vm_set_opcode_handler(zend_op* op)
{
 op->handler = zend_vm_get_opcode_handler(zend_user_opcodes[op->opcode], op);
}

__attribute__ ((visibility("default"))) int zend_do_fcall(zend_execute_data *execute_data )
{
 return zend_do_fcall_common_helper_SPEC(execute_data );
}
# 1463 "/root/mountpoint-genprog/genprog-many-bugs/php-bug-2011-02-11-f912a2d087-b84967d3e2/php/Zend/zend_execute.c" 2

__attribute__ ((visibility("default"))) int zend_set_user_opcode_handler(zend_uchar opcode, user_opcode_handler_t handler)
{
 if (opcode != 150) {
  zend_user_opcodes[opcode] = 150;
  zend_user_opcode_handlers[opcode] = handler;
  return 0;
 }
 return -1;
}

__attribute__ ((visibility("default"))) user_opcode_handler_t zend_get_user_opcode_handler(zend_uchar opcode)
{
 return zend_user_opcode_handlers[opcode];
}

__attribute__ ((visibility("default"))) zval *zend_get_zval_ptr(int op_type, const znode_op *node, const temp_variable *Ts, zend_free_op *should_free, int type ) {
 return _get_zval_ptr(op_type, node, Ts, should_free, type );
}

__attribute__ ((visibility("default"))) zval **zend_get_zval_ptr_ptr(int op_type, const znode_op *node, const temp_variable *Ts, zend_free_op *should_free, int type ) {
 return _get_zval_ptr_ptr(op_type, node, Ts, should_free, type );
}
